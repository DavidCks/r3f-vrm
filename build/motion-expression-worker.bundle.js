(function () {
  'use strict';

  function _arrayLikeToArray(r, a) {
    (null == a || a > r.length) && (a = r.length);
    for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
    return n;
  }
  function _arrayWithHoles(r) {
    if (Array.isArray(r)) return r;
  }
  function _arrayWithoutHoles(r) {
    if (Array.isArray(r)) return _arrayLikeToArray(r);
  }
  function asyncGeneratorStep(n, t, e, r, o, a, c) {
    try {
      var i = n[a](c),
        u = i.value;
    } catch (n) {
      return void e(n);
    }
    i.done ? t(u) : Promise.resolve(u).then(r, o);
  }
  function _asyncToGenerator(n) {
    return function () {
      var t = this,
        e = arguments;
      return new Promise(function (r, o) {
        var a = n.apply(t, e);
        function _next(n) {
          asyncGeneratorStep(a, r, o, _next, _throw, "next", n);
        }
        function _throw(n) {
          asyncGeneratorStep(a, r, o, _next, _throw, "throw", n);
        }
        _next(void 0);
      });
    };
  }
  function _classCallCheck(a, n) {
    if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
  }
  function _defineProperties(e, r) {
    for (var t = 0; t < r.length; t++) {
      var o = r[t];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);
    }
  }
  function _createClass(e, r, t) {
    return r && _defineProperties(e.prototype, r), Object.defineProperty(e, "prototype", {
      writable: !1
    }), e;
  }
  function _createForOfIteratorHelper(r, e) {
    var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
    if (!t) {
      if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e) {
        t && (r = t);
        var n = 0,
          F = function () {};
        return {
          s: F,
          n: function () {
            return n >= r.length ? {
              done: !0
            } : {
              done: !1,
              value: r[n++]
            };
          },
          e: function (r) {
            throw r;
          },
          f: F
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var o,
      a = !0,
      u = !1;
    return {
      s: function () {
        t = t.call(r);
      },
      n: function () {
        var r = t.next();
        return a = r.done, r;
      },
      e: function (r) {
        u = !0, o = r;
      },
      f: function () {
        try {
          a || null == t.return || t.return();
        } finally {
          if (u) throw o;
        }
      }
    };
  }
  function _defineProperty(e, r, t) {
    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
      value: t,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }) : e[r] = t, e;
  }
  function _iterableToArray(r) {
    if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
  }
  function _iterableToArrayLimit(r, l) {
    var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
    if (null != t) {
      var e,
        n,
        i,
        u,
        a = [],
        f = !0,
        o = !1;
      try {
        if (i = (t = t.call(r)).next, 0 === l) {
          if (Object(t) !== t) return;
          f = !1;
        } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
      } catch (r) {
        o = !0, n = r;
      } finally {
        try {
          if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
        } finally {
          if (o) throw n;
        }
      }
      return a;
    }
  }
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _regeneratorRuntime() {
    _regeneratorRuntime = function () {
      return e;
    };
    var t,
      e = {},
      r = Object.prototype,
      n = r.hasOwnProperty,
      o = Object.defineProperty || function (t, e, r) {
        t[e] = r.value;
      },
      i = "function" == typeof Symbol ? Symbol : {},
      a = i.iterator || "@@iterator",
      c = i.asyncIterator || "@@asyncIterator",
      u = i.toStringTag || "@@toStringTag";
    function define(t, e, r) {
      return Object.defineProperty(t, e, {
        value: r,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }), t[e];
    }
    try {
      define({}, "");
    } catch (t) {
      define = function (t, e, r) {
        return t[e] = r;
      };
    }
    function wrap(t, e, r, n) {
      var i = e && e.prototype instanceof Generator ? e : Generator,
        a = Object.create(i.prototype),
        c = new Context(n || []);
      return o(a, "_invoke", {
        value: makeInvokeMethod(t, r, c)
      }), a;
    }
    function tryCatch(t, e, r) {
      try {
        return {
          type: "normal",
          arg: t.call(e, r)
        };
      } catch (t) {
        return {
          type: "throw",
          arg: t
        };
      }
    }
    e.wrap = wrap;
    var h = "suspendedStart",
      l = "suspendedYield",
      f = "executing",
      s = "completed",
      y = {};
    function Generator() {}
    function GeneratorFunction() {}
    function GeneratorFunctionPrototype() {}
    var p = {};
    define(p, a, function () {
      return this;
    });
    var d = Object.getPrototypeOf,
      v = d && d(d(values([])));
    v && v !== r && n.call(v, a) && (p = v);
    var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
    function defineIteratorMethods(t) {
      ["next", "throw", "return"].forEach(function (e) {
        define(t, e, function (t) {
          return this._invoke(e, t);
        });
      });
    }
    function AsyncIterator(t, e) {
      function invoke(r, o, i, a) {
        var c = tryCatch(t[r], t, o);
        if ("throw" !== c.type) {
          var u = c.arg,
            h = u.value;
          return h && "object" == typeof h && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) {
            invoke("next", t, i, a);
          }, function (t) {
            invoke("throw", t, i, a);
          }) : e.resolve(h).then(function (t) {
            u.value = t, i(u);
          }, function (t) {
            return invoke("throw", t, i, a);
          });
        }
        a(c.arg);
      }
      var r;
      o(this, "_invoke", {
        value: function (t, n) {
          function callInvokeWithMethodAndArg() {
            return new e(function (e, r) {
              invoke(t, n, e, r);
            });
          }
          return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        }
      });
    }
    function makeInvokeMethod(e, r, n) {
      var o = h;
      return function (i, a) {
        if (o === f) throw Error("Generator is already running");
        if (o === s) {
          if ("throw" === i) throw a;
          return {
            value: t,
            done: !0
          };
        }
        for (n.method = i, n.arg = a;;) {
          var c = n.delegate;
          if (c) {
            var u = maybeInvokeDelegate(c, n);
            if (u) {
              if (u === y) continue;
              return u;
            }
          }
          if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) {
            if (o === h) throw o = s, n.arg;
            n.dispatchException(n.arg);
          } else "return" === n.method && n.abrupt("return", n.arg);
          o = f;
          var p = tryCatch(e, r, n);
          if ("normal" === p.type) {
            if (o = n.done ? s : l, p.arg === y) continue;
            return {
              value: p.arg,
              done: n.done
            };
          }
          "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg);
        }
      };
    }
    function maybeInvokeDelegate(e, r) {
      var n = r.method,
        o = e.iterator[n];
      if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y;
      var i = tryCatch(o, e.iterator, r.arg);
      if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y;
      var a = i.arg;
      return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y);
    }
    function pushTryEntry(t) {
      var e = {
        tryLoc: t[0]
      };
      1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);
    }
    function resetTryEntry(t) {
      var e = t.completion || {};
      e.type = "normal", delete e.arg, t.completion = e;
    }
    function Context(t) {
      this.tryEntries = [{
        tryLoc: "root"
      }], t.forEach(pushTryEntry, this), this.reset(!0);
    }
    function values(e) {
      if (e || "" === e) {
        var r = e[a];
        if (r) return r.call(e);
        if ("function" == typeof e.next) return e;
        if (!isNaN(e.length)) {
          var o = -1,
            i = function next() {
              for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next;
              return next.value = t, next.done = !0, next;
            };
          return i.next = i;
        }
      }
      throw new TypeError(typeof e + " is not iterable");
    }
    return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
      value: GeneratorFunctionPrototype,
      configurable: !0
    }), o(GeneratorFunctionPrototype, "constructor", {
      value: GeneratorFunction,
      configurable: !0
    }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) {
      var e = "function" == typeof t && t.constructor;
      return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name));
    }, e.mark = function (t) {
      return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t;
    }, e.awrap = function (t) {
      return {
        __await: t
      };
    }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () {
      return this;
    }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) {
      void 0 === i && (i = Promise);
      var a = new AsyncIterator(wrap(t, r, n, o), i);
      return e.isGeneratorFunction(r) ? a : a.next().then(function (t) {
        return t.done ? t.value : a.next();
      });
    }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () {
      return this;
    }), define(g, "toString", function () {
      return "[object Generator]";
    }), e.keys = function (t) {
      var e = Object(t),
        r = [];
      for (var n in e) r.push(n);
      return r.reverse(), function next() {
        for (; r.length;) {
          var t = r.pop();
          if (t in e) return next.value = t, next.done = !1, next;
        }
        return next.done = !0, next;
      };
    }, e.values = values, Context.prototype = {
      constructor: Context,
      reset: function (e) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t);
      },
      stop: function () {
        this.done = !0;
        var t = this.tryEntries[0].completion;
        if ("throw" === t.type) throw t.arg;
        return this.rval;
      },
      dispatchException: function (e) {
        if (this.done) throw e;
        var r = this;
        function handle(n, o) {
          return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o;
        }
        for (var o = this.tryEntries.length - 1; o >= 0; --o) {
          var i = this.tryEntries[o],
            a = i.completion;
          if ("root" === i.tryLoc) return handle("end");
          if (i.tryLoc <= this.prev) {
            var c = n.call(i, "catchLoc"),
              u = n.call(i, "finallyLoc");
            if (c && u) {
              if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
              if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
            } else if (c) {
              if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
            } else {
              if (!u) throw Error("try statement without catch or finally");
              if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
            }
          }
        }
      },
      abrupt: function (t, e) {
        for (var r = this.tryEntries.length - 1; r >= 0; --r) {
          var o = this.tryEntries[r];
          if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) {
            var i = o;
            break;
          }
        }
        i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);
        var a = i ? i.completion : {};
        return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a);
      },
      complete: function (t, e) {
        if ("throw" === t.type) throw t.arg;
        return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y;
      },
      finish: function (t) {
        for (var e = this.tryEntries.length - 1; e >= 0; --e) {
          var r = this.tryEntries[e];
          if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y;
        }
      },
      catch: function (t) {
        for (var e = this.tryEntries.length - 1; e >= 0; --e) {
          var r = this.tryEntries[e];
          if (r.tryLoc === t) {
            var n = r.completion;
            if ("throw" === n.type) {
              var o = n.arg;
              resetTryEntry(r);
            }
            return o;
          }
        }
        throw Error("illegal catch attempt");
      },
      delegateYield: function (e, r, n) {
        return this.delegate = {
          iterator: values(e),
          resultName: r,
          nextLoc: n
        }, "next" === this.method && (this.arg = t), y;
      }
    }, e;
  }
  function _slicedToArray(r, e) {
    return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();
  }
  function _toConsumableArray(r) {
    return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();
  }
  function _toPrimitive(t, r) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r);
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (String )(t);
  }
  function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _unsupportedIterableToArray(r, a) {
    if (r) {
      if ("string" == typeof r) return _arrayLikeToArray(r, a);
      var t = {}.toString.call(r).slice(8, -1);
      return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
    }
  }

  /**
   * @license
   * Copyright 2010-2024 Three.js Authors
   * SPDX-License-Identifier: MIT
   */
  const REVISION = '167';
  const CullFaceNone = 0;
  const CullFaceBack = 1;
  const CullFaceFront = 2;
  const PCFShadowMap = 1;
  const PCFSoftShadowMap = 2;
  const VSMShadowMap = 3;
  const FrontSide = 0;
  const BackSide = 1;
  const DoubleSide = 2;
  const NoBlending = 0;
  const NormalBlending = 1;
  const AdditiveBlending = 2;
  const SubtractiveBlending = 3;
  const MultiplyBlending = 4;
  const CustomBlending = 5;
  const AddEquation = 100;
  const SubtractEquation = 101;
  const ReverseSubtractEquation = 102;
  const MinEquation = 103;
  const MaxEquation = 104;
  const ZeroFactor = 200;
  const OneFactor = 201;
  const SrcColorFactor = 202;
  const OneMinusSrcColorFactor = 203;
  const SrcAlphaFactor = 204;
  const OneMinusSrcAlphaFactor = 205;
  const DstAlphaFactor = 206;
  const OneMinusDstAlphaFactor = 207;
  const DstColorFactor = 208;
  const OneMinusDstColorFactor = 209;
  const SrcAlphaSaturateFactor = 210;
  const ConstantColorFactor = 211;
  const OneMinusConstantColorFactor = 212;
  const ConstantAlphaFactor = 213;
  const OneMinusConstantAlphaFactor = 214;
  const NeverDepth = 0;
  const AlwaysDepth = 1;
  const LessDepth = 2;
  const LessEqualDepth = 3;
  const EqualDepth = 4;
  const GreaterEqualDepth = 5;
  const GreaterDepth = 6;
  const NotEqualDepth = 7;
  const MultiplyOperation = 0;
  const MixOperation = 1;
  const AddOperation = 2;
  const NoToneMapping = 0;
  const LinearToneMapping = 1;
  const ReinhardToneMapping = 2;
  const CineonToneMapping = 3;
  const ACESFilmicToneMapping = 4;
  const CustomToneMapping = 5;
  const AgXToneMapping = 6;
  const NeutralToneMapping = 7;
  const AttachedBindMode = 'attached';
  const DetachedBindMode = 'detached';

  const UVMapping = 300;
  const CubeReflectionMapping = 301;
  const CubeRefractionMapping = 302;
  const EquirectangularReflectionMapping = 303;
  const EquirectangularRefractionMapping = 304;
  const CubeUVReflectionMapping = 306;
  const RepeatWrapping = 1000;
  const ClampToEdgeWrapping = 1001;
  const MirroredRepeatWrapping = 1002;
  const NearestFilter = 1003;
  const NearestMipmapNearestFilter = 1004;
  const NearestMipmapLinearFilter = 1005;
  const LinearFilter = 1006;
  const LinearMipmapNearestFilter = 1007;
  const LinearMipmapLinearFilter = 1008;
  const UnsignedByteType = 1009;
  const ByteType = 1010;
  const ShortType = 1011;
  const UnsignedShortType = 1012;
  const IntType = 1013;
  const UnsignedIntType = 1014;
  const FloatType = 1015;
  const HalfFloatType = 1016;
  const UnsignedShort4444Type = 1017;
  const UnsignedShort5551Type = 1018;
  const UnsignedInt248Type = 1020;
  const UnsignedInt5999Type = 35902;
  const AlphaFormat = 1021;
  const RGBFormat = 1022;
  const RGBAFormat = 1023;
  const LuminanceFormat = 1024;
  const LuminanceAlphaFormat = 1025;
  const DepthFormat = 1026;
  const DepthStencilFormat = 1027;
  const RedFormat = 1028;
  const RedIntegerFormat = 1029;
  const RGFormat = 1030;
  const RGIntegerFormat = 1031;
  const RGBAIntegerFormat = 1033;

  const RGB_S3TC_DXT1_Format = 33776;
  const RGBA_S3TC_DXT1_Format = 33777;
  const RGBA_S3TC_DXT3_Format = 33778;
  const RGBA_S3TC_DXT5_Format = 33779;
  const RGB_PVRTC_4BPPV1_Format = 35840;
  const RGB_PVRTC_2BPPV1_Format = 35841;
  const RGBA_PVRTC_4BPPV1_Format = 35842;
  const RGBA_PVRTC_2BPPV1_Format = 35843;
  const RGB_ETC1_Format = 36196;
  const RGB_ETC2_Format = 37492;
  const RGBA_ETC2_EAC_Format = 37496;
  const RGBA_ASTC_4x4_Format = 37808;
  const RGBA_ASTC_5x4_Format = 37809;
  const RGBA_ASTC_5x5_Format = 37810;
  const RGBA_ASTC_6x5_Format = 37811;
  const RGBA_ASTC_6x6_Format = 37812;
  const RGBA_ASTC_8x5_Format = 37813;
  const RGBA_ASTC_8x6_Format = 37814;
  const RGBA_ASTC_8x8_Format = 37815;
  const RGBA_ASTC_10x5_Format = 37816;
  const RGBA_ASTC_10x6_Format = 37817;
  const RGBA_ASTC_10x8_Format = 37818;
  const RGBA_ASTC_10x10_Format = 37819;
  const RGBA_ASTC_12x10_Format = 37820;
  const RGBA_ASTC_12x12_Format = 37821;
  const RGBA_BPTC_Format = 36492;
  const RGB_BPTC_SIGNED_Format = 36494;
  const RGB_BPTC_UNSIGNED_Format = 36495;
  const RED_RGTC1_Format = 36283;
  const SIGNED_RED_RGTC1_Format = 36284;
  const RED_GREEN_RGTC2_Format = 36285;
  const SIGNED_RED_GREEN_RGTC2_Format = 36286;
  const InterpolateDiscrete = 2300;
  const InterpolateLinear = 2301;
  const InterpolateSmooth = 2302;
  const ZeroCurvatureEnding = 2400;
  const ZeroSlopeEnding = 2401;
  const WrapAroundEnding = 2402;
  const NormalAnimationBlendMode = 2500;
  const TrianglesDrawMode = 0;
  const TriangleStripDrawMode = 1;
  const TriangleFanDrawMode = 2;
  const BasicDepthPacking = 3200;
  const RGBADepthPacking = 3201;
  const TangentSpaceNormalMap = 0;
  const ObjectSpaceNormalMap = 1;

  // Color space string identifiers, matching CSS Color Module Level 4 and WebGPU names where available.
  const NoColorSpace = '';
  const SRGBColorSpace = 'srgb';
  const LinearSRGBColorSpace = 'srgb-linear';
  const DisplayP3ColorSpace = 'display-p3';
  const LinearDisplayP3ColorSpace = 'display-p3-linear';

  const LinearTransfer = 'linear';
  const SRGBTransfer = 'srgb';

  const Rec709Primaries = 'rec709';
  const P3Primaries = 'p3';
  const KeepStencilOp = 7680;
  const AlwaysStencilFunc = 519;

  const NeverCompare = 512;
  const LessCompare = 513;
  const EqualCompare = 514;
  const LessEqualCompare = 515;
  const GreaterCompare = 516;
  const NotEqualCompare = 517;
  const GreaterEqualCompare = 518;
  const AlwaysCompare = 519;

  const StaticDrawUsage = 35044;
  const DynamicDrawUsage = 35048;
  const GLSL3 = '300 es';

  const WebGLCoordinateSystem = 2000;
  const WebGPUCoordinateSystem = 2001;

  /**
   * https://github.com/mrdoob/eventdispatcher.js/
   */

  class EventDispatcher {

  	addEventListener( type, listener ) {

  		if ( this._listeners === undefined ) this._listeners = {};

  		const listeners = this._listeners;

  		if ( listeners[ type ] === undefined ) {

  			listeners[ type ] = [];

  		}

  		if ( listeners[ type ].indexOf( listener ) === - 1 ) {

  			listeners[ type ].push( listener );

  		}

  	}

  	hasEventListener( type, listener ) {

  		if ( this._listeners === undefined ) return false;

  		const listeners = this._listeners;

  		return listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;

  	}

  	removeEventListener( type, listener ) {

  		if ( this._listeners === undefined ) return;

  		const listeners = this._listeners;
  		const listenerArray = listeners[ type ];

  		if ( listenerArray !== undefined ) {

  			const index = listenerArray.indexOf( listener );

  			if ( index !== - 1 ) {

  				listenerArray.splice( index, 1 );

  			}

  		}

  	}

  	dispatchEvent( event ) {

  		if ( this._listeners === undefined ) return;

  		const listeners = this._listeners;
  		const listenerArray = listeners[ event.type ];

  		if ( listenerArray !== undefined ) {

  			event.target = this;

  			// Make a copy, in case listeners are removed while iterating.
  			const array = listenerArray.slice( 0 );

  			for ( let i = 0, l = array.length; i < l; i ++ ) {

  				array[ i ].call( this, event );

  			}

  			event.target = null;

  		}

  	}

  }

  const _lut = [ '00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '0a', '0b', '0c', '0d', '0e', '0f', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '1a', '1b', '1c', '1d', '1e', '1f', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '2a', '2b', '2c', '2d', '2e', '2f', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '3a', '3b', '3c', '3d', '3e', '3f', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '4a', '4b', '4c', '4d', '4e', '4f', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59', '5a', '5b', '5c', '5d', '5e', '5f', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '6a', '6b', '6c', '6d', '6e', '6f', '70', '71', '72', '73', '74', '75', '76', '77', '78', '79', '7a', '7b', '7c', '7d', '7e', '7f', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '8a', '8b', '8c', '8d', '8e', '8f', '90', '91', '92', '93', '94', '95', '96', '97', '98', '99', '9a', '9b', '9c', '9d', '9e', '9f', 'a0', 'a1', 'a2', 'a3', 'a4', 'a5', 'a6', 'a7', 'a8', 'a9', 'aa', 'ab', 'ac', 'ad', 'ae', 'af', 'b0', 'b1', 'b2', 'b3', 'b4', 'b5', 'b6', 'b7', 'b8', 'b9', 'ba', 'bb', 'bc', 'bd', 'be', 'bf', 'c0', 'c1', 'c2', 'c3', 'c4', 'c5', 'c6', 'c7', 'c8', 'c9', 'ca', 'cb', 'cc', 'cd', 'ce', 'cf', 'd0', 'd1', 'd2', 'd3', 'd4', 'd5', 'd6', 'd7', 'd8', 'd9', 'da', 'db', 'dc', 'dd', 'de', 'df', 'e0', 'e1', 'e2', 'e3', 'e4', 'e5', 'e6', 'e7', 'e8', 'e9', 'ea', 'eb', 'ec', 'ed', 'ee', 'ef', 'f0', 'f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'fa', 'fb', 'fc', 'fd', 'fe', 'ff' ];

  let _seed = 1234567;


  const DEG2RAD = Math.PI / 180;
  const RAD2DEG$1 = 180 / Math.PI;

  // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
  function generateUUID() {

  	const d0 = Math.random() * 0xffffffff | 0;
  	const d1 = Math.random() * 0xffffffff | 0;
  	const d2 = Math.random() * 0xffffffff | 0;
  	const d3 = Math.random() * 0xffffffff | 0;
  	const uuid = _lut[ d0 & 0xff ] + _lut[ d0 >> 8 & 0xff ] + _lut[ d0 >> 16 & 0xff ] + _lut[ d0 >> 24 & 0xff ] + '-' +
  			_lut[ d1 & 0xff ] + _lut[ d1 >> 8 & 0xff ] + '-' + _lut[ d1 >> 16 & 0x0f | 0x40 ] + _lut[ d1 >> 24 & 0xff ] + '-' +
  			_lut[ d2 & 0x3f | 0x80 ] + _lut[ d2 >> 8 & 0xff ] + '-' + _lut[ d2 >> 16 & 0xff ] + _lut[ d2 >> 24 & 0xff ] +
  			_lut[ d3 & 0xff ] + _lut[ d3 >> 8 & 0xff ] + _lut[ d3 >> 16 & 0xff ] + _lut[ d3 >> 24 & 0xff ];

  	// .toLowerCase() here flattens concatenated strings to save heap memory space.
  	return uuid.toLowerCase();

  }

  function clamp( value, min, max ) {

  	return Math.max( min, Math.min( max, value ) );

  }

  // compute euclidean modulo of m % n
  // https://en.wikipedia.org/wiki/Modulo_operation
  function euclideanModulo( n, m ) {

  	return ( ( n % m ) + m ) % m;

  }

  // Linear mapping from range <a1, a2> to range <b1, b2>
  function mapLinear( x, a1, a2, b1, b2 ) {

  	return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

  }

  // https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/
  function inverseLerp( x, y, value ) {

  	if ( x !== y ) {

  		return ( value - x ) / ( y - x );

  	} else {

  		return 0;

  	}

  }

  // https://en.wikipedia.org/wiki/Linear_interpolation
  function lerp( x, y, t ) {

  	return ( 1 - t ) * x + t * y;

  }

  // http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/
  function damp( x, y, lambda, dt ) {

  	return lerp( x, y, 1 - Math.exp( - lambda * dt ) );

  }

  // https://www.desmos.com/calculator/vcsjnyz7x4
  function pingpong( x, length = 1 ) {

  	return length - Math.abs( euclideanModulo( x, length * 2 ) - length );

  }

  // http://en.wikipedia.org/wiki/Smoothstep
  function smoothstep( x, min, max ) {

  	if ( x <= min ) return 0;
  	if ( x >= max ) return 1;

  	x = ( x - min ) / ( max - min );

  	return x * x * ( 3 - 2 * x );

  }

  function smootherstep( x, min, max ) {

  	if ( x <= min ) return 0;
  	if ( x >= max ) return 1;

  	x = ( x - min ) / ( max - min );

  	return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

  }

  // Random integer from <low, high> interval
  function randInt( low, high ) {

  	return low + Math.floor( Math.random() * ( high - low + 1 ) );

  }

  // Random float from <low, high> interval
  function randFloat( low, high ) {

  	return low + Math.random() * ( high - low );

  }

  // Random float from <-range/2, range/2> interval
  function randFloatSpread( range ) {

  	return range * ( 0.5 - Math.random() );

  }

  // Deterministic pseudo-random float in the interval [ 0, 1 ]
  function seededRandom( s ) {

  	if ( s !== undefined ) _seed = s;

  	// Mulberry32 generator

  	let t = _seed += 0x6D2B79F5;

  	t = Math.imul( t ^ t >>> 15, t | 1 );

  	t ^= t + Math.imul( t ^ t >>> 7, t | 61 );

  	return ( ( t ^ t >>> 14 ) >>> 0 ) / 4294967296;

  }

  function degToRad( degrees ) {

  	return degrees * DEG2RAD;

  }

  function radToDeg( radians ) {

  	return radians * RAD2DEG$1;

  }

  function isPowerOfTwo( value ) {

  	return ( value & ( value - 1 ) ) === 0 && value !== 0;

  }

  function ceilPowerOfTwo( value ) {

  	return Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );

  }

  function floorPowerOfTwo( value ) {

  	return Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );

  }

  function setQuaternionFromProperEuler( q, a, b, c, order ) {

  	// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles

  	// rotations are applied to the axes in the order specified by 'order'
  	// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
  	// angles are in radians

  	const cos = Math.cos;
  	const sin = Math.sin;

  	const c2 = cos( b / 2 );
  	const s2 = sin( b / 2 );

  	const c13 = cos( ( a + c ) / 2 );
  	const s13 = sin( ( a + c ) / 2 );

  	const c1_3 = cos( ( a - c ) / 2 );
  	const s1_3 = sin( ( a - c ) / 2 );

  	const c3_1 = cos( ( c - a ) / 2 );
  	const s3_1 = sin( ( c - a ) / 2 );

  	switch ( order ) {

  		case 'XYX':
  			q.set( c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13 );
  			break;

  		case 'YZY':
  			q.set( s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13 );
  			break;

  		case 'ZXZ':
  			q.set( s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13 );
  			break;

  		case 'XZX':
  			q.set( c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13 );
  			break;

  		case 'YXY':
  			q.set( s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13 );
  			break;

  		case 'ZYZ':
  			q.set( s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13 );
  			break;

  		default:
  			console.warn( 'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order );

  	}

  }

  function denormalize( value, array ) {

  	switch ( array.constructor ) {

  		case Float32Array:

  			return value;

  		case Uint32Array:

  			return value / 4294967295.0;

  		case Uint16Array:

  			return value / 65535.0;

  		case Uint8Array:

  			return value / 255.0;

  		case Int32Array:

  			return Math.max( value / 2147483647.0, - 1.0 );

  		case Int16Array:

  			return Math.max( value / 32767.0, - 1.0 );

  		case Int8Array:

  			return Math.max( value / 127.0, - 1.0 );

  		default:

  			throw new Error( 'Invalid component type.' );

  	}

  }

  function normalize( value, array ) {

  	switch ( array.constructor ) {

  		case Float32Array:

  			return value;

  		case Uint32Array:

  			return Math.round( value * 4294967295.0 );

  		case Uint16Array:

  			return Math.round( value * 65535.0 );

  		case Uint8Array:

  			return Math.round( value * 255.0 );

  		case Int32Array:

  			return Math.round( value * 2147483647.0 );

  		case Int16Array:

  			return Math.round( value * 32767.0 );

  		case Int8Array:

  			return Math.round( value * 127.0 );

  		default:

  			throw new Error( 'Invalid component type.' );

  	}

  }

  const MathUtils = {
  	DEG2RAD: DEG2RAD,
  	RAD2DEG: RAD2DEG$1,
  	generateUUID: generateUUID,
  	clamp: clamp,
  	euclideanModulo: euclideanModulo,
  	mapLinear: mapLinear,
  	inverseLerp: inverseLerp,
  	lerp: lerp,
  	damp: damp,
  	pingpong: pingpong,
  	smoothstep: smoothstep,
  	smootherstep: smootherstep,
  	randInt: randInt,
  	randFloat: randFloat,
  	randFloatSpread: randFloatSpread,
  	seededRandom: seededRandom,
  	degToRad: degToRad,
  	radToDeg: radToDeg,
  	isPowerOfTwo: isPowerOfTwo,
  	ceilPowerOfTwo: ceilPowerOfTwo,
  	floorPowerOfTwo: floorPowerOfTwo,
  	setQuaternionFromProperEuler: setQuaternionFromProperEuler,
  	normalize: normalize,
  	denormalize: denormalize
  };

  class Vector2 {

  	constructor( x = 0, y = 0 ) {

  		Vector2.prototype.isVector2 = true;

  		this.x = x;
  		this.y = y;

  	}

  	get width() {

  		return this.x;

  	}

  	set width( value ) {

  		this.x = value;

  	}

  	get height() {

  		return this.y;

  	}

  	set height( value ) {

  		this.y = value;

  	}

  	set( x, y ) {

  		this.x = x;
  		this.y = y;

  		return this;

  	}

  	setScalar( scalar ) {

  		this.x = scalar;
  		this.y = scalar;

  		return this;

  	}

  	setX( x ) {

  		this.x = x;

  		return this;

  	}

  	setY( y ) {

  		this.y = y;

  		return this;

  	}

  	setComponent( index, value ) {

  		switch ( index ) {

  			case 0: this.x = value; break;
  			case 1: this.y = value; break;
  			default: throw new Error( 'index is out of range: ' + index );

  		}

  		return this;

  	}

  	getComponent( index ) {

  		switch ( index ) {

  			case 0: return this.x;
  			case 1: return this.y;
  			default: throw new Error( 'index is out of range: ' + index );

  		}

  	}

  	clone() {

  		return new this.constructor( this.x, this.y );

  	}

  	copy( v ) {

  		this.x = v.x;
  		this.y = v.y;

  		return this;

  	}

  	add( v ) {

  		this.x += v.x;
  		this.y += v.y;

  		return this;

  	}

  	addScalar( s ) {

  		this.x += s;
  		this.y += s;

  		return this;

  	}

  	addVectors( a, b ) {

  		this.x = a.x + b.x;
  		this.y = a.y + b.y;

  		return this;

  	}

  	addScaledVector( v, s ) {

  		this.x += v.x * s;
  		this.y += v.y * s;

  		return this;

  	}

  	sub( v ) {

  		this.x -= v.x;
  		this.y -= v.y;

  		return this;

  	}

  	subScalar( s ) {

  		this.x -= s;
  		this.y -= s;

  		return this;

  	}

  	subVectors( a, b ) {

  		this.x = a.x - b.x;
  		this.y = a.y - b.y;

  		return this;

  	}

  	multiply( v ) {

  		this.x *= v.x;
  		this.y *= v.y;

  		return this;

  	}

  	multiplyScalar( scalar ) {

  		this.x *= scalar;
  		this.y *= scalar;

  		return this;

  	}

  	divide( v ) {

  		this.x /= v.x;
  		this.y /= v.y;

  		return this;

  	}

  	divideScalar( scalar ) {

  		return this.multiplyScalar( 1 / scalar );

  	}

  	applyMatrix3( m ) {

  		const x = this.x, y = this.y;
  		const e = m.elements;

  		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];
  		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];

  		return this;

  	}

  	min( v ) {

  		this.x = Math.min( this.x, v.x );
  		this.y = Math.min( this.y, v.y );

  		return this;

  	}

  	max( v ) {

  		this.x = Math.max( this.x, v.x );
  		this.y = Math.max( this.y, v.y );

  		return this;

  	}

  	clamp( min, max ) {

  		// assumes min < max, componentwise

  		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
  		this.y = Math.max( min.y, Math.min( max.y, this.y ) );

  		return this;

  	}

  	clampScalar( minVal, maxVal ) {

  		this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
  		this.y = Math.max( minVal, Math.min( maxVal, this.y ) );

  		return this;

  	}

  	clampLength( min, max ) {

  		const length = this.length();

  		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

  	}

  	floor() {

  		this.x = Math.floor( this.x );
  		this.y = Math.floor( this.y );

  		return this;

  	}

  	ceil() {

  		this.x = Math.ceil( this.x );
  		this.y = Math.ceil( this.y );

  		return this;

  	}

  	round() {

  		this.x = Math.round( this.x );
  		this.y = Math.round( this.y );

  		return this;

  	}

  	roundToZero() {

  		this.x = Math.trunc( this.x );
  		this.y = Math.trunc( this.y );

  		return this;

  	}

  	negate() {

  		this.x = - this.x;
  		this.y = - this.y;

  		return this;

  	}

  	dot( v ) {

  		return this.x * v.x + this.y * v.y;

  	}

  	cross( v ) {

  		return this.x * v.y - this.y * v.x;

  	}

  	lengthSq() {

  		return this.x * this.x + this.y * this.y;

  	}

  	length() {

  		return Math.sqrt( this.x * this.x + this.y * this.y );

  	}

  	manhattanLength() {

  		return Math.abs( this.x ) + Math.abs( this.y );

  	}

  	normalize() {

  		return this.divideScalar( this.length() || 1 );

  	}

  	angle() {

  		// computes the angle in radians with respect to the positive x-axis

  		const angle = Math.atan2( - this.y, - this.x ) + Math.PI;

  		return angle;

  	}

  	angleTo( v ) {

  		const denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );

  		if ( denominator === 0 ) return Math.PI / 2;

  		const theta = this.dot( v ) / denominator;

  		// clamp, to handle numerical problems

  		return Math.acos( clamp( theta, - 1, 1 ) );

  	}

  	distanceTo( v ) {

  		return Math.sqrt( this.distanceToSquared( v ) );

  	}

  	distanceToSquared( v ) {

  		const dx = this.x - v.x, dy = this.y - v.y;
  		return dx * dx + dy * dy;

  	}

  	manhattanDistanceTo( v ) {

  		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );

  	}

  	setLength( length ) {

  		return this.normalize().multiplyScalar( length );

  	}

  	lerp( v, alpha ) {

  		this.x += ( v.x - this.x ) * alpha;
  		this.y += ( v.y - this.y ) * alpha;

  		return this;

  	}

  	lerpVectors( v1, v2, alpha ) {

  		this.x = v1.x + ( v2.x - v1.x ) * alpha;
  		this.y = v1.y + ( v2.y - v1.y ) * alpha;

  		return this;

  	}

  	equals( v ) {

  		return ( ( v.x === this.x ) && ( v.y === this.y ) );

  	}

  	fromArray( array, offset = 0 ) {

  		this.x = array[ offset ];
  		this.y = array[ offset + 1 ];

  		return this;

  	}

  	toArray( array = [], offset = 0 ) {

  		array[ offset ] = this.x;
  		array[ offset + 1 ] = this.y;

  		return array;

  	}

  	fromBufferAttribute( attribute, index ) {

  		this.x = attribute.getX( index );
  		this.y = attribute.getY( index );

  		return this;

  	}

  	rotateAround( center, angle ) {

  		const c = Math.cos( angle ), s = Math.sin( angle );

  		const x = this.x - center.x;
  		const y = this.y - center.y;

  		this.x = x * c - y * s + center.x;
  		this.y = x * s + y * c + center.y;

  		return this;

  	}

  	random() {

  		this.x = Math.random();
  		this.y = Math.random();

  		return this;

  	}

  	*[ Symbol.iterator ]() {

  		yield this.x;
  		yield this.y;

  	}

  }

  class Matrix3 {

  	constructor( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

  		Matrix3.prototype.isMatrix3 = true;

  		this.elements = [

  			1, 0, 0,
  			0, 1, 0,
  			0, 0, 1

  		];

  		if ( n11 !== undefined ) {

  			this.set( n11, n12, n13, n21, n22, n23, n31, n32, n33 );

  		}

  	}

  	set( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

  		const te = this.elements;

  		te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
  		te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
  		te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;

  		return this;

  	}

  	identity() {

  		this.set(

  			1, 0, 0,
  			0, 1, 0,
  			0, 0, 1

  		);

  		return this;

  	}

  	copy( m ) {

  		const te = this.elements;
  		const me = m.elements;

  		te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];
  		te[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];
  		te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];

  		return this;

  	}

  	extractBasis( xAxis, yAxis, zAxis ) {

  		xAxis.setFromMatrix3Column( this, 0 );
  		yAxis.setFromMatrix3Column( this, 1 );
  		zAxis.setFromMatrix3Column( this, 2 );

  		return this;

  	}

  	setFromMatrix4( m ) {

  		const me = m.elements;

  		this.set(

  			me[ 0 ], me[ 4 ], me[ 8 ],
  			me[ 1 ], me[ 5 ], me[ 9 ],
  			me[ 2 ], me[ 6 ], me[ 10 ]

  		);

  		return this;

  	}

  	multiply( m ) {

  		return this.multiplyMatrices( this, m );

  	}

  	premultiply( m ) {

  		return this.multiplyMatrices( m, this );

  	}

  	multiplyMatrices( a, b ) {

  		const ae = a.elements;
  		const be = b.elements;
  		const te = this.elements;

  		const a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];
  		const a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];
  		const a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];

  		const b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];
  		const b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];
  		const b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];

  		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;
  		te[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;
  		te[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;

  		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;
  		te[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;
  		te[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;

  		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;
  		te[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;
  		te[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;

  		return this;

  	}

  	multiplyScalar( s ) {

  		const te = this.elements;

  		te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
  		te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
  		te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

  		return this;

  	}

  	determinant() {

  		const te = this.elements;

  		const a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
  			d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
  			g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

  		return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

  	}

  	invert() {

  		const te = this.elements,

  			n11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ],
  			n12 = te[ 3 ], n22 = te[ 4 ], n32 = te[ 5 ],
  			n13 = te[ 6 ], n23 = te[ 7 ], n33 = te[ 8 ],

  			t11 = n33 * n22 - n32 * n23,
  			t12 = n32 * n13 - n33 * n12,
  			t13 = n23 * n12 - n22 * n13,

  			det = n11 * t11 + n21 * t12 + n31 * t13;

  		if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0 );

  		const detInv = 1 / det;

  		te[ 0 ] = t11 * detInv;
  		te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
  		te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;

  		te[ 3 ] = t12 * detInv;
  		te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
  		te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;

  		te[ 6 ] = t13 * detInv;
  		te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
  		te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;

  		return this;

  	}

  	transpose() {

  		let tmp;
  		const m = this.elements;

  		tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
  		tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
  		tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

  		return this;

  	}

  	getNormalMatrix( matrix4 ) {

  		return this.setFromMatrix4( matrix4 ).invert().transpose();

  	}

  	transposeIntoArray( r ) {

  		const m = this.elements;

  		r[ 0 ] = m[ 0 ];
  		r[ 1 ] = m[ 3 ];
  		r[ 2 ] = m[ 6 ];
  		r[ 3 ] = m[ 1 ];
  		r[ 4 ] = m[ 4 ];
  		r[ 5 ] = m[ 7 ];
  		r[ 6 ] = m[ 2 ];
  		r[ 7 ] = m[ 5 ];
  		r[ 8 ] = m[ 8 ];

  		return this;

  	}

  	setUvTransform( tx, ty, sx, sy, rotation, cx, cy ) {

  		const c = Math.cos( rotation );
  		const s = Math.sin( rotation );

  		this.set(
  			sx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,
  			- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,
  			0, 0, 1
  		);

  		return this;

  	}

  	//

  	scale( sx, sy ) {

  		this.premultiply( _m3.makeScale( sx, sy ) );

  		return this;

  	}

  	rotate( theta ) {

  		this.premultiply( _m3.makeRotation( - theta ) );

  		return this;

  	}

  	translate( tx, ty ) {

  		this.premultiply( _m3.makeTranslation( tx, ty ) );

  		return this;

  	}

  	// for 2D Transforms

  	makeTranslation( x, y ) {

  		if ( x.isVector2 ) {

  			this.set(

  				1, 0, x.x,
  				0, 1, x.y,
  				0, 0, 1

  			);

  		} else {

  			this.set(

  				1, 0, x,
  				0, 1, y,
  				0, 0, 1

  			);

  		}

  		return this;

  	}

  	makeRotation( theta ) {

  		// counterclockwise

  		const c = Math.cos( theta );
  		const s = Math.sin( theta );

  		this.set(

  			c, - s, 0,
  			s, c, 0,
  			0, 0, 1

  		);

  		return this;

  	}

  	makeScale( x, y ) {

  		this.set(

  			x, 0, 0,
  			0, y, 0,
  			0, 0, 1

  		);

  		return this;

  	}

  	//

  	equals( matrix ) {

  		const te = this.elements;
  		const me = matrix.elements;

  		for ( let i = 0; i < 9; i ++ ) {

  			if ( te[ i ] !== me[ i ] ) return false;

  		}

  		return true;

  	}

  	fromArray( array, offset = 0 ) {

  		for ( let i = 0; i < 9; i ++ ) {

  			this.elements[ i ] = array[ i + offset ];

  		}

  		return this;

  	}

  	toArray( array = [], offset = 0 ) {

  		const te = this.elements;

  		array[ offset ] = te[ 0 ];
  		array[ offset + 1 ] = te[ 1 ];
  		array[ offset + 2 ] = te[ 2 ];

  		array[ offset + 3 ] = te[ 3 ];
  		array[ offset + 4 ] = te[ 4 ];
  		array[ offset + 5 ] = te[ 5 ];

  		array[ offset + 6 ] = te[ 6 ];
  		array[ offset + 7 ] = te[ 7 ];
  		array[ offset + 8 ] = te[ 8 ];

  		return array;

  	}

  	clone() {

  		return new this.constructor().fromArray( this.elements );

  	}

  }

  const _m3 = /*@__PURE__*/ new Matrix3();

  function arrayNeedsUint32( array ) {

  	// assumes larger values usually on last

  	for ( let i = array.length - 1; i >= 0; -- i ) {

  		if ( array[ i ] >= 65535 ) return true; // account for PRIMITIVE_RESTART_FIXED_INDEX, #24565

  	}

  	return false;

  }

  function createElementNS( name ) {

  	return document.createElementNS( 'http://www.w3.org/1999/xhtml', name );

  }

  function createCanvasElement() {

  	const canvas = createElementNS( 'canvas' );
  	canvas.style.display = 'block';
  	return canvas;

  }

  const _cache = {};

  function warnOnce( message ) {

  	if ( message in _cache ) return;

  	_cache[ message ] = true;

  	console.warn( message );

  }

  function probeAsync( gl, sync, interval ) {

  	return new Promise( function ( resolve, reject ) {

  		function probe() {

  			switch ( gl.clientWaitSync( sync, gl.SYNC_FLUSH_COMMANDS_BIT, 0 ) ) {

  				case gl.WAIT_FAILED:
  					reject();
  					break;

  				case gl.TIMEOUT_EXPIRED:
  					setTimeout( probe, interval );
  					break;

  				default:
  					resolve();

  			}

  		}

  		setTimeout( probe, interval );

  	} );

  }

  /**
   * Matrices converting P3 <-> Rec. 709 primaries, without gamut mapping
   * or clipping. Based on W3C specifications for sRGB and Display P3,
   * and ICC specifications for the D50 connection space. Values in/out
   * are _linear_ sRGB and _linear_ Display P3.
   *
   * Note that both sRGB and Display P3 use the sRGB transfer functions.
   *
   * Reference:
   * - http://www.russellcottrell.com/photo/matrixCalculator.htm
   */

  const LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = /*@__PURE__*/ new Matrix3().set(
  	0.8224621, 0.177538, 0.0,
  	0.0331941, 0.9668058, 0.0,
  	0.0170827, 0.0723974, 0.9105199,
  );

  const LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = /*@__PURE__*/ new Matrix3().set(
  	1.2249401, - 0.2249404, 0.0,
  	- 0.0420569, 1.0420571, 0.0,
  	- 0.0196376, - 0.0786361, 1.0982735
  );

  /**
   * Defines supported color spaces by transfer function and primaries,
   * and provides conversions to/from the Linear-sRGB reference space.
   */
  const COLOR_SPACES = {
  	[ LinearSRGBColorSpace ]: {
  		transfer: LinearTransfer,
  		primaries: Rec709Primaries,
  		luminanceCoefficients: [ 0.2126, 0.7152, 0.0722 ],
  		toReference: ( color ) => color,
  		fromReference: ( color ) => color,
  	},
  	[ SRGBColorSpace ]: {
  		transfer: SRGBTransfer,
  		primaries: Rec709Primaries,
  		luminanceCoefficients: [ 0.2126, 0.7152, 0.0722 ],
  		toReference: ( color ) => color.convertSRGBToLinear(),
  		fromReference: ( color ) => color.convertLinearToSRGB(),
  	},
  	[ LinearDisplayP3ColorSpace ]: {
  		transfer: LinearTransfer,
  		primaries: P3Primaries,
  		luminanceCoefficients: [ 0.2289, 0.6917, 0.0793 ],
  		toReference: ( color ) => color.applyMatrix3( LINEAR_DISPLAY_P3_TO_LINEAR_SRGB ),
  		fromReference: ( color ) => color.applyMatrix3( LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 ),
  	},
  	[ DisplayP3ColorSpace ]: {
  		transfer: SRGBTransfer,
  		primaries: P3Primaries,
  		luminanceCoefficients: [ 0.2289, 0.6917, 0.0793 ],
  		toReference: ( color ) => color.convertSRGBToLinear().applyMatrix3( LINEAR_DISPLAY_P3_TO_LINEAR_SRGB ),
  		fromReference: ( color ) => color.applyMatrix3( LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 ).convertLinearToSRGB(),
  	},
  };

  const SUPPORTED_WORKING_COLOR_SPACES = new Set( [ LinearSRGBColorSpace, LinearDisplayP3ColorSpace ] );

  const ColorManagement = {

  	enabled: true,

  	_workingColorSpace: LinearSRGBColorSpace,

  	get workingColorSpace() {

  		return this._workingColorSpace;

  	},

  	set workingColorSpace( colorSpace ) {

  		if ( ! SUPPORTED_WORKING_COLOR_SPACES.has( colorSpace ) ) {

  			throw new Error( `Unsupported working color space, "${ colorSpace }".` );

  		}

  		this._workingColorSpace = colorSpace;

  	},

  	convert: function ( color, sourceColorSpace, targetColorSpace ) {

  		if ( this.enabled === false || sourceColorSpace === targetColorSpace || ! sourceColorSpace || ! targetColorSpace ) {

  			return color;

  		}

  		const sourceToReference = COLOR_SPACES[ sourceColorSpace ].toReference;
  		const targetFromReference = COLOR_SPACES[ targetColorSpace ].fromReference;

  		return targetFromReference( sourceToReference( color ) );

  	},

  	fromWorkingColorSpace: function ( color, targetColorSpace ) {

  		return this.convert( color, this._workingColorSpace, targetColorSpace );

  	},

  	toWorkingColorSpace: function ( color, sourceColorSpace ) {

  		return this.convert( color, sourceColorSpace, this._workingColorSpace );

  	},

  	getPrimaries: function ( colorSpace ) {

  		return COLOR_SPACES[ colorSpace ].primaries;

  	},

  	getTransfer: function ( colorSpace ) {

  		if ( colorSpace === NoColorSpace ) return LinearTransfer;

  		return COLOR_SPACES[ colorSpace ].transfer;

  	},

  	getLuminanceCoefficients: function ( target, colorSpace = this._workingColorSpace ) {

  		return target.fromArray( COLOR_SPACES[ colorSpace ].luminanceCoefficients );

  	},

  };


  function SRGBToLinear( c ) {

  	return ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );

  }

  function LinearToSRGB( c ) {

  	return ( c < 0.0031308 ) ? c * 12.92 : 1.055 * ( Math.pow( c, 0.41666 ) ) - 0.055;

  }

  let _canvas;

  class ImageUtils {

  	static getDataURL( image ) {

  		if ( /^data:/i.test( image.src ) ) {

  			return image.src;

  		}

  		if ( typeof HTMLCanvasElement === 'undefined' ) {

  			return image.src;

  		}

  		let canvas;

  		if ( image instanceof HTMLCanvasElement ) {

  			canvas = image;

  		} else {

  			if ( _canvas === undefined ) _canvas = createElementNS( 'canvas' );

  			_canvas.width = image.width;
  			_canvas.height = image.height;

  			const context = _canvas.getContext( '2d' );

  			if ( image instanceof ImageData ) {

  				context.putImageData( image, 0, 0 );

  			} else {

  				context.drawImage( image, 0, 0, image.width, image.height );

  			}

  			canvas = _canvas;

  		}

  		if ( canvas.width > 2048 || canvas.height > 2048 ) {

  			console.warn( 'THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons', image );

  			return canvas.toDataURL( 'image/jpeg', 0.6 );

  		} else {

  			return canvas.toDataURL( 'image/png' );

  		}

  	}

  	static sRGBToLinear( image ) {

  		if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
  			( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
  			( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

  			const canvas = createElementNS( 'canvas' );

  			canvas.width = image.width;
  			canvas.height = image.height;

  			const context = canvas.getContext( '2d' );
  			context.drawImage( image, 0, 0, image.width, image.height );

  			const imageData = context.getImageData( 0, 0, image.width, image.height );
  			const data = imageData.data;

  			for ( let i = 0; i < data.length; i ++ ) {

  				data[ i ] = SRGBToLinear( data[ i ] / 255 ) * 255;

  			}

  			context.putImageData( imageData, 0, 0 );

  			return canvas;

  		} else if ( image.data ) {

  			const data = image.data.slice( 0 );

  			for ( let i = 0; i < data.length; i ++ ) {

  				if ( data instanceof Uint8Array || data instanceof Uint8ClampedArray ) {

  					data[ i ] = Math.floor( SRGBToLinear( data[ i ] / 255 ) * 255 );

  				} else {

  					// assuming float

  					data[ i ] = SRGBToLinear( data[ i ] );

  				}

  			}

  			return {
  				data: data,
  				width: image.width,
  				height: image.height
  			};

  		} else {

  			console.warn( 'THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.' );
  			return image;

  		}

  	}

  }

  let _sourceId = 0;

  class Source {

  	constructor( data = null ) {

  		this.isSource = true;

  		Object.defineProperty( this, 'id', { value: _sourceId ++ } );

  		this.uuid = generateUUID();

  		this.data = data;
  		this.dataReady = true;

  		this.version = 0;

  	}

  	set needsUpdate( value ) {

  		if ( value === true ) this.version ++;

  	}

  	toJSON( meta ) {

  		const isRootObject = ( meta === undefined || typeof meta === 'string' );

  		if ( ! isRootObject && meta.images[ this.uuid ] !== undefined ) {

  			return meta.images[ this.uuid ];

  		}

  		const output = {
  			uuid: this.uuid,
  			url: ''
  		};

  		const data = this.data;

  		if ( data !== null ) {

  			let url;

  			if ( Array.isArray( data ) ) {

  				// cube texture

  				url = [];

  				for ( let i = 0, l = data.length; i < l; i ++ ) {

  					if ( data[ i ].isDataTexture ) {

  						url.push( serializeImage( data[ i ].image ) );

  					} else {

  						url.push( serializeImage( data[ i ] ) );

  					}

  				}

  			} else {

  				// texture

  				url = serializeImage( data );

  			}

  			output.url = url;

  		}

  		if ( ! isRootObject ) {

  			meta.images[ this.uuid ] = output;

  		}

  		return output;

  	}

  }

  function serializeImage( image ) {

  	if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
  		( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
  		( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

  		// default images

  		return ImageUtils.getDataURL( image );

  	} else {

  		if ( image.data ) {

  			// images of DataTexture

  			return {
  				data: Array.from( image.data ),
  				width: image.width,
  				height: image.height,
  				type: image.data.constructor.name
  			};

  		} else {

  			console.warn( 'THREE.Texture: Unable to serialize Texture.' );
  			return {};

  		}

  	}

  }

  let _textureId = 0;

  class Texture extends EventDispatcher {

  	constructor( image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = Texture.DEFAULT_ANISOTROPY, colorSpace = NoColorSpace ) {

  		super();

  		this.isTexture = true;

  		Object.defineProperty( this, 'id', { value: _textureId ++ } );

  		this.uuid = generateUUID();

  		this.name = '';

  		this.source = new Source( image );
  		this.mipmaps = [];

  		this.mapping = mapping;
  		this.channel = 0;

  		this.wrapS = wrapS;
  		this.wrapT = wrapT;

  		this.magFilter = magFilter;
  		this.minFilter = minFilter;

  		this.anisotropy = anisotropy;

  		this.format = format;
  		this.internalFormat = null;
  		this.type = type;

  		this.offset = new Vector2( 0, 0 );
  		this.repeat = new Vector2( 1, 1 );
  		this.center = new Vector2( 0, 0 );
  		this.rotation = 0;

  		this.matrixAutoUpdate = true;
  		this.matrix = new Matrix3();

  		this.generateMipmaps = true;
  		this.premultiplyAlpha = false;
  		this.flipY = true;
  		this.unpackAlignment = 4;	// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

  		this.colorSpace = colorSpace;

  		this.userData = {};

  		this.version = 0;
  		this.onUpdate = null;

  		this.isRenderTargetTexture = false; // indicates whether a texture belongs to a render target or not
  		this.pmremVersion = 0; // indicates whether this texture should be processed by PMREMGenerator or not (only relevant for render target textures)

  	}

  	get image() {

  		return this.source.data;

  	}

  	set image( value = null ) {

  		this.source.data = value;

  	}

  	updateMatrix() {

  		this.matrix.setUvTransform( this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y );

  	}

  	clone() {

  		return new this.constructor().copy( this );

  	}

  	copy( source ) {

  		this.name = source.name;

  		this.source = source.source;
  		this.mipmaps = source.mipmaps.slice( 0 );

  		this.mapping = source.mapping;
  		this.channel = source.channel;

  		this.wrapS = source.wrapS;
  		this.wrapT = source.wrapT;

  		this.magFilter = source.magFilter;
  		this.minFilter = source.minFilter;

  		this.anisotropy = source.anisotropy;

  		this.format = source.format;
  		this.internalFormat = source.internalFormat;
  		this.type = source.type;

  		this.offset.copy( source.offset );
  		this.repeat.copy( source.repeat );
  		this.center.copy( source.center );
  		this.rotation = source.rotation;

  		this.matrixAutoUpdate = source.matrixAutoUpdate;
  		this.matrix.copy( source.matrix );

  		this.generateMipmaps = source.generateMipmaps;
  		this.premultiplyAlpha = source.premultiplyAlpha;
  		this.flipY = source.flipY;
  		this.unpackAlignment = source.unpackAlignment;
  		this.colorSpace = source.colorSpace;

  		this.userData = JSON.parse( JSON.stringify( source.userData ) );

  		this.needsUpdate = true;

  		return this;

  	}

  	toJSON( meta ) {

  		const isRootObject = ( meta === undefined || typeof meta === 'string' );

  		if ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) {

  			return meta.textures[ this.uuid ];

  		}

  		const output = {

  			metadata: {
  				version: 4.6,
  				type: 'Texture',
  				generator: 'Texture.toJSON'
  			},

  			uuid: this.uuid,
  			name: this.name,

  			image: this.source.toJSON( meta ).uuid,

  			mapping: this.mapping,
  			channel: this.channel,

  			repeat: [ this.repeat.x, this.repeat.y ],
  			offset: [ this.offset.x, this.offset.y ],
  			center: [ this.center.x, this.center.y ],
  			rotation: this.rotation,

  			wrap: [ this.wrapS, this.wrapT ],

  			format: this.format,
  			internalFormat: this.internalFormat,
  			type: this.type,
  			colorSpace: this.colorSpace,

  			minFilter: this.minFilter,
  			magFilter: this.magFilter,
  			anisotropy: this.anisotropy,

  			flipY: this.flipY,

  			generateMipmaps: this.generateMipmaps,
  			premultiplyAlpha: this.premultiplyAlpha,
  			unpackAlignment: this.unpackAlignment

  		};

  		if ( Object.keys( this.userData ).length > 0 ) output.userData = this.userData;

  		if ( ! isRootObject ) {

  			meta.textures[ this.uuid ] = output;

  		}

  		return output;

  	}

  	dispose() {

  		this.dispatchEvent( { type: 'dispose' } );

  	}

  	transformUv( uv ) {

  		if ( this.mapping !== UVMapping ) return uv;

  		uv.applyMatrix3( this.matrix );

  		if ( uv.x < 0 || uv.x > 1 ) {

  			switch ( this.wrapS ) {

  				case RepeatWrapping:

  					uv.x = uv.x - Math.floor( uv.x );
  					break;

  				case ClampToEdgeWrapping:

  					uv.x = uv.x < 0 ? 0 : 1;
  					break;

  				case MirroredRepeatWrapping:

  					if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {

  						uv.x = Math.ceil( uv.x ) - uv.x;

  					} else {

  						uv.x = uv.x - Math.floor( uv.x );

  					}

  					break;

  			}

  		}

  		if ( uv.y < 0 || uv.y > 1 ) {

  			switch ( this.wrapT ) {

  				case RepeatWrapping:

  					uv.y = uv.y - Math.floor( uv.y );
  					break;

  				case ClampToEdgeWrapping:

  					uv.y = uv.y < 0 ? 0 : 1;
  					break;

  				case MirroredRepeatWrapping:

  					if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {

  						uv.y = Math.ceil( uv.y ) - uv.y;

  					} else {

  						uv.y = uv.y - Math.floor( uv.y );

  					}

  					break;

  			}

  		}

  		if ( this.flipY ) {

  			uv.y = 1 - uv.y;

  		}

  		return uv;

  	}

  	set needsUpdate( value ) {

  		if ( value === true ) {

  			this.version ++;
  			this.source.needsUpdate = true;

  		}

  	}

  	set needsPMREMUpdate( value ) {

  		if ( value === true ) {

  			this.pmremVersion ++;

  		}

  	}

  }

  Texture.DEFAULT_IMAGE = null;
  Texture.DEFAULT_MAPPING = UVMapping;
  Texture.DEFAULT_ANISOTROPY = 1;

  class Vector4 {

  	constructor( x = 0, y = 0, z = 0, w = 1 ) {

  		Vector4.prototype.isVector4 = true;

  		this.x = x;
  		this.y = y;
  		this.z = z;
  		this.w = w;

  	}

  	get width() {

  		return this.z;

  	}

  	set width( value ) {

  		this.z = value;

  	}

  	get height() {

  		return this.w;

  	}

  	set height( value ) {

  		this.w = value;

  	}

  	set( x, y, z, w ) {

  		this.x = x;
  		this.y = y;
  		this.z = z;
  		this.w = w;

  		return this;

  	}

  	setScalar( scalar ) {

  		this.x = scalar;
  		this.y = scalar;
  		this.z = scalar;
  		this.w = scalar;

  		return this;

  	}

  	setX( x ) {

  		this.x = x;

  		return this;

  	}

  	setY( y ) {

  		this.y = y;

  		return this;

  	}

  	setZ( z ) {

  		this.z = z;

  		return this;

  	}

  	setW( w ) {

  		this.w = w;

  		return this;

  	}

  	setComponent( index, value ) {

  		switch ( index ) {

  			case 0: this.x = value; break;
  			case 1: this.y = value; break;
  			case 2: this.z = value; break;
  			case 3: this.w = value; break;
  			default: throw new Error( 'index is out of range: ' + index );

  		}

  		return this;

  	}

  	getComponent( index ) {

  		switch ( index ) {

  			case 0: return this.x;
  			case 1: return this.y;
  			case 2: return this.z;
  			case 3: return this.w;
  			default: throw new Error( 'index is out of range: ' + index );

  		}

  	}

  	clone() {

  		return new this.constructor( this.x, this.y, this.z, this.w );

  	}

  	copy( v ) {

  		this.x = v.x;
  		this.y = v.y;
  		this.z = v.z;
  		this.w = ( v.w !== undefined ) ? v.w : 1;

  		return this;

  	}

  	add( v ) {

  		this.x += v.x;
  		this.y += v.y;
  		this.z += v.z;
  		this.w += v.w;

  		return this;

  	}

  	addScalar( s ) {

  		this.x += s;
  		this.y += s;
  		this.z += s;
  		this.w += s;

  		return this;

  	}

  	addVectors( a, b ) {

  		this.x = a.x + b.x;
  		this.y = a.y + b.y;
  		this.z = a.z + b.z;
  		this.w = a.w + b.w;

  		return this;

  	}

  	addScaledVector( v, s ) {

  		this.x += v.x * s;
  		this.y += v.y * s;
  		this.z += v.z * s;
  		this.w += v.w * s;

  		return this;

  	}

  	sub( v ) {

  		this.x -= v.x;
  		this.y -= v.y;
  		this.z -= v.z;
  		this.w -= v.w;

  		return this;

  	}

  	subScalar( s ) {

  		this.x -= s;
  		this.y -= s;
  		this.z -= s;
  		this.w -= s;

  		return this;

  	}

  	subVectors( a, b ) {

  		this.x = a.x - b.x;
  		this.y = a.y - b.y;
  		this.z = a.z - b.z;
  		this.w = a.w - b.w;

  		return this;

  	}

  	multiply( v ) {

  		this.x *= v.x;
  		this.y *= v.y;
  		this.z *= v.z;
  		this.w *= v.w;

  		return this;

  	}

  	multiplyScalar( scalar ) {

  		this.x *= scalar;
  		this.y *= scalar;
  		this.z *= scalar;
  		this.w *= scalar;

  		return this;

  	}

  	applyMatrix4( m ) {

  		const x = this.x, y = this.y, z = this.z, w = this.w;
  		const e = m.elements;

  		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
  		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
  		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
  		this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

  		return this;

  	}

  	divideScalar( scalar ) {

  		return this.multiplyScalar( 1 / scalar );

  	}

  	setAxisAngleFromQuaternion( q ) {

  		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

  		// q is assumed to be normalized

  		this.w = 2 * Math.acos( q.w );

  		const s = Math.sqrt( 1 - q.w * q.w );

  		if ( s < 0.0001 ) {

  			this.x = 1;
  			this.y = 0;
  			this.z = 0;

  		} else {

  			this.x = q.x / s;
  			this.y = q.y / s;
  			this.z = q.z / s;

  		}

  		return this;

  	}

  	setAxisAngleFromRotationMatrix( m ) {

  		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

  		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

  		let angle, x, y, z; // variables for result
  		const epsilon = 0.01,		// margin to allow for rounding errors
  			epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

  			te = m.elements,

  			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
  			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
  			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

  		if ( ( Math.abs( m12 - m21 ) < epsilon ) &&
  		     ( Math.abs( m13 - m31 ) < epsilon ) &&
  		     ( Math.abs( m23 - m32 ) < epsilon ) ) {

  			// singularity found
  			// first check for identity matrix which must have +1 for all terms
  			// in leading diagonal and zero in other terms

  			if ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&
  			     ( Math.abs( m13 + m31 ) < epsilon2 ) &&
  			     ( Math.abs( m23 + m32 ) < epsilon2 ) &&
  			     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

  				// this singularity is identity matrix so angle = 0

  				this.set( 1, 0, 0, 0 );

  				return this; // zero angle, arbitrary axis

  			}

  			// otherwise this singularity is angle = 180

  			angle = Math.PI;

  			const xx = ( m11 + 1 ) / 2;
  			const yy = ( m22 + 1 ) / 2;
  			const zz = ( m33 + 1 ) / 2;
  			const xy = ( m12 + m21 ) / 4;
  			const xz = ( m13 + m31 ) / 4;
  			const yz = ( m23 + m32 ) / 4;

  			if ( ( xx > yy ) && ( xx > zz ) ) {

  				// m11 is the largest diagonal term

  				if ( xx < epsilon ) {

  					x = 0;
  					y = 0.707106781;
  					z = 0.707106781;

  				} else {

  					x = Math.sqrt( xx );
  					y = xy / x;
  					z = xz / x;

  				}

  			} else if ( yy > zz ) {

  				// m22 is the largest diagonal term

  				if ( yy < epsilon ) {

  					x = 0.707106781;
  					y = 0;
  					z = 0.707106781;

  				} else {

  					y = Math.sqrt( yy );
  					x = xy / y;
  					z = yz / y;

  				}

  			} else {

  				// m33 is the largest diagonal term so base result on this

  				if ( zz < epsilon ) {

  					x = 0.707106781;
  					y = 0.707106781;
  					z = 0;

  				} else {

  					z = Math.sqrt( zz );
  					x = xz / z;
  					y = yz / z;

  				}

  			}

  			this.set( x, y, z, angle );

  			return this; // return 180 deg rotation

  		}

  		// as we have reached here there are no singularities so we can handle normally

  		let s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +
  			( m13 - m31 ) * ( m13 - m31 ) +
  			( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

  		if ( Math.abs( s ) < 0.001 ) s = 1;

  		// prevent divide by zero, should not happen if matrix is orthogonal and should be
  		// caught by singularity test above, but I've left it in just in case

  		this.x = ( m32 - m23 ) / s;
  		this.y = ( m13 - m31 ) / s;
  		this.z = ( m21 - m12 ) / s;
  		this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

  		return this;

  	}

  	setFromMatrixPosition( m ) {

  		const e = m.elements;

  		this.x = e[ 12 ];
  		this.y = e[ 13 ];
  		this.z = e[ 14 ];
  		this.w = e[ 15 ];

  		return this;

  	}

  	min( v ) {

  		this.x = Math.min( this.x, v.x );
  		this.y = Math.min( this.y, v.y );
  		this.z = Math.min( this.z, v.z );
  		this.w = Math.min( this.w, v.w );

  		return this;

  	}

  	max( v ) {

  		this.x = Math.max( this.x, v.x );
  		this.y = Math.max( this.y, v.y );
  		this.z = Math.max( this.z, v.z );
  		this.w = Math.max( this.w, v.w );

  		return this;

  	}

  	clamp( min, max ) {

  		// assumes min < max, componentwise

  		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
  		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
  		this.z = Math.max( min.z, Math.min( max.z, this.z ) );
  		this.w = Math.max( min.w, Math.min( max.w, this.w ) );

  		return this;

  	}

  	clampScalar( minVal, maxVal ) {

  		this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
  		this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
  		this.z = Math.max( minVal, Math.min( maxVal, this.z ) );
  		this.w = Math.max( minVal, Math.min( maxVal, this.w ) );

  		return this;

  	}

  	clampLength( min, max ) {

  		const length = this.length();

  		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

  	}

  	floor() {

  		this.x = Math.floor( this.x );
  		this.y = Math.floor( this.y );
  		this.z = Math.floor( this.z );
  		this.w = Math.floor( this.w );

  		return this;

  	}

  	ceil() {

  		this.x = Math.ceil( this.x );
  		this.y = Math.ceil( this.y );
  		this.z = Math.ceil( this.z );
  		this.w = Math.ceil( this.w );

  		return this;

  	}

  	round() {

  		this.x = Math.round( this.x );
  		this.y = Math.round( this.y );
  		this.z = Math.round( this.z );
  		this.w = Math.round( this.w );

  		return this;

  	}

  	roundToZero() {

  		this.x = Math.trunc( this.x );
  		this.y = Math.trunc( this.y );
  		this.z = Math.trunc( this.z );
  		this.w = Math.trunc( this.w );

  		return this;

  	}

  	negate() {

  		this.x = - this.x;
  		this.y = - this.y;
  		this.z = - this.z;
  		this.w = - this.w;

  		return this;

  	}

  	dot( v ) {

  		return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

  	}

  	lengthSq() {

  		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

  	}

  	length() {

  		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

  	}

  	manhattanLength() {

  		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

  	}

  	normalize() {

  		return this.divideScalar( this.length() || 1 );

  	}

  	setLength( length ) {

  		return this.normalize().multiplyScalar( length );

  	}

  	lerp( v, alpha ) {

  		this.x += ( v.x - this.x ) * alpha;
  		this.y += ( v.y - this.y ) * alpha;
  		this.z += ( v.z - this.z ) * alpha;
  		this.w += ( v.w - this.w ) * alpha;

  		return this;

  	}

  	lerpVectors( v1, v2, alpha ) {

  		this.x = v1.x + ( v2.x - v1.x ) * alpha;
  		this.y = v1.y + ( v2.y - v1.y ) * alpha;
  		this.z = v1.z + ( v2.z - v1.z ) * alpha;
  		this.w = v1.w + ( v2.w - v1.w ) * alpha;

  		return this;

  	}

  	equals( v ) {

  		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

  	}

  	fromArray( array, offset = 0 ) {

  		this.x = array[ offset ];
  		this.y = array[ offset + 1 ];
  		this.z = array[ offset + 2 ];
  		this.w = array[ offset + 3 ];

  		return this;

  	}

  	toArray( array = [], offset = 0 ) {

  		array[ offset ] = this.x;
  		array[ offset + 1 ] = this.y;
  		array[ offset + 2 ] = this.z;
  		array[ offset + 3 ] = this.w;

  		return array;

  	}

  	fromBufferAttribute( attribute, index ) {

  		this.x = attribute.getX( index );
  		this.y = attribute.getY( index );
  		this.z = attribute.getZ( index );
  		this.w = attribute.getW( index );

  		return this;

  	}

  	random() {

  		this.x = Math.random();
  		this.y = Math.random();
  		this.z = Math.random();
  		this.w = Math.random();

  		return this;

  	}

  	*[ Symbol.iterator ]() {

  		yield this.x;
  		yield this.y;
  		yield this.z;
  		yield this.w;

  	}

  }

  /*
   In options, we can specify:
   * Texture parameters for an auto-generated target texture
   * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
  */
  class RenderTarget extends EventDispatcher {

  	constructor( width = 1, height = 1, options = {} ) {

  		super();

  		this.isRenderTarget = true;

  		this.width = width;
  		this.height = height;
  		this.depth = 1;

  		this.scissor = new Vector4( 0, 0, width, height );
  		this.scissorTest = false;

  		this.viewport = new Vector4( 0, 0, width, height );

  		const image = { width: width, height: height, depth: 1 };

  		options = Object.assign( {
  			generateMipmaps: false,
  			internalFormat: null,
  			minFilter: LinearFilter,
  			depthBuffer: true,
  			stencilBuffer: false,
  			resolveDepthBuffer: true,
  			resolveStencilBuffer: true,
  			depthTexture: null,
  			samples: 0,
  			count: 1
  		}, options );

  		const texture = new Texture( image, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.colorSpace );

  		texture.flipY = false;
  		texture.generateMipmaps = options.generateMipmaps;
  		texture.internalFormat = options.internalFormat;

  		this.textures = [];

  		const count = options.count;
  		for ( let i = 0; i < count; i ++ ) {

  			this.textures[ i ] = texture.clone();
  			this.textures[ i ].isRenderTargetTexture = true;

  		}

  		this.depthBuffer = options.depthBuffer;
  		this.stencilBuffer = options.stencilBuffer;

  		this.resolveDepthBuffer = options.resolveDepthBuffer;
  		this.resolveStencilBuffer = options.resolveStencilBuffer;

  		this.depthTexture = options.depthTexture;

  		this.samples = options.samples;

  	}

  	get texture() {

  		return this.textures[ 0 ];

  	}

  	set texture( value ) {

  		this.textures[ 0 ] = value;

  	}

  	setSize( width, height, depth = 1 ) {

  		if ( this.width !== width || this.height !== height || this.depth !== depth ) {

  			this.width = width;
  			this.height = height;
  			this.depth = depth;

  			for ( let i = 0, il = this.textures.length; i < il; i ++ ) {

  				this.textures[ i ].image.width = width;
  				this.textures[ i ].image.height = height;
  				this.textures[ i ].image.depth = depth;

  			}

  			this.dispose();

  		}

  		this.viewport.set( 0, 0, width, height );
  		this.scissor.set( 0, 0, width, height );

  	}

  	clone() {

  		return new this.constructor().copy( this );

  	}

  	copy( source ) {

  		this.width = source.width;
  		this.height = source.height;
  		this.depth = source.depth;

  		this.scissor.copy( source.scissor );
  		this.scissorTest = source.scissorTest;

  		this.viewport.copy( source.viewport );

  		this.textures.length = 0;

  		for ( let i = 0, il = source.textures.length; i < il; i ++ ) {

  			this.textures[ i ] = source.textures[ i ].clone();
  			this.textures[ i ].isRenderTargetTexture = true;

  		}

  		// ensure image object is not shared, see #20328

  		const image = Object.assign( {}, source.texture.image );
  		this.texture.source = new Source( image );

  		this.depthBuffer = source.depthBuffer;
  		this.stencilBuffer = source.stencilBuffer;

  		this.resolveDepthBuffer = source.resolveDepthBuffer;
  		this.resolveStencilBuffer = source.resolveStencilBuffer;

  		if ( source.depthTexture !== null ) this.depthTexture = source.depthTexture.clone();

  		this.samples = source.samples;

  		return this;

  	}

  	dispose() {

  		this.dispatchEvent( { type: 'dispose' } );

  	}

  }

  class WebGLRenderTarget extends RenderTarget {

  	constructor( width = 1, height = 1, options = {} ) {

  		super( width, height, options );

  		this.isWebGLRenderTarget = true;

  	}

  }

  class DataArrayTexture extends Texture {

  	constructor( data = null, width = 1, height = 1, depth = 1 ) {

  		super( null );

  		this.isDataArrayTexture = true;

  		this.image = { data, width, height, depth };

  		this.magFilter = NearestFilter;
  		this.minFilter = NearestFilter;

  		this.wrapR = ClampToEdgeWrapping;

  		this.generateMipmaps = false;
  		this.flipY = false;
  		this.unpackAlignment = 1;

  		this.layerUpdates = new Set();

  	}

  	addLayerUpdate( layerIndex ) {

  		this.layerUpdates.add( layerIndex );

  	}

  	clearLayerUpdates() {

  		this.layerUpdates.clear();

  	}

  }

  class Data3DTexture extends Texture {

  	constructor( data = null, width = 1, height = 1, depth = 1 ) {

  		// We're going to add .setXXX() methods for setting properties later.
  		// Users can still set in DataTexture3D directly.
  		//
  		//	const texture = new THREE.DataTexture3D( data, width, height, depth );
  		// 	texture.anisotropy = 16;
  		//
  		// See #14839

  		super( null );

  		this.isData3DTexture = true;

  		this.image = { data, width, height, depth };

  		this.magFilter = NearestFilter;
  		this.minFilter = NearestFilter;

  		this.wrapR = ClampToEdgeWrapping;

  		this.generateMipmaps = false;
  		this.flipY = false;
  		this.unpackAlignment = 1;

  	}

  }

  class Quaternion {

  	constructor( x = 0, y = 0, z = 0, w = 1 ) {

  		this.isQuaternion = true;

  		this._x = x;
  		this._y = y;
  		this._z = z;
  		this._w = w;

  	}

  	static slerpFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {

  		// fuzz-free, array-based Quaternion SLERP operation

  		let x0 = src0[ srcOffset0 + 0 ],
  			y0 = src0[ srcOffset0 + 1 ],
  			z0 = src0[ srcOffset0 + 2 ],
  			w0 = src0[ srcOffset0 + 3 ];

  		const x1 = src1[ srcOffset1 + 0 ],
  			y1 = src1[ srcOffset1 + 1 ],
  			z1 = src1[ srcOffset1 + 2 ],
  			w1 = src1[ srcOffset1 + 3 ];

  		if ( t === 0 ) {

  			dst[ dstOffset + 0 ] = x0;
  			dst[ dstOffset + 1 ] = y0;
  			dst[ dstOffset + 2 ] = z0;
  			dst[ dstOffset + 3 ] = w0;
  			return;

  		}

  		if ( t === 1 ) {

  			dst[ dstOffset + 0 ] = x1;
  			dst[ dstOffset + 1 ] = y1;
  			dst[ dstOffset + 2 ] = z1;
  			dst[ dstOffset + 3 ] = w1;
  			return;

  		}

  		if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {

  			let s = 1 - t;
  			const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
  				dir = ( cos >= 0 ? 1 : - 1 ),
  				sqrSin = 1 - cos * cos;

  			// Skip the Slerp for tiny steps to avoid numeric problems:
  			if ( sqrSin > Number.EPSILON ) {

  				const sin = Math.sqrt( sqrSin ),
  					len = Math.atan2( sin, cos * dir );

  				s = Math.sin( s * len ) / sin;
  				t = Math.sin( t * len ) / sin;

  			}

  			const tDir = t * dir;

  			x0 = x0 * s + x1 * tDir;
  			y0 = y0 * s + y1 * tDir;
  			z0 = z0 * s + z1 * tDir;
  			w0 = w0 * s + w1 * tDir;

  			// Normalize in case we just did a lerp:
  			if ( s === 1 - t ) {

  				const f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );

  				x0 *= f;
  				y0 *= f;
  				z0 *= f;
  				w0 *= f;

  			}

  		}

  		dst[ dstOffset ] = x0;
  		dst[ dstOffset + 1 ] = y0;
  		dst[ dstOffset + 2 ] = z0;
  		dst[ dstOffset + 3 ] = w0;

  	}

  	static multiplyQuaternionsFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1 ) {

  		const x0 = src0[ srcOffset0 ];
  		const y0 = src0[ srcOffset0 + 1 ];
  		const z0 = src0[ srcOffset0 + 2 ];
  		const w0 = src0[ srcOffset0 + 3 ];

  		const x1 = src1[ srcOffset1 ];
  		const y1 = src1[ srcOffset1 + 1 ];
  		const z1 = src1[ srcOffset1 + 2 ];
  		const w1 = src1[ srcOffset1 + 3 ];

  		dst[ dstOffset ] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
  		dst[ dstOffset + 1 ] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
  		dst[ dstOffset + 2 ] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
  		dst[ dstOffset + 3 ] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;

  		return dst;

  	}

  	get x() {

  		return this._x;

  	}

  	set x( value ) {

  		this._x = value;
  		this._onChangeCallback();

  	}

  	get y() {

  		return this._y;

  	}

  	set y( value ) {

  		this._y = value;
  		this._onChangeCallback();

  	}

  	get z() {

  		return this._z;

  	}

  	set z( value ) {

  		this._z = value;
  		this._onChangeCallback();

  	}

  	get w() {

  		return this._w;

  	}

  	set w( value ) {

  		this._w = value;
  		this._onChangeCallback();

  	}

  	set( x, y, z, w ) {

  		this._x = x;
  		this._y = y;
  		this._z = z;
  		this._w = w;

  		this._onChangeCallback();

  		return this;

  	}

  	clone() {

  		return new this.constructor( this._x, this._y, this._z, this._w );

  	}

  	copy( quaternion ) {

  		this._x = quaternion.x;
  		this._y = quaternion.y;
  		this._z = quaternion.z;
  		this._w = quaternion.w;

  		this._onChangeCallback();

  		return this;

  	}

  	setFromEuler( euler, update = true ) {

  		const x = euler._x, y = euler._y, z = euler._z, order = euler._order;

  		// http://www.mathworks.com/matlabcentral/fileexchange/
  		// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
  		//	content/SpinCalc.m

  		const cos = Math.cos;
  		const sin = Math.sin;

  		const c1 = cos( x / 2 );
  		const c2 = cos( y / 2 );
  		const c3 = cos( z / 2 );

  		const s1 = sin( x / 2 );
  		const s2 = sin( y / 2 );
  		const s3 = sin( z / 2 );

  		switch ( order ) {

  			case 'XYZ':
  				this._x = s1 * c2 * c3 + c1 * s2 * s3;
  				this._y = c1 * s2 * c3 - s1 * c2 * s3;
  				this._z = c1 * c2 * s3 + s1 * s2 * c3;
  				this._w = c1 * c2 * c3 - s1 * s2 * s3;
  				break;

  			case 'YXZ':
  				this._x = s1 * c2 * c3 + c1 * s2 * s3;
  				this._y = c1 * s2 * c3 - s1 * c2 * s3;
  				this._z = c1 * c2 * s3 - s1 * s2 * c3;
  				this._w = c1 * c2 * c3 + s1 * s2 * s3;
  				break;

  			case 'ZXY':
  				this._x = s1 * c2 * c3 - c1 * s2 * s3;
  				this._y = c1 * s2 * c3 + s1 * c2 * s3;
  				this._z = c1 * c2 * s3 + s1 * s2 * c3;
  				this._w = c1 * c2 * c3 - s1 * s2 * s3;
  				break;

  			case 'ZYX':
  				this._x = s1 * c2 * c3 - c1 * s2 * s3;
  				this._y = c1 * s2 * c3 + s1 * c2 * s3;
  				this._z = c1 * c2 * s3 - s1 * s2 * c3;
  				this._w = c1 * c2 * c3 + s1 * s2 * s3;
  				break;

  			case 'YZX':
  				this._x = s1 * c2 * c3 + c1 * s2 * s3;
  				this._y = c1 * s2 * c3 + s1 * c2 * s3;
  				this._z = c1 * c2 * s3 - s1 * s2 * c3;
  				this._w = c1 * c2 * c3 - s1 * s2 * s3;
  				break;

  			case 'XZY':
  				this._x = s1 * c2 * c3 - c1 * s2 * s3;
  				this._y = c1 * s2 * c3 - s1 * c2 * s3;
  				this._z = c1 * c2 * s3 + s1 * s2 * c3;
  				this._w = c1 * c2 * c3 + s1 * s2 * s3;
  				break;

  			default:
  				console.warn( 'THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order );

  		}

  		if ( update === true ) this._onChangeCallback();

  		return this;

  	}

  	setFromAxisAngle( axis, angle ) {

  		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

  		// assumes axis is normalized

  		const halfAngle = angle / 2, s = Math.sin( halfAngle );

  		this._x = axis.x * s;
  		this._y = axis.y * s;
  		this._z = axis.z * s;
  		this._w = Math.cos( halfAngle );

  		this._onChangeCallback();

  		return this;

  	}

  	setFromRotationMatrix( m ) {

  		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

  		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

  		const te = m.elements,

  			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
  			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
  			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

  			trace = m11 + m22 + m33;

  		if ( trace > 0 ) {

  			const s = 0.5 / Math.sqrt( trace + 1.0 );

  			this._w = 0.25 / s;
  			this._x = ( m32 - m23 ) * s;
  			this._y = ( m13 - m31 ) * s;
  			this._z = ( m21 - m12 ) * s;

  		} else if ( m11 > m22 && m11 > m33 ) {

  			const s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

  			this._w = ( m32 - m23 ) / s;
  			this._x = 0.25 * s;
  			this._y = ( m12 + m21 ) / s;
  			this._z = ( m13 + m31 ) / s;

  		} else if ( m22 > m33 ) {

  			const s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

  			this._w = ( m13 - m31 ) / s;
  			this._x = ( m12 + m21 ) / s;
  			this._y = 0.25 * s;
  			this._z = ( m23 + m32 ) / s;

  		} else {

  			const s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

  			this._w = ( m21 - m12 ) / s;
  			this._x = ( m13 + m31 ) / s;
  			this._y = ( m23 + m32 ) / s;
  			this._z = 0.25 * s;

  		}

  		this._onChangeCallback();

  		return this;

  	}

  	setFromUnitVectors( vFrom, vTo ) {

  		// assumes direction vectors vFrom and vTo are normalized

  		let r = vFrom.dot( vTo ) + 1;

  		if ( r < Number.EPSILON ) {

  			// vFrom and vTo point in opposite directions

  			r = 0;

  			if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

  				this._x = - vFrom.y;
  				this._y = vFrom.x;
  				this._z = 0;
  				this._w = r;

  			} else {

  				this._x = 0;
  				this._y = - vFrom.z;
  				this._z = vFrom.y;
  				this._w = r;

  			}

  		} else {

  			// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3

  			this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
  			this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
  			this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
  			this._w = r;

  		}

  		return this.normalize();

  	}

  	angleTo( q ) {

  		return 2 * Math.acos( Math.abs( clamp( this.dot( q ), - 1, 1 ) ) );

  	}

  	rotateTowards( q, step ) {

  		const angle = this.angleTo( q );

  		if ( angle === 0 ) return this;

  		const t = Math.min( 1, step / angle );

  		this.slerp( q, t );

  		return this;

  	}

  	identity() {

  		return this.set( 0, 0, 0, 1 );

  	}

  	invert() {

  		// quaternion is assumed to have unit length

  		return this.conjugate();

  	}

  	conjugate() {

  		this._x *= - 1;
  		this._y *= - 1;
  		this._z *= - 1;

  		this._onChangeCallback();

  		return this;

  	}

  	dot( v ) {

  		return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

  	}

  	lengthSq() {

  		return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

  	}

  	length() {

  		return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

  	}

  	normalize() {

  		let l = this.length();

  		if ( l === 0 ) {

  			this._x = 0;
  			this._y = 0;
  			this._z = 0;
  			this._w = 1;

  		} else {

  			l = 1 / l;

  			this._x = this._x * l;
  			this._y = this._y * l;
  			this._z = this._z * l;
  			this._w = this._w * l;

  		}

  		this._onChangeCallback();

  		return this;

  	}

  	multiply( q ) {

  		return this.multiplyQuaternions( this, q );

  	}

  	premultiply( q ) {

  		return this.multiplyQuaternions( q, this );

  	}

  	multiplyQuaternions( a, b ) {

  		// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

  		const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
  		const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

  		this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
  		this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
  		this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
  		this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

  		this._onChangeCallback();

  		return this;

  	}

  	slerp( qb, t ) {

  		if ( t === 0 ) return this;
  		if ( t === 1 ) return this.copy( qb );

  		const x = this._x, y = this._y, z = this._z, w = this._w;

  		// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

  		let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

  		if ( cosHalfTheta < 0 ) {

  			this._w = - qb._w;
  			this._x = - qb._x;
  			this._y = - qb._y;
  			this._z = - qb._z;

  			cosHalfTheta = - cosHalfTheta;

  		} else {

  			this.copy( qb );

  		}

  		if ( cosHalfTheta >= 1.0 ) {

  			this._w = w;
  			this._x = x;
  			this._y = y;
  			this._z = z;

  			return this;

  		}

  		const sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

  		if ( sqrSinHalfTheta <= Number.EPSILON ) {

  			const s = 1 - t;
  			this._w = s * w + t * this._w;
  			this._x = s * x + t * this._x;
  			this._y = s * y + t * this._y;
  			this._z = s * z + t * this._z;

  			this.normalize(); // normalize calls _onChangeCallback()

  			return this;

  		}

  		const sinHalfTheta = Math.sqrt( sqrSinHalfTheta );
  		const halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
  		const ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
  			ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

  		this._w = ( w * ratioA + this._w * ratioB );
  		this._x = ( x * ratioA + this._x * ratioB );
  		this._y = ( y * ratioA + this._y * ratioB );
  		this._z = ( z * ratioA + this._z * ratioB );

  		this._onChangeCallback();

  		return this;

  	}

  	slerpQuaternions( qa, qb, t ) {

  		return this.copy( qa ).slerp( qb, t );

  	}

  	random() {

  		// sets this quaternion to a uniform random unit quaternnion

  		// Ken Shoemake
  		// Uniform random rotations
  		// D. Kirk, editor, Graphics Gems III, pages 124-132. Academic Press, New York, 1992.

  		const theta1 = 2 * Math.PI * Math.random();
  		const theta2 = 2 * Math.PI * Math.random();

  		const x0 = Math.random();
  		const r1 = Math.sqrt( 1 - x0 );
  		const r2 = Math.sqrt( x0 );

  		return this.set(
  			r1 * Math.sin( theta1 ),
  			r1 * Math.cos( theta1 ),
  			r2 * Math.sin( theta2 ),
  			r2 * Math.cos( theta2 ),
  		);

  	}

  	equals( quaternion ) {

  		return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

  	}

  	fromArray( array, offset = 0 ) {

  		this._x = array[ offset ];
  		this._y = array[ offset + 1 ];
  		this._z = array[ offset + 2 ];
  		this._w = array[ offset + 3 ];

  		this._onChangeCallback();

  		return this;

  	}

  	toArray( array = [], offset = 0 ) {

  		array[ offset ] = this._x;
  		array[ offset + 1 ] = this._y;
  		array[ offset + 2 ] = this._z;
  		array[ offset + 3 ] = this._w;

  		return array;

  	}

  	fromBufferAttribute( attribute, index ) {

  		this._x = attribute.getX( index );
  		this._y = attribute.getY( index );
  		this._z = attribute.getZ( index );
  		this._w = attribute.getW( index );

  		this._onChangeCallback();

  		return this;

  	}

  	toJSON() {

  		return this.toArray();

  	}

  	_onChange( callback ) {

  		this._onChangeCallback = callback;

  		return this;

  	}

  	_onChangeCallback() {}

  	*[ Symbol.iterator ]() {

  		yield this._x;
  		yield this._y;
  		yield this._z;
  		yield this._w;

  	}

  }

  class Vector3 {

  	constructor( x = 0, y = 0, z = 0 ) {

  		Vector3.prototype.isVector3 = true;

  		this.x = x;
  		this.y = y;
  		this.z = z;

  	}

  	set( x, y, z ) {

  		if ( z === undefined ) z = this.z; // sprite.scale.set(x,y)

  		this.x = x;
  		this.y = y;
  		this.z = z;

  		return this;

  	}

  	setScalar( scalar ) {

  		this.x = scalar;
  		this.y = scalar;
  		this.z = scalar;

  		return this;

  	}

  	setX( x ) {

  		this.x = x;

  		return this;

  	}

  	setY( y ) {

  		this.y = y;

  		return this;

  	}

  	setZ( z ) {

  		this.z = z;

  		return this;

  	}

  	setComponent( index, value ) {

  		switch ( index ) {

  			case 0: this.x = value; break;
  			case 1: this.y = value; break;
  			case 2: this.z = value; break;
  			default: throw new Error( 'index is out of range: ' + index );

  		}

  		return this;

  	}

  	getComponent( index ) {

  		switch ( index ) {

  			case 0: return this.x;
  			case 1: return this.y;
  			case 2: return this.z;
  			default: throw new Error( 'index is out of range: ' + index );

  		}

  	}

  	clone() {

  		return new this.constructor( this.x, this.y, this.z );

  	}

  	copy( v ) {

  		this.x = v.x;
  		this.y = v.y;
  		this.z = v.z;

  		return this;

  	}

  	add( v ) {

  		this.x += v.x;
  		this.y += v.y;
  		this.z += v.z;

  		return this;

  	}

  	addScalar( s ) {

  		this.x += s;
  		this.y += s;
  		this.z += s;

  		return this;

  	}

  	addVectors( a, b ) {

  		this.x = a.x + b.x;
  		this.y = a.y + b.y;
  		this.z = a.z + b.z;

  		return this;

  	}

  	addScaledVector( v, s ) {

  		this.x += v.x * s;
  		this.y += v.y * s;
  		this.z += v.z * s;

  		return this;

  	}

  	sub( v ) {

  		this.x -= v.x;
  		this.y -= v.y;
  		this.z -= v.z;

  		return this;

  	}

  	subScalar( s ) {

  		this.x -= s;
  		this.y -= s;
  		this.z -= s;

  		return this;

  	}

  	subVectors( a, b ) {

  		this.x = a.x - b.x;
  		this.y = a.y - b.y;
  		this.z = a.z - b.z;

  		return this;

  	}

  	multiply( v ) {

  		this.x *= v.x;
  		this.y *= v.y;
  		this.z *= v.z;

  		return this;

  	}

  	multiplyScalar( scalar ) {

  		this.x *= scalar;
  		this.y *= scalar;
  		this.z *= scalar;

  		return this;

  	}

  	multiplyVectors( a, b ) {

  		this.x = a.x * b.x;
  		this.y = a.y * b.y;
  		this.z = a.z * b.z;

  		return this;

  	}

  	applyEuler( euler ) {

  		return this.applyQuaternion( _quaternion$4.setFromEuler( euler ) );

  	}

  	applyAxisAngle( axis, angle ) {

  		return this.applyQuaternion( _quaternion$4.setFromAxisAngle( axis, angle ) );

  	}

  	applyMatrix3( m ) {

  		const x = this.x, y = this.y, z = this.z;
  		const e = m.elements;

  		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
  		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
  		this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

  		return this;

  	}

  	applyNormalMatrix( m ) {

  		return this.applyMatrix3( m ).normalize();

  	}

  	applyMatrix4( m ) {

  		const x = this.x, y = this.y, z = this.z;
  		const e = m.elements;

  		const w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );

  		this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;
  		this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;
  		this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;

  		return this;

  	}

  	applyQuaternion( q ) {

  		// quaternion q is assumed to have unit length

  		const vx = this.x, vy = this.y, vz = this.z;
  		const qx = q.x, qy = q.y, qz = q.z, qw = q.w;

  		// t = 2 * cross( q.xyz, v );
  		const tx = 2 * ( qy * vz - qz * vy );
  		const ty = 2 * ( qz * vx - qx * vz );
  		const tz = 2 * ( qx * vy - qy * vx );

  		// v + q.w * t + cross( q.xyz, t );
  		this.x = vx + qw * tx + qy * tz - qz * ty;
  		this.y = vy + qw * ty + qz * tx - qx * tz;
  		this.z = vz + qw * tz + qx * ty - qy * tx;

  		return this;

  	}

  	project( camera ) {

  		return this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );

  	}

  	unproject( camera ) {

  		return this.applyMatrix4( camera.projectionMatrixInverse ).applyMatrix4( camera.matrixWorld );

  	}

  	transformDirection( m ) {

  		// input: THREE.Matrix4 affine matrix
  		// vector interpreted as a direction

  		const x = this.x, y = this.y, z = this.z;
  		const e = m.elements;

  		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;
  		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;
  		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

  		return this.normalize();

  	}

  	divide( v ) {

  		this.x /= v.x;
  		this.y /= v.y;
  		this.z /= v.z;

  		return this;

  	}

  	divideScalar( scalar ) {

  		return this.multiplyScalar( 1 / scalar );

  	}

  	min( v ) {

  		this.x = Math.min( this.x, v.x );
  		this.y = Math.min( this.y, v.y );
  		this.z = Math.min( this.z, v.z );

  		return this;

  	}

  	max( v ) {

  		this.x = Math.max( this.x, v.x );
  		this.y = Math.max( this.y, v.y );
  		this.z = Math.max( this.z, v.z );

  		return this;

  	}

  	clamp( min, max ) {

  		// assumes min < max, componentwise

  		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
  		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
  		this.z = Math.max( min.z, Math.min( max.z, this.z ) );

  		return this;

  	}

  	clampScalar( minVal, maxVal ) {

  		this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
  		this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
  		this.z = Math.max( minVal, Math.min( maxVal, this.z ) );

  		return this;

  	}

  	clampLength( min, max ) {

  		const length = this.length();

  		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

  	}

  	floor() {

  		this.x = Math.floor( this.x );
  		this.y = Math.floor( this.y );
  		this.z = Math.floor( this.z );

  		return this;

  	}

  	ceil() {

  		this.x = Math.ceil( this.x );
  		this.y = Math.ceil( this.y );
  		this.z = Math.ceil( this.z );

  		return this;

  	}

  	round() {

  		this.x = Math.round( this.x );
  		this.y = Math.round( this.y );
  		this.z = Math.round( this.z );

  		return this;

  	}

  	roundToZero() {

  		this.x = Math.trunc( this.x );
  		this.y = Math.trunc( this.y );
  		this.z = Math.trunc( this.z );

  		return this;

  	}

  	negate() {

  		this.x = - this.x;
  		this.y = - this.y;
  		this.z = - this.z;

  		return this;

  	}

  	dot( v ) {

  		return this.x * v.x + this.y * v.y + this.z * v.z;

  	}

  	// TODO lengthSquared?

  	lengthSq() {

  		return this.x * this.x + this.y * this.y + this.z * this.z;

  	}

  	length() {

  		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

  	}

  	manhattanLength() {

  		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

  	}

  	normalize() {

  		return this.divideScalar( this.length() || 1 );

  	}

  	setLength( length ) {

  		return this.normalize().multiplyScalar( length );

  	}

  	lerp( v, alpha ) {

  		this.x += ( v.x - this.x ) * alpha;
  		this.y += ( v.y - this.y ) * alpha;
  		this.z += ( v.z - this.z ) * alpha;

  		return this;

  	}

  	lerpVectors( v1, v2, alpha ) {

  		this.x = v1.x + ( v2.x - v1.x ) * alpha;
  		this.y = v1.y + ( v2.y - v1.y ) * alpha;
  		this.z = v1.z + ( v2.z - v1.z ) * alpha;

  		return this;

  	}

  	cross( v ) {

  		return this.crossVectors( this, v );

  	}

  	crossVectors( a, b ) {

  		const ax = a.x, ay = a.y, az = a.z;
  		const bx = b.x, by = b.y, bz = b.z;

  		this.x = ay * bz - az * by;
  		this.y = az * bx - ax * bz;
  		this.z = ax * by - ay * bx;

  		return this;

  	}

  	projectOnVector( v ) {

  		const denominator = v.lengthSq();

  		if ( denominator === 0 ) return this.set( 0, 0, 0 );

  		const scalar = v.dot( this ) / denominator;

  		return this.copy( v ).multiplyScalar( scalar );

  	}

  	projectOnPlane( planeNormal ) {

  		_vector$c.copy( this ).projectOnVector( planeNormal );

  		return this.sub( _vector$c );

  	}

  	reflect( normal ) {

  		// reflect incident vector off plane orthogonal to normal
  		// normal is assumed to have unit length

  		return this.sub( _vector$c.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

  	}

  	angleTo( v ) {

  		const denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );

  		if ( denominator === 0 ) return Math.PI / 2;

  		const theta = this.dot( v ) / denominator;

  		// clamp, to handle numerical problems

  		return Math.acos( clamp( theta, - 1, 1 ) );

  	}

  	distanceTo( v ) {

  		return Math.sqrt( this.distanceToSquared( v ) );

  	}

  	distanceToSquared( v ) {

  		const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;

  		return dx * dx + dy * dy + dz * dz;

  	}

  	manhattanDistanceTo( v ) {

  		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );

  	}

  	setFromSpherical( s ) {

  		return this.setFromSphericalCoords( s.radius, s.phi, s.theta );

  	}

  	setFromSphericalCoords( radius, phi, theta ) {

  		const sinPhiRadius = Math.sin( phi ) * radius;

  		this.x = sinPhiRadius * Math.sin( theta );
  		this.y = Math.cos( phi ) * radius;
  		this.z = sinPhiRadius * Math.cos( theta );

  		return this;

  	}

  	setFromCylindrical( c ) {

  		return this.setFromCylindricalCoords( c.radius, c.theta, c.y );

  	}

  	setFromCylindricalCoords( radius, theta, y ) {

  		this.x = radius * Math.sin( theta );
  		this.y = y;
  		this.z = radius * Math.cos( theta );

  		return this;

  	}

  	setFromMatrixPosition( m ) {

  		const e = m.elements;

  		this.x = e[ 12 ];
  		this.y = e[ 13 ];
  		this.z = e[ 14 ];

  		return this;

  	}

  	setFromMatrixScale( m ) {

  		const sx = this.setFromMatrixColumn( m, 0 ).length();
  		const sy = this.setFromMatrixColumn( m, 1 ).length();
  		const sz = this.setFromMatrixColumn( m, 2 ).length();

  		this.x = sx;
  		this.y = sy;
  		this.z = sz;

  		return this;

  	}

  	setFromMatrixColumn( m, index ) {

  		return this.fromArray( m.elements, index * 4 );

  	}

  	setFromMatrix3Column( m, index ) {

  		return this.fromArray( m.elements, index * 3 );

  	}

  	setFromEuler( e ) {

  		this.x = e._x;
  		this.y = e._y;
  		this.z = e._z;

  		return this;

  	}

  	setFromColor( c ) {

  		this.x = c.r;
  		this.y = c.g;
  		this.z = c.b;

  		return this;

  	}

  	equals( v ) {

  		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

  	}

  	fromArray( array, offset = 0 ) {

  		this.x = array[ offset ];
  		this.y = array[ offset + 1 ];
  		this.z = array[ offset + 2 ];

  		return this;

  	}

  	toArray( array = [], offset = 0 ) {

  		array[ offset ] = this.x;
  		array[ offset + 1 ] = this.y;
  		array[ offset + 2 ] = this.z;

  		return array;

  	}

  	fromBufferAttribute( attribute, index ) {

  		this.x = attribute.getX( index );
  		this.y = attribute.getY( index );
  		this.z = attribute.getZ( index );

  		return this;

  	}

  	random() {

  		this.x = Math.random();
  		this.y = Math.random();
  		this.z = Math.random();

  		return this;

  	}

  	randomDirection() {

  		// https://mathworld.wolfram.com/SpherePointPicking.html

  		const theta = Math.random() * Math.PI * 2;
  		const u = Math.random() * 2 - 1;
  		const c = Math.sqrt( 1 - u * u );

  		this.x = c * Math.cos( theta );
  		this.y = u;
  		this.z = c * Math.sin( theta );

  		return this;

  	}

  	*[ Symbol.iterator ]() {

  		yield this.x;
  		yield this.y;
  		yield this.z;

  	}

  }

  const _vector$c = /*@__PURE__*/ new Vector3();
  const _quaternion$4 = /*@__PURE__*/ new Quaternion();

  class Box3 {

  	constructor( min = new Vector3( + Infinity, + Infinity, + Infinity ), max = new Vector3( - Infinity, - Infinity, - Infinity ) ) {

  		this.isBox3 = true;

  		this.min = min;
  		this.max = max;

  	}

  	set( min, max ) {

  		this.min.copy( min );
  		this.max.copy( max );

  		return this;

  	}

  	setFromArray( array ) {

  		this.makeEmpty();

  		for ( let i = 0, il = array.length; i < il; i += 3 ) {

  			this.expandByPoint( _vector$b.fromArray( array, i ) );

  		}

  		return this;

  	}

  	setFromBufferAttribute( attribute ) {

  		this.makeEmpty();

  		for ( let i = 0, il = attribute.count; i < il; i ++ ) {

  			this.expandByPoint( _vector$b.fromBufferAttribute( attribute, i ) );

  		}

  		return this;

  	}

  	setFromPoints( points ) {

  		this.makeEmpty();

  		for ( let i = 0, il = points.length; i < il; i ++ ) {

  			this.expandByPoint( points[ i ] );

  		}

  		return this;

  	}

  	setFromCenterAndSize( center, size ) {

  		const halfSize = _vector$b.copy( size ).multiplyScalar( 0.5 );

  		this.min.copy( center ).sub( halfSize );
  		this.max.copy( center ).add( halfSize );

  		return this;

  	}

  	setFromObject( object, precise = false ) {

  		this.makeEmpty();

  		return this.expandByObject( object, precise );

  	}

  	clone() {

  		return new this.constructor().copy( this );

  	}

  	copy( box ) {

  		this.min.copy( box.min );
  		this.max.copy( box.max );

  		return this;

  	}

  	makeEmpty() {

  		this.min.x = this.min.y = this.min.z = + Infinity;
  		this.max.x = this.max.y = this.max.z = - Infinity;

  		return this;

  	}

  	isEmpty() {

  		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

  		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

  	}

  	getCenter( target ) {

  		return this.isEmpty() ? target.set( 0, 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

  	}

  	getSize( target ) {

  		return this.isEmpty() ? target.set( 0, 0, 0 ) : target.subVectors( this.max, this.min );

  	}

  	expandByPoint( point ) {

  		this.min.min( point );
  		this.max.max( point );

  		return this;

  	}

  	expandByVector( vector ) {

  		this.min.sub( vector );
  		this.max.add( vector );

  		return this;

  	}

  	expandByScalar( scalar ) {

  		this.min.addScalar( - scalar );
  		this.max.addScalar( scalar );

  		return this;

  	}

  	expandByObject( object, precise = false ) {

  		// Computes the world-axis-aligned bounding box of an object (including its children),
  		// accounting for both the object's, and children's, world transforms

  		object.updateWorldMatrix( false, false );

  		const geometry = object.geometry;

  		if ( geometry !== undefined ) {

  			const positionAttribute = geometry.getAttribute( 'position' );

  			// precise AABB computation based on vertex data requires at least a position attribute.
  			// instancing isn't supported so far and uses the normal (conservative) code path.

  			if ( precise === true && positionAttribute !== undefined && object.isInstancedMesh !== true ) {

  				for ( let i = 0, l = positionAttribute.count; i < l; i ++ ) {

  					if ( object.isMesh === true ) {

  						object.getVertexPosition( i, _vector$b );

  					} else {

  						_vector$b.fromBufferAttribute( positionAttribute, i );

  					}

  					_vector$b.applyMatrix4( object.matrixWorld );
  					this.expandByPoint( _vector$b );

  				}

  			} else {

  				if ( object.boundingBox !== undefined ) {

  					// object-level bounding box

  					if ( object.boundingBox === null ) {

  						object.computeBoundingBox();

  					}

  					_box$4.copy( object.boundingBox );


  				} else {

  					// geometry-level bounding box

  					if ( geometry.boundingBox === null ) {

  						geometry.computeBoundingBox();

  					}

  					_box$4.copy( geometry.boundingBox );

  				}

  				_box$4.applyMatrix4( object.matrixWorld );

  				this.union( _box$4 );

  			}

  		}

  		const children = object.children;

  		for ( let i = 0, l = children.length; i < l; i ++ ) {

  			this.expandByObject( children[ i ], precise );

  		}

  		return this;

  	}

  	containsPoint( point ) {

  		return point.x >= this.min.x && point.x <= this.max.x &&
  			point.y >= this.min.y && point.y <= this.max.y &&
  			point.z >= this.min.z && point.z <= this.max.z;

  	}

  	containsBox( box ) {

  		return this.min.x <= box.min.x && box.max.x <= this.max.x &&
  			this.min.y <= box.min.y && box.max.y <= this.max.y &&
  			this.min.z <= box.min.z && box.max.z <= this.max.z;

  	}

  	getParameter( point, target ) {

  		// This can potentially have a divide by zero if the box
  		// has a size dimension of 0.

  		return target.set(
  			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
  			( point.y - this.min.y ) / ( this.max.y - this.min.y ),
  			( point.z - this.min.z ) / ( this.max.z - this.min.z )
  		);

  	}

  	intersectsBox( box ) {

  		// using 6 splitting planes to rule out intersections.
  		return box.max.x >= this.min.x && box.min.x <= this.max.x &&
  			box.max.y >= this.min.y && box.min.y <= this.max.y &&
  			box.max.z >= this.min.z && box.min.z <= this.max.z;

  	}

  	intersectsSphere( sphere ) {

  		// Find the point on the AABB closest to the sphere center.
  		this.clampPoint( sphere.center, _vector$b );

  		// If that point is inside the sphere, the AABB and sphere intersect.
  		return _vector$b.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );

  	}

  	intersectsPlane( plane ) {

  		// We compute the minimum and maximum dot product values. If those values
  		// are on the same side (back or front) of the plane, then there is no intersection.

  		let min, max;

  		if ( plane.normal.x > 0 ) {

  			min = plane.normal.x * this.min.x;
  			max = plane.normal.x * this.max.x;

  		} else {

  			min = plane.normal.x * this.max.x;
  			max = plane.normal.x * this.min.x;

  		}

  		if ( plane.normal.y > 0 ) {

  			min += plane.normal.y * this.min.y;
  			max += plane.normal.y * this.max.y;

  		} else {

  			min += plane.normal.y * this.max.y;
  			max += plane.normal.y * this.min.y;

  		}

  		if ( plane.normal.z > 0 ) {

  			min += plane.normal.z * this.min.z;
  			max += plane.normal.z * this.max.z;

  		} else {

  			min += plane.normal.z * this.max.z;
  			max += plane.normal.z * this.min.z;

  		}

  		return ( min <= - plane.constant && max >= - plane.constant );

  	}

  	intersectsTriangle( triangle ) {

  		if ( this.isEmpty() ) {

  			return false;

  		}

  		// compute box center and extents
  		this.getCenter( _center );
  		_extents.subVectors( this.max, _center );

  		// translate triangle to aabb origin
  		_v0$3.subVectors( triangle.a, _center );
  		_v1$7.subVectors( triangle.b, _center );
  		_v2$4.subVectors( triangle.c, _center );

  		// compute edge vectors for triangle
  		_f0.subVectors( _v1$7, _v0$3 );
  		_f1.subVectors( _v2$4, _v1$7 );
  		_f2.subVectors( _v0$3, _v2$4 );

  		// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
  		// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
  		// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
  		let axes = [
  			0, - _f0.z, _f0.y, 0, - _f1.z, _f1.y, 0, - _f2.z, _f2.y,
  			_f0.z, 0, - _f0.x, _f1.z, 0, - _f1.x, _f2.z, 0, - _f2.x,
  			- _f0.y, _f0.x, 0, - _f1.y, _f1.x, 0, - _f2.y, _f2.x, 0
  		];
  		if ( ! satForAxes( axes, _v0$3, _v1$7, _v2$4, _extents ) ) {

  			return false;

  		}

  		// test 3 face normals from the aabb
  		axes = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ];
  		if ( ! satForAxes( axes, _v0$3, _v1$7, _v2$4, _extents ) ) {

  			return false;

  		}

  		// finally testing the face normal of the triangle
  		// use already existing triangle edge vectors here
  		_triangleNormal.crossVectors( _f0, _f1 );
  		axes = [ _triangleNormal.x, _triangleNormal.y, _triangleNormal.z ];

  		return satForAxes( axes, _v0$3, _v1$7, _v2$4, _extents );

  	}

  	clampPoint( point, target ) {

  		return target.copy( point ).clamp( this.min, this.max );

  	}

  	distanceToPoint( point ) {

  		return this.clampPoint( point, _vector$b ).distanceTo( point );

  	}

  	getBoundingSphere( target ) {

  		if ( this.isEmpty() ) {

  			target.makeEmpty();

  		} else {

  			this.getCenter( target.center );

  			target.radius = this.getSize( _vector$b ).length() * 0.5;

  		}

  		return target;

  	}

  	intersect( box ) {

  		this.min.max( box.min );
  		this.max.min( box.max );

  		// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
  		if ( this.isEmpty() ) this.makeEmpty();

  		return this;

  	}

  	union( box ) {

  		this.min.min( box.min );
  		this.max.max( box.max );

  		return this;

  	}

  	applyMatrix4( matrix ) {

  		// transform of empty box is an empty box.
  		if ( this.isEmpty() ) return this;

  		// NOTE: I am using a binary pattern to specify all 2^3 combinations below
  		_points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
  		_points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
  		_points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
  		_points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
  		_points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
  		_points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
  		_points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
  		_points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 111

  		this.setFromPoints( _points );

  		return this;

  	}

  	translate( offset ) {

  		this.min.add( offset );
  		this.max.add( offset );

  		return this;

  	}

  	equals( box ) {

  		return box.min.equals( this.min ) && box.max.equals( this.max );

  	}

  }

  const _points = [
  	/*@__PURE__*/ new Vector3(),
  	/*@__PURE__*/ new Vector3(),
  	/*@__PURE__*/ new Vector3(),
  	/*@__PURE__*/ new Vector3(),
  	/*@__PURE__*/ new Vector3(),
  	/*@__PURE__*/ new Vector3(),
  	/*@__PURE__*/ new Vector3(),
  	/*@__PURE__*/ new Vector3()
  ];

  const _vector$b = /*@__PURE__*/ new Vector3();

  const _box$4 = /*@__PURE__*/ new Box3();

  // triangle centered vertices

  const _v0$3 = /*@__PURE__*/ new Vector3();
  const _v1$7 = /*@__PURE__*/ new Vector3();
  const _v2$4 = /*@__PURE__*/ new Vector3();

  // triangle edge vectors

  const _f0 = /*@__PURE__*/ new Vector3();
  const _f1 = /*@__PURE__*/ new Vector3();
  const _f2 = /*@__PURE__*/ new Vector3();

  const _center = /*@__PURE__*/ new Vector3();
  const _extents = /*@__PURE__*/ new Vector3();
  const _triangleNormal = /*@__PURE__*/ new Vector3();
  const _testAxis = /*@__PURE__*/ new Vector3();

  function satForAxes( axes, v0, v1, v2, extents ) {

  	for ( let i = 0, j = axes.length - 3; i <= j; i += 3 ) {

  		_testAxis.fromArray( axes, i );
  		// project the aabb onto the separating axis
  		const r = extents.x * Math.abs( _testAxis.x ) + extents.y * Math.abs( _testAxis.y ) + extents.z * Math.abs( _testAxis.z );
  		// project all 3 vertices of the triangle onto the separating axis
  		const p0 = v0.dot( _testAxis );
  		const p1 = v1.dot( _testAxis );
  		const p2 = v2.dot( _testAxis );
  		// actual test, basically see if either of the most extreme of the triangle points intersects r
  		if ( Math.max( - Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {

  			// points of the projected triangle are outside the projected half-length of the aabb
  			// the axis is separating and we can exit
  			return false;

  		}

  	}

  	return true;

  }

  const _box$3 = /*@__PURE__*/ new Box3();
  const _v1$6 = /*@__PURE__*/ new Vector3();
  const _v2$3 = /*@__PURE__*/ new Vector3();

  class Sphere {

  	constructor( center = new Vector3(), radius = - 1 ) {

  		this.isSphere = true;

  		this.center = center;
  		this.radius = radius;

  	}

  	set( center, radius ) {

  		this.center.copy( center );
  		this.radius = radius;

  		return this;

  	}

  	setFromPoints( points, optionalCenter ) {

  		const center = this.center;

  		if ( optionalCenter !== undefined ) {

  			center.copy( optionalCenter );

  		} else {

  			_box$3.setFromPoints( points ).getCenter( center );

  		}

  		let maxRadiusSq = 0;

  		for ( let i = 0, il = points.length; i < il; i ++ ) {

  			maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

  		}

  		this.radius = Math.sqrt( maxRadiusSq );

  		return this;

  	}

  	copy( sphere ) {

  		this.center.copy( sphere.center );
  		this.radius = sphere.radius;

  		return this;

  	}

  	isEmpty() {

  		return ( this.radius < 0 );

  	}

  	makeEmpty() {

  		this.center.set( 0, 0, 0 );
  		this.radius = - 1;

  		return this;

  	}

  	containsPoint( point ) {

  		return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

  	}

  	distanceToPoint( point ) {

  		return ( point.distanceTo( this.center ) - this.radius );

  	}

  	intersectsSphere( sphere ) {

  		const radiusSum = this.radius + sphere.radius;

  		return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

  	}

  	intersectsBox( box ) {

  		return box.intersectsSphere( this );

  	}

  	intersectsPlane( plane ) {

  		return Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;

  	}

  	clampPoint( point, target ) {

  		const deltaLengthSq = this.center.distanceToSquared( point );

  		target.copy( point );

  		if ( deltaLengthSq > ( this.radius * this.radius ) ) {

  			target.sub( this.center ).normalize();
  			target.multiplyScalar( this.radius ).add( this.center );

  		}

  		return target;

  	}

  	getBoundingBox( target ) {

  		if ( this.isEmpty() ) {

  			// Empty sphere produces empty bounding box
  			target.makeEmpty();
  			return target;

  		}

  		target.set( this.center, this.center );
  		target.expandByScalar( this.radius );

  		return target;

  	}

  	applyMatrix4( matrix ) {

  		this.center.applyMatrix4( matrix );
  		this.radius = this.radius * matrix.getMaxScaleOnAxis();

  		return this;

  	}

  	translate( offset ) {

  		this.center.add( offset );

  		return this;

  	}

  	expandByPoint( point ) {

  		if ( this.isEmpty() ) {

  			this.center.copy( point );

  			this.radius = 0;

  			return this;

  		}

  		_v1$6.subVectors( point, this.center );

  		const lengthSq = _v1$6.lengthSq();

  		if ( lengthSq > ( this.radius * this.radius ) ) {

  			// calculate the minimal sphere

  			const length = Math.sqrt( lengthSq );

  			const delta = ( length - this.radius ) * 0.5;

  			this.center.addScaledVector( _v1$6, delta / length );

  			this.radius += delta;

  		}

  		return this;

  	}

  	union( sphere ) {

  		if ( sphere.isEmpty() ) {

  			return this;

  		}

  		if ( this.isEmpty() ) {

  			this.copy( sphere );

  			return this;

  		}

  		if ( this.center.equals( sphere.center ) === true ) {

  			 this.radius = Math.max( this.radius, sphere.radius );

  		} else {

  			_v2$3.subVectors( sphere.center, this.center ).setLength( sphere.radius );

  			this.expandByPoint( _v1$6.copy( sphere.center ).add( _v2$3 ) );

  			this.expandByPoint( _v1$6.copy( sphere.center ).sub( _v2$3 ) );

  		}

  		return this;

  	}

  	equals( sphere ) {

  		return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

  	}

  	clone() {

  		return new this.constructor().copy( this );

  	}

  }

  const _vector$a = /*@__PURE__*/ new Vector3();
  const _segCenter = /*@__PURE__*/ new Vector3();
  const _segDir = /*@__PURE__*/ new Vector3();
  const _diff = /*@__PURE__*/ new Vector3();

  const _edge1 = /*@__PURE__*/ new Vector3();
  const _edge2 = /*@__PURE__*/ new Vector3();
  const _normal$1 = /*@__PURE__*/ new Vector3();

  class Ray {

  	constructor( origin = new Vector3(), direction = new Vector3( 0, 0, - 1 ) ) {

  		this.origin = origin;
  		this.direction = direction;

  	}

  	set( origin, direction ) {

  		this.origin.copy( origin );
  		this.direction.copy( direction );

  		return this;

  	}

  	copy( ray ) {

  		this.origin.copy( ray.origin );
  		this.direction.copy( ray.direction );

  		return this;

  	}

  	at( t, target ) {

  		return target.copy( this.origin ).addScaledVector( this.direction, t );

  	}

  	lookAt( v ) {

  		this.direction.copy( v ).sub( this.origin ).normalize();

  		return this;

  	}

  	recast( t ) {

  		this.origin.copy( this.at( t, _vector$a ) );

  		return this;

  	}

  	closestPointToPoint( point, target ) {

  		target.subVectors( point, this.origin );

  		const directionDistance = target.dot( this.direction );

  		if ( directionDistance < 0 ) {

  			return target.copy( this.origin );

  		}

  		return target.copy( this.origin ).addScaledVector( this.direction, directionDistance );

  	}

  	distanceToPoint( point ) {

  		return Math.sqrt( this.distanceSqToPoint( point ) );

  	}

  	distanceSqToPoint( point ) {

  		const directionDistance = _vector$a.subVectors( point, this.origin ).dot( this.direction );

  		// point behind the ray

  		if ( directionDistance < 0 ) {

  			return this.origin.distanceToSquared( point );

  		}

  		_vector$a.copy( this.origin ).addScaledVector( this.direction, directionDistance );

  		return _vector$a.distanceToSquared( point );

  	}

  	distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

  		// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteDistRaySegment.h
  		// It returns the min distance between the ray and the segment
  		// defined by v0 and v1
  		// It can also set two optional targets :
  		// - The closest point on the ray
  		// - The closest point on the segment

  		_segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
  		_segDir.copy( v1 ).sub( v0 ).normalize();
  		_diff.copy( this.origin ).sub( _segCenter );

  		const segExtent = v0.distanceTo( v1 ) * 0.5;
  		const a01 = - this.direction.dot( _segDir );
  		const b0 = _diff.dot( this.direction );
  		const b1 = - _diff.dot( _segDir );
  		const c = _diff.lengthSq();
  		const det = Math.abs( 1 - a01 * a01 );
  		let s0, s1, sqrDist, extDet;

  		if ( det > 0 ) {

  			// The ray and segment are not parallel.

  			s0 = a01 * b1 - b0;
  			s1 = a01 * b0 - b1;
  			extDet = segExtent * det;

  			if ( s0 >= 0 ) {

  				if ( s1 >= - extDet ) {

  					if ( s1 <= extDet ) {

  						// region 0
  						// Minimum at interior points of ray and segment.

  						const invDet = 1 / det;
  						s0 *= invDet;
  						s1 *= invDet;
  						sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

  					} else {

  						// region 1

  						s1 = segExtent;
  						s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
  						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

  					}

  				} else {

  					// region 5

  					s1 = - segExtent;
  					s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
  					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

  				}

  			} else {

  				if ( s1 <= - extDet ) {

  					// region 4

  					s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
  					s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
  					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

  				} else if ( s1 <= extDet ) {

  					// region 3

  					s0 = 0;
  					s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
  					sqrDist = s1 * ( s1 + 2 * b1 ) + c;

  				} else {

  					// region 2

  					s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
  					s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
  					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

  				}

  			}

  		} else {

  			// Ray and segment are parallel.

  			s1 = ( a01 > 0 ) ? - segExtent : segExtent;
  			s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
  			sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

  		}

  		if ( optionalPointOnRay ) {

  			optionalPointOnRay.copy( this.origin ).addScaledVector( this.direction, s0 );

  		}

  		if ( optionalPointOnSegment ) {

  			optionalPointOnSegment.copy( _segCenter ).addScaledVector( _segDir, s1 );

  		}

  		return sqrDist;

  	}

  	intersectSphere( sphere, target ) {

  		_vector$a.subVectors( sphere.center, this.origin );
  		const tca = _vector$a.dot( this.direction );
  		const d2 = _vector$a.dot( _vector$a ) - tca * tca;
  		const radius2 = sphere.radius * sphere.radius;

  		if ( d2 > radius2 ) return null;

  		const thc = Math.sqrt( radius2 - d2 );

  		// t0 = first intersect point - entrance on front of sphere
  		const t0 = tca - thc;

  		// t1 = second intersect point - exit point on back of sphere
  		const t1 = tca + thc;

  		// test to see if t1 is behind the ray - if so, return null
  		if ( t1 < 0 ) return null;

  		// test to see if t0 is behind the ray:
  		// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
  		// in order to always return an intersect point that is in front of the ray.
  		if ( t0 < 0 ) return this.at( t1, target );

  		// else t0 is in front of the ray, so return the first collision point scaled by t0
  		return this.at( t0, target );

  	}

  	intersectsSphere( sphere ) {

  		return this.distanceSqToPoint( sphere.center ) <= ( sphere.radius * sphere.radius );

  	}

  	distanceToPlane( plane ) {

  		const denominator = plane.normal.dot( this.direction );

  		if ( denominator === 0 ) {

  			// line is coplanar, return origin
  			if ( plane.distanceToPoint( this.origin ) === 0 ) {

  				return 0;

  			}

  			// Null is preferable to undefined since undefined means.... it is undefined

  			return null;

  		}

  		const t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

  		// Return if the ray never intersects the plane

  		return t >= 0 ? t : null;

  	}

  	intersectPlane( plane, target ) {

  		const t = this.distanceToPlane( plane );

  		if ( t === null ) {

  			return null;

  		}

  		return this.at( t, target );

  	}

  	intersectsPlane( plane ) {

  		// check if the ray lies on the plane first

  		const distToPoint = plane.distanceToPoint( this.origin );

  		if ( distToPoint === 0 ) {

  			return true;

  		}

  		const denominator = plane.normal.dot( this.direction );

  		if ( denominator * distToPoint < 0 ) {

  			return true;

  		}

  		// ray origin is behind the plane (and is pointing behind it)

  		return false;

  	}

  	intersectBox( box, target ) {

  		let tmin, tmax, tymin, tymax, tzmin, tzmax;

  		const invdirx = 1 / this.direction.x,
  			invdiry = 1 / this.direction.y,
  			invdirz = 1 / this.direction.z;

  		const origin = this.origin;

  		if ( invdirx >= 0 ) {

  			tmin = ( box.min.x - origin.x ) * invdirx;
  			tmax = ( box.max.x - origin.x ) * invdirx;

  		} else {

  			tmin = ( box.max.x - origin.x ) * invdirx;
  			tmax = ( box.min.x - origin.x ) * invdirx;

  		}

  		if ( invdiry >= 0 ) {

  			tymin = ( box.min.y - origin.y ) * invdiry;
  			tymax = ( box.max.y - origin.y ) * invdiry;

  		} else {

  			tymin = ( box.max.y - origin.y ) * invdiry;
  			tymax = ( box.min.y - origin.y ) * invdiry;

  		}

  		if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;

  		if ( tymin > tmin || isNaN( tmin ) ) tmin = tymin;

  		if ( tymax < tmax || isNaN( tmax ) ) tmax = tymax;

  		if ( invdirz >= 0 ) {

  			tzmin = ( box.min.z - origin.z ) * invdirz;
  			tzmax = ( box.max.z - origin.z ) * invdirz;

  		} else {

  			tzmin = ( box.max.z - origin.z ) * invdirz;
  			tzmax = ( box.min.z - origin.z ) * invdirz;

  		}

  		if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;

  		if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

  		if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

  		//return point closest to the ray (positive side)

  		if ( tmax < 0 ) return null;

  		return this.at( tmin >= 0 ? tmin : tmax, target );

  	}

  	intersectsBox( box ) {

  		return this.intersectBox( box, _vector$a ) !== null;

  	}

  	intersectTriangle( a, b, c, backfaceCulling, target ) {

  		// Compute the offset origin, edges, and normal.

  		// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h

  		_edge1.subVectors( b, a );
  		_edge2.subVectors( c, a );
  		_normal$1.crossVectors( _edge1, _edge2 );

  		// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
  		// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
  		//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
  		//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
  		//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
  		let DdN = this.direction.dot( _normal$1 );
  		let sign;

  		if ( DdN > 0 ) {

  			if ( backfaceCulling ) return null;
  			sign = 1;

  		} else if ( DdN < 0 ) {

  			sign = - 1;
  			DdN = - DdN;

  		} else {

  			return null;

  		}

  		_diff.subVectors( this.origin, a );
  		const DdQxE2 = sign * this.direction.dot( _edge2.crossVectors( _diff, _edge2 ) );

  		// b1 < 0, no intersection
  		if ( DdQxE2 < 0 ) {

  			return null;

  		}

  		const DdE1xQ = sign * this.direction.dot( _edge1.cross( _diff ) );

  		// b2 < 0, no intersection
  		if ( DdE1xQ < 0 ) {

  			return null;

  		}

  		// b1+b2 > 1, no intersection
  		if ( DdQxE2 + DdE1xQ > DdN ) {

  			return null;

  		}

  		// Line intersects triangle, check if ray does.
  		const QdN = - sign * _diff.dot( _normal$1 );

  		// t < 0, no intersection
  		if ( QdN < 0 ) {

  			return null;

  		}

  		// Ray intersects triangle.
  		return this.at( QdN / DdN, target );

  	}

  	applyMatrix4( matrix4 ) {

  		this.origin.applyMatrix4( matrix4 );
  		this.direction.transformDirection( matrix4 );

  		return this;

  	}

  	equals( ray ) {

  		return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

  	}

  	clone() {

  		return new this.constructor().copy( this );

  	}

  }

  class Matrix4 {

  	constructor( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

  		Matrix4.prototype.isMatrix4 = true;

  		this.elements = [

  			1, 0, 0, 0,
  			0, 1, 0, 0,
  			0, 0, 1, 0,
  			0, 0, 0, 1

  		];

  		if ( n11 !== undefined ) {

  			this.set( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 );

  		}

  	}

  	set( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

  		const te = this.elements;

  		te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
  		te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
  		te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
  		te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

  		return this;

  	}

  	identity() {

  		this.set(

  			1, 0, 0, 0,
  			0, 1, 0, 0,
  			0, 0, 1, 0,
  			0, 0, 0, 1

  		);

  		return this;

  	}

  	clone() {

  		return new Matrix4().fromArray( this.elements );

  	}

  	copy( m ) {

  		const te = this.elements;
  		const me = m.elements;

  		te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];
  		te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];
  		te[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];
  		te[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];

  		return this;

  	}

  	copyPosition( m ) {

  		const te = this.elements, me = m.elements;

  		te[ 12 ] = me[ 12 ];
  		te[ 13 ] = me[ 13 ];
  		te[ 14 ] = me[ 14 ];

  		return this;

  	}

  	setFromMatrix3( m ) {

  		const me = m.elements;

  		this.set(

  			me[ 0 ], me[ 3 ], me[ 6 ], 0,
  			me[ 1 ], me[ 4 ], me[ 7 ], 0,
  			me[ 2 ], me[ 5 ], me[ 8 ], 0,
  			0, 0, 0, 1

  		);

  		return this;

  	}

  	extractBasis( xAxis, yAxis, zAxis ) {

  		xAxis.setFromMatrixColumn( this, 0 );
  		yAxis.setFromMatrixColumn( this, 1 );
  		zAxis.setFromMatrixColumn( this, 2 );

  		return this;

  	}

  	makeBasis( xAxis, yAxis, zAxis ) {

  		this.set(
  			xAxis.x, yAxis.x, zAxis.x, 0,
  			xAxis.y, yAxis.y, zAxis.y, 0,
  			xAxis.z, yAxis.z, zAxis.z, 0,
  			0, 0, 0, 1
  		);

  		return this;

  	}

  	extractRotation( m ) {

  		// this method does not support reflection matrices

  		const te = this.elements;
  		const me = m.elements;

  		const scaleX = 1 / _v1$5.setFromMatrixColumn( m, 0 ).length();
  		const scaleY = 1 / _v1$5.setFromMatrixColumn( m, 1 ).length();
  		const scaleZ = 1 / _v1$5.setFromMatrixColumn( m, 2 ).length();

  		te[ 0 ] = me[ 0 ] * scaleX;
  		te[ 1 ] = me[ 1 ] * scaleX;
  		te[ 2 ] = me[ 2 ] * scaleX;
  		te[ 3 ] = 0;

  		te[ 4 ] = me[ 4 ] * scaleY;
  		te[ 5 ] = me[ 5 ] * scaleY;
  		te[ 6 ] = me[ 6 ] * scaleY;
  		te[ 7 ] = 0;

  		te[ 8 ] = me[ 8 ] * scaleZ;
  		te[ 9 ] = me[ 9 ] * scaleZ;
  		te[ 10 ] = me[ 10 ] * scaleZ;
  		te[ 11 ] = 0;

  		te[ 12 ] = 0;
  		te[ 13 ] = 0;
  		te[ 14 ] = 0;
  		te[ 15 ] = 1;

  		return this;

  	}

  	makeRotationFromEuler( euler ) {

  		const te = this.elements;

  		const x = euler.x, y = euler.y, z = euler.z;
  		const a = Math.cos( x ), b = Math.sin( x );
  		const c = Math.cos( y ), d = Math.sin( y );
  		const e = Math.cos( z ), f = Math.sin( z );

  		if ( euler.order === 'XYZ' ) {

  			const ae = a * e, af = a * f, be = b * e, bf = b * f;

  			te[ 0 ] = c * e;
  			te[ 4 ] = - c * f;
  			te[ 8 ] = d;

  			te[ 1 ] = af + be * d;
  			te[ 5 ] = ae - bf * d;
  			te[ 9 ] = - b * c;

  			te[ 2 ] = bf - ae * d;
  			te[ 6 ] = be + af * d;
  			te[ 10 ] = a * c;

  		} else if ( euler.order === 'YXZ' ) {

  			const ce = c * e, cf = c * f, de = d * e, df = d * f;

  			te[ 0 ] = ce + df * b;
  			te[ 4 ] = de * b - cf;
  			te[ 8 ] = a * d;

  			te[ 1 ] = a * f;
  			te[ 5 ] = a * e;
  			te[ 9 ] = - b;

  			te[ 2 ] = cf * b - de;
  			te[ 6 ] = df + ce * b;
  			te[ 10 ] = a * c;

  		} else if ( euler.order === 'ZXY' ) {

  			const ce = c * e, cf = c * f, de = d * e, df = d * f;

  			te[ 0 ] = ce - df * b;
  			te[ 4 ] = - a * f;
  			te[ 8 ] = de + cf * b;

  			te[ 1 ] = cf + de * b;
  			te[ 5 ] = a * e;
  			te[ 9 ] = df - ce * b;

  			te[ 2 ] = - a * d;
  			te[ 6 ] = b;
  			te[ 10 ] = a * c;

  		} else if ( euler.order === 'ZYX' ) {

  			const ae = a * e, af = a * f, be = b * e, bf = b * f;

  			te[ 0 ] = c * e;
  			te[ 4 ] = be * d - af;
  			te[ 8 ] = ae * d + bf;

  			te[ 1 ] = c * f;
  			te[ 5 ] = bf * d + ae;
  			te[ 9 ] = af * d - be;

  			te[ 2 ] = - d;
  			te[ 6 ] = b * c;
  			te[ 10 ] = a * c;

  		} else if ( euler.order === 'YZX' ) {

  			const ac = a * c, ad = a * d, bc = b * c, bd = b * d;

  			te[ 0 ] = c * e;
  			te[ 4 ] = bd - ac * f;
  			te[ 8 ] = bc * f + ad;

  			te[ 1 ] = f;
  			te[ 5 ] = a * e;
  			te[ 9 ] = - b * e;

  			te[ 2 ] = - d * e;
  			te[ 6 ] = ad * f + bc;
  			te[ 10 ] = ac - bd * f;

  		} else if ( euler.order === 'XZY' ) {

  			const ac = a * c, ad = a * d, bc = b * c, bd = b * d;

  			te[ 0 ] = c * e;
  			te[ 4 ] = - f;
  			te[ 8 ] = d * e;

  			te[ 1 ] = ac * f + bd;
  			te[ 5 ] = a * e;
  			te[ 9 ] = ad * f - bc;

  			te[ 2 ] = bc * f - ad;
  			te[ 6 ] = b * e;
  			te[ 10 ] = bd * f + ac;

  		}

  		// bottom row
  		te[ 3 ] = 0;
  		te[ 7 ] = 0;
  		te[ 11 ] = 0;

  		// last column
  		te[ 12 ] = 0;
  		te[ 13 ] = 0;
  		te[ 14 ] = 0;
  		te[ 15 ] = 1;

  		return this;

  	}

  	makeRotationFromQuaternion( q ) {

  		return this.compose( _zero, q, _one );

  	}

  	lookAt( eye, target, up ) {

  		const te = this.elements;

  		_z.subVectors( eye, target );

  		if ( _z.lengthSq() === 0 ) {

  			// eye and target are in the same position

  			_z.z = 1;

  		}

  		_z.normalize();
  		_x.crossVectors( up, _z );

  		if ( _x.lengthSq() === 0 ) {

  			// up and z are parallel

  			if ( Math.abs( up.z ) === 1 ) {

  				_z.x += 0.0001;

  			} else {

  				_z.z += 0.0001;

  			}

  			_z.normalize();
  			_x.crossVectors( up, _z );

  		}

  		_x.normalize();
  		_y.crossVectors( _z, _x );

  		te[ 0 ] = _x.x; te[ 4 ] = _y.x; te[ 8 ] = _z.x;
  		te[ 1 ] = _x.y; te[ 5 ] = _y.y; te[ 9 ] = _z.y;
  		te[ 2 ] = _x.z; te[ 6 ] = _y.z; te[ 10 ] = _z.z;

  		return this;

  	}

  	multiply( m ) {

  		return this.multiplyMatrices( this, m );

  	}

  	premultiply( m ) {

  		return this.multiplyMatrices( m, this );

  	}

  	multiplyMatrices( a, b ) {

  		const ae = a.elements;
  		const be = b.elements;
  		const te = this.elements;

  		const a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
  		const a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
  		const a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
  		const a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

  		const b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
  		const b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
  		const b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
  		const b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

  		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
  		te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
  		te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
  		te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

  		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
  		te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
  		te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
  		te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

  		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
  		te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
  		te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
  		te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

  		te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
  		te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
  		te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
  		te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

  		return this;

  	}

  	multiplyScalar( s ) {

  		const te = this.elements;

  		te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
  		te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
  		te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
  		te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

  		return this;

  	}

  	determinant() {

  		const te = this.elements;

  		const n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
  		const n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
  		const n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
  		const n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

  		//TODO: make this more efficient
  		//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

  		return (
  			n41 * (
  				+ n14 * n23 * n32
  				 - n13 * n24 * n32
  				 - n14 * n22 * n33
  				 + n12 * n24 * n33
  				 + n13 * n22 * n34
  				 - n12 * n23 * n34
  			) +
  			n42 * (
  				+ n11 * n23 * n34
  				 - n11 * n24 * n33
  				 + n14 * n21 * n33
  				 - n13 * n21 * n34
  				 + n13 * n24 * n31
  				 - n14 * n23 * n31
  			) +
  			n43 * (
  				+ n11 * n24 * n32
  				 - n11 * n22 * n34
  				 - n14 * n21 * n32
  				 + n12 * n21 * n34
  				 + n14 * n22 * n31
  				 - n12 * n24 * n31
  			) +
  			n44 * (
  				- n13 * n22 * n31
  				 - n11 * n23 * n32
  				 + n11 * n22 * n33
  				 + n13 * n21 * n32
  				 - n12 * n21 * n33
  				 + n12 * n23 * n31
  			)

  		);

  	}

  	transpose() {

  		const te = this.elements;
  		let tmp;

  		tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
  		tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
  		tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

  		tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
  		tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
  		tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

  		return this;

  	}

  	setPosition( x, y, z ) {

  		const te = this.elements;

  		if ( x.isVector3 ) {

  			te[ 12 ] = x.x;
  			te[ 13 ] = x.y;
  			te[ 14 ] = x.z;

  		} else {

  			te[ 12 ] = x;
  			te[ 13 ] = y;
  			te[ 14 ] = z;

  		}

  		return this;

  	}

  	invert() {

  		// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
  		const te = this.elements,

  			n11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ], n41 = te[ 3 ],
  			n12 = te[ 4 ], n22 = te[ 5 ], n32 = te[ 6 ], n42 = te[ 7 ],
  			n13 = te[ 8 ], n23 = te[ 9 ], n33 = te[ 10 ], n43 = te[ 11 ],
  			n14 = te[ 12 ], n24 = te[ 13 ], n34 = te[ 14 ], n44 = te[ 15 ],

  			t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
  			t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
  			t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
  			t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

  		const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

  		if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 );

  		const detInv = 1 / det;

  		te[ 0 ] = t11 * detInv;
  		te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
  		te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
  		te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;

  		te[ 4 ] = t12 * detInv;
  		te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
  		te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
  		te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;

  		te[ 8 ] = t13 * detInv;
  		te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
  		te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
  		te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;

  		te[ 12 ] = t14 * detInv;
  		te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
  		te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
  		te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;

  		return this;

  	}

  	scale( v ) {

  		const te = this.elements;
  		const x = v.x, y = v.y, z = v.z;

  		te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
  		te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
  		te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
  		te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

  		return this;

  	}

  	getMaxScaleOnAxis() {

  		const te = this.elements;

  		const scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
  		const scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
  		const scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

  		return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );

  	}

  	makeTranslation( x, y, z ) {

  		if ( x.isVector3 ) {

  			this.set(

  				1, 0, 0, x.x,
  				0, 1, 0, x.y,
  				0, 0, 1, x.z,
  				0, 0, 0, 1

  			);

  		} else {

  			this.set(

  				1, 0, 0, x,
  				0, 1, 0, y,
  				0, 0, 1, z,
  				0, 0, 0, 1

  			);

  		}

  		return this;

  	}

  	makeRotationX( theta ) {

  		const c = Math.cos( theta ), s = Math.sin( theta );

  		this.set(

  			1, 0, 0, 0,
  			0, c, - s, 0,
  			0, s, c, 0,
  			0, 0, 0, 1

  		);

  		return this;

  	}

  	makeRotationY( theta ) {

  		const c = Math.cos( theta ), s = Math.sin( theta );

  		this.set(

  			 c, 0, s, 0,
  			 0, 1, 0, 0,
  			- s, 0, c, 0,
  			 0, 0, 0, 1

  		);

  		return this;

  	}

  	makeRotationZ( theta ) {

  		const c = Math.cos( theta ), s = Math.sin( theta );

  		this.set(

  			c, - s, 0, 0,
  			s, c, 0, 0,
  			0, 0, 1, 0,
  			0, 0, 0, 1

  		);

  		return this;

  	}

  	makeRotationAxis( axis, angle ) {

  		// Based on http://www.gamedev.net/reference/articles/article1199.asp

  		const c = Math.cos( angle );
  		const s = Math.sin( angle );
  		const t = 1 - c;
  		const x = axis.x, y = axis.y, z = axis.z;
  		const tx = t * x, ty = t * y;

  		this.set(

  			tx * x + c, tx * y - s * z, tx * z + s * y, 0,
  			tx * y + s * z, ty * y + c, ty * z - s * x, 0,
  			tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
  			0, 0, 0, 1

  		);

  		return this;

  	}

  	makeScale( x, y, z ) {

  		this.set(

  			x, 0, 0, 0,
  			0, y, 0, 0,
  			0, 0, z, 0,
  			0, 0, 0, 1

  		);

  		return this;

  	}

  	makeShear( xy, xz, yx, yz, zx, zy ) {

  		this.set(

  			1, yx, zx, 0,
  			xy, 1, zy, 0,
  			xz, yz, 1, 0,
  			0, 0, 0, 1

  		);

  		return this;

  	}

  	compose( position, quaternion, scale ) {

  		const te = this.elements;

  		const x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
  		const x2 = x + x,	y2 = y + y, z2 = z + z;
  		const xx = x * x2, xy = x * y2, xz = x * z2;
  		const yy = y * y2, yz = y * z2, zz = z * z2;
  		const wx = w * x2, wy = w * y2, wz = w * z2;

  		const sx = scale.x, sy = scale.y, sz = scale.z;

  		te[ 0 ] = ( 1 - ( yy + zz ) ) * sx;
  		te[ 1 ] = ( xy + wz ) * sx;
  		te[ 2 ] = ( xz - wy ) * sx;
  		te[ 3 ] = 0;

  		te[ 4 ] = ( xy - wz ) * sy;
  		te[ 5 ] = ( 1 - ( xx + zz ) ) * sy;
  		te[ 6 ] = ( yz + wx ) * sy;
  		te[ 7 ] = 0;

  		te[ 8 ] = ( xz + wy ) * sz;
  		te[ 9 ] = ( yz - wx ) * sz;
  		te[ 10 ] = ( 1 - ( xx + yy ) ) * sz;
  		te[ 11 ] = 0;

  		te[ 12 ] = position.x;
  		te[ 13 ] = position.y;
  		te[ 14 ] = position.z;
  		te[ 15 ] = 1;

  		return this;

  	}

  	decompose( position, quaternion, scale ) {

  		const te = this.elements;

  		let sx = _v1$5.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
  		const sy = _v1$5.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
  		const sz = _v1$5.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

  		// if determine is negative, we need to invert one scale
  		const det = this.determinant();
  		if ( det < 0 ) sx = - sx;

  		position.x = te[ 12 ];
  		position.y = te[ 13 ];
  		position.z = te[ 14 ];

  		// scale the rotation part
  		_m1$4.copy( this );

  		const invSX = 1 / sx;
  		const invSY = 1 / sy;
  		const invSZ = 1 / sz;

  		_m1$4.elements[ 0 ] *= invSX;
  		_m1$4.elements[ 1 ] *= invSX;
  		_m1$4.elements[ 2 ] *= invSX;

  		_m1$4.elements[ 4 ] *= invSY;
  		_m1$4.elements[ 5 ] *= invSY;
  		_m1$4.elements[ 6 ] *= invSY;

  		_m1$4.elements[ 8 ] *= invSZ;
  		_m1$4.elements[ 9 ] *= invSZ;
  		_m1$4.elements[ 10 ] *= invSZ;

  		quaternion.setFromRotationMatrix( _m1$4 );

  		scale.x = sx;
  		scale.y = sy;
  		scale.z = sz;

  		return this;

  	}

  	makePerspective( left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem ) {

  		const te = this.elements;
  		const x = 2 * near / ( right - left );
  		const y = 2 * near / ( top - bottom );

  		const a = ( right + left ) / ( right - left );
  		const b = ( top + bottom ) / ( top - bottom );

  		let c, d;

  		if ( coordinateSystem === WebGLCoordinateSystem ) {

  			c = - ( far + near ) / ( far - near );
  			d = ( - 2 * far * near ) / ( far - near );

  		} else if ( coordinateSystem === WebGPUCoordinateSystem ) {

  			c = - far / ( far - near );
  			d = ( - far * near ) / ( far - near );

  		} else {

  			throw new Error( 'THREE.Matrix4.makePerspective(): Invalid coordinate system: ' + coordinateSystem );

  		}

  		te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a; 	te[ 12 ] = 0;
  		te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b; 	te[ 13 ] = 0;
  		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c; 	te[ 14 ] = d;
  		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

  		return this;

  	}

  	makeOrthographic( left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem ) {

  		const te = this.elements;
  		const w = 1.0 / ( right - left );
  		const h = 1.0 / ( top - bottom );
  		const p = 1.0 / ( far - near );

  		const x = ( right + left ) * w;
  		const y = ( top + bottom ) * h;

  		let z, zInv;

  		if ( coordinateSystem === WebGLCoordinateSystem ) {

  			z = ( far + near ) * p;
  			zInv = - 2 * p;

  		} else if ( coordinateSystem === WebGPUCoordinateSystem ) {

  			z = near * p;
  			zInv = - 1 * p;

  		} else {

  			throw new Error( 'THREE.Matrix4.makeOrthographic(): Invalid coordinate system: ' + coordinateSystem );

  		}

  		te[ 0 ] = 2 * w;	te[ 4 ] = 0;		te[ 8 ] = 0; 		te[ 12 ] = - x;
  		te[ 1 ] = 0; 		te[ 5 ] = 2 * h;	te[ 9 ] = 0; 		te[ 13 ] = - y;
  		te[ 2 ] = 0; 		te[ 6 ] = 0;		te[ 10 ] = zInv;	te[ 14 ] = - z;
  		te[ 3 ] = 0; 		te[ 7 ] = 0;		te[ 11 ] = 0;		te[ 15 ] = 1;

  		return this;

  	}

  	equals( matrix ) {

  		const te = this.elements;
  		const me = matrix.elements;

  		for ( let i = 0; i < 16; i ++ ) {

  			if ( te[ i ] !== me[ i ] ) return false;

  		}

  		return true;

  	}

  	fromArray( array, offset = 0 ) {

  		for ( let i = 0; i < 16; i ++ ) {

  			this.elements[ i ] = array[ i + offset ];

  		}

  		return this;

  	}

  	toArray( array = [], offset = 0 ) {

  		const te = this.elements;

  		array[ offset ] = te[ 0 ];
  		array[ offset + 1 ] = te[ 1 ];
  		array[ offset + 2 ] = te[ 2 ];
  		array[ offset + 3 ] = te[ 3 ];

  		array[ offset + 4 ] = te[ 4 ];
  		array[ offset + 5 ] = te[ 5 ];
  		array[ offset + 6 ] = te[ 6 ];
  		array[ offset + 7 ] = te[ 7 ];

  		array[ offset + 8 ] = te[ 8 ];
  		array[ offset + 9 ] = te[ 9 ];
  		array[ offset + 10 ] = te[ 10 ];
  		array[ offset + 11 ] = te[ 11 ];

  		array[ offset + 12 ] = te[ 12 ];
  		array[ offset + 13 ] = te[ 13 ];
  		array[ offset + 14 ] = te[ 14 ];
  		array[ offset + 15 ] = te[ 15 ];

  		return array;

  	}

  }

  const _v1$5 = /*@__PURE__*/ new Vector3();
  const _m1$4 = /*@__PURE__*/ new Matrix4();
  const _zero = /*@__PURE__*/ new Vector3( 0, 0, 0 );
  const _one = /*@__PURE__*/ new Vector3( 1, 1, 1 );
  const _x = /*@__PURE__*/ new Vector3();
  const _y = /*@__PURE__*/ new Vector3();
  const _z = /*@__PURE__*/ new Vector3();

  const _matrix$2 = /*@__PURE__*/ new Matrix4();
  const _quaternion$3 = /*@__PURE__*/ new Quaternion();

  class Euler {

  	constructor( x = 0, y = 0, z = 0, order = Euler.DEFAULT_ORDER ) {

  		this.isEuler = true;

  		this._x = x;
  		this._y = y;
  		this._z = z;
  		this._order = order;

  	}

  	get x() {

  		return this._x;

  	}

  	set x( value ) {

  		this._x = value;
  		this._onChangeCallback();

  	}

  	get y() {

  		return this._y;

  	}

  	set y( value ) {

  		this._y = value;
  		this._onChangeCallback();

  	}

  	get z() {

  		return this._z;

  	}

  	set z( value ) {

  		this._z = value;
  		this._onChangeCallback();

  	}

  	get order() {

  		return this._order;

  	}

  	set order( value ) {

  		this._order = value;
  		this._onChangeCallback();

  	}

  	set( x, y, z, order = this._order ) {

  		this._x = x;
  		this._y = y;
  		this._z = z;
  		this._order = order;

  		this._onChangeCallback();

  		return this;

  	}

  	clone() {

  		return new this.constructor( this._x, this._y, this._z, this._order );

  	}

  	copy( euler ) {

  		this._x = euler._x;
  		this._y = euler._y;
  		this._z = euler._z;
  		this._order = euler._order;

  		this._onChangeCallback();

  		return this;

  	}

  	setFromRotationMatrix( m, order = this._order, update = true ) {

  		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

  		const te = m.elements;
  		const m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
  		const m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
  		const m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

  		switch ( order ) {

  			case 'XYZ':

  				this._y = Math.asin( clamp( m13, - 1, 1 ) );

  				if ( Math.abs( m13 ) < 0.9999999 ) {

  					this._x = Math.atan2( - m23, m33 );
  					this._z = Math.atan2( - m12, m11 );

  				} else {

  					this._x = Math.atan2( m32, m22 );
  					this._z = 0;

  				}

  				break;

  			case 'YXZ':

  				this._x = Math.asin( - clamp( m23, - 1, 1 ) );

  				if ( Math.abs( m23 ) < 0.9999999 ) {

  					this._y = Math.atan2( m13, m33 );
  					this._z = Math.atan2( m21, m22 );

  				} else {

  					this._y = Math.atan2( - m31, m11 );
  					this._z = 0;

  				}

  				break;

  			case 'ZXY':

  				this._x = Math.asin( clamp( m32, - 1, 1 ) );

  				if ( Math.abs( m32 ) < 0.9999999 ) {

  					this._y = Math.atan2( - m31, m33 );
  					this._z = Math.atan2( - m12, m22 );

  				} else {

  					this._y = 0;
  					this._z = Math.atan2( m21, m11 );

  				}

  				break;

  			case 'ZYX':

  				this._y = Math.asin( - clamp( m31, - 1, 1 ) );

  				if ( Math.abs( m31 ) < 0.9999999 ) {

  					this._x = Math.atan2( m32, m33 );
  					this._z = Math.atan2( m21, m11 );

  				} else {

  					this._x = 0;
  					this._z = Math.atan2( - m12, m22 );

  				}

  				break;

  			case 'YZX':

  				this._z = Math.asin( clamp( m21, - 1, 1 ) );

  				if ( Math.abs( m21 ) < 0.9999999 ) {

  					this._x = Math.atan2( - m23, m22 );
  					this._y = Math.atan2( - m31, m11 );

  				} else {

  					this._x = 0;
  					this._y = Math.atan2( m13, m33 );

  				}

  				break;

  			case 'XZY':

  				this._z = Math.asin( - clamp( m12, - 1, 1 ) );

  				if ( Math.abs( m12 ) < 0.9999999 ) {

  					this._x = Math.atan2( m32, m22 );
  					this._y = Math.atan2( m13, m11 );

  				} else {

  					this._x = Math.atan2( - m23, m33 );
  					this._y = 0;

  				}

  				break;

  			default:

  				console.warn( 'THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order );

  		}

  		this._order = order;

  		if ( update === true ) this._onChangeCallback();

  		return this;

  	}

  	setFromQuaternion( q, order, update ) {

  		_matrix$2.makeRotationFromQuaternion( q );

  		return this.setFromRotationMatrix( _matrix$2, order, update );

  	}

  	setFromVector3( v, order = this._order ) {

  		return this.set( v.x, v.y, v.z, order );

  	}

  	reorder( newOrder ) {

  		// WARNING: this discards revolution information -bhouston

  		_quaternion$3.setFromEuler( this );

  		return this.setFromQuaternion( _quaternion$3, newOrder );

  	}

  	equals( euler ) {

  		return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

  	}

  	fromArray( array ) {

  		this._x = array[ 0 ];
  		this._y = array[ 1 ];
  		this._z = array[ 2 ];
  		if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

  		this._onChangeCallback();

  		return this;

  	}

  	toArray( array = [], offset = 0 ) {

  		array[ offset ] = this._x;
  		array[ offset + 1 ] = this._y;
  		array[ offset + 2 ] = this._z;
  		array[ offset + 3 ] = this._order;

  		return array;

  	}

  	_onChange( callback ) {

  		this._onChangeCallback = callback;

  		return this;

  	}

  	_onChangeCallback() {}

  	*[ Symbol.iterator ]() {

  		yield this._x;
  		yield this._y;
  		yield this._z;
  		yield this._order;

  	}

  }

  Euler.DEFAULT_ORDER = 'XYZ';

  class Layers {

  	constructor() {

  		this.mask = 1 | 0;

  	}

  	set( channel ) {

  		this.mask = ( 1 << channel | 0 ) >>> 0;

  	}

  	enable( channel ) {

  		this.mask |= 1 << channel | 0;

  	}

  	enableAll() {

  		this.mask = 0xffffffff | 0;

  	}

  	toggle( channel ) {

  		this.mask ^= 1 << channel | 0;

  	}

  	disable( channel ) {

  		this.mask &= ~ ( 1 << channel | 0 );

  	}

  	disableAll() {

  		this.mask = 0;

  	}

  	test( layers ) {

  		return ( this.mask & layers.mask ) !== 0;

  	}

  	isEnabled( channel ) {

  		return ( this.mask & ( 1 << channel | 0 ) ) !== 0;

  	}

  }

  let _object3DId = 0;

  const _v1$4 = /*@__PURE__*/ new Vector3();
  const _q1 = /*@__PURE__*/ new Quaternion();
  const _m1$3 = /*@__PURE__*/ new Matrix4();
  const _target = /*@__PURE__*/ new Vector3();

  const _position$3 = /*@__PURE__*/ new Vector3();
  const _scale$2 = /*@__PURE__*/ new Vector3();
  const _quaternion$2 = /*@__PURE__*/ new Quaternion();

  const _xAxis = /*@__PURE__*/ new Vector3( 1, 0, 0 );
  const _yAxis = /*@__PURE__*/ new Vector3( 0, 1, 0 );
  const _zAxis = /*@__PURE__*/ new Vector3( 0, 0, 1 );

  const _addedEvent = { type: 'added' };
  const _removedEvent = { type: 'removed' };

  const _childaddedEvent = { type: 'childadded', child: null };
  const _childremovedEvent = { type: 'childremoved', child: null };

  class Object3D extends EventDispatcher {

  	constructor() {

  		super();

  		this.isObject3D = true;

  		Object.defineProperty( this, 'id', { value: _object3DId ++ } );

  		this.uuid = generateUUID();

  		this.name = '';
  		this.type = 'Object3D';

  		this.parent = null;
  		this.children = [];

  		this.up = Object3D.DEFAULT_UP.clone();

  		const position = new Vector3();
  		const rotation = new Euler();
  		const quaternion = new Quaternion();
  		const scale = new Vector3( 1, 1, 1 );

  		function onRotationChange() {

  			quaternion.setFromEuler( rotation, false );

  		}

  		function onQuaternionChange() {

  			rotation.setFromQuaternion( quaternion, undefined, false );

  		}

  		rotation._onChange( onRotationChange );
  		quaternion._onChange( onQuaternionChange );

  		Object.defineProperties( this, {
  			position: {
  				configurable: true,
  				enumerable: true,
  				value: position
  			},
  			rotation: {
  				configurable: true,
  				enumerable: true,
  				value: rotation
  			},
  			quaternion: {
  				configurable: true,
  				enumerable: true,
  				value: quaternion
  			},
  			scale: {
  				configurable: true,
  				enumerable: true,
  				value: scale
  			},
  			modelViewMatrix: {
  				value: new Matrix4()
  			},
  			normalMatrix: {
  				value: new Matrix3()
  			}
  		} );

  		this.matrix = new Matrix4();
  		this.matrixWorld = new Matrix4();

  		this.matrixAutoUpdate = Object3D.DEFAULT_MATRIX_AUTO_UPDATE;

  		this.matrixWorldAutoUpdate = Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE; // checked by the renderer
  		this.matrixWorldNeedsUpdate = false;

  		this.layers = new Layers();
  		this.visible = true;

  		this.castShadow = false;
  		this.receiveShadow = false;

  		this.frustumCulled = true;
  		this.renderOrder = 0;

  		this.animations = [];

  		this.userData = {};

  	}

  	onBeforeShadow( /* renderer, object, camera, shadowCamera, geometry, depthMaterial, group */ ) {}

  	onAfterShadow( /* renderer, object, camera, shadowCamera, geometry, depthMaterial, group */ ) {}

  	onBeforeRender( /* renderer, scene, camera, geometry, material, group */ ) {}

  	onAfterRender( /* renderer, scene, camera, geometry, material, group */ ) {}

  	applyMatrix4( matrix ) {

  		if ( this.matrixAutoUpdate ) this.updateMatrix();

  		this.matrix.premultiply( matrix );

  		this.matrix.decompose( this.position, this.quaternion, this.scale );

  	}

  	applyQuaternion( q ) {

  		this.quaternion.premultiply( q );

  		return this;

  	}

  	setRotationFromAxisAngle( axis, angle ) {

  		// assumes axis is normalized

  		this.quaternion.setFromAxisAngle( axis, angle );

  	}

  	setRotationFromEuler( euler ) {

  		this.quaternion.setFromEuler( euler, true );

  	}

  	setRotationFromMatrix( m ) {

  		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

  		this.quaternion.setFromRotationMatrix( m );

  	}

  	setRotationFromQuaternion( q ) {

  		// assumes q is normalized

  		this.quaternion.copy( q );

  	}

  	rotateOnAxis( axis, angle ) {

  		// rotate object on axis in object space
  		// axis is assumed to be normalized

  		_q1.setFromAxisAngle( axis, angle );

  		this.quaternion.multiply( _q1 );

  		return this;

  	}

  	rotateOnWorldAxis( axis, angle ) {

  		// rotate object on axis in world space
  		// axis is assumed to be normalized
  		// method assumes no rotated parent

  		_q1.setFromAxisAngle( axis, angle );

  		this.quaternion.premultiply( _q1 );

  		return this;

  	}

  	rotateX( angle ) {

  		return this.rotateOnAxis( _xAxis, angle );

  	}

  	rotateY( angle ) {

  		return this.rotateOnAxis( _yAxis, angle );

  	}

  	rotateZ( angle ) {

  		return this.rotateOnAxis( _zAxis, angle );

  	}

  	translateOnAxis( axis, distance ) {

  		// translate object by distance along axis in object space
  		// axis is assumed to be normalized

  		_v1$4.copy( axis ).applyQuaternion( this.quaternion );

  		this.position.add( _v1$4.multiplyScalar( distance ) );

  		return this;

  	}

  	translateX( distance ) {

  		return this.translateOnAxis( _xAxis, distance );

  	}

  	translateY( distance ) {

  		return this.translateOnAxis( _yAxis, distance );

  	}

  	translateZ( distance ) {

  		return this.translateOnAxis( _zAxis, distance );

  	}

  	localToWorld( vector ) {

  		this.updateWorldMatrix( true, false );

  		return vector.applyMatrix4( this.matrixWorld );

  	}

  	worldToLocal( vector ) {

  		this.updateWorldMatrix( true, false );

  		return vector.applyMatrix4( _m1$3.copy( this.matrixWorld ).invert() );

  	}

  	lookAt( x, y, z ) {

  		// This method does not support objects having non-uniformly-scaled parent(s)

  		if ( x.isVector3 ) {

  			_target.copy( x );

  		} else {

  			_target.set( x, y, z );

  		}

  		const parent = this.parent;

  		this.updateWorldMatrix( true, false );

  		_position$3.setFromMatrixPosition( this.matrixWorld );

  		if ( this.isCamera || this.isLight ) {

  			_m1$3.lookAt( _position$3, _target, this.up );

  		} else {

  			_m1$3.lookAt( _target, _position$3, this.up );

  		}

  		this.quaternion.setFromRotationMatrix( _m1$3 );

  		if ( parent ) {

  			_m1$3.extractRotation( parent.matrixWorld );
  			_q1.setFromRotationMatrix( _m1$3 );
  			this.quaternion.premultiply( _q1.invert() );

  		}

  	}

  	add( object ) {

  		if ( arguments.length > 1 ) {

  			for ( let i = 0; i < arguments.length; i ++ ) {

  				this.add( arguments[ i ] );

  			}

  			return this;

  		}

  		if ( object === this ) {

  			console.error( 'THREE.Object3D.add: object can\'t be added as a child of itself.', object );
  			return this;

  		}

  		if ( object && object.isObject3D ) {

  			object.removeFromParent();
  			object.parent = this;
  			this.children.push( object );

  			object.dispatchEvent( _addedEvent );

  			_childaddedEvent.child = object;
  			this.dispatchEvent( _childaddedEvent );
  			_childaddedEvent.child = null;

  		} else {

  			console.error( 'THREE.Object3D.add: object not an instance of THREE.Object3D.', object );

  		}

  		return this;

  	}

  	remove( object ) {

  		if ( arguments.length > 1 ) {

  			for ( let i = 0; i < arguments.length; i ++ ) {

  				this.remove( arguments[ i ] );

  			}

  			return this;

  		}

  		const index = this.children.indexOf( object );

  		if ( index !== - 1 ) {

  			object.parent = null;
  			this.children.splice( index, 1 );

  			object.dispatchEvent( _removedEvent );

  			_childremovedEvent.child = object;
  			this.dispatchEvent( _childremovedEvent );
  			_childremovedEvent.child = null;

  		}

  		return this;

  	}

  	removeFromParent() {

  		const parent = this.parent;

  		if ( parent !== null ) {

  			parent.remove( this );

  		}

  		return this;

  	}

  	clear() {

  		return this.remove( ... this.children );

  	}

  	attach( object ) {

  		// adds object as a child of this, while maintaining the object's world transform

  		// Note: This method does not support scene graphs having non-uniformly-scaled nodes(s)

  		this.updateWorldMatrix( true, false );

  		_m1$3.copy( this.matrixWorld ).invert();

  		if ( object.parent !== null ) {

  			object.parent.updateWorldMatrix( true, false );

  			_m1$3.multiply( object.parent.matrixWorld );

  		}

  		object.applyMatrix4( _m1$3 );

  		object.removeFromParent();
  		object.parent = this;
  		this.children.push( object );

  		object.updateWorldMatrix( false, true );

  		object.dispatchEvent( _addedEvent );

  		_childaddedEvent.child = object;
  		this.dispatchEvent( _childaddedEvent );
  		_childaddedEvent.child = null;

  		return this;

  	}

  	getObjectById( id ) {

  		return this.getObjectByProperty( 'id', id );

  	}

  	getObjectByName( name ) {

  		return this.getObjectByProperty( 'name', name );

  	}

  	getObjectByProperty( name, value ) {

  		if ( this[ name ] === value ) return this;

  		for ( let i = 0, l = this.children.length; i < l; i ++ ) {

  			const child = this.children[ i ];
  			const object = child.getObjectByProperty( name, value );

  			if ( object !== undefined ) {

  				return object;

  			}

  		}

  		return undefined;

  	}

  	getObjectsByProperty( name, value, result = [] ) {

  		if ( this[ name ] === value ) result.push( this );

  		const children = this.children;

  		for ( let i = 0, l = children.length; i < l; i ++ ) {

  			children[ i ].getObjectsByProperty( name, value, result );

  		}

  		return result;

  	}

  	getWorldPosition( target ) {

  		this.updateWorldMatrix( true, false );

  		return target.setFromMatrixPosition( this.matrixWorld );

  	}

  	getWorldQuaternion( target ) {

  		this.updateWorldMatrix( true, false );

  		this.matrixWorld.decompose( _position$3, target, _scale$2 );

  		return target;

  	}

  	getWorldScale( target ) {

  		this.updateWorldMatrix( true, false );

  		this.matrixWorld.decompose( _position$3, _quaternion$2, target );

  		return target;

  	}

  	getWorldDirection( target ) {

  		this.updateWorldMatrix( true, false );

  		const e = this.matrixWorld.elements;

  		return target.set( e[ 8 ], e[ 9 ], e[ 10 ] ).normalize();

  	}

  	raycast( /* raycaster, intersects */ ) {}

  	traverse( callback ) {

  		callback( this );

  		const children = this.children;

  		for ( let i = 0, l = children.length; i < l; i ++ ) {

  			children[ i ].traverse( callback );

  		}

  	}

  	traverseVisible( callback ) {

  		if ( this.visible === false ) return;

  		callback( this );

  		const children = this.children;

  		for ( let i = 0, l = children.length; i < l; i ++ ) {

  			children[ i ].traverseVisible( callback );

  		}

  	}

  	traverseAncestors( callback ) {

  		const parent = this.parent;

  		if ( parent !== null ) {

  			callback( parent );

  			parent.traverseAncestors( callback );

  		}

  	}

  	updateMatrix() {

  		this.matrix.compose( this.position, this.quaternion, this.scale );

  		this.matrixWorldNeedsUpdate = true;

  	}

  	updateMatrixWorld( force ) {

  		if ( this.matrixAutoUpdate ) this.updateMatrix();

  		if ( this.matrixWorldNeedsUpdate || force ) {

  			if ( this.matrixWorldAutoUpdate === true ) {

  				if ( this.parent === null ) {

  					this.matrixWorld.copy( this.matrix );

  				} else {

  					this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

  				}

  			}

  			this.matrixWorldNeedsUpdate = false;

  			force = true;

  		}

  		// make sure descendants are updated if required

  		const children = this.children;

  		for ( let i = 0, l = children.length; i < l; i ++ ) {

  			const child = children[ i ];

  			child.updateMatrixWorld( force );

  		}

  	}

  	updateWorldMatrix( updateParents, updateChildren ) {

  		const parent = this.parent;

  		if ( updateParents === true && parent !== null ) {

  			parent.updateWorldMatrix( true, false );

  		}

  		if ( this.matrixAutoUpdate ) this.updateMatrix();

  		if ( this.matrixWorldAutoUpdate === true ) {

  			if ( this.parent === null ) {

  				this.matrixWorld.copy( this.matrix );

  			} else {

  				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

  			}

  		}

  		// make sure descendants are updated

  		if ( updateChildren === true ) {

  			const children = this.children;

  			for ( let i = 0, l = children.length; i < l; i ++ ) {

  				const child = children[ i ];

  				child.updateWorldMatrix( false, true );

  			}

  		}

  	}

  	toJSON( meta ) {

  		// meta is a string when called from JSON.stringify
  		const isRootObject = ( meta === undefined || typeof meta === 'string' );

  		const output = {};

  		// meta is a hash used to collect geometries, materials.
  		// not providing it implies that this is the root object
  		// being serialized.
  		if ( isRootObject ) {

  			// initialize meta obj
  			meta = {
  				geometries: {},
  				materials: {},
  				textures: {},
  				images: {},
  				shapes: {},
  				skeletons: {},
  				animations: {},
  				nodes: {}
  			};

  			output.metadata = {
  				version: 4.6,
  				type: 'Object',
  				generator: 'Object3D.toJSON'
  			};

  		}

  		// standard Object3D serialization

  		const object = {};

  		object.uuid = this.uuid;
  		object.type = this.type;

  		if ( this.name !== '' ) object.name = this.name;
  		if ( this.castShadow === true ) object.castShadow = true;
  		if ( this.receiveShadow === true ) object.receiveShadow = true;
  		if ( this.visible === false ) object.visible = false;
  		if ( this.frustumCulled === false ) object.frustumCulled = false;
  		if ( this.renderOrder !== 0 ) object.renderOrder = this.renderOrder;
  		if ( Object.keys( this.userData ).length > 0 ) object.userData = this.userData;

  		object.layers = this.layers.mask;
  		object.matrix = this.matrix.toArray();
  		object.up = this.up.toArray();

  		if ( this.matrixAutoUpdate === false ) object.matrixAutoUpdate = false;

  		// object specific properties

  		if ( this.isInstancedMesh ) {

  			object.type = 'InstancedMesh';
  			object.count = this.count;
  			object.instanceMatrix = this.instanceMatrix.toJSON();
  			if ( this.instanceColor !== null ) object.instanceColor = this.instanceColor.toJSON();

  		}

  		if ( this.isBatchedMesh ) {

  			object.type = 'BatchedMesh';
  			object.perObjectFrustumCulled = this.perObjectFrustumCulled;
  			object.sortObjects = this.sortObjects;

  			object.drawRanges = this._drawRanges;
  			object.reservedRanges = this._reservedRanges;

  			object.visibility = this._visibility;
  			object.active = this._active;
  			object.bounds = this._bounds.map( bound => ( {
  				boxInitialized: bound.boxInitialized,
  				boxMin: bound.box.min.toArray(),
  				boxMax: bound.box.max.toArray(),

  				sphereInitialized: bound.sphereInitialized,
  				sphereRadius: bound.sphere.radius,
  				sphereCenter: bound.sphere.center.toArray()
  			} ) );

  			object.maxInstanceCount = this._maxInstanceCount;
  			object.maxVertexCount = this._maxVertexCount;
  			object.maxIndexCount = this._maxIndexCount;

  			object.geometryInitialized = this._geometryInitialized;
  			object.geometryCount = this._geometryCount;

  			object.matricesTexture = this._matricesTexture.toJSON( meta );

  			if ( this._colorsTexture !== null ) object.colorsTexture = this._colorsTexture.toJSON( meta );

  			if ( this.boundingSphere !== null ) {

  				object.boundingSphere = {
  					center: object.boundingSphere.center.toArray(),
  					radius: object.boundingSphere.radius
  				};

  			}

  			if ( this.boundingBox !== null ) {

  				object.boundingBox = {
  					min: object.boundingBox.min.toArray(),
  					max: object.boundingBox.max.toArray()
  				};

  			}

  		}

  		//

  		function serialize( library, element ) {

  			if ( library[ element.uuid ] === undefined ) {

  				library[ element.uuid ] = element.toJSON( meta );

  			}

  			return element.uuid;

  		}

  		if ( this.isScene ) {

  			if ( this.background ) {

  				if ( this.background.isColor ) {

  					object.background = this.background.toJSON();

  				} else if ( this.background.isTexture ) {

  					object.background = this.background.toJSON( meta ).uuid;

  				}

  			}

  			if ( this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true ) {

  				object.environment = this.environment.toJSON( meta ).uuid;

  			}

  		} else if ( this.isMesh || this.isLine || this.isPoints ) {

  			object.geometry = serialize( meta.geometries, this.geometry );

  			const parameters = this.geometry.parameters;

  			if ( parameters !== undefined && parameters.shapes !== undefined ) {

  				const shapes = parameters.shapes;

  				if ( Array.isArray( shapes ) ) {

  					for ( let i = 0, l = shapes.length; i < l; i ++ ) {

  						const shape = shapes[ i ];

  						serialize( meta.shapes, shape );

  					}

  				} else {

  					serialize( meta.shapes, shapes );

  				}

  			}

  		}

  		if ( this.isSkinnedMesh ) {

  			object.bindMode = this.bindMode;
  			object.bindMatrix = this.bindMatrix.toArray();

  			if ( this.skeleton !== undefined ) {

  				serialize( meta.skeletons, this.skeleton );

  				object.skeleton = this.skeleton.uuid;

  			}

  		}

  		if ( this.material !== undefined ) {

  			if ( Array.isArray( this.material ) ) {

  				const uuids = [];

  				for ( let i = 0, l = this.material.length; i < l; i ++ ) {

  					uuids.push( serialize( meta.materials, this.material[ i ] ) );

  				}

  				object.material = uuids;

  			} else {

  				object.material = serialize( meta.materials, this.material );

  			}

  		}

  		//

  		if ( this.children.length > 0 ) {

  			object.children = [];

  			for ( let i = 0; i < this.children.length; i ++ ) {

  				object.children.push( this.children[ i ].toJSON( meta ).object );

  			}

  		}

  		//

  		if ( this.animations.length > 0 ) {

  			object.animations = [];

  			for ( let i = 0; i < this.animations.length; i ++ ) {

  				const animation = this.animations[ i ];

  				object.animations.push( serialize( meta.animations, animation ) );

  			}

  		}

  		if ( isRootObject ) {

  			const geometries = extractFromCache( meta.geometries );
  			const materials = extractFromCache( meta.materials );
  			const textures = extractFromCache( meta.textures );
  			const images = extractFromCache( meta.images );
  			const shapes = extractFromCache( meta.shapes );
  			const skeletons = extractFromCache( meta.skeletons );
  			const animations = extractFromCache( meta.animations );
  			const nodes = extractFromCache( meta.nodes );

  			if ( geometries.length > 0 ) output.geometries = geometries;
  			if ( materials.length > 0 ) output.materials = materials;
  			if ( textures.length > 0 ) output.textures = textures;
  			if ( images.length > 0 ) output.images = images;
  			if ( shapes.length > 0 ) output.shapes = shapes;
  			if ( skeletons.length > 0 ) output.skeletons = skeletons;
  			if ( animations.length > 0 ) output.animations = animations;
  			if ( nodes.length > 0 ) output.nodes = nodes;

  		}

  		output.object = object;

  		return output;

  		// extract data from the cache hash
  		// remove metadata on each item
  		// and return as array
  		function extractFromCache( cache ) {

  			const values = [];
  			for ( const key in cache ) {

  				const data = cache[ key ];
  				delete data.metadata;
  				values.push( data );

  			}

  			return values;

  		}

  	}

  	clone( recursive ) {

  		return new this.constructor().copy( this, recursive );

  	}

  	copy( source, recursive = true ) {

  		this.name = source.name;

  		this.up.copy( source.up );

  		this.position.copy( source.position );
  		this.rotation.order = source.rotation.order;
  		this.quaternion.copy( source.quaternion );
  		this.scale.copy( source.scale );

  		this.matrix.copy( source.matrix );
  		this.matrixWorld.copy( source.matrixWorld );

  		this.matrixAutoUpdate = source.matrixAutoUpdate;

  		this.matrixWorldAutoUpdate = source.matrixWorldAutoUpdate;
  		this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

  		this.layers.mask = source.layers.mask;
  		this.visible = source.visible;

  		this.castShadow = source.castShadow;
  		this.receiveShadow = source.receiveShadow;

  		this.frustumCulled = source.frustumCulled;
  		this.renderOrder = source.renderOrder;

  		this.animations = source.animations.slice();

  		this.userData = JSON.parse( JSON.stringify( source.userData ) );

  		if ( recursive === true ) {

  			for ( let i = 0; i < source.children.length; i ++ ) {

  				const child = source.children[ i ];
  				this.add( child.clone() );

  			}

  		}

  		return this;

  	}

  }

  Object3D.DEFAULT_UP = /*@__PURE__*/ new Vector3( 0, 1, 0 );
  Object3D.DEFAULT_MATRIX_AUTO_UPDATE = true;
  Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;

  const _v0$2 = /*@__PURE__*/ new Vector3();
  const _v1$3 = /*@__PURE__*/ new Vector3();
  const _v2$2 = /*@__PURE__*/ new Vector3();
  const _v3$2 = /*@__PURE__*/ new Vector3();

  const _vab = /*@__PURE__*/ new Vector3();
  const _vac = /*@__PURE__*/ new Vector3();
  const _vbc = /*@__PURE__*/ new Vector3();
  const _vap = /*@__PURE__*/ new Vector3();
  const _vbp = /*@__PURE__*/ new Vector3();
  const _vcp = /*@__PURE__*/ new Vector3();

  class Triangle {

  	constructor( a = new Vector3(), b = new Vector3(), c = new Vector3() ) {

  		this.a = a;
  		this.b = b;
  		this.c = c;

  	}

  	static getNormal( a, b, c, target ) {

  		target.subVectors( c, b );
  		_v0$2.subVectors( a, b );
  		target.cross( _v0$2 );

  		const targetLengthSq = target.lengthSq();
  		if ( targetLengthSq > 0 ) {

  			return target.multiplyScalar( 1 / Math.sqrt( targetLengthSq ) );

  		}

  		return target.set( 0, 0, 0 );

  	}

  	// static/instance method to calculate barycentric coordinates
  	// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  	static getBarycoord( point, a, b, c, target ) {

  		_v0$2.subVectors( c, a );
  		_v1$3.subVectors( b, a );
  		_v2$2.subVectors( point, a );

  		const dot00 = _v0$2.dot( _v0$2 );
  		const dot01 = _v0$2.dot( _v1$3 );
  		const dot02 = _v0$2.dot( _v2$2 );
  		const dot11 = _v1$3.dot( _v1$3 );
  		const dot12 = _v1$3.dot( _v2$2 );

  		const denom = ( dot00 * dot11 - dot01 * dot01 );

  		// collinear or singular triangle
  		if ( denom === 0 ) {

  			target.set( 0, 0, 0 );
  			return null;

  		}

  		const invDenom = 1 / denom;
  		const u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
  		const v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

  		// barycentric coordinates must always sum to 1
  		return target.set( 1 - u - v, v, u );

  	}

  	static containsPoint( point, a, b, c ) {

  		// if the triangle is degenerate then we can't contain a point
  		if ( this.getBarycoord( point, a, b, c, _v3$2 ) === null ) {

  			return false;

  		}

  		return ( _v3$2.x >= 0 ) && ( _v3$2.y >= 0 ) && ( ( _v3$2.x + _v3$2.y ) <= 1 );

  	}

  	static getInterpolation( point, p1, p2, p3, v1, v2, v3, target ) {

  		if ( this.getBarycoord( point, p1, p2, p3, _v3$2 ) === null ) {

  			target.x = 0;
  			target.y = 0;
  			if ( 'z' in target ) target.z = 0;
  			if ( 'w' in target ) target.w = 0;
  			return null;

  		}

  		target.setScalar( 0 );
  		target.addScaledVector( v1, _v3$2.x );
  		target.addScaledVector( v2, _v3$2.y );
  		target.addScaledVector( v3, _v3$2.z );

  		return target;

  	}

  	static isFrontFacing( a, b, c, direction ) {

  		_v0$2.subVectors( c, b );
  		_v1$3.subVectors( a, b );

  		// strictly front facing
  		return ( _v0$2.cross( _v1$3 ).dot( direction ) < 0 ) ? true : false;

  	}

  	set( a, b, c ) {

  		this.a.copy( a );
  		this.b.copy( b );
  		this.c.copy( c );

  		return this;

  	}

  	setFromPointsAndIndices( points, i0, i1, i2 ) {

  		this.a.copy( points[ i0 ] );
  		this.b.copy( points[ i1 ] );
  		this.c.copy( points[ i2 ] );

  		return this;

  	}

  	setFromAttributeAndIndices( attribute, i0, i1, i2 ) {

  		this.a.fromBufferAttribute( attribute, i0 );
  		this.b.fromBufferAttribute( attribute, i1 );
  		this.c.fromBufferAttribute( attribute, i2 );

  		return this;

  	}

  	clone() {

  		return new this.constructor().copy( this );

  	}

  	copy( triangle ) {

  		this.a.copy( triangle.a );
  		this.b.copy( triangle.b );
  		this.c.copy( triangle.c );

  		return this;

  	}

  	getArea() {

  		_v0$2.subVectors( this.c, this.b );
  		_v1$3.subVectors( this.a, this.b );

  		return _v0$2.cross( _v1$3 ).length() * 0.5;

  	}

  	getMidpoint( target ) {

  		return target.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

  	}

  	getNormal( target ) {

  		return Triangle.getNormal( this.a, this.b, this.c, target );

  	}

  	getPlane( target ) {

  		return target.setFromCoplanarPoints( this.a, this.b, this.c );

  	}

  	getBarycoord( point, target ) {

  		return Triangle.getBarycoord( point, this.a, this.b, this.c, target );

  	}

  	getInterpolation( point, v1, v2, v3, target ) {

  		return Triangle.getInterpolation( point, this.a, this.b, this.c, v1, v2, v3, target );

  	}

  	containsPoint( point ) {

  		return Triangle.containsPoint( point, this.a, this.b, this.c );

  	}

  	isFrontFacing( direction ) {

  		return Triangle.isFrontFacing( this.a, this.b, this.c, direction );

  	}

  	intersectsBox( box ) {

  		return box.intersectsTriangle( this );

  	}

  	closestPointToPoint( p, target ) {

  		const a = this.a, b = this.b, c = this.c;
  		let v, w;

  		// algorithm thanks to Real-Time Collision Detection by Christer Ericson,
  		// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
  		// under the accompanying license; see chapter 5.1.5 for detailed explanation.
  		// basically, we're distinguishing which of the voronoi regions of the triangle
  		// the point lies in with the minimum amount of redundant computation.

  		_vab.subVectors( b, a );
  		_vac.subVectors( c, a );
  		_vap.subVectors( p, a );
  		const d1 = _vab.dot( _vap );
  		const d2 = _vac.dot( _vap );
  		if ( d1 <= 0 && d2 <= 0 ) {

  			// vertex region of A; barycentric coords (1, 0, 0)
  			return target.copy( a );

  		}

  		_vbp.subVectors( p, b );
  		const d3 = _vab.dot( _vbp );
  		const d4 = _vac.dot( _vbp );
  		if ( d3 >= 0 && d4 <= d3 ) {

  			// vertex region of B; barycentric coords (0, 1, 0)
  			return target.copy( b );

  		}

  		const vc = d1 * d4 - d3 * d2;
  		if ( vc <= 0 && d1 >= 0 && d3 <= 0 ) {

  			v = d1 / ( d1 - d3 );
  			// edge region of AB; barycentric coords (1-v, v, 0)
  			return target.copy( a ).addScaledVector( _vab, v );

  		}

  		_vcp.subVectors( p, c );
  		const d5 = _vab.dot( _vcp );
  		const d6 = _vac.dot( _vcp );
  		if ( d6 >= 0 && d5 <= d6 ) {

  			// vertex region of C; barycentric coords (0, 0, 1)
  			return target.copy( c );

  		}

  		const vb = d5 * d2 - d1 * d6;
  		if ( vb <= 0 && d2 >= 0 && d6 <= 0 ) {

  			w = d2 / ( d2 - d6 );
  			// edge region of AC; barycentric coords (1-w, 0, w)
  			return target.copy( a ).addScaledVector( _vac, w );

  		}

  		const va = d3 * d6 - d5 * d4;
  		if ( va <= 0 && ( d4 - d3 ) >= 0 && ( d5 - d6 ) >= 0 ) {

  			_vbc.subVectors( c, b );
  			w = ( d4 - d3 ) / ( ( d4 - d3 ) + ( d5 - d6 ) );
  			// edge region of BC; barycentric coords (0, 1-w, w)
  			return target.copy( b ).addScaledVector( _vbc, w ); // edge region of BC

  		}

  		// face region
  		const denom = 1 / ( va + vb + vc );
  		// u = va * denom
  		v = vb * denom;
  		w = vc * denom;

  		return target.copy( a ).addScaledVector( _vab, v ).addScaledVector( _vac, w );

  	}

  	equals( triangle ) {

  		return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

  	}

  }

  const _colorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
  	'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
  	'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
  	'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
  	'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
  	'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
  	'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
  	'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
  	'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
  	'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
  	'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
  	'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
  	'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
  	'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
  	'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
  	'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
  	'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
  	'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
  	'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
  	'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
  	'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
  	'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
  	'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
  	'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

  const _hslA = { h: 0, s: 0, l: 0 };
  const _hslB = { h: 0, s: 0, l: 0 };

  function hue2rgb( p, q, t ) {

  	if ( t < 0 ) t += 1;
  	if ( t > 1 ) t -= 1;
  	if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
  	if ( t < 1 / 2 ) return q;
  	if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
  	return p;

  }

  class Color {

  	constructor( r, g, b ) {

  		this.isColor = true;

  		this.r = 1;
  		this.g = 1;
  		this.b = 1;

  		return this.set( r, g, b );

  	}

  	set( r, g, b ) {

  		if ( g === undefined && b === undefined ) {

  			// r is THREE.Color, hex or string

  			const value = r;

  			if ( value && value.isColor ) {

  				this.copy( value );

  			} else if ( typeof value === 'number' ) {

  				this.setHex( value );

  			} else if ( typeof value === 'string' ) {

  				this.setStyle( value );

  			}

  		} else {

  			this.setRGB( r, g, b );

  		}

  		return this;

  	}

  	setScalar( scalar ) {

  		this.r = scalar;
  		this.g = scalar;
  		this.b = scalar;

  		return this;

  	}

  	setHex( hex, colorSpace = SRGBColorSpace ) {

  		hex = Math.floor( hex );

  		this.r = ( hex >> 16 & 255 ) / 255;
  		this.g = ( hex >> 8 & 255 ) / 255;
  		this.b = ( hex & 255 ) / 255;

  		ColorManagement.toWorkingColorSpace( this, colorSpace );

  		return this;

  	}

  	setRGB( r, g, b, colorSpace = ColorManagement.workingColorSpace ) {

  		this.r = r;
  		this.g = g;
  		this.b = b;

  		ColorManagement.toWorkingColorSpace( this, colorSpace );

  		return this;

  	}

  	setHSL( h, s, l, colorSpace = ColorManagement.workingColorSpace ) {

  		// h,s,l ranges are in 0.0 - 1.0
  		h = euclideanModulo( h, 1 );
  		s = clamp( s, 0, 1 );
  		l = clamp( l, 0, 1 );

  		if ( s === 0 ) {

  			this.r = this.g = this.b = l;

  		} else {

  			const p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
  			const q = ( 2 * l ) - p;

  			this.r = hue2rgb( q, p, h + 1 / 3 );
  			this.g = hue2rgb( q, p, h );
  			this.b = hue2rgb( q, p, h - 1 / 3 );

  		}

  		ColorManagement.toWorkingColorSpace( this, colorSpace );

  		return this;

  	}

  	setStyle( style, colorSpace = SRGBColorSpace ) {

  		function handleAlpha( string ) {

  			if ( string === undefined ) return;

  			if ( parseFloat( string ) < 1 ) {

  				console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );

  			}

  		}


  		let m;

  		if ( m = /^(\w+)\(([^\)]*)\)/.exec( style ) ) {

  			// rgb / hsl

  			let color;
  			const name = m[ 1 ];
  			const components = m[ 2 ];

  			switch ( name ) {

  				case 'rgb':
  				case 'rgba':

  					if ( color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

  						// rgb(255,0,0) rgba(255,0,0,0.5)

  						handleAlpha( color[ 4 ] );

  						return this.setRGB(
  							Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255,
  							Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255,
  							Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255,
  							colorSpace
  						);

  					}

  					if ( color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

  						// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)

  						handleAlpha( color[ 4 ] );

  						return this.setRGB(
  							Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100,
  							Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100,
  							Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100,
  							colorSpace
  						);

  					}

  					break;

  				case 'hsl':
  				case 'hsla':

  					if ( color = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

  						// hsl(120,50%,50%) hsla(120,50%,50%,0.5)

  						handleAlpha( color[ 4 ] );

  						return this.setHSL(
  							parseFloat( color[ 1 ] ) / 360,
  							parseFloat( color[ 2 ] ) / 100,
  							parseFloat( color[ 3 ] ) / 100,
  							colorSpace
  						);

  					}

  					break;

  				default:

  					console.warn( 'THREE.Color: Unknown color model ' + style );

  			}

  		} else if ( m = /^\#([A-Fa-f\d]+)$/.exec( style ) ) {

  			// hex color

  			const hex = m[ 1 ];
  			const size = hex.length;

  			if ( size === 3 ) {

  				// #ff0
  				return this.setRGB(
  					parseInt( hex.charAt( 0 ), 16 ) / 15,
  					parseInt( hex.charAt( 1 ), 16 ) / 15,
  					parseInt( hex.charAt( 2 ), 16 ) / 15,
  					colorSpace
  				);

  			} else if ( size === 6 ) {

  				// #ff0000
  				return this.setHex( parseInt( hex, 16 ), colorSpace );

  			} else {

  				console.warn( 'THREE.Color: Invalid hex color ' + style );

  			}

  		} else if ( style && style.length > 0 ) {

  			return this.setColorName( style, colorSpace );

  		}

  		return this;

  	}

  	setColorName( style, colorSpace = SRGBColorSpace ) {

  		// color keywords
  		const hex = _colorKeywords[ style.toLowerCase() ];

  		if ( hex !== undefined ) {

  			// red
  			this.setHex( hex, colorSpace );

  		} else {

  			// unknown color
  			console.warn( 'THREE.Color: Unknown color ' + style );

  		}

  		return this;

  	}

  	clone() {

  		return new this.constructor( this.r, this.g, this.b );

  	}

  	copy( color ) {

  		this.r = color.r;
  		this.g = color.g;
  		this.b = color.b;

  		return this;

  	}

  	copySRGBToLinear( color ) {

  		this.r = SRGBToLinear( color.r );
  		this.g = SRGBToLinear( color.g );
  		this.b = SRGBToLinear( color.b );

  		return this;

  	}

  	copyLinearToSRGB( color ) {

  		this.r = LinearToSRGB( color.r );
  		this.g = LinearToSRGB( color.g );
  		this.b = LinearToSRGB( color.b );

  		return this;

  	}

  	convertSRGBToLinear() {

  		this.copySRGBToLinear( this );

  		return this;

  	}

  	convertLinearToSRGB() {

  		this.copyLinearToSRGB( this );

  		return this;

  	}

  	getHex( colorSpace = SRGBColorSpace ) {

  		ColorManagement.fromWorkingColorSpace( _color$1.copy( this ), colorSpace );

  		return Math.round( clamp( _color$1.r * 255, 0, 255 ) ) * 65536 + Math.round( clamp( _color$1.g * 255, 0, 255 ) ) * 256 + Math.round( clamp( _color$1.b * 255, 0, 255 ) );

  	}

  	getHexString( colorSpace = SRGBColorSpace ) {

  		return ( '000000' + this.getHex( colorSpace ).toString( 16 ) ).slice( - 6 );

  	}

  	getHSL( target, colorSpace = ColorManagement.workingColorSpace ) {

  		// h,s,l ranges are in 0.0 - 1.0

  		ColorManagement.fromWorkingColorSpace( _color$1.copy( this ), colorSpace );

  		const r = _color$1.r, g = _color$1.g, b = _color$1.b;

  		const max = Math.max( r, g, b );
  		const min = Math.min( r, g, b );

  		let hue, saturation;
  		const lightness = ( min + max ) / 2.0;

  		if ( min === max ) {

  			hue = 0;
  			saturation = 0;

  		} else {

  			const delta = max - min;

  			saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

  			switch ( max ) {

  				case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
  				case g: hue = ( b - r ) / delta + 2; break;
  				case b: hue = ( r - g ) / delta + 4; break;

  			}

  			hue /= 6;

  		}

  		target.h = hue;
  		target.s = saturation;
  		target.l = lightness;

  		return target;

  	}

  	getRGB( target, colorSpace = ColorManagement.workingColorSpace ) {

  		ColorManagement.fromWorkingColorSpace( _color$1.copy( this ), colorSpace );

  		target.r = _color$1.r;
  		target.g = _color$1.g;
  		target.b = _color$1.b;

  		return target;

  	}

  	getStyle( colorSpace = SRGBColorSpace ) {

  		ColorManagement.fromWorkingColorSpace( _color$1.copy( this ), colorSpace );

  		const r = _color$1.r, g = _color$1.g, b = _color$1.b;

  		if ( colorSpace !== SRGBColorSpace ) {

  			// Requires CSS Color Module Level 4 (https://www.w3.org/TR/css-color-4/).
  			return `color(${ colorSpace } ${ r.toFixed( 3 ) } ${ g.toFixed( 3 ) } ${ b.toFixed( 3 ) })`;

  		}

  		return `rgb(${ Math.round( r * 255 ) },${ Math.round( g * 255 ) },${ Math.round( b * 255 ) })`;

  	}

  	offsetHSL( h, s, l ) {

  		this.getHSL( _hslA );

  		return this.setHSL( _hslA.h + h, _hslA.s + s, _hslA.l + l );

  	}

  	add( color ) {

  		this.r += color.r;
  		this.g += color.g;
  		this.b += color.b;

  		return this;

  	}

  	addColors( color1, color2 ) {

  		this.r = color1.r + color2.r;
  		this.g = color1.g + color2.g;
  		this.b = color1.b + color2.b;

  		return this;

  	}

  	addScalar( s ) {

  		this.r += s;
  		this.g += s;
  		this.b += s;

  		return this;

  	}

  	sub( color ) {

  		this.r = Math.max( 0, this.r - color.r );
  		this.g = Math.max( 0, this.g - color.g );
  		this.b = Math.max( 0, this.b - color.b );

  		return this;

  	}

  	multiply( color ) {

  		this.r *= color.r;
  		this.g *= color.g;
  		this.b *= color.b;

  		return this;

  	}

  	multiplyScalar( s ) {

  		this.r *= s;
  		this.g *= s;
  		this.b *= s;

  		return this;

  	}

  	lerp( color, alpha ) {

  		this.r += ( color.r - this.r ) * alpha;
  		this.g += ( color.g - this.g ) * alpha;
  		this.b += ( color.b - this.b ) * alpha;

  		return this;

  	}

  	lerpColors( color1, color2, alpha ) {

  		this.r = color1.r + ( color2.r - color1.r ) * alpha;
  		this.g = color1.g + ( color2.g - color1.g ) * alpha;
  		this.b = color1.b + ( color2.b - color1.b ) * alpha;

  		return this;

  	}

  	lerpHSL( color, alpha ) {

  		this.getHSL( _hslA );
  		color.getHSL( _hslB );

  		const h = lerp( _hslA.h, _hslB.h, alpha );
  		const s = lerp( _hslA.s, _hslB.s, alpha );
  		const l = lerp( _hslA.l, _hslB.l, alpha );

  		this.setHSL( h, s, l );

  		return this;

  	}

  	setFromVector3( v ) {

  		this.r = v.x;
  		this.g = v.y;
  		this.b = v.z;

  		return this;

  	}

  	applyMatrix3( m ) {

  		const r = this.r, g = this.g, b = this.b;
  		const e = m.elements;

  		this.r = e[ 0 ] * r + e[ 3 ] * g + e[ 6 ] * b;
  		this.g = e[ 1 ] * r + e[ 4 ] * g + e[ 7 ] * b;
  		this.b = e[ 2 ] * r + e[ 5 ] * g + e[ 8 ] * b;

  		return this;

  	}

  	equals( c ) {

  		return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

  	}

  	fromArray( array, offset = 0 ) {

  		this.r = array[ offset ];
  		this.g = array[ offset + 1 ];
  		this.b = array[ offset + 2 ];

  		return this;

  	}

  	toArray( array = [], offset = 0 ) {

  		array[ offset ] = this.r;
  		array[ offset + 1 ] = this.g;
  		array[ offset + 2 ] = this.b;

  		return array;

  	}

  	fromBufferAttribute( attribute, index ) {

  		this.r = attribute.getX( index );
  		this.g = attribute.getY( index );
  		this.b = attribute.getZ( index );

  		return this;

  	}

  	toJSON() {

  		return this.getHex();

  	}

  	*[ Symbol.iterator ]() {

  		yield this.r;
  		yield this.g;
  		yield this.b;

  	}

  }

  const _color$1 = /*@__PURE__*/ new Color();

  Color.NAMES = _colorKeywords;

  let _materialId = 0;

  class Material extends EventDispatcher {

  	constructor() {

  		super();

  		this.isMaterial = true;

  		Object.defineProperty( this, 'id', { value: _materialId ++ } );

  		this.uuid = generateUUID();

  		this.name = '';
  		this.type = 'Material';

  		this.blending = NormalBlending;
  		this.side = FrontSide;
  		this.vertexColors = false;

  		this.opacity = 1;
  		this.transparent = false;
  		this.alphaHash = false;

  		this.blendSrc = SrcAlphaFactor;
  		this.blendDst = OneMinusSrcAlphaFactor;
  		this.blendEquation = AddEquation;
  		this.blendSrcAlpha = null;
  		this.blendDstAlpha = null;
  		this.blendEquationAlpha = null;
  		this.blendColor = new Color( 0, 0, 0 );
  		this.blendAlpha = 0;

  		this.depthFunc = LessEqualDepth;
  		this.depthTest = true;
  		this.depthWrite = true;

  		this.stencilWriteMask = 0xff;
  		this.stencilFunc = AlwaysStencilFunc;
  		this.stencilRef = 0;
  		this.stencilFuncMask = 0xff;
  		this.stencilFail = KeepStencilOp;
  		this.stencilZFail = KeepStencilOp;
  		this.stencilZPass = KeepStencilOp;
  		this.stencilWrite = false;

  		this.clippingPlanes = null;
  		this.clipIntersection = false;
  		this.clipShadows = false;

  		this.shadowSide = null;

  		this.colorWrite = true;

  		this.precision = null; // override the renderer's default precision for this material

  		this.polygonOffset = false;
  		this.polygonOffsetFactor = 0;
  		this.polygonOffsetUnits = 0;

  		this.dithering = false;

  		this.alphaToCoverage = false;
  		this.premultipliedAlpha = false;
  		this.forceSinglePass = false;

  		this.visible = true;

  		this.toneMapped = true;

  		this.userData = {};

  		this.version = 0;

  		this._alphaTest = 0;

  	}

  	get alphaTest() {

  		return this._alphaTest;

  	}

  	set alphaTest( value ) {

  		if ( this._alphaTest > 0 !== value > 0 ) {

  			this.version ++;

  		}

  		this._alphaTest = value;

  	}

  	onBeforeCompile( /* shaderobject, renderer */ ) {}

  	customProgramCacheKey() {

  		return this.onBeforeCompile.toString();

  	}

  	setValues( values ) {

  		if ( values === undefined ) return;

  		for ( const key in values ) {

  			const newValue = values[ key ];

  			if ( newValue === undefined ) {

  				console.warn( `THREE.Material: parameter '${ key }' has value of undefined.` );
  				continue;

  			}

  			const currentValue = this[ key ];

  			if ( currentValue === undefined ) {

  				console.warn( `THREE.Material: '${ key }' is not a property of THREE.${ this.type }.` );
  				continue;

  			}

  			if ( currentValue && currentValue.isColor ) {

  				currentValue.set( newValue );

  			} else if ( ( currentValue && currentValue.isVector3 ) && ( newValue && newValue.isVector3 ) ) {

  				currentValue.copy( newValue );

  			} else {

  				this[ key ] = newValue;

  			}

  		}

  	}

  	toJSON( meta ) {

  		const isRootObject = ( meta === undefined || typeof meta === 'string' );

  		if ( isRootObject ) {

  			meta = {
  				textures: {},
  				images: {}
  			};

  		}

  		const data = {
  			metadata: {
  				version: 4.6,
  				type: 'Material',
  				generator: 'Material.toJSON'
  			}
  		};

  		// standard Material serialization
  		data.uuid = this.uuid;
  		data.type = this.type;

  		if ( this.name !== '' ) data.name = this.name;

  		if ( this.color && this.color.isColor ) data.color = this.color.getHex();

  		if ( this.roughness !== undefined ) data.roughness = this.roughness;
  		if ( this.metalness !== undefined ) data.metalness = this.metalness;

  		if ( this.sheen !== undefined ) data.sheen = this.sheen;
  		if ( this.sheenColor && this.sheenColor.isColor ) data.sheenColor = this.sheenColor.getHex();
  		if ( this.sheenRoughness !== undefined ) data.sheenRoughness = this.sheenRoughness;
  		if ( this.emissive && this.emissive.isColor ) data.emissive = this.emissive.getHex();
  		if ( this.emissiveIntensity !== undefined && this.emissiveIntensity !== 1 ) data.emissiveIntensity = this.emissiveIntensity;

  		if ( this.specular && this.specular.isColor ) data.specular = this.specular.getHex();
  		if ( this.specularIntensity !== undefined ) data.specularIntensity = this.specularIntensity;
  		if ( this.specularColor && this.specularColor.isColor ) data.specularColor = this.specularColor.getHex();
  		if ( this.shininess !== undefined ) data.shininess = this.shininess;
  		if ( this.clearcoat !== undefined ) data.clearcoat = this.clearcoat;
  		if ( this.clearcoatRoughness !== undefined ) data.clearcoatRoughness = this.clearcoatRoughness;

  		if ( this.clearcoatMap && this.clearcoatMap.isTexture ) {

  			data.clearcoatMap = this.clearcoatMap.toJSON( meta ).uuid;

  		}

  		if ( this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture ) {

  			data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON( meta ).uuid;

  		}

  		if ( this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture ) {

  			data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON( meta ).uuid;
  			data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();

  		}

  		if ( this.dispersion !== undefined ) data.dispersion = this.dispersion;

  		if ( this.iridescence !== undefined ) data.iridescence = this.iridescence;
  		if ( this.iridescenceIOR !== undefined ) data.iridescenceIOR = this.iridescenceIOR;
  		if ( this.iridescenceThicknessRange !== undefined ) data.iridescenceThicknessRange = this.iridescenceThicknessRange;

  		if ( this.iridescenceMap && this.iridescenceMap.isTexture ) {

  			data.iridescenceMap = this.iridescenceMap.toJSON( meta ).uuid;

  		}

  		if ( this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture ) {

  			data.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON( meta ).uuid;

  		}

  		if ( this.anisotropy !== undefined ) data.anisotropy = this.anisotropy;
  		if ( this.anisotropyRotation !== undefined ) data.anisotropyRotation = this.anisotropyRotation;

  		if ( this.anisotropyMap && this.anisotropyMap.isTexture ) {

  			data.anisotropyMap = this.anisotropyMap.toJSON( meta ).uuid;

  		}

  		if ( this.map && this.map.isTexture ) data.map = this.map.toJSON( meta ).uuid;
  		if ( this.matcap && this.matcap.isTexture ) data.matcap = this.matcap.toJSON( meta ).uuid;
  		if ( this.alphaMap && this.alphaMap.isTexture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;

  		if ( this.lightMap && this.lightMap.isTexture ) {

  			data.lightMap = this.lightMap.toJSON( meta ).uuid;
  			data.lightMapIntensity = this.lightMapIntensity;

  		}

  		if ( this.aoMap && this.aoMap.isTexture ) {

  			data.aoMap = this.aoMap.toJSON( meta ).uuid;
  			data.aoMapIntensity = this.aoMapIntensity;

  		}

  		if ( this.bumpMap && this.bumpMap.isTexture ) {

  			data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
  			data.bumpScale = this.bumpScale;

  		}

  		if ( this.normalMap && this.normalMap.isTexture ) {

  			data.normalMap = this.normalMap.toJSON( meta ).uuid;
  			data.normalMapType = this.normalMapType;
  			data.normalScale = this.normalScale.toArray();

  		}

  		if ( this.displacementMap && this.displacementMap.isTexture ) {

  			data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
  			data.displacementScale = this.displacementScale;
  			data.displacementBias = this.displacementBias;

  		}

  		if ( this.roughnessMap && this.roughnessMap.isTexture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;
  		if ( this.metalnessMap && this.metalnessMap.isTexture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;

  		if ( this.emissiveMap && this.emissiveMap.isTexture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;
  		if ( this.specularMap && this.specularMap.isTexture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;
  		if ( this.specularIntensityMap && this.specularIntensityMap.isTexture ) data.specularIntensityMap = this.specularIntensityMap.toJSON( meta ).uuid;
  		if ( this.specularColorMap && this.specularColorMap.isTexture ) data.specularColorMap = this.specularColorMap.toJSON( meta ).uuid;

  		if ( this.envMap && this.envMap.isTexture ) {

  			data.envMap = this.envMap.toJSON( meta ).uuid;

  			if ( this.combine !== undefined ) data.combine = this.combine;

  		}

  		if ( this.envMapRotation !== undefined ) data.envMapRotation = this.envMapRotation.toArray();
  		if ( this.envMapIntensity !== undefined ) data.envMapIntensity = this.envMapIntensity;
  		if ( this.reflectivity !== undefined ) data.reflectivity = this.reflectivity;
  		if ( this.refractionRatio !== undefined ) data.refractionRatio = this.refractionRatio;

  		if ( this.gradientMap && this.gradientMap.isTexture ) {

  			data.gradientMap = this.gradientMap.toJSON( meta ).uuid;

  		}

  		if ( this.transmission !== undefined ) data.transmission = this.transmission;
  		if ( this.transmissionMap && this.transmissionMap.isTexture ) data.transmissionMap = this.transmissionMap.toJSON( meta ).uuid;
  		if ( this.thickness !== undefined ) data.thickness = this.thickness;
  		if ( this.thicknessMap && this.thicknessMap.isTexture ) data.thicknessMap = this.thicknessMap.toJSON( meta ).uuid;
  		if ( this.attenuationDistance !== undefined && this.attenuationDistance !== Infinity ) data.attenuationDistance = this.attenuationDistance;
  		if ( this.attenuationColor !== undefined ) data.attenuationColor = this.attenuationColor.getHex();

  		if ( this.size !== undefined ) data.size = this.size;
  		if ( this.shadowSide !== null ) data.shadowSide = this.shadowSide;
  		if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;

  		if ( this.blending !== NormalBlending ) data.blending = this.blending;
  		if ( this.side !== FrontSide ) data.side = this.side;
  		if ( this.vertexColors === true ) data.vertexColors = true;

  		if ( this.opacity < 1 ) data.opacity = this.opacity;
  		if ( this.transparent === true ) data.transparent = true;

  		if ( this.blendSrc !== SrcAlphaFactor ) data.blendSrc = this.blendSrc;
  		if ( this.blendDst !== OneMinusSrcAlphaFactor ) data.blendDst = this.blendDst;
  		if ( this.blendEquation !== AddEquation ) data.blendEquation = this.blendEquation;
  		if ( this.blendSrcAlpha !== null ) data.blendSrcAlpha = this.blendSrcAlpha;
  		if ( this.blendDstAlpha !== null ) data.blendDstAlpha = this.blendDstAlpha;
  		if ( this.blendEquationAlpha !== null ) data.blendEquationAlpha = this.blendEquationAlpha;
  		if ( this.blendColor && this.blendColor.isColor ) data.blendColor = this.blendColor.getHex();
  		if ( this.blendAlpha !== 0 ) data.blendAlpha = this.blendAlpha;

  		if ( this.depthFunc !== LessEqualDepth ) data.depthFunc = this.depthFunc;
  		if ( this.depthTest === false ) data.depthTest = this.depthTest;
  		if ( this.depthWrite === false ) data.depthWrite = this.depthWrite;
  		if ( this.colorWrite === false ) data.colorWrite = this.colorWrite;

  		if ( this.stencilWriteMask !== 0xff ) data.stencilWriteMask = this.stencilWriteMask;
  		if ( this.stencilFunc !== AlwaysStencilFunc ) data.stencilFunc = this.stencilFunc;
  		if ( this.stencilRef !== 0 ) data.stencilRef = this.stencilRef;
  		if ( this.stencilFuncMask !== 0xff ) data.stencilFuncMask = this.stencilFuncMask;
  		if ( this.stencilFail !== KeepStencilOp ) data.stencilFail = this.stencilFail;
  		if ( this.stencilZFail !== KeepStencilOp ) data.stencilZFail = this.stencilZFail;
  		if ( this.stencilZPass !== KeepStencilOp ) data.stencilZPass = this.stencilZPass;
  		if ( this.stencilWrite === true ) data.stencilWrite = this.stencilWrite;

  		// rotation (SpriteMaterial)
  		if ( this.rotation !== undefined && this.rotation !== 0 ) data.rotation = this.rotation;

  		if ( this.polygonOffset === true ) data.polygonOffset = true;
  		if ( this.polygonOffsetFactor !== 0 ) data.polygonOffsetFactor = this.polygonOffsetFactor;
  		if ( this.polygonOffsetUnits !== 0 ) data.polygonOffsetUnits = this.polygonOffsetUnits;

  		if ( this.linewidth !== undefined && this.linewidth !== 1 ) data.linewidth = this.linewidth;
  		if ( this.dashSize !== undefined ) data.dashSize = this.dashSize;
  		if ( this.gapSize !== undefined ) data.gapSize = this.gapSize;
  		if ( this.scale !== undefined ) data.scale = this.scale;

  		if ( this.dithering === true ) data.dithering = true;

  		if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
  		if ( this.alphaHash === true ) data.alphaHash = true;
  		if ( this.alphaToCoverage === true ) data.alphaToCoverage = true;
  		if ( this.premultipliedAlpha === true ) data.premultipliedAlpha = true;
  		if ( this.forceSinglePass === true ) data.forceSinglePass = true;

  		if ( this.wireframe === true ) data.wireframe = true;
  		if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;
  		if ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;
  		if ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;

  		if ( this.flatShading === true ) data.flatShading = true;

  		if ( this.visible === false ) data.visible = false;

  		if ( this.toneMapped === false ) data.toneMapped = false;

  		if ( this.fog === false ) data.fog = false;

  		if ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;

  		// TODO: Copied from Object3D.toJSON

  		function extractFromCache( cache ) {

  			const values = [];

  			for ( const key in cache ) {

  				const data = cache[ key ];
  				delete data.metadata;
  				values.push( data );

  			}

  			return values;

  		}

  		if ( isRootObject ) {

  			const textures = extractFromCache( meta.textures );
  			const images = extractFromCache( meta.images );

  			if ( textures.length > 0 ) data.textures = textures;
  			if ( images.length > 0 ) data.images = images;

  		}

  		return data;

  	}

  	clone() {

  		return new this.constructor().copy( this );

  	}

  	copy( source ) {

  		this.name = source.name;

  		this.blending = source.blending;
  		this.side = source.side;
  		this.vertexColors = source.vertexColors;

  		this.opacity = source.opacity;
  		this.transparent = source.transparent;

  		this.blendSrc = source.blendSrc;
  		this.blendDst = source.blendDst;
  		this.blendEquation = source.blendEquation;
  		this.blendSrcAlpha = source.blendSrcAlpha;
  		this.blendDstAlpha = source.blendDstAlpha;
  		this.blendEquationAlpha = source.blendEquationAlpha;
  		this.blendColor.copy( source.blendColor );
  		this.blendAlpha = source.blendAlpha;

  		this.depthFunc = source.depthFunc;
  		this.depthTest = source.depthTest;
  		this.depthWrite = source.depthWrite;

  		this.stencilWriteMask = source.stencilWriteMask;
  		this.stencilFunc = source.stencilFunc;
  		this.stencilRef = source.stencilRef;
  		this.stencilFuncMask = source.stencilFuncMask;
  		this.stencilFail = source.stencilFail;
  		this.stencilZFail = source.stencilZFail;
  		this.stencilZPass = source.stencilZPass;
  		this.stencilWrite = source.stencilWrite;

  		const srcPlanes = source.clippingPlanes;
  		let dstPlanes = null;

  		if ( srcPlanes !== null ) {

  			const n = srcPlanes.length;
  			dstPlanes = new Array( n );

  			for ( let i = 0; i !== n; ++ i ) {

  				dstPlanes[ i ] = srcPlanes[ i ].clone();

  			}

  		}

  		this.clippingPlanes = dstPlanes;
  		this.clipIntersection = source.clipIntersection;
  		this.clipShadows = source.clipShadows;

  		this.shadowSide = source.shadowSide;

  		this.colorWrite = source.colorWrite;

  		this.precision = source.precision;

  		this.polygonOffset = source.polygonOffset;
  		this.polygonOffsetFactor = source.polygonOffsetFactor;
  		this.polygonOffsetUnits = source.polygonOffsetUnits;

  		this.dithering = source.dithering;

  		this.alphaTest = source.alphaTest;
  		this.alphaHash = source.alphaHash;
  		this.alphaToCoverage = source.alphaToCoverage;
  		this.premultipliedAlpha = source.premultipliedAlpha;
  		this.forceSinglePass = source.forceSinglePass;

  		this.visible = source.visible;

  		this.toneMapped = source.toneMapped;

  		this.userData = JSON.parse( JSON.stringify( source.userData ) );

  		return this;

  	}

  	dispose() {

  		this.dispatchEvent( { type: 'dispose' } );

  	}

  	set needsUpdate( value ) {

  		if ( value === true ) this.version ++;

  	}

  	onBuild( /* shaderobject, renderer */ ) {

  		console.warn( 'Material: onBuild() has been removed.' ); // @deprecated, r166

  	}

  	onBeforeRender( /* renderer, scene, camera, geometry, object, group */ ) {

  		console.warn( 'Material: onBeforeRender() has been removed.' ); // @deprecated, r166

  	}


  }

  class MeshBasicMaterial extends Material {

  	constructor( parameters ) {

  		super();

  		this.isMeshBasicMaterial = true;

  		this.type = 'MeshBasicMaterial';

  		this.color = new Color( 0xffffff ); // emissive

  		this.map = null;

  		this.lightMap = null;
  		this.lightMapIntensity = 1.0;

  		this.aoMap = null;
  		this.aoMapIntensity = 1.0;

  		this.specularMap = null;

  		this.alphaMap = null;

  		this.envMap = null;
  		this.envMapRotation = new Euler();
  		this.combine = MultiplyOperation;
  		this.reflectivity = 1;
  		this.refractionRatio = 0.98;

  		this.wireframe = false;
  		this.wireframeLinewidth = 1;
  		this.wireframeLinecap = 'round';
  		this.wireframeLinejoin = 'round';

  		this.fog = true;

  		this.setValues( parameters );

  	}

  	copy( source ) {

  		super.copy( source );

  		this.color.copy( source.color );

  		this.map = source.map;

  		this.lightMap = source.lightMap;
  		this.lightMapIntensity = source.lightMapIntensity;

  		this.aoMap = source.aoMap;
  		this.aoMapIntensity = source.aoMapIntensity;

  		this.specularMap = source.specularMap;

  		this.alphaMap = source.alphaMap;

  		this.envMap = source.envMap;
  		this.envMapRotation.copy( source.envMapRotation );
  		this.combine = source.combine;
  		this.reflectivity = source.reflectivity;
  		this.refractionRatio = source.refractionRatio;

  		this.wireframe = source.wireframe;
  		this.wireframeLinewidth = source.wireframeLinewidth;
  		this.wireframeLinecap = source.wireframeLinecap;
  		this.wireframeLinejoin = source.wireframeLinejoin;

  		this.fog = source.fog;

  		return this;

  	}

  }

  const _vector$9 = /*@__PURE__*/ new Vector3();
  const _vector2$1 = /*@__PURE__*/ new Vector2();

  class BufferAttribute {

  	constructor( array, itemSize, normalized = false ) {

  		if ( Array.isArray( array ) ) {

  			throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

  		}

  		this.isBufferAttribute = true;

  		this.name = '';

  		this.array = array;
  		this.itemSize = itemSize;
  		this.count = array !== undefined ? array.length / itemSize : 0;
  		this.normalized = normalized;

  		this.usage = StaticDrawUsage;
  		this._updateRange = { offset: 0, count: - 1 };
  		this.updateRanges = [];
  		this.gpuType = FloatType;

  		this.version = 0;

  	}

  	onUploadCallback() {}

  	set needsUpdate( value ) {

  		if ( value === true ) this.version ++;

  	}

  	get updateRange() {

  		warnOnce( 'THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead.' ); // @deprecated, r159
  		return this._updateRange;

  	}

  	setUsage( value ) {

  		this.usage = value;

  		return this;

  	}

  	addUpdateRange( start, count ) {

  		this.updateRanges.push( { start, count } );

  	}

  	clearUpdateRanges() {

  		this.updateRanges.length = 0;

  	}

  	copy( source ) {

  		this.name = source.name;
  		this.array = new source.array.constructor( source.array );
  		this.itemSize = source.itemSize;
  		this.count = source.count;
  		this.normalized = source.normalized;

  		this.usage = source.usage;
  		this.gpuType = source.gpuType;

  		return this;

  	}

  	copyAt( index1, attribute, index2 ) {

  		index1 *= this.itemSize;
  		index2 *= attribute.itemSize;

  		for ( let i = 0, l = this.itemSize; i < l; i ++ ) {

  			this.array[ index1 + i ] = attribute.array[ index2 + i ];

  		}

  		return this;

  	}

  	copyArray( array ) {

  		this.array.set( array );

  		return this;

  	}

  	applyMatrix3( m ) {

  		if ( this.itemSize === 2 ) {

  			for ( let i = 0, l = this.count; i < l; i ++ ) {

  				_vector2$1.fromBufferAttribute( this, i );
  				_vector2$1.applyMatrix3( m );

  				this.setXY( i, _vector2$1.x, _vector2$1.y );

  			}

  		} else if ( this.itemSize === 3 ) {

  			for ( let i = 0, l = this.count; i < l; i ++ ) {

  				_vector$9.fromBufferAttribute( this, i );
  				_vector$9.applyMatrix3( m );

  				this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

  			}

  		}

  		return this;

  	}

  	applyMatrix4( m ) {

  		for ( let i = 0, l = this.count; i < l; i ++ ) {

  			_vector$9.fromBufferAttribute( this, i );

  			_vector$9.applyMatrix4( m );

  			this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

  		}

  		return this;

  	}

  	applyNormalMatrix( m ) {

  		for ( let i = 0, l = this.count; i < l; i ++ ) {

  			_vector$9.fromBufferAttribute( this, i );

  			_vector$9.applyNormalMatrix( m );

  			this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

  		}

  		return this;

  	}

  	transformDirection( m ) {

  		for ( let i = 0, l = this.count; i < l; i ++ ) {

  			_vector$9.fromBufferAttribute( this, i );

  			_vector$9.transformDirection( m );

  			this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

  		}

  		return this;

  	}

  	set( value, offset = 0 ) {

  		// Matching BufferAttribute constructor, do not normalize the array.
  		this.array.set( value, offset );

  		return this;

  	}

  	getComponent( index, component ) {

  		let value = this.array[ index * this.itemSize + component ];

  		if ( this.normalized ) value = denormalize( value, this.array );

  		return value;

  	}

  	setComponent( index, component, value ) {

  		if ( this.normalized ) value = normalize( value, this.array );

  		this.array[ index * this.itemSize + component ] = value;

  		return this;

  	}

  	getX( index ) {

  		let x = this.array[ index * this.itemSize ];

  		if ( this.normalized ) x = denormalize( x, this.array );

  		return x;

  	}

  	setX( index, x ) {

  		if ( this.normalized ) x = normalize( x, this.array );

  		this.array[ index * this.itemSize ] = x;

  		return this;

  	}

  	getY( index ) {

  		let y = this.array[ index * this.itemSize + 1 ];

  		if ( this.normalized ) y = denormalize( y, this.array );

  		return y;

  	}

  	setY( index, y ) {

  		if ( this.normalized ) y = normalize( y, this.array );

  		this.array[ index * this.itemSize + 1 ] = y;

  		return this;

  	}

  	getZ( index ) {

  		let z = this.array[ index * this.itemSize + 2 ];

  		if ( this.normalized ) z = denormalize( z, this.array );

  		return z;

  	}

  	setZ( index, z ) {

  		if ( this.normalized ) z = normalize( z, this.array );

  		this.array[ index * this.itemSize + 2 ] = z;

  		return this;

  	}

  	getW( index ) {

  		let w = this.array[ index * this.itemSize + 3 ];

  		if ( this.normalized ) w = denormalize( w, this.array );

  		return w;

  	}

  	setW( index, w ) {

  		if ( this.normalized ) w = normalize( w, this.array );

  		this.array[ index * this.itemSize + 3 ] = w;

  		return this;

  	}

  	setXY( index, x, y ) {

  		index *= this.itemSize;

  		if ( this.normalized ) {

  			x = normalize( x, this.array );
  			y = normalize( y, this.array );

  		}

  		this.array[ index + 0 ] = x;
  		this.array[ index + 1 ] = y;

  		return this;

  	}

  	setXYZ( index, x, y, z ) {

  		index *= this.itemSize;

  		if ( this.normalized ) {

  			x = normalize( x, this.array );
  			y = normalize( y, this.array );
  			z = normalize( z, this.array );

  		}

  		this.array[ index + 0 ] = x;
  		this.array[ index + 1 ] = y;
  		this.array[ index + 2 ] = z;

  		return this;

  	}

  	setXYZW( index, x, y, z, w ) {

  		index *= this.itemSize;

  		if ( this.normalized ) {

  			x = normalize( x, this.array );
  			y = normalize( y, this.array );
  			z = normalize( z, this.array );
  			w = normalize( w, this.array );

  		}

  		this.array[ index + 0 ] = x;
  		this.array[ index + 1 ] = y;
  		this.array[ index + 2 ] = z;
  		this.array[ index + 3 ] = w;

  		return this;

  	}

  	onUpload( callback ) {

  		this.onUploadCallback = callback;

  		return this;

  	}

  	clone() {

  		return new this.constructor( this.array, this.itemSize ).copy( this );

  	}

  	toJSON() {

  		const data = {
  			itemSize: this.itemSize,
  			type: this.array.constructor.name,
  			array: Array.from( this.array ),
  			normalized: this.normalized
  		};

  		if ( this.name !== '' ) data.name = this.name;
  		if ( this.usage !== StaticDrawUsage ) data.usage = this.usage;

  		return data;

  	}

  }

  class Uint16BufferAttribute extends BufferAttribute {

  	constructor( array, itemSize, normalized ) {

  		super( new Uint16Array( array ), itemSize, normalized );

  	}

  }

  class Uint32BufferAttribute extends BufferAttribute {

  	constructor( array, itemSize, normalized ) {

  		super( new Uint32Array( array ), itemSize, normalized );

  	}

  }


  class Float32BufferAttribute extends BufferAttribute {

  	constructor( array, itemSize, normalized ) {

  		super( new Float32Array( array ), itemSize, normalized );

  	}

  }

  let _id$2 = 0;

  const _m1$2 = /*@__PURE__*/ new Matrix4();
  const _obj = /*@__PURE__*/ new Object3D();
  const _offset = /*@__PURE__*/ new Vector3();
  const _box$2 = /*@__PURE__*/ new Box3();
  const _boxMorphTargets = /*@__PURE__*/ new Box3();
  const _vector$8 = /*@__PURE__*/ new Vector3();

  class BufferGeometry extends EventDispatcher {

  	constructor() {

  		super();

  		this.isBufferGeometry = true;

  		Object.defineProperty( this, 'id', { value: _id$2 ++ } );

  		this.uuid = generateUUID();

  		this.name = '';
  		this.type = 'BufferGeometry';

  		this.index = null;
  		this.attributes = {};

  		this.morphAttributes = {};
  		this.morphTargetsRelative = false;

  		this.groups = [];

  		this.boundingBox = null;
  		this.boundingSphere = null;

  		this.drawRange = { start: 0, count: Infinity };

  		this.userData = {};

  	}

  	getIndex() {

  		return this.index;

  	}

  	setIndex( index ) {

  		if ( Array.isArray( index ) ) {

  			this.index = new ( arrayNeedsUint32( index ) ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );

  		} else {

  			this.index = index;

  		}

  		return this;

  	}

  	getAttribute( name ) {

  		return this.attributes[ name ];

  	}

  	setAttribute( name, attribute ) {

  		this.attributes[ name ] = attribute;

  		return this;

  	}

  	deleteAttribute( name ) {

  		delete this.attributes[ name ];

  		return this;

  	}

  	hasAttribute( name ) {

  		return this.attributes[ name ] !== undefined;

  	}

  	addGroup( start, count, materialIndex = 0 ) {

  		this.groups.push( {

  			start: start,
  			count: count,
  			materialIndex: materialIndex

  		} );

  	}

  	clearGroups() {

  		this.groups = [];

  	}

  	setDrawRange( start, count ) {

  		this.drawRange.start = start;
  		this.drawRange.count = count;

  	}

  	applyMatrix4( matrix ) {

  		const position = this.attributes.position;

  		if ( position !== undefined ) {

  			position.applyMatrix4( matrix );

  			position.needsUpdate = true;

  		}

  		const normal = this.attributes.normal;

  		if ( normal !== undefined ) {

  			const normalMatrix = new Matrix3().getNormalMatrix( matrix );

  			normal.applyNormalMatrix( normalMatrix );

  			normal.needsUpdate = true;

  		}

  		const tangent = this.attributes.tangent;

  		if ( tangent !== undefined ) {

  			tangent.transformDirection( matrix );

  			tangent.needsUpdate = true;

  		}

  		if ( this.boundingBox !== null ) {

  			this.computeBoundingBox();

  		}

  		if ( this.boundingSphere !== null ) {

  			this.computeBoundingSphere();

  		}

  		return this;

  	}

  	applyQuaternion( q ) {

  		_m1$2.makeRotationFromQuaternion( q );

  		this.applyMatrix4( _m1$2 );

  		return this;

  	}

  	rotateX( angle ) {

  		// rotate geometry around world x-axis

  		_m1$2.makeRotationX( angle );

  		this.applyMatrix4( _m1$2 );

  		return this;

  	}

  	rotateY( angle ) {

  		// rotate geometry around world y-axis

  		_m1$2.makeRotationY( angle );

  		this.applyMatrix4( _m1$2 );

  		return this;

  	}

  	rotateZ( angle ) {

  		// rotate geometry around world z-axis

  		_m1$2.makeRotationZ( angle );

  		this.applyMatrix4( _m1$2 );

  		return this;

  	}

  	translate( x, y, z ) {

  		// translate geometry

  		_m1$2.makeTranslation( x, y, z );

  		this.applyMatrix4( _m1$2 );

  		return this;

  	}

  	scale( x, y, z ) {

  		// scale geometry

  		_m1$2.makeScale( x, y, z );

  		this.applyMatrix4( _m1$2 );

  		return this;

  	}

  	lookAt( vector ) {

  		_obj.lookAt( vector );

  		_obj.updateMatrix();

  		this.applyMatrix4( _obj.matrix );

  		return this;

  	}

  	center() {

  		this.computeBoundingBox();

  		this.boundingBox.getCenter( _offset ).negate();

  		this.translate( _offset.x, _offset.y, _offset.z );

  		return this;

  	}

  	setFromPoints( points ) {

  		const position = [];

  		for ( let i = 0, l = points.length; i < l; i ++ ) {

  			const point = points[ i ];
  			position.push( point.x, point.y, point.z || 0 );

  		}

  		this.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );

  		return this;

  	}

  	computeBoundingBox() {

  		if ( this.boundingBox === null ) {

  			this.boundingBox = new Box3();

  		}

  		const position = this.attributes.position;
  		const morphAttributesPosition = this.morphAttributes.position;

  		if ( position && position.isGLBufferAttribute ) {

  			console.error( 'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.', this );

  			this.boundingBox.set(
  				new Vector3( - Infinity, - Infinity, - Infinity ),
  				new Vector3( + Infinity, + Infinity, + Infinity )
  			);

  			return;

  		}

  		if ( position !== undefined ) {

  			this.boundingBox.setFromBufferAttribute( position );

  			// process morph attributes if present

  			if ( morphAttributesPosition ) {

  				for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

  					const morphAttribute = morphAttributesPosition[ i ];
  					_box$2.setFromBufferAttribute( morphAttribute );

  					if ( this.morphTargetsRelative ) {

  						_vector$8.addVectors( this.boundingBox.min, _box$2.min );
  						this.boundingBox.expandByPoint( _vector$8 );

  						_vector$8.addVectors( this.boundingBox.max, _box$2.max );
  						this.boundingBox.expandByPoint( _vector$8 );

  					} else {

  						this.boundingBox.expandByPoint( _box$2.min );
  						this.boundingBox.expandByPoint( _box$2.max );

  					}

  				}

  			}

  		} else {

  			this.boundingBox.makeEmpty();

  		}

  		if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

  			console.error( 'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );

  		}

  	}

  	computeBoundingSphere() {

  		if ( this.boundingSphere === null ) {

  			this.boundingSphere = new Sphere();

  		}

  		const position = this.attributes.position;
  		const morphAttributesPosition = this.morphAttributes.position;

  		if ( position && position.isGLBufferAttribute ) {

  			console.error( 'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.', this );

  			this.boundingSphere.set( new Vector3(), Infinity );

  			return;

  		}

  		if ( position ) {

  			// first, find the center of the bounding sphere

  			const center = this.boundingSphere.center;

  			_box$2.setFromBufferAttribute( position );

  			// process morph attributes if present

  			if ( morphAttributesPosition ) {

  				for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

  					const morphAttribute = morphAttributesPosition[ i ];
  					_boxMorphTargets.setFromBufferAttribute( morphAttribute );

  					if ( this.morphTargetsRelative ) {

  						_vector$8.addVectors( _box$2.min, _boxMorphTargets.min );
  						_box$2.expandByPoint( _vector$8 );

  						_vector$8.addVectors( _box$2.max, _boxMorphTargets.max );
  						_box$2.expandByPoint( _vector$8 );

  					} else {

  						_box$2.expandByPoint( _boxMorphTargets.min );
  						_box$2.expandByPoint( _boxMorphTargets.max );

  					}

  				}

  			}

  			_box$2.getCenter( center );

  			// second, try to find a boundingSphere with a radius smaller than the
  			// boundingSphere of the boundingBox: sqrt(3) smaller in the best case

  			let maxRadiusSq = 0;

  			for ( let i = 0, il = position.count; i < il; i ++ ) {

  				_vector$8.fromBufferAttribute( position, i );

  				maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$8 ) );

  			}

  			// process morph attributes if present

  			if ( morphAttributesPosition ) {

  				for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

  					const morphAttribute = morphAttributesPosition[ i ];
  					const morphTargetsRelative = this.morphTargetsRelative;

  					for ( let j = 0, jl = morphAttribute.count; j < jl; j ++ ) {

  						_vector$8.fromBufferAttribute( morphAttribute, j );

  						if ( morphTargetsRelative ) {

  							_offset.fromBufferAttribute( position, j );
  							_vector$8.add( _offset );

  						}

  						maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$8 ) );

  					}

  				}

  			}

  			this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

  			if ( isNaN( this.boundingSphere.radius ) ) {

  				console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );

  			}

  		}

  	}

  	computeTangents() {

  		const index = this.index;
  		const attributes = this.attributes;

  		// based on http://www.terathon.com/code/tangent.html
  		// (per vertex tangents)

  		if ( index === null ||
  			 attributes.position === undefined ||
  			 attributes.normal === undefined ||
  			 attributes.uv === undefined ) {

  			console.error( 'THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)' );
  			return;

  		}

  		const positionAttribute = attributes.position;
  		const normalAttribute = attributes.normal;
  		const uvAttribute = attributes.uv;

  		if ( this.hasAttribute( 'tangent' ) === false ) {

  			this.setAttribute( 'tangent', new BufferAttribute( new Float32Array( 4 * positionAttribute.count ), 4 ) );

  		}

  		const tangentAttribute = this.getAttribute( 'tangent' );

  		const tan1 = [], tan2 = [];

  		for ( let i = 0; i < positionAttribute.count; i ++ ) {

  			tan1[ i ] = new Vector3();
  			tan2[ i ] = new Vector3();

  		}

  		const vA = new Vector3(),
  			vB = new Vector3(),
  			vC = new Vector3(),

  			uvA = new Vector2(),
  			uvB = new Vector2(),
  			uvC = new Vector2(),

  			sdir = new Vector3(),
  			tdir = new Vector3();

  		function handleTriangle( a, b, c ) {

  			vA.fromBufferAttribute( positionAttribute, a );
  			vB.fromBufferAttribute( positionAttribute, b );
  			vC.fromBufferAttribute( positionAttribute, c );

  			uvA.fromBufferAttribute( uvAttribute, a );
  			uvB.fromBufferAttribute( uvAttribute, b );
  			uvC.fromBufferAttribute( uvAttribute, c );

  			vB.sub( vA );
  			vC.sub( vA );

  			uvB.sub( uvA );
  			uvC.sub( uvA );

  			const r = 1.0 / ( uvB.x * uvC.y - uvC.x * uvB.y );

  			// silently ignore degenerate uv triangles having coincident or colinear vertices

  			if ( ! isFinite( r ) ) return;

  			sdir.copy( vB ).multiplyScalar( uvC.y ).addScaledVector( vC, - uvB.y ).multiplyScalar( r );
  			tdir.copy( vC ).multiplyScalar( uvB.x ).addScaledVector( vB, - uvC.x ).multiplyScalar( r );

  			tan1[ a ].add( sdir );
  			tan1[ b ].add( sdir );
  			tan1[ c ].add( sdir );

  			tan2[ a ].add( tdir );
  			tan2[ b ].add( tdir );
  			tan2[ c ].add( tdir );

  		}

  		let groups = this.groups;

  		if ( groups.length === 0 ) {

  			groups = [ {
  				start: 0,
  				count: index.count
  			} ];

  		}

  		for ( let i = 0, il = groups.length; i < il; ++ i ) {

  			const group = groups[ i ];

  			const start = group.start;
  			const count = group.count;

  			for ( let j = start, jl = start + count; j < jl; j += 3 ) {

  				handleTriangle(
  					index.getX( j + 0 ),
  					index.getX( j + 1 ),
  					index.getX( j + 2 )
  				);

  			}

  		}

  		const tmp = new Vector3(), tmp2 = new Vector3();
  		const n = new Vector3(), n2 = new Vector3();

  		function handleVertex( v ) {

  			n.fromBufferAttribute( normalAttribute, v );
  			n2.copy( n );

  			const t = tan1[ v ];

  			// Gram-Schmidt orthogonalize

  			tmp.copy( t );
  			tmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();

  			// Calculate handedness

  			tmp2.crossVectors( n2, t );
  			const test = tmp2.dot( tan2[ v ] );
  			const w = ( test < 0.0 ) ? - 1.0 : 1.0;

  			tangentAttribute.setXYZW( v, tmp.x, tmp.y, tmp.z, w );

  		}

  		for ( let i = 0, il = groups.length; i < il; ++ i ) {

  			const group = groups[ i ];

  			const start = group.start;
  			const count = group.count;

  			for ( let j = start, jl = start + count; j < jl; j += 3 ) {

  				handleVertex( index.getX( j + 0 ) );
  				handleVertex( index.getX( j + 1 ) );
  				handleVertex( index.getX( j + 2 ) );

  			}

  		}

  	}

  	computeVertexNormals() {

  		const index = this.index;
  		const positionAttribute = this.getAttribute( 'position' );

  		if ( positionAttribute !== undefined ) {

  			let normalAttribute = this.getAttribute( 'normal' );

  			if ( normalAttribute === undefined ) {

  				normalAttribute = new BufferAttribute( new Float32Array( positionAttribute.count * 3 ), 3 );
  				this.setAttribute( 'normal', normalAttribute );

  			} else {

  				// reset existing normals to zero

  				for ( let i = 0, il = normalAttribute.count; i < il; i ++ ) {

  					normalAttribute.setXYZ( i, 0, 0, 0 );

  				}

  			}

  			const pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
  			const nA = new Vector3(), nB = new Vector3(), nC = new Vector3();
  			const cb = new Vector3(), ab = new Vector3();

  			// indexed elements

  			if ( index ) {

  				for ( let i = 0, il = index.count; i < il; i += 3 ) {

  					const vA = index.getX( i + 0 );
  					const vB = index.getX( i + 1 );
  					const vC = index.getX( i + 2 );

  					pA.fromBufferAttribute( positionAttribute, vA );
  					pB.fromBufferAttribute( positionAttribute, vB );
  					pC.fromBufferAttribute( positionAttribute, vC );

  					cb.subVectors( pC, pB );
  					ab.subVectors( pA, pB );
  					cb.cross( ab );

  					nA.fromBufferAttribute( normalAttribute, vA );
  					nB.fromBufferAttribute( normalAttribute, vB );
  					nC.fromBufferAttribute( normalAttribute, vC );

  					nA.add( cb );
  					nB.add( cb );
  					nC.add( cb );

  					normalAttribute.setXYZ( vA, nA.x, nA.y, nA.z );
  					normalAttribute.setXYZ( vB, nB.x, nB.y, nB.z );
  					normalAttribute.setXYZ( vC, nC.x, nC.y, nC.z );

  				}

  			} else {

  				// non-indexed elements (unconnected triangle soup)

  				for ( let i = 0, il = positionAttribute.count; i < il; i += 3 ) {

  					pA.fromBufferAttribute( positionAttribute, i + 0 );
  					pB.fromBufferAttribute( positionAttribute, i + 1 );
  					pC.fromBufferAttribute( positionAttribute, i + 2 );

  					cb.subVectors( pC, pB );
  					ab.subVectors( pA, pB );
  					cb.cross( ab );

  					normalAttribute.setXYZ( i + 0, cb.x, cb.y, cb.z );
  					normalAttribute.setXYZ( i + 1, cb.x, cb.y, cb.z );
  					normalAttribute.setXYZ( i + 2, cb.x, cb.y, cb.z );

  				}

  			}

  			this.normalizeNormals();

  			normalAttribute.needsUpdate = true;

  		}

  	}

  	normalizeNormals() {

  		const normals = this.attributes.normal;

  		for ( let i = 0, il = normals.count; i < il; i ++ ) {

  			_vector$8.fromBufferAttribute( normals, i );

  			_vector$8.normalize();

  			normals.setXYZ( i, _vector$8.x, _vector$8.y, _vector$8.z );

  		}

  	}

  	toNonIndexed() {

  		function convertBufferAttribute( attribute, indices ) {

  			const array = attribute.array;
  			const itemSize = attribute.itemSize;
  			const normalized = attribute.normalized;

  			const array2 = new array.constructor( indices.length * itemSize );

  			let index = 0, index2 = 0;

  			for ( let i = 0, l = indices.length; i < l; i ++ ) {

  				if ( attribute.isInterleavedBufferAttribute ) {

  					index = indices[ i ] * attribute.data.stride + attribute.offset;

  				} else {

  					index = indices[ i ] * itemSize;

  				}

  				for ( let j = 0; j < itemSize; j ++ ) {

  					array2[ index2 ++ ] = array[ index ++ ];

  				}

  			}

  			return new BufferAttribute( array2, itemSize, normalized );

  		}

  		//

  		if ( this.index === null ) {

  			console.warn( 'THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.' );
  			return this;

  		}

  		const geometry2 = new BufferGeometry();

  		const indices = this.index.array;
  		const attributes = this.attributes;

  		// attributes

  		for ( const name in attributes ) {

  			const attribute = attributes[ name ];

  			const newAttribute = convertBufferAttribute( attribute, indices );

  			geometry2.setAttribute( name, newAttribute );

  		}

  		// morph attributes

  		const morphAttributes = this.morphAttributes;

  		for ( const name in morphAttributes ) {

  			const morphArray = [];
  			const morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

  			for ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {

  				const attribute = morphAttribute[ i ];

  				const newAttribute = convertBufferAttribute( attribute, indices );

  				morphArray.push( newAttribute );

  			}

  			geometry2.morphAttributes[ name ] = morphArray;

  		}

  		geometry2.morphTargetsRelative = this.morphTargetsRelative;

  		// groups

  		const groups = this.groups;

  		for ( let i = 0, l = groups.length; i < l; i ++ ) {

  			const group = groups[ i ];
  			geometry2.addGroup( group.start, group.count, group.materialIndex );

  		}

  		return geometry2;

  	}

  	toJSON() {

  		const data = {
  			metadata: {
  				version: 4.6,
  				type: 'BufferGeometry',
  				generator: 'BufferGeometry.toJSON'
  			}
  		};

  		// standard BufferGeometry serialization

  		data.uuid = this.uuid;
  		data.type = this.type;
  		if ( this.name !== '' ) data.name = this.name;
  		if ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;

  		if ( this.parameters !== undefined ) {

  			const parameters = this.parameters;

  			for ( const key in parameters ) {

  				if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

  			}

  			return data;

  		}

  		// for simplicity the code assumes attributes are not shared across geometries, see #15811

  		data.data = { attributes: {} };

  		const index = this.index;

  		if ( index !== null ) {

  			data.data.index = {
  				type: index.array.constructor.name,
  				array: Array.prototype.slice.call( index.array )
  			};

  		}

  		const attributes = this.attributes;

  		for ( const key in attributes ) {

  			const attribute = attributes[ key ];

  			data.data.attributes[ key ] = attribute.toJSON( data.data );

  		}

  		const morphAttributes = {};
  		let hasMorphAttributes = false;

  		for ( const key in this.morphAttributes ) {

  			const attributeArray = this.morphAttributes[ key ];

  			const array = [];

  			for ( let i = 0, il = attributeArray.length; i < il; i ++ ) {

  				const attribute = attributeArray[ i ];

  				array.push( attribute.toJSON( data.data ) );

  			}

  			if ( array.length > 0 ) {

  				morphAttributes[ key ] = array;

  				hasMorphAttributes = true;

  			}

  		}

  		if ( hasMorphAttributes ) {

  			data.data.morphAttributes = morphAttributes;
  			data.data.morphTargetsRelative = this.morphTargetsRelative;

  		}

  		const groups = this.groups;

  		if ( groups.length > 0 ) {

  			data.data.groups = JSON.parse( JSON.stringify( groups ) );

  		}

  		const boundingSphere = this.boundingSphere;

  		if ( boundingSphere !== null ) {

  			data.data.boundingSphere = {
  				center: boundingSphere.center.toArray(),
  				radius: boundingSphere.radius
  			};

  		}

  		return data;

  	}

  	clone() {

  		return new this.constructor().copy( this );

  	}

  	copy( source ) {

  		// reset

  		this.index = null;
  		this.attributes = {};
  		this.morphAttributes = {};
  		this.groups = [];
  		this.boundingBox = null;
  		this.boundingSphere = null;

  		// used for storing cloned, shared data

  		const data = {};

  		// name

  		this.name = source.name;

  		// index

  		const index = source.index;

  		if ( index !== null ) {

  			this.setIndex( index.clone( data ) );

  		}

  		// attributes

  		const attributes = source.attributes;

  		for ( const name in attributes ) {

  			const attribute = attributes[ name ];
  			this.setAttribute( name, attribute.clone( data ) );

  		}

  		// morph attributes

  		const morphAttributes = source.morphAttributes;

  		for ( const name in morphAttributes ) {

  			const array = [];
  			const morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

  			for ( let i = 0, l = morphAttribute.length; i < l; i ++ ) {

  				array.push( morphAttribute[ i ].clone( data ) );

  			}

  			this.morphAttributes[ name ] = array;

  		}

  		this.morphTargetsRelative = source.morphTargetsRelative;

  		// groups

  		const groups = source.groups;

  		for ( let i = 0, l = groups.length; i < l; i ++ ) {

  			const group = groups[ i ];
  			this.addGroup( group.start, group.count, group.materialIndex );

  		}

  		// bounding box

  		const boundingBox = source.boundingBox;

  		if ( boundingBox !== null ) {

  			this.boundingBox = boundingBox.clone();

  		}

  		// bounding sphere

  		const boundingSphere = source.boundingSphere;

  		if ( boundingSphere !== null ) {

  			this.boundingSphere = boundingSphere.clone();

  		}

  		// draw range

  		this.drawRange.start = source.drawRange.start;
  		this.drawRange.count = source.drawRange.count;

  		// user data

  		this.userData = source.userData;

  		return this;

  	}

  	dispose() {

  		this.dispatchEvent( { type: 'dispose' } );

  	}

  }

  const _inverseMatrix$3 = /*@__PURE__*/ new Matrix4();
  const _ray$3 = /*@__PURE__*/ new Ray();
  const _sphere$6 = /*@__PURE__*/ new Sphere();
  const _sphereHitAt = /*@__PURE__*/ new Vector3();

  const _vA$1 = /*@__PURE__*/ new Vector3();
  const _vB$1 = /*@__PURE__*/ new Vector3();
  const _vC$1 = /*@__PURE__*/ new Vector3();

  const _tempA = /*@__PURE__*/ new Vector3();
  const _morphA = /*@__PURE__*/ new Vector3();

  const _uvA$1 = /*@__PURE__*/ new Vector2();
  const _uvB$1 = /*@__PURE__*/ new Vector2();
  const _uvC$1 = /*@__PURE__*/ new Vector2();

  const _normalA = /*@__PURE__*/ new Vector3();
  const _normalB = /*@__PURE__*/ new Vector3();
  const _normalC = /*@__PURE__*/ new Vector3();

  const _intersectionPoint = /*@__PURE__*/ new Vector3();
  const _intersectionPointWorld = /*@__PURE__*/ new Vector3();

  class Mesh extends Object3D {

  	constructor( geometry = new BufferGeometry(), material = new MeshBasicMaterial() ) {

  		super();

  		this.isMesh = true;

  		this.type = 'Mesh';

  		this.geometry = geometry;
  		this.material = material;

  		this.updateMorphTargets();

  	}

  	copy( source, recursive ) {

  		super.copy( source, recursive );

  		if ( source.morphTargetInfluences !== undefined ) {

  			this.morphTargetInfluences = source.morphTargetInfluences.slice();

  		}

  		if ( source.morphTargetDictionary !== undefined ) {

  			this.morphTargetDictionary = Object.assign( {}, source.morphTargetDictionary );

  		}

  		this.material = Array.isArray( source.material ) ? source.material.slice() : source.material;
  		this.geometry = source.geometry;

  		return this;

  	}

  	updateMorphTargets() {

  		const geometry = this.geometry;

  		const morphAttributes = geometry.morphAttributes;
  		const keys = Object.keys( morphAttributes );

  		if ( keys.length > 0 ) {

  			const morphAttribute = morphAttributes[ keys[ 0 ] ];

  			if ( morphAttribute !== undefined ) {

  				this.morphTargetInfluences = [];
  				this.morphTargetDictionary = {};

  				for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

  					const name = morphAttribute[ m ].name || String( m );

  					this.morphTargetInfluences.push( 0 );
  					this.morphTargetDictionary[ name ] = m;

  				}

  			}

  		}

  	}

  	getVertexPosition( index, target ) {

  		const geometry = this.geometry;
  		const position = geometry.attributes.position;
  		const morphPosition = geometry.morphAttributes.position;
  		const morphTargetsRelative = geometry.morphTargetsRelative;

  		target.fromBufferAttribute( position, index );

  		const morphInfluences = this.morphTargetInfluences;

  		if ( morphPosition && morphInfluences ) {

  			_morphA.set( 0, 0, 0 );

  			for ( let i = 0, il = morphPosition.length; i < il; i ++ ) {

  				const influence = morphInfluences[ i ];
  				const morphAttribute = morphPosition[ i ];

  				if ( influence === 0 ) continue;

  				_tempA.fromBufferAttribute( morphAttribute, index );

  				if ( morphTargetsRelative ) {

  					_morphA.addScaledVector( _tempA, influence );

  				} else {

  					_morphA.addScaledVector( _tempA.sub( target ), influence );

  				}

  			}

  			target.add( _morphA );

  		}

  		return target;

  	}

  	raycast( raycaster, intersects ) {

  		const geometry = this.geometry;
  		const material = this.material;
  		const matrixWorld = this.matrixWorld;

  		if ( material === undefined ) return;

  		// test with bounding sphere in world space

  		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

  		_sphere$6.copy( geometry.boundingSphere );
  		_sphere$6.applyMatrix4( matrixWorld );

  		// check distance from ray origin to bounding sphere

  		_ray$3.copy( raycaster.ray ).recast( raycaster.near );

  		if ( _sphere$6.containsPoint( _ray$3.origin ) === false ) {

  			if ( _ray$3.intersectSphere( _sphere$6, _sphereHitAt ) === null ) return;

  			if ( _ray$3.origin.distanceToSquared( _sphereHitAt ) > ( raycaster.far - raycaster.near ) ** 2 ) return;

  		}

  		// convert ray to local space of mesh

  		_inverseMatrix$3.copy( matrixWorld ).invert();
  		_ray$3.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$3 );

  		// test with bounding box in local space

  		if ( geometry.boundingBox !== null ) {

  			if ( _ray$3.intersectsBox( geometry.boundingBox ) === false ) return;

  		}

  		// test for intersections with geometry

  		this._computeIntersections( raycaster, intersects, _ray$3 );

  	}

  	_computeIntersections( raycaster, intersects, rayLocalSpace ) {

  		let intersection;

  		const geometry = this.geometry;
  		const material = this.material;

  		const index = geometry.index;
  		const position = geometry.attributes.position;
  		const uv = geometry.attributes.uv;
  		const uv1 = geometry.attributes.uv1;
  		const normal = geometry.attributes.normal;
  		const groups = geometry.groups;
  		const drawRange = geometry.drawRange;

  		if ( index !== null ) {

  			// indexed buffer geometry

  			if ( Array.isArray( material ) ) {

  				for ( let i = 0, il = groups.length; i < il; i ++ ) {

  					const group = groups[ i ];
  					const groupMaterial = material[ group.materialIndex ];

  					const start = Math.max( group.start, drawRange.start );
  					const end = Math.min( index.count, Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) ) );

  					for ( let j = start, jl = end; j < jl; j += 3 ) {

  						const a = index.getX( j );
  						const b = index.getX( j + 1 );
  						const c = index.getX( j + 2 );

  						intersection = checkGeometryIntersection( this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c );

  						if ( intersection ) {

  							intersection.faceIndex = Math.floor( j / 3 ); // triangle number in indexed buffer semantics
  							intersection.face.materialIndex = group.materialIndex;
  							intersects.push( intersection );

  						}

  					}

  				}

  			} else {

  				const start = Math.max( 0, drawRange.start );
  				const end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

  				for ( let i = start, il = end; i < il; i += 3 ) {

  					const a = index.getX( i );
  					const b = index.getX( i + 1 );
  					const c = index.getX( i + 2 );

  					intersection = checkGeometryIntersection( this, material, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c );

  					if ( intersection ) {

  						intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indexed buffer semantics
  						intersects.push( intersection );

  					}

  				}

  			}

  		} else if ( position !== undefined ) {

  			// non-indexed buffer geometry

  			if ( Array.isArray( material ) ) {

  				for ( let i = 0, il = groups.length; i < il; i ++ ) {

  					const group = groups[ i ];
  					const groupMaterial = material[ group.materialIndex ];

  					const start = Math.max( group.start, drawRange.start );
  					const end = Math.min( position.count, Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) ) );

  					for ( let j = start, jl = end; j < jl; j += 3 ) {

  						const a = j;
  						const b = j + 1;
  						const c = j + 2;

  						intersection = checkGeometryIntersection( this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c );

  						if ( intersection ) {

  							intersection.faceIndex = Math.floor( j / 3 ); // triangle number in non-indexed buffer semantics
  							intersection.face.materialIndex = group.materialIndex;
  							intersects.push( intersection );

  						}

  					}

  				}

  			} else {

  				const start = Math.max( 0, drawRange.start );
  				const end = Math.min( position.count, ( drawRange.start + drawRange.count ) );

  				for ( let i = start, il = end; i < il; i += 3 ) {

  					const a = i;
  					const b = i + 1;
  					const c = i + 2;

  					intersection = checkGeometryIntersection( this, material, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c );

  					if ( intersection ) {

  						intersection.faceIndex = Math.floor( i / 3 ); // triangle number in non-indexed buffer semantics
  						intersects.push( intersection );

  					}

  				}

  			}

  		}

  	}

  }

  function checkIntersection$1( object, material, raycaster, ray, pA, pB, pC, point ) {

  	let intersect;

  	if ( material.side === BackSide ) {

  		intersect = ray.intersectTriangle( pC, pB, pA, true, point );

  	} else {

  		intersect = ray.intersectTriangle( pA, pB, pC, ( material.side === FrontSide ), point );

  	}

  	if ( intersect === null ) return null;

  	_intersectionPointWorld.copy( point );
  	_intersectionPointWorld.applyMatrix4( object.matrixWorld );

  	const distance = raycaster.ray.origin.distanceTo( _intersectionPointWorld );

  	if ( distance < raycaster.near || distance > raycaster.far ) return null;

  	return {
  		distance: distance,
  		point: _intersectionPointWorld.clone(),
  		object: object
  	};

  }

  function checkGeometryIntersection( object, material, raycaster, ray, uv, uv1, normal, a, b, c ) {

  	object.getVertexPosition( a, _vA$1 );
  	object.getVertexPosition( b, _vB$1 );
  	object.getVertexPosition( c, _vC$1 );

  	const intersection = checkIntersection$1( object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint );

  	if ( intersection ) {

  		if ( uv ) {

  			_uvA$1.fromBufferAttribute( uv, a );
  			_uvB$1.fromBufferAttribute( uv, b );
  			_uvC$1.fromBufferAttribute( uv, c );

  			intersection.uv = Triangle.getInterpolation( _intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2() );

  		}

  		if ( uv1 ) {

  			_uvA$1.fromBufferAttribute( uv1, a );
  			_uvB$1.fromBufferAttribute( uv1, b );
  			_uvC$1.fromBufferAttribute( uv1, c );

  			intersection.uv1 = Triangle.getInterpolation( _intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2() );

  		}

  		if ( normal ) {

  			_normalA.fromBufferAttribute( normal, a );
  			_normalB.fromBufferAttribute( normal, b );
  			_normalC.fromBufferAttribute( normal, c );

  			intersection.normal = Triangle.getInterpolation( _intersectionPoint, _vA$1, _vB$1, _vC$1, _normalA, _normalB, _normalC, new Vector3() );

  			if ( intersection.normal.dot( ray.direction ) > 0 ) {

  				intersection.normal.multiplyScalar( - 1 );

  			}

  		}

  		const face = {
  			a: a,
  			b: b,
  			c: c,
  			normal: new Vector3(),
  			materialIndex: 0
  		};

  		Triangle.getNormal( _vA$1, _vB$1, _vC$1, face.normal );

  		intersection.face = face;

  	}

  	return intersection;

  }

  class BoxGeometry extends BufferGeometry {

  	constructor( width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1 ) {

  		super();

  		this.type = 'BoxGeometry';

  		this.parameters = {
  			width: width,
  			height: height,
  			depth: depth,
  			widthSegments: widthSegments,
  			heightSegments: heightSegments,
  			depthSegments: depthSegments
  		};

  		const scope = this;

  		// segments

  		widthSegments = Math.floor( widthSegments );
  		heightSegments = Math.floor( heightSegments );
  		depthSegments = Math.floor( depthSegments );

  		// buffers

  		const indices = [];
  		const vertices = [];
  		const normals = [];
  		const uvs = [];

  		// helper variables

  		let numberOfVertices = 0;
  		let groupStart = 0;

  		// build each side of the box geometry

  		buildPlane( 'z', 'y', 'x', - 1, - 1, depth, height, width, depthSegments, heightSegments, 0 ); // px
  		buildPlane( 'z', 'y', 'x', 1, - 1, depth, height, - width, depthSegments, heightSegments, 1 ); // nx
  		buildPlane( 'x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2 ); // py
  		buildPlane( 'x', 'z', 'y', 1, - 1, width, depth, - height, widthSegments, depthSegments, 3 ); // ny
  		buildPlane( 'x', 'y', 'z', 1, - 1, width, height, depth, widthSegments, heightSegments, 4 ); // pz
  		buildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth, widthSegments, heightSegments, 5 ); // nz

  		// build geometry

  		this.setIndex( indices );
  		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
  		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

  		function buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {

  			const segmentWidth = width / gridX;
  			const segmentHeight = height / gridY;

  			const widthHalf = width / 2;
  			const heightHalf = height / 2;
  			const depthHalf = depth / 2;

  			const gridX1 = gridX + 1;
  			const gridY1 = gridY + 1;

  			let vertexCounter = 0;
  			let groupCount = 0;

  			const vector = new Vector3();

  			// generate vertices, normals and uvs

  			for ( let iy = 0; iy < gridY1; iy ++ ) {

  				const y = iy * segmentHeight - heightHalf;

  				for ( let ix = 0; ix < gridX1; ix ++ ) {

  					const x = ix * segmentWidth - widthHalf;

  					// set values to correct vector component

  					vector[ u ] = x * udir;
  					vector[ v ] = y * vdir;
  					vector[ w ] = depthHalf;

  					// now apply vector to vertex buffer

  					vertices.push( vector.x, vector.y, vector.z );

  					// set values to correct vector component

  					vector[ u ] = 0;
  					vector[ v ] = 0;
  					vector[ w ] = depth > 0 ? 1 : - 1;

  					// now apply vector to normal buffer

  					normals.push( vector.x, vector.y, vector.z );

  					// uvs

  					uvs.push( ix / gridX );
  					uvs.push( 1 - ( iy / gridY ) );

  					// counters

  					vertexCounter += 1;

  				}

  			}

  			// indices

  			// 1. you need three indices to draw a single face
  			// 2. a single segment consists of two faces
  			// 3. so we need to generate six (2*3) indices per segment

  			for ( let iy = 0; iy < gridY; iy ++ ) {

  				for ( let ix = 0; ix < gridX; ix ++ ) {

  					const a = numberOfVertices + ix + gridX1 * iy;
  					const b = numberOfVertices + ix + gridX1 * ( iy + 1 );
  					const c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );
  					const d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;

  					// faces

  					indices.push( a, b, d );
  					indices.push( b, c, d );

  					// increase counter

  					groupCount += 6;

  				}

  			}

  			// add a group to the geometry. this will ensure multi material support

  			scope.addGroup( groupStart, groupCount, materialIndex );

  			// calculate new start value for groups

  			groupStart += groupCount;

  			// update total number of vertices

  			numberOfVertices += vertexCounter;

  		}

  	}

  	copy( source ) {

  		super.copy( source );

  		this.parameters = Object.assign( {}, source.parameters );

  		return this;

  	}

  	static fromJSON( data ) {

  		return new BoxGeometry( data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments );

  	}

  }

  /**
   * Uniform Utilities
   */

  function cloneUniforms( src ) {

  	const dst = {};

  	for ( const u in src ) {

  		dst[ u ] = {};

  		for ( const p in src[ u ] ) {

  			const property = src[ u ][ p ];

  			if ( property && ( property.isColor ||
  				property.isMatrix3 || property.isMatrix4 ||
  				property.isVector2 || property.isVector3 || property.isVector4 ||
  				property.isTexture || property.isQuaternion ) ) {

  				if ( property.isRenderTargetTexture ) {

  					console.warn( 'UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms().' );
  					dst[ u ][ p ] = null;

  				} else {

  					dst[ u ][ p ] = property.clone();

  				}

  			} else if ( Array.isArray( property ) ) {

  				dst[ u ][ p ] = property.slice();

  			} else {

  				dst[ u ][ p ] = property;

  			}

  		}

  	}

  	return dst;

  }

  function mergeUniforms( uniforms ) {

  	const merged = {};

  	for ( let u = 0; u < uniforms.length; u ++ ) {

  		const tmp = cloneUniforms( uniforms[ u ] );

  		for ( const p in tmp ) {

  			merged[ p ] = tmp[ p ];

  		}

  	}

  	return merged;

  }

  function cloneUniformsGroups( src ) {

  	const dst = [];

  	for ( let u = 0; u < src.length; u ++ ) {

  		dst.push( src[ u ].clone() );

  	}

  	return dst;

  }

  function getUnlitUniformColorSpace( renderer ) {

  	const currentRenderTarget = renderer.getRenderTarget();

  	if ( currentRenderTarget === null ) {

  		// https://github.com/mrdoob/three.js/pull/23937#issuecomment-1111067398
  		return renderer.outputColorSpace;

  	}

  	// https://github.com/mrdoob/three.js/issues/27868
  	if ( currentRenderTarget.isXRRenderTarget === true ) {

  		return currentRenderTarget.texture.colorSpace;

  	}

  	return ColorManagement.workingColorSpace;

  }

  // Legacy

  const UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };

  var default_vertex = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";

  var default_fragment = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";

  class ShaderMaterial extends Material {

  	constructor( parameters ) {

  		super();

  		this.isShaderMaterial = true;

  		this.type = 'ShaderMaterial';

  		this.defines = {};
  		this.uniforms = {};
  		this.uniformsGroups = [];

  		this.vertexShader = default_vertex;
  		this.fragmentShader = default_fragment;

  		this.linewidth = 1;

  		this.wireframe = false;
  		this.wireframeLinewidth = 1;

  		this.fog = false; // set to use scene fog
  		this.lights = false; // set to use scene lights
  		this.clipping = false; // set to use user-defined clipping planes

  		this.forceSinglePass = true;

  		this.extensions = {
  			clipCullDistance: false, // set to use vertex shader clipping
  			multiDraw: false // set to use vertex shader multi_draw / enable gl_DrawID
  		};

  		// When rendered geometry doesn't include these attributes but the material does,
  		// use these default values in WebGL. This avoids errors when buffer data is missing.
  		this.defaultAttributeValues = {
  			'color': [ 1, 1, 1 ],
  			'uv': [ 0, 0 ],
  			'uv1': [ 0, 0 ]
  		};

  		this.index0AttributeName = undefined;
  		this.uniformsNeedUpdate = false;

  		this.glslVersion = null;

  		if ( parameters !== undefined ) {

  			this.setValues( parameters );

  		}

  	}

  	copy( source ) {

  		super.copy( source );

  		this.fragmentShader = source.fragmentShader;
  		this.vertexShader = source.vertexShader;

  		this.uniforms = cloneUniforms( source.uniforms );
  		this.uniformsGroups = cloneUniformsGroups( source.uniformsGroups );

  		this.defines = Object.assign( {}, source.defines );

  		this.wireframe = source.wireframe;
  		this.wireframeLinewidth = source.wireframeLinewidth;

  		this.fog = source.fog;
  		this.lights = source.lights;
  		this.clipping = source.clipping;

  		this.extensions = Object.assign( {}, source.extensions );

  		this.glslVersion = source.glslVersion;

  		return this;

  	}

  	toJSON( meta ) {

  		const data = super.toJSON( meta );

  		data.glslVersion = this.glslVersion;
  		data.uniforms = {};

  		for ( const name in this.uniforms ) {

  			const uniform = this.uniforms[ name ];
  			const value = uniform.value;

  			if ( value && value.isTexture ) {

  				data.uniforms[ name ] = {
  					type: 't',
  					value: value.toJSON( meta ).uuid
  				};

  			} else if ( value && value.isColor ) {

  				data.uniforms[ name ] = {
  					type: 'c',
  					value: value.getHex()
  				};

  			} else if ( value && value.isVector2 ) {

  				data.uniforms[ name ] = {
  					type: 'v2',
  					value: value.toArray()
  				};

  			} else if ( value && value.isVector3 ) {

  				data.uniforms[ name ] = {
  					type: 'v3',
  					value: value.toArray()
  				};

  			} else if ( value && value.isVector4 ) {

  				data.uniforms[ name ] = {
  					type: 'v4',
  					value: value.toArray()
  				};

  			} else if ( value && value.isMatrix3 ) {

  				data.uniforms[ name ] = {
  					type: 'm3',
  					value: value.toArray()
  				};

  			} else if ( value && value.isMatrix4 ) {

  				data.uniforms[ name ] = {
  					type: 'm4',
  					value: value.toArray()
  				};

  			} else {

  				data.uniforms[ name ] = {
  					value: value
  				};

  				// note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far

  			}

  		}

  		if ( Object.keys( this.defines ).length > 0 ) data.defines = this.defines;

  		data.vertexShader = this.vertexShader;
  		data.fragmentShader = this.fragmentShader;

  		data.lights = this.lights;
  		data.clipping = this.clipping;

  		const extensions = {};

  		for ( const key in this.extensions ) {

  			if ( this.extensions[ key ] === true ) extensions[ key ] = true;

  		}

  		if ( Object.keys( extensions ).length > 0 ) data.extensions = extensions;

  		return data;

  	}

  }

  class Camera extends Object3D {

  	constructor() {

  		super();

  		this.isCamera = true;

  		this.type = 'Camera';

  		this.matrixWorldInverse = new Matrix4();

  		this.projectionMatrix = new Matrix4();
  		this.projectionMatrixInverse = new Matrix4();

  		this.coordinateSystem = WebGLCoordinateSystem;

  	}

  	copy( source, recursive ) {

  		super.copy( source, recursive );

  		this.matrixWorldInverse.copy( source.matrixWorldInverse );

  		this.projectionMatrix.copy( source.projectionMatrix );
  		this.projectionMatrixInverse.copy( source.projectionMatrixInverse );

  		this.coordinateSystem = source.coordinateSystem;

  		return this;

  	}

  	getWorldDirection( target ) {

  		return super.getWorldDirection( target ).negate();

  	}

  	updateMatrixWorld( force ) {

  		super.updateMatrixWorld( force );

  		this.matrixWorldInverse.copy( this.matrixWorld ).invert();

  	}

  	updateWorldMatrix( updateParents, updateChildren ) {

  		super.updateWorldMatrix( updateParents, updateChildren );

  		this.matrixWorldInverse.copy( this.matrixWorld ).invert();

  	}

  	clone() {

  		return new this.constructor().copy( this );

  	}

  }

  const _v3$1 = /*@__PURE__*/ new Vector3();
  const _minTarget = /*@__PURE__*/ new Vector2();
  const _maxTarget = /*@__PURE__*/ new Vector2();


  class PerspectiveCamera extends Camera {

  	constructor( fov = 50, aspect = 1, near = 0.1, far = 2000 ) {

  		super();

  		this.isPerspectiveCamera = true;

  		this.type = 'PerspectiveCamera';

  		this.fov = fov;
  		this.zoom = 1;

  		this.near = near;
  		this.far = far;
  		this.focus = 10;

  		this.aspect = aspect;
  		this.view = null;

  		this.filmGauge = 35;	// width of the film (default in millimeters)
  		this.filmOffset = 0;	// horizontal film offset (same unit as gauge)

  		this.updateProjectionMatrix();

  	}

  	copy( source, recursive ) {

  		super.copy( source, recursive );

  		this.fov = source.fov;
  		this.zoom = source.zoom;

  		this.near = source.near;
  		this.far = source.far;
  		this.focus = source.focus;

  		this.aspect = source.aspect;
  		this.view = source.view === null ? null : Object.assign( {}, source.view );

  		this.filmGauge = source.filmGauge;
  		this.filmOffset = source.filmOffset;

  		return this;

  	}

  	/**
  	 * Sets the FOV by focal length in respect to the current .filmGauge.
  	 *
  	 * The default film gauge is 35, so that the focal length can be specified for
  	 * a 35mm (full frame) camera.
  	 *
  	 * Values for focal length and film gauge must have the same unit.
  	 */
  	setFocalLength( focalLength ) {

  		/** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */
  		const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;

  		this.fov = RAD2DEG$1 * 2 * Math.atan( vExtentSlope );
  		this.updateProjectionMatrix();

  	}

  	/**
  	 * Calculates the focal length from the current .fov and .filmGauge.
  	 */
  	getFocalLength() {

  		const vExtentSlope = Math.tan( DEG2RAD * 0.5 * this.fov );

  		return 0.5 * this.getFilmHeight() / vExtentSlope;

  	}

  	getEffectiveFOV() {

  		return RAD2DEG$1 * 2 * Math.atan(
  			Math.tan( DEG2RAD * 0.5 * this.fov ) / this.zoom );

  	}

  	getFilmWidth() {

  		// film not completely covered in portrait format (aspect < 1)
  		return this.filmGauge * Math.min( this.aspect, 1 );

  	}

  	getFilmHeight() {

  		// film not completely covered in landscape format (aspect > 1)
  		return this.filmGauge / Math.max( this.aspect, 1 );

  	}

  	/**
  	 * Computes the 2D bounds of the camera's viewable rectangle at a given distance along the viewing direction.
  	 * Sets minTarget and maxTarget to the coordinates of the lower-left and upper-right corners of the view rectangle.
  	 */
  	getViewBounds( distance, minTarget, maxTarget ) {

  		_v3$1.set( - 1, - 1, 0.5 ).applyMatrix4( this.projectionMatrixInverse );

  		minTarget.set( _v3$1.x, _v3$1.y ).multiplyScalar( - distance / _v3$1.z );

  		_v3$1.set( 1, 1, 0.5 ).applyMatrix4( this.projectionMatrixInverse );

  		maxTarget.set( _v3$1.x, _v3$1.y ).multiplyScalar( - distance / _v3$1.z );

  	}

  	/**
  	 * Computes the width and height of the camera's viewable rectangle at a given distance along the viewing direction.
  	 * Copies the result into the target Vector2, where x is width and y is height.
  	 */
  	getViewSize( distance, target ) {

  		this.getViewBounds( distance, _minTarget, _maxTarget );

  		return target.subVectors( _maxTarget, _minTarget );

  	}

  	/**
  	 * Sets an offset in a larger frustum. This is useful for multi-window or
  	 * multi-monitor/multi-machine setups.
  	 *
  	 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
  	 * the monitors are in grid like this
  	 *
  	 *   +---+---+---+
  	 *   | A | B | C |
  	 *   +---+---+---+
  	 *   | D | E | F |
  	 *   +---+---+---+
  	 *
  	 * then for each monitor you would call it like this
  	 *
  	 *   const w = 1920;
  	 *   const h = 1080;
  	 *   const fullWidth = w * 3;
  	 *   const fullHeight = h * 2;
  	 *
  	 *   --A--
  	 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
  	 *   --B--
  	 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
  	 *   --C--
  	 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
  	 *   --D--
  	 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
  	 *   --E--
  	 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
  	 *   --F--
  	 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
  	 *
  	 *   Note there is no reason monitors have to be the same size or in a grid.
  	 */
  	setViewOffset( fullWidth, fullHeight, x, y, width, height ) {

  		this.aspect = fullWidth / fullHeight;

  		if ( this.view === null ) {

  			this.view = {
  				enabled: true,
  				fullWidth: 1,
  				fullHeight: 1,
  				offsetX: 0,
  				offsetY: 0,
  				width: 1,
  				height: 1
  			};

  		}

  		this.view.enabled = true;
  		this.view.fullWidth = fullWidth;
  		this.view.fullHeight = fullHeight;
  		this.view.offsetX = x;
  		this.view.offsetY = y;
  		this.view.width = width;
  		this.view.height = height;

  		this.updateProjectionMatrix();

  	}

  	clearViewOffset() {

  		if ( this.view !== null ) {

  			this.view.enabled = false;

  		}

  		this.updateProjectionMatrix();

  	}

  	updateProjectionMatrix() {

  		const near = this.near;
  		let top = near * Math.tan( DEG2RAD * 0.5 * this.fov ) / this.zoom;
  		let height = 2 * top;
  		let width = this.aspect * height;
  		let left = - 0.5 * width;
  		const view = this.view;

  		if ( this.view !== null && this.view.enabled ) {

  			const fullWidth = view.fullWidth,
  				fullHeight = view.fullHeight;

  			left += view.offsetX * width / fullWidth;
  			top -= view.offsetY * height / fullHeight;
  			width *= view.width / fullWidth;
  			height *= view.height / fullHeight;

  		}

  		const skew = this.filmOffset;
  		if ( skew !== 0 ) left += near * skew / this.getFilmWidth();

  		this.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far, this.coordinateSystem );

  		this.projectionMatrixInverse.copy( this.projectionMatrix ).invert();

  	}

  	toJSON( meta ) {

  		const data = super.toJSON( meta );

  		data.object.fov = this.fov;
  		data.object.zoom = this.zoom;

  		data.object.near = this.near;
  		data.object.far = this.far;
  		data.object.focus = this.focus;

  		data.object.aspect = this.aspect;

  		if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

  		data.object.filmGauge = this.filmGauge;
  		data.object.filmOffset = this.filmOffset;

  		return data;

  	}

  }

  const fov = - 90; // negative fov is not an error
  const aspect = 1;

  class CubeCamera extends Object3D {

  	constructor( near, far, renderTarget ) {

  		super();

  		this.type = 'CubeCamera';

  		this.renderTarget = renderTarget;
  		this.coordinateSystem = null;
  		this.activeMipmapLevel = 0;

  		const cameraPX = new PerspectiveCamera( fov, aspect, near, far );
  		cameraPX.layers = this.layers;
  		this.add( cameraPX );

  		const cameraNX = new PerspectiveCamera( fov, aspect, near, far );
  		cameraNX.layers = this.layers;
  		this.add( cameraNX );

  		const cameraPY = new PerspectiveCamera( fov, aspect, near, far );
  		cameraPY.layers = this.layers;
  		this.add( cameraPY );

  		const cameraNY = new PerspectiveCamera( fov, aspect, near, far );
  		cameraNY.layers = this.layers;
  		this.add( cameraNY );

  		const cameraPZ = new PerspectiveCamera( fov, aspect, near, far );
  		cameraPZ.layers = this.layers;
  		this.add( cameraPZ );

  		const cameraNZ = new PerspectiveCamera( fov, aspect, near, far );
  		cameraNZ.layers = this.layers;
  		this.add( cameraNZ );

  	}

  	updateCoordinateSystem() {

  		const coordinateSystem = this.coordinateSystem;

  		const cameras = this.children.concat();

  		const [ cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ ] = cameras;

  		for ( const camera of cameras ) this.remove( camera );

  		if ( coordinateSystem === WebGLCoordinateSystem ) {

  			cameraPX.up.set( 0, 1, 0 );
  			cameraPX.lookAt( 1, 0, 0 );

  			cameraNX.up.set( 0, 1, 0 );
  			cameraNX.lookAt( - 1, 0, 0 );

  			cameraPY.up.set( 0, 0, - 1 );
  			cameraPY.lookAt( 0, 1, 0 );

  			cameraNY.up.set( 0, 0, 1 );
  			cameraNY.lookAt( 0, - 1, 0 );

  			cameraPZ.up.set( 0, 1, 0 );
  			cameraPZ.lookAt( 0, 0, 1 );

  			cameraNZ.up.set( 0, 1, 0 );
  			cameraNZ.lookAt( 0, 0, - 1 );

  		} else if ( coordinateSystem === WebGPUCoordinateSystem ) {

  			cameraPX.up.set( 0, - 1, 0 );
  			cameraPX.lookAt( - 1, 0, 0 );

  			cameraNX.up.set( 0, - 1, 0 );
  			cameraNX.lookAt( 1, 0, 0 );

  			cameraPY.up.set( 0, 0, 1 );
  			cameraPY.lookAt( 0, 1, 0 );

  			cameraNY.up.set( 0, 0, - 1 );
  			cameraNY.lookAt( 0, - 1, 0 );

  			cameraPZ.up.set( 0, - 1, 0 );
  			cameraPZ.lookAt( 0, 0, 1 );

  			cameraNZ.up.set( 0, - 1, 0 );
  			cameraNZ.lookAt( 0, 0, - 1 );

  		} else {

  			throw new Error( 'THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: ' + coordinateSystem );

  		}

  		for ( const camera of cameras ) {

  			this.add( camera );

  			camera.updateMatrixWorld();

  		}

  	}

  	update( renderer, scene ) {

  		if ( this.parent === null ) this.updateMatrixWorld();

  		const { renderTarget, activeMipmapLevel } = this;

  		if ( this.coordinateSystem !== renderer.coordinateSystem ) {

  			this.coordinateSystem = renderer.coordinateSystem;

  			this.updateCoordinateSystem();

  		}

  		const [ cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ ] = this.children;

  		const currentRenderTarget = renderer.getRenderTarget();
  		const currentActiveCubeFace = renderer.getActiveCubeFace();
  		const currentActiveMipmapLevel = renderer.getActiveMipmapLevel();

  		const currentXrEnabled = renderer.xr.enabled;

  		renderer.xr.enabled = false;

  		const generateMipmaps = renderTarget.texture.generateMipmaps;

  		renderTarget.texture.generateMipmaps = false;

  		renderer.setRenderTarget( renderTarget, 0, activeMipmapLevel );
  		renderer.render( scene, cameraPX );

  		renderer.setRenderTarget( renderTarget, 1, activeMipmapLevel );
  		renderer.render( scene, cameraNX );

  		renderer.setRenderTarget( renderTarget, 2, activeMipmapLevel );
  		renderer.render( scene, cameraPY );

  		renderer.setRenderTarget( renderTarget, 3, activeMipmapLevel );
  		renderer.render( scene, cameraNY );

  		renderer.setRenderTarget( renderTarget, 4, activeMipmapLevel );
  		renderer.render( scene, cameraPZ );

  		// mipmaps are generated during the last call of render()
  		// at this point, all sides of the cube render target are defined

  		renderTarget.texture.generateMipmaps = generateMipmaps;

  		renderer.setRenderTarget( renderTarget, 5, activeMipmapLevel );
  		renderer.render( scene, cameraNZ );

  		renderer.setRenderTarget( currentRenderTarget, currentActiveCubeFace, currentActiveMipmapLevel );

  		renderer.xr.enabled = currentXrEnabled;

  		renderTarget.texture.needsPMREMUpdate = true;

  	}

  }

  class CubeTexture extends Texture {

  	constructor( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace ) {

  		images = images !== undefined ? images : [];
  		mapping = mapping !== undefined ? mapping : CubeReflectionMapping;

  		super( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace );

  		this.isCubeTexture = true;

  		this.flipY = false;

  	}

  	get images() {

  		return this.image;

  	}

  	set images( value ) {

  		this.image = value;

  	}

  }

  class WebGLCubeRenderTarget extends WebGLRenderTarget {

  	constructor( size = 1, options = {} ) {

  		super( size, size, options );

  		this.isWebGLCubeRenderTarget = true;

  		const image = { width: size, height: size, depth: 1 };
  		const images = [ image, image, image, image, image, image ];

  		this.texture = new CubeTexture( images, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.colorSpace );

  		// By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)
  		// in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,
  		// in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.

  		// three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped
  		// and the flag isRenderTargetTexture controls this conversion. The flip is not required when using WebGLCubeRenderTarget.texture
  		// as a cube texture (this is detected when isRenderTargetTexture is set to true for cube textures).

  		this.texture.isRenderTargetTexture = true;

  		this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
  		this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;

  	}

  	fromEquirectangularTexture( renderer, texture ) {

  		this.texture.type = texture.type;
  		this.texture.colorSpace = texture.colorSpace;

  		this.texture.generateMipmaps = texture.generateMipmaps;
  		this.texture.minFilter = texture.minFilter;
  		this.texture.magFilter = texture.magFilter;

  		const shader = {

  			uniforms: {
  				tEquirect: { value: null },
  			},

  			vertexShader: /* glsl */`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,

  			fragmentShader: /* glsl */`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
  		};

  		const geometry = new BoxGeometry( 5, 5, 5 );

  		const material = new ShaderMaterial( {

  			name: 'CubemapFromEquirect',

  			uniforms: cloneUniforms( shader.uniforms ),
  			vertexShader: shader.vertexShader,
  			fragmentShader: shader.fragmentShader,
  			side: BackSide,
  			blending: NoBlending

  		} );

  		material.uniforms.tEquirect.value = texture;

  		const mesh = new Mesh( geometry, material );

  		const currentMinFilter = texture.minFilter;

  		// Avoid blurred poles
  		if ( texture.minFilter === LinearMipmapLinearFilter ) texture.minFilter = LinearFilter;

  		const camera = new CubeCamera( 1, 10, this );
  		camera.update( renderer, mesh );

  		texture.minFilter = currentMinFilter;

  		mesh.geometry.dispose();
  		mesh.material.dispose();

  		return this;

  	}

  	clear( renderer, color, depth, stencil ) {

  		const currentRenderTarget = renderer.getRenderTarget();

  		for ( let i = 0; i < 6; i ++ ) {

  			renderer.setRenderTarget( this, i );

  			renderer.clear( color, depth, stencil );

  		}

  		renderer.setRenderTarget( currentRenderTarget );

  	}

  }

  const _vector1 = /*@__PURE__*/ new Vector3();
  const _vector2 = /*@__PURE__*/ new Vector3();
  const _normalMatrix = /*@__PURE__*/ new Matrix3();

  class Plane {

  	constructor( normal = new Vector3( 1, 0, 0 ), constant = 0 ) {

  		this.isPlane = true;

  		// normal is assumed to be normalized

  		this.normal = normal;
  		this.constant = constant;

  	}

  	set( normal, constant ) {

  		this.normal.copy( normal );
  		this.constant = constant;

  		return this;

  	}

  	setComponents( x, y, z, w ) {

  		this.normal.set( x, y, z );
  		this.constant = w;

  		return this;

  	}

  	setFromNormalAndCoplanarPoint( normal, point ) {

  		this.normal.copy( normal );
  		this.constant = - point.dot( this.normal );

  		return this;

  	}

  	setFromCoplanarPoints( a, b, c ) {

  		const normal = _vector1.subVectors( c, b ).cross( _vector2.subVectors( a, b ) ).normalize();

  		// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

  		this.setFromNormalAndCoplanarPoint( normal, a );

  		return this;

  	}

  	copy( plane ) {

  		this.normal.copy( plane.normal );
  		this.constant = plane.constant;

  		return this;

  	}

  	normalize() {

  		// Note: will lead to a divide by zero if the plane is invalid.

  		const inverseNormalLength = 1.0 / this.normal.length();
  		this.normal.multiplyScalar( inverseNormalLength );
  		this.constant *= inverseNormalLength;

  		return this;

  	}

  	negate() {

  		this.constant *= - 1;
  		this.normal.negate();

  		return this;

  	}

  	distanceToPoint( point ) {

  		return this.normal.dot( point ) + this.constant;

  	}

  	distanceToSphere( sphere ) {

  		return this.distanceToPoint( sphere.center ) - sphere.radius;

  	}

  	projectPoint( point, target ) {

  		return target.copy( point ).addScaledVector( this.normal, - this.distanceToPoint( point ) );

  	}

  	intersectLine( line, target ) {

  		const direction = line.delta( _vector1 );

  		const denominator = this.normal.dot( direction );

  		if ( denominator === 0 ) {

  			// line is coplanar, return origin
  			if ( this.distanceToPoint( line.start ) === 0 ) {

  				return target.copy( line.start );

  			}

  			// Unsure if this is the correct method to handle this case.
  			return null;

  		}

  		const t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

  		if ( t < 0 || t > 1 ) {

  			return null;

  		}

  		return target.copy( line.start ).addScaledVector( direction, t );

  	}

  	intersectsLine( line ) {

  		// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

  		const startSign = this.distanceToPoint( line.start );
  		const endSign = this.distanceToPoint( line.end );

  		return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

  	}

  	intersectsBox( box ) {

  		return box.intersectsPlane( this );

  	}

  	intersectsSphere( sphere ) {

  		return sphere.intersectsPlane( this );

  	}

  	coplanarPoint( target ) {

  		return target.copy( this.normal ).multiplyScalar( - this.constant );

  	}

  	applyMatrix4( matrix, optionalNormalMatrix ) {

  		const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix( matrix );

  		const referencePoint = this.coplanarPoint( _vector1 ).applyMatrix4( matrix );

  		const normal = this.normal.applyMatrix3( normalMatrix ).normalize();

  		this.constant = - referencePoint.dot( normal );

  		return this;

  	}

  	translate( offset ) {

  		this.constant -= offset.dot( this.normal );

  		return this;

  	}

  	equals( plane ) {

  		return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );

  	}

  	clone() {

  		return new this.constructor().copy( this );

  	}

  }

  const _sphere$5 = /*@__PURE__*/ new Sphere();
  const _vector$7 = /*@__PURE__*/ new Vector3();

  class Frustum {

  	constructor( p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane() ) {

  		this.planes = [ p0, p1, p2, p3, p4, p5 ];

  	}

  	set( p0, p1, p2, p3, p4, p5 ) {

  		const planes = this.planes;

  		planes[ 0 ].copy( p0 );
  		planes[ 1 ].copy( p1 );
  		planes[ 2 ].copy( p2 );
  		planes[ 3 ].copy( p3 );
  		planes[ 4 ].copy( p4 );
  		planes[ 5 ].copy( p5 );

  		return this;

  	}

  	copy( frustum ) {

  		const planes = this.planes;

  		for ( let i = 0; i < 6; i ++ ) {

  			planes[ i ].copy( frustum.planes[ i ] );

  		}

  		return this;

  	}

  	setFromProjectionMatrix( m, coordinateSystem = WebGLCoordinateSystem ) {

  		const planes = this.planes;
  		const me = m.elements;
  		const me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
  		const me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
  		const me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
  		const me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

  		planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
  		planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
  		planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
  		planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
  		planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();

  		if ( coordinateSystem === WebGLCoordinateSystem ) {

  			planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

  		} else if ( coordinateSystem === WebGPUCoordinateSystem ) {

  			planes[ 5 ].setComponents( me2, me6, me10, me14 ).normalize();

  		} else {

  			throw new Error( 'THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: ' + coordinateSystem );

  		}

  		return this;

  	}

  	intersectsObject( object ) {

  		if ( object.boundingSphere !== undefined ) {

  			if ( object.boundingSphere === null ) object.computeBoundingSphere();

  			_sphere$5.copy( object.boundingSphere ).applyMatrix4( object.matrixWorld );

  		} else {

  			const geometry = object.geometry;

  			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

  			_sphere$5.copy( geometry.boundingSphere ).applyMatrix4( object.matrixWorld );

  		}

  		return this.intersectsSphere( _sphere$5 );

  	}

  	intersectsSprite( sprite ) {

  		_sphere$5.center.set( 0, 0, 0 );
  		_sphere$5.radius = 0.7071067811865476;
  		_sphere$5.applyMatrix4( sprite.matrixWorld );

  		return this.intersectsSphere( _sphere$5 );

  	}

  	intersectsSphere( sphere ) {

  		const planes = this.planes;
  		const center = sphere.center;
  		const negRadius = - sphere.radius;

  		for ( let i = 0; i < 6; i ++ ) {

  			const distance = planes[ i ].distanceToPoint( center );

  			if ( distance < negRadius ) {

  				return false;

  			}

  		}

  		return true;

  	}

  	intersectsBox( box ) {

  		const planes = this.planes;

  		for ( let i = 0; i < 6; i ++ ) {

  			const plane = planes[ i ];

  			// corner at max distance

  			_vector$7.x = plane.normal.x > 0 ? box.max.x : box.min.x;
  			_vector$7.y = plane.normal.y > 0 ? box.max.y : box.min.y;
  			_vector$7.z = plane.normal.z > 0 ? box.max.z : box.min.z;

  			if ( plane.distanceToPoint( _vector$7 ) < 0 ) {

  				return false;

  			}

  		}

  		return true;

  	}

  	containsPoint( point ) {

  		const planes = this.planes;

  		for ( let i = 0; i < 6; i ++ ) {

  			if ( planes[ i ].distanceToPoint( point ) < 0 ) {

  				return false;

  			}

  		}

  		return true;

  	}

  	clone() {

  		return new this.constructor().copy( this );

  	}

  }

  function WebGLAnimation() {

  	let context = null;
  	let isAnimating = false;
  	let animationLoop = null;
  	let requestId = null;

  	function onAnimationFrame( time, frame ) {

  		animationLoop( time, frame );

  		requestId = context.requestAnimationFrame( onAnimationFrame );

  	}

  	return {

  		start: function () {

  			if ( isAnimating === true ) return;
  			if ( animationLoop === null ) return;

  			requestId = context.requestAnimationFrame( onAnimationFrame );

  			isAnimating = true;

  		},

  		stop: function () {

  			context.cancelAnimationFrame( requestId );

  			isAnimating = false;

  		},

  		setAnimationLoop: function ( callback ) {

  			animationLoop = callback;

  		},

  		setContext: function ( value ) {

  			context = value;

  		}

  	};

  }

  function WebGLAttributes( gl ) {

  	const buffers = new WeakMap();

  	function createBuffer( attribute, bufferType ) {

  		const array = attribute.array;
  		const usage = attribute.usage;
  		const size = array.byteLength;

  		const buffer = gl.createBuffer();

  		gl.bindBuffer( bufferType, buffer );
  		gl.bufferData( bufferType, array, usage );

  		attribute.onUploadCallback();

  		let type;

  		if ( array instanceof Float32Array ) {

  			type = gl.FLOAT;

  		} else if ( array instanceof Uint16Array ) {

  			if ( attribute.isFloat16BufferAttribute ) {

  				type = gl.HALF_FLOAT;

  			} else {

  				type = gl.UNSIGNED_SHORT;

  			}

  		} else if ( array instanceof Int16Array ) {

  			type = gl.SHORT;

  		} else if ( array instanceof Uint32Array ) {

  			type = gl.UNSIGNED_INT;

  		} else if ( array instanceof Int32Array ) {

  			type = gl.INT;

  		} else if ( array instanceof Int8Array ) {

  			type = gl.BYTE;

  		} else if ( array instanceof Uint8Array ) {

  			type = gl.UNSIGNED_BYTE;

  		} else if ( array instanceof Uint8ClampedArray ) {

  			type = gl.UNSIGNED_BYTE;

  		} else {

  			throw new Error( 'THREE.WebGLAttributes: Unsupported buffer data format: ' + array );

  		}

  		return {
  			buffer: buffer,
  			type: type,
  			bytesPerElement: array.BYTES_PER_ELEMENT,
  			version: attribute.version,
  			size: size
  		};

  	}

  	function updateBuffer( buffer, attribute, bufferType ) {

  		const array = attribute.array;
  		const updateRange = attribute._updateRange; // @deprecated, r159
  		const updateRanges = attribute.updateRanges;

  		gl.bindBuffer( bufferType, buffer );

  		if ( updateRange.count === - 1 && updateRanges.length === 0 ) {

  			// Not using update ranges
  			gl.bufferSubData( bufferType, 0, array );

  		}

  		if ( updateRanges.length !== 0 ) {

  			for ( let i = 0, l = updateRanges.length; i < l; i ++ ) {

  				const range = updateRanges[ i ];

  				gl.bufferSubData( bufferType, range.start * array.BYTES_PER_ELEMENT,
  					array, range.start, range.count );

  			}

  			attribute.clearUpdateRanges();

  		}

  		// @deprecated, r159
  		if ( updateRange.count !== - 1 ) {

  			gl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
  				array, updateRange.offset, updateRange.count );

  			updateRange.count = - 1; // reset range

  		}

  		attribute.onUploadCallback();

  	}

  	//

  	function get( attribute ) {

  		if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

  		return buffers.get( attribute );

  	}

  	function remove( attribute ) {

  		if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

  		const data = buffers.get( attribute );

  		if ( data ) {

  			gl.deleteBuffer( data.buffer );

  			buffers.delete( attribute );

  		}

  	}

  	function update( attribute, bufferType ) {

  		if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

  		if ( attribute.isGLBufferAttribute ) {

  			const cached = buffers.get( attribute );

  			if ( ! cached || cached.version < attribute.version ) {

  				buffers.set( attribute, {
  					buffer: attribute.buffer,
  					type: attribute.type,
  					bytesPerElement: attribute.elementSize,
  					version: attribute.version
  				} );

  			}

  			return;

  		}

  		const data = buffers.get( attribute );

  		if ( data === undefined ) {

  			buffers.set( attribute, createBuffer( attribute, bufferType ) );

  		} else if ( data.version < attribute.version ) {

  			if ( data.size !== attribute.array.byteLength ) {

  				throw new Error( 'THREE.WebGLAttributes: The size of the buffer attribute\'s array buffer does not match the original size. Resizing buffer attributes is not supported.' );

  			}

  			updateBuffer( data.buffer, attribute, bufferType );

  			data.version = attribute.version;

  		}

  	}

  	return {

  		get: get,
  		remove: remove,
  		update: update

  	};

  }

  class PlaneGeometry extends BufferGeometry {

  	constructor( width = 1, height = 1, widthSegments = 1, heightSegments = 1 ) {

  		super();

  		this.type = 'PlaneGeometry';

  		this.parameters = {
  			width: width,
  			height: height,
  			widthSegments: widthSegments,
  			heightSegments: heightSegments
  		};

  		const width_half = width / 2;
  		const height_half = height / 2;

  		const gridX = Math.floor( widthSegments );
  		const gridY = Math.floor( heightSegments );

  		const gridX1 = gridX + 1;
  		const gridY1 = gridY + 1;

  		const segment_width = width / gridX;
  		const segment_height = height / gridY;

  		//

  		const indices = [];
  		const vertices = [];
  		const normals = [];
  		const uvs = [];

  		for ( let iy = 0; iy < gridY1; iy ++ ) {

  			const y = iy * segment_height - height_half;

  			for ( let ix = 0; ix < gridX1; ix ++ ) {

  				const x = ix * segment_width - width_half;

  				vertices.push( x, - y, 0 );

  				normals.push( 0, 0, 1 );

  				uvs.push( ix / gridX );
  				uvs.push( 1 - ( iy / gridY ) );

  			}

  		}

  		for ( let iy = 0; iy < gridY; iy ++ ) {

  			for ( let ix = 0; ix < gridX; ix ++ ) {

  				const a = ix + gridX1 * iy;
  				const b = ix + gridX1 * ( iy + 1 );
  				const c = ( ix + 1 ) + gridX1 * ( iy + 1 );
  				const d = ( ix + 1 ) + gridX1 * iy;

  				indices.push( a, b, d );
  				indices.push( b, c, d );

  			}

  		}

  		this.setIndex( indices );
  		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
  		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

  	}

  	copy( source ) {

  		super.copy( source );

  		this.parameters = Object.assign( {}, source.parameters );

  		return this;

  	}

  	static fromJSON( data ) {

  		return new PlaneGeometry( data.width, data.height, data.widthSegments, data.heightSegments );

  	}

  }

  var alphahash_fragment = "#ifdef USE_ALPHAHASH\n\tif ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif";

  var alphahash_pars_fragment = "#ifdef USE_ALPHAHASH\n\tconst float ALPHA_HASH_SCALE = 0.05;\n\tfloat hash2D( vec2 value ) {\n\t\treturn fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n\t}\n\tfloat hash3D( vec3 value ) {\n\t\treturn hash2D( vec2( hash2D( value.xy ), value.z ) );\n\t}\n\tfloat getAlphaHashThreshold( vec3 position ) {\n\t\tfloat maxDeriv = max(\n\t\t\tlength( dFdx( position.xyz ) ),\n\t\t\tlength( dFdy( position.xyz ) )\n\t\t);\n\t\tfloat pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n\t\tvec2 pixScales = vec2(\n\t\t\texp2( floor( log2( pixScale ) ) ),\n\t\t\texp2( ceil( log2( pixScale ) ) )\n\t\t);\n\t\tvec2 alpha = vec2(\n\t\t\thash3D( floor( pixScales.x * position.xyz ) ),\n\t\t\thash3D( floor( pixScales.y * position.xyz ) )\n\t\t);\n\t\tfloat lerpFactor = fract( log2( pixScale ) );\n\t\tfloat x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n\t\tfloat a = min( lerpFactor, 1.0 - lerpFactor );\n\t\tvec3 cases = vec3(\n\t\t\tx * x / ( 2.0 * a * ( 1.0 - a ) ),\n\t\t\t( x - 0.5 * a ) / ( 1.0 - a ),\n\t\t\t1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n\t\t);\n\t\tfloat threshold = ( x < ( 1.0 - a ) )\n\t\t\t? ( ( x < a ) ? cases.x : cases.y )\n\t\t\t: cases.z;\n\t\treturn clamp( threshold , 1.0e-6, 1.0 );\n\t}\n#endif";

  var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif";

  var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";

  var alphatest_fragment = "#ifdef USE_ALPHATEST\n\t#ifdef ALPHA_TO_COVERAGE\n\tdiffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );\n\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\tif ( diffuseColor.a < alphaTest ) discard;\n\t#endif\n#endif";

  var alphatest_pars_fragment = "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif";

  var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_CLEARCOAT ) \n\t\tclearcoatSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_SHEEN ) \n\t\tsheenSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif";

  var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";

  var batching_pars_vertex = "#ifdef USE_BATCHING\n\t#if ! defined( GL_ANGLE_multi_draw )\n\t#define gl_DrawID _gl_DrawID\n\tuniform int _gl_DrawID;\n\t#endif\n\tuniform highp sampler2D batchingTexture;\n\tuniform highp usampler2D batchingIdTexture;\n\tmat4 getBatchingMatrix( const in float i ) {\n\t\tint size = textureSize( batchingTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n\tfloat getIndirectIndex( const in int i ) {\n\t\tint size = textureSize( batchingIdTexture, 0 ).x;\n\t\tint x = i % size;\n\t\tint y = i / size;\n\t\treturn float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );\n\t}\n#endif\n#ifdef USE_BATCHING_COLOR\n\tuniform sampler2D batchingColorTexture;\n\tvec3 getBatchingColor( const in float i ) {\n\t\tint size = textureSize( batchingColorTexture, 0 ).x;\n\t\tint j = int( i );\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\treturn texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;\n\t}\n#endif";

  var batching_vertex = "#ifdef USE_BATCHING\n\tmat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );\n#endif";

  var begin_vertex = "vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n\tvPosition = vec3( position );\n#endif";

  var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif";

  var bsdfs = "float G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n} // validated";

  var iridescence_fragment = "#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\treturn vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif";

  var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vBumpMapUv );\n\t\tvec2 dSTdy = dFdy( vBumpMapUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );\n\t\tvec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif";

  var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#ifdef ALPHA_TO_COVERAGE\n\t\tfloat distanceToPlane, distanceGradient;\n\t\tfloat clipOpacity = 1.0;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\tclipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\tif ( clipOpacity == 0.0 ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tfloat unionClipOpacity = 1.0;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\t\tunionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tclipOpacity *= 1.0 - unionClipOpacity;\n\t\t#endif\n\t\tdiffuseColor.a *= clipOpacity;\n\t\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tbool clipped = true;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tif ( clipped ) discard;\n\t\t#endif\n\t#endif\n#endif";

  var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";

  var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif";

  var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif";

  var color_fragment = "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif";

  var color_pars_fragment = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif";

  var color_pars_vertex = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n\tvarying vec3 vColor;\n#endif";

  var color_vertex = "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif\n#ifdef USE_BATCHING_COLOR\n\tvec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );\n\tvColor.xyz *= batchingColor.xyz;\n#endif";

  var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\n#ifdef USE_ALPHAHASH\n\tvarying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated";

  var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif";

  var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = objectTangent;\n#endif\n#ifdef USE_BATCHING\n\tmat3 bm = mat3( batchingMatrix );\n\ttransformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );\n\ttransformedNormal = bm * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = bm * transformedTangent;\n\t#endif\n#endif\n#ifdef USE_INSTANCING\n\tmat3 im = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );\n\ttransformedNormal = im * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = im * transformedTangent;\n\t#endif\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\ttransformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif";

  var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif";

  var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif";

  var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif";

  var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif";

  var colorspace_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";

  var colorspace_pars_fragment = "\nconst mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(\n\tvec3( 0.8224621, 0.177538, 0.0 ),\n\tvec3( 0.0331941, 0.9668058, 0.0 ),\n\tvec3( 0.0170827, 0.0723974, 0.9105199 )\n);\nconst mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.2249401, - 0.2249404, 0.0 ),\n\tvec3( - 0.0420569, 1.0420571, 0.0 ),\n\tvec3( - 0.0196376, - 0.0786361, 1.0982735 )\n);\nvec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {\n\treturn vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );\n}\nvec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {\n\treturn vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );\n}\nvec4 LinearTransferOETF( in vec4 value ) {\n\treturn value;\n}\nvec4 sRGBTransferOETF( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}";

  var envmap_fragment = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif";

  var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform mat3 envMapRotation;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif";

  var envmap_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif";

  var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif";

  var envmap_vertex = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif";

  var fog_vertex = "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif";

  var fog_pars_vertex = "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif";

  var fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";

  var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";

  var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}";

  var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";

  var lights_lambert_fragment = "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;";

  var lights_lambert_pars_fragment = "varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert";

  var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\n#if defined( USE_LIGHT_PROBES )\n\tuniform vec3 lightProbe[ 9 ];\n#endif\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif ( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif";

  var envmap_physical_pars_fragment = "#ifdef USE_ENVMAP\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\t#ifdef USE_ANISOTROPY\n\t\tvec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n\t\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\t\tvec3 bentNormal = cross( bitangent, viewDir );\n\t\t\t\tbentNormal = normalize( cross( bentNormal, bitangent ) );\n\t\t\t\tbentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n\t\t\t\treturn getIBLRadiance( viewDir, bentNormal, roughness );\n\t\t\t#else\n\t\t\t\treturn vec3( 0.0 );\n\t\t\t#endif\n\t\t}\n\t#endif\n#endif";

  var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";

  var lights_toon_pars_fragment = "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon";

  var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";

  var lights_phong_pars_fragment = "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong";

  var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef USE_SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULAR_COLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n\t\t#endif\n\t\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_DISPERSION\n\tmaterial.dispersion = dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\t#ifdef USE_ANISOTROPYMAP\n\t\tmat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n\t\tvec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n\t\tvec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n\t#else\n\t\tvec2 anisotropyV = anisotropyVector;\n\t#endif\n\tmaterial.anisotropy = length( anisotropyV );\n\tif( material.anisotropy == 0.0 ) {\n\t\tanisotropyV = vec2( 1.0, 0.0 );\n\t} else {\n\t\tanisotropyV /= material.anisotropy;\n\t\tmaterial.anisotropy = saturate( material.anisotropy );\n\t}\n\tmaterial.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n\tmaterial.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;\n\tmaterial.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;\n#endif";

  var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\tfloat dispersion;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat anisotropy;\n\t\tfloat alphaT;\n\t\tvec3 anisotropyT;\n\t\tvec3 anisotropyB;\n\t#endif\n};\nvec3 clearcoatSpecularDirect = vec3( 0.0 );\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\nvec3 sheenSpecularDirect = vec3( 0.0 );\nvec3 sheenSpecularIndirect = vec3(0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n\tfloat V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n\t\tfloat gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n\t\tfloat gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n\t\tfloat v = 0.5 / ( gv + gl );\n\t\treturn saturate(v);\n\t}\n\tfloat D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n\t\tfloat a2 = alphaT * alphaB;\n\t\thighp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n\t\thighp float v2 = dot( v, v );\n\t\tfloat w2 = a2 / v2;\n\t\treturn RECIPROCAL_PI * a2 * pow2 ( w2 );\n\t}\n#endif\n#ifdef USE_CLEARCOAT\n\tvec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n\t\tvec3 f0 = material.clearcoatF0;\n\t\tfloat f90 = material.clearcoatF90;\n\t\tfloat roughness = material.clearcoatRoughness;\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n\tvec3 f0 = material.specularColor;\n\tfloat f90 = material.specularF90;\n\tfloat roughness = material.roughness;\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t#ifdef USE_IRIDESCENCE\n\t\tF = mix( F, material.iridescenceFresnel, material.iridescence );\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat dotTL = dot( material.anisotropyT, lightDir );\n\t\tfloat dotTV = dot( material.anisotropyT, viewDir );\n\t\tfloat dotTH = dot( material.anisotropyT, halfDir );\n\t\tfloat dotBL = dot( material.anisotropyB, lightDir );\n\t\tfloat dotBV = dot( material.anisotropyB, viewDir );\n\t\tfloat dotBH = dot( material.anisotropyB, halfDir );\n\t\tfloat V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n\t\tfloat D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n\t#else\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t#endif\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometryNormal;\n\t\tvec3 viewDir = geometryViewDir;\n\t\tvec3 position = geometryPosition;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";

  var lights_fragment_begin = "\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n#ifdef USE_CLEARCOAT\n\tgeometryClearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometryViewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometryPosition, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometryPosition, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if defined( USE_LIGHT_PROBES )\n\t\tirradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif";

  var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometryNormal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\t#ifdef USE_ANISOTROPY\n\t\tradiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\n\t#else\n\t\tradiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif";

  var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif";

  var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF )\n\tgl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";

  var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif";

  var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif";

  var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\tvFragDepth = 1.0 + gl_Position.w;\n\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n#endif";

  var map_fragment = "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif";

  var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif";

  var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t#if defined( USE_POINTS_UV )\n\t\tvec2 uv = vUv;\n\t#else\n\t\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";

  var map_particle_pars_fragment = "#if defined( USE_POINTS_UV )\n\tvarying vec2 vUv;\n#else\n\t#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t\tuniform mat3 uvTransform;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";

  var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif";

  var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";

  var morphinstance_vertex = "#ifdef USE_INSTANCING_MORPH\n\tfloat morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\tfloat morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tmorphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;\n\t}\n#endif";

  var morphcolor_vertex = "#if defined( USE_MORPHCOLORS )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif";

  var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t}\n#endif";

  var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_INSTANCING_MORPH\n\t\tuniform float morphTargetBaseInfluence;\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t#endif\n\tuniform sampler2DArray morphTargetsTexture;\n\tuniform ivec2 morphTargetsTextureSize;\n\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t}\n#endif";

  var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t}\n#endif";

  var normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal *= faceDirection;\n\t#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn = getTangentFrame( - vViewPosition, normal,\n\t\t#if defined( USE_NORMALMAP )\n\t\t\tvNormalMapUv\n\t\t#elif defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tvClearcoatNormalMapUv\n\t\t#else\n\t\t\tvUv\n\t\t#endif\n\t\t);\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn[0] *= faceDirection;\n\t\ttbn[1] *= faceDirection;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn2[0] *= faceDirection;\n\t\ttbn2[1] *= faceDirection;\n\t#endif\n#endif\nvec3 nonPerturbedNormal = normal;";

  var normal_fragment_maps = "#ifdef USE_NORMALMAP_OBJECTSPACE\n\tnormal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n\tvec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\tnormal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";

  var normal_pars_fragment = "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif";

  var normal_pars_vertex = "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif";

  var normal_vertex = "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif";

  var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n\tmat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( uv.st );\n\t\tvec2 st1 = dFdy( uv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n\t\treturn mat3( T * scale, B * scale, N );\n\t}\n#endif";

  var clearcoat_normal_fragment_begin = "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = nonPerturbedNormal;\n#endif";

  var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\tclearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif";

  var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif";

  var iridescence_pars_fragment = "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif";

  var opaque_fragment = "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );";

  var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;\nconst float Inv255 = 1. / 255.;\nconst vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );\nconst vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );\nconst vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );\nconst vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );\nvec4 packDepthToRGBA( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec4( 0., 0., 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec4( 1., 1., 1., 1. );\n\tfloat vuf;\n\tfloat af = modf( v * PackFactors.a, vuf );\n\tfloat bf = modf( vuf * ShiftRight8, vuf );\n\tfloat gf = modf( vuf * ShiftRight8, vuf );\n\treturn vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );\n}\nvec3 packDepthToRGB( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec3( 0., 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec3( 1., 1., 1. );\n\tfloat vuf;\n\tfloat bf = modf( v * PackFactors.b, vuf );\n\tfloat gf = modf( vuf * ShiftRight8, vuf );\n\treturn vec3( vuf * Inv255, gf * PackUpscale, bf );\n}\nvec2 packDepthToRG( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec2( 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec2( 1., 1. );\n\tfloat vuf;\n\tfloat gf = modf( v * 256., vuf );\n\treturn vec2( vuf * Inv255, gf );\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors4 );\n}\nfloat unpackRGBToDepth( const in vec3 v ) {\n\treturn dot( v, UnpackFactors3 );\n}\nfloat unpackRGToDepth( const in vec2 v ) {\n\treturn v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;\n}\nvec4 pack2HalfToRGBA( const in vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( const in vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * depth - far );\n}";

  var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif";

  var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_BATCHING\n\tmvPosition = batchingMatrix * mvPosition;\n#endif\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";

  var dithering_fragment = "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";

  var dithering_pars_fragment = "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif";

  var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n\troughnessFactor *= texelRoughness.g;\n#endif";

  var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";

  var shadowmap_pars_fragment = "#if NUM_SPOT_LIGHT_COORDS > 0\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n\tuniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n\t\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn mix( 1.0, shadow, shadowIntensity );\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tfloat shadow = 1.0;\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\t\n\t\tfloat lightToPositionLength = length( lightToPosition );\n\t\tif ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {\n\t\t\tfloat dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\t\tdp += shadowBias;\n\t\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\t\tshadow = (\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t\t) * ( 1.0 / 9.0 );\n\t\t\t#else\n\t\t\t\tshadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t\t#endif\n\t\t}\n\t\treturn mix( 1.0, shadow, shadowIntensity );\n\t}\n#endif";

  var shadowmap_pars_vertex = "#if NUM_SPOT_LIGHT_COORDS > 0\n\tuniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif";

  var shadowmap_vertex = "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n#endif";

  var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}";

  var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";

  var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tint size = textureSize( boneTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n#endif";

  var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";

  var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif";

  var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";

  var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";

  var tonemapping_fragment = "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";

  var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.6605, - 0.1246, - 0.0182 ),\n\tvec3( - 0.5876, 1.1329, - 0.1006 ),\n\tvec3( - 0.0728, - 0.0083, 1.1187 )\n);\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(\n\tvec3( 0.6274, 0.0691, 0.0164 ),\n\tvec3( 0.3293, 0.9195, 0.0880 ),\n\tvec3( 0.0433, 0.0113, 0.8956 )\n);\nvec3 agxDefaultContrastApprox( vec3 x ) {\n\tvec3 x2 = x * x;\n\tvec3 x4 = x2 * x2;\n\treturn + 15.5 * x4 * x2\n\t\t- 40.14 * x4 * x\n\t\t+ 31.96 * x4\n\t\t- 6.868 * x2 * x\n\t\t+ 0.4298 * x2\n\t\t+ 0.1191 * x\n\t\t- 0.00232;\n}\nvec3 AgXToneMapping( vec3 color ) {\n\tconst mat3 AgXInsetMatrix = mat3(\n\t\tvec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),\n\t\tvec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),\n\t\tvec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )\n\t);\n\tconst mat3 AgXOutsetMatrix = mat3(\n\t\tvec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),\n\t\tvec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),\n\t\tvec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )\n\t);\n\tconst float AgxMinEv = - 12.47393;\tconst float AgxMaxEv = 4.026069;\n\tcolor *= toneMappingExposure;\n\tcolor = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\n\tcolor = AgXInsetMatrix * color;\n\tcolor = max( color, 1e-10 );\tcolor = log2( color );\n\tcolor = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );\n\tcolor = clamp( color, 0.0, 1.0 );\n\tcolor = agxDefaultContrastApprox( color );\n\tcolor = AgXOutsetMatrix * color;\n\tcolor = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );\n\tcolor = LINEAR_REC2020_TO_LINEAR_SRGB * color;\n\tcolor = clamp( color, 0.0, 1.0 );\n\treturn color;\n}\nvec3 NeutralToneMapping( vec3 color ) {\n\tconst float StartCompression = 0.8 - 0.04;\n\tconst float Desaturation = 0.15;\n\tcolor *= toneMappingExposure;\n\tfloat x = min( color.r, min( color.g, color.b ) );\n\tfloat offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\n\tcolor -= offset;\n\tfloat peak = max( color.r, max( color.g, color.b ) );\n\tif ( peak < StartCompression ) return color;\n\tfloat d = 1. - StartCompression;\n\tfloat newPeak = 1. - d * d / ( peak + d - StartCompression );\n\tcolor *= newPeak / peak;\n\tfloat g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );\n\treturn mix( color, vec3( newPeak ), g );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";

  var transmission_fragment = "#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmitted = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif";

  var transmission_pars_fragment = "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tfloat w0( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n\t}\n\tfloat w1( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n\t}\n\tfloat w2( float a ){\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n\t}\n\tfloat w3( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * a * a );\n\t}\n\tfloat g0( float a ) {\n\t\treturn w0( a ) + w1( a );\n\t}\n\tfloat g1( float a ) {\n\t\treturn w2( a ) + w3( a );\n\t}\n\tfloat h0( float a ) {\n\t\treturn - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n\t}\n\tfloat h1( float a ) {\n\t\treturn 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n\t}\n\tvec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n\t\tuv = uv * texelSize.zw + 0.5;\n\t\tvec2 iuv = floor( uv );\n\t\tvec2 fuv = fract( uv );\n\t\tfloat g0x = g0( fuv.x );\n\t\tfloat g1x = g1( fuv.x );\n\t\tfloat h0x = h0( fuv.x );\n\t\tfloat h1x = h1( fuv.x );\n\t\tfloat h0y = h0( fuv.y );\n\t\tfloat h1y = h1( fuv.y );\n\t\tvec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\treturn g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n\t\t\tg1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n\t}\n\tvec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n\t\tvec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n\t\tvec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n\t\tvec2 fLodSizeInv = 1.0 / fLodSize;\n\t\tvec2 cLodSizeInv = 1.0 / cLodSize;\n\t\tvec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n\t\tvec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n\t\treturn mix( fSample, cSample, fract( lod ) );\n\t}\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\treturn textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n\t}\n\tvec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn vec3( 1.0 );\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec4 transmittedLight;\n\t\tvec3 transmittance;\n\t\t#ifdef USE_DISPERSION\n\t\t\tfloat halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;\n\t\t\tvec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );\n\t\t\tfor ( int i = 0; i < 3; i ++ ) {\n\t\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );\n\t\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\t\n\t\t\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\t\trefractionCoords += 1.0;\n\t\t\t\trefractionCoords /= 2.0;\n\t\t\n\t\t\t\tvec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );\n\t\t\t\ttransmittedLight[ i ] = transmissionSample[ i ];\n\t\t\t\ttransmittedLight.a += transmissionSample.a;\n\t\t\t\ttransmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];\n\t\t\t}\n\t\t\ttransmittedLight.a /= 3.0;\n\t\t\n\t\t#else\n\t\t\n\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\trefractionCoords += 1.0;\n\t\t\trefractionCoords /= 2.0;\n\t\t\ttransmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\t\ttransmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\t\n\t\t#endif\n\t\tvec3 attenuatedColor = transmittance * transmittedLight.rgb;\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\tfloat transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n\t}\n#endif";

  var uv_pars_fragment = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif";

  var uv_pars_vertex = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif";

  var uv_vertex = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n\tvMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n\tvAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n\tvLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n\tvAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n\tvBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n\tvNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tvDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n\tvMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n\tvSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tvTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n\tvThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif";

  var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_BATCHING\n\t\tworldPosition = batchingMatrix * worldPosition;\n\t#endif\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif";

  const vertex$h = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}";

  const fragment$h = "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\ttexColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}";

  const vertex$g = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";

  const fragment$g = "#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nuniform mat3 backgroundRotation;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}";

  const vertex$f = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";

  const fragment$f = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}";

  const vertex$e = "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}";

  const fragment$e = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#elif DEPTH_PACKING == 3202\n\t\tgl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );\n\t#elif DEPTH_PACKING == 3203\n\t\tgl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );\n\t#endif\n}";

  const vertex$d = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}";

  const fragment$d = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}";

  const vertex$c = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}";

  const fragment$c = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}";

  const vertex$b = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";

  const fragment$b = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";

  const vertex$a = "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}";

  const fragment$a = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

  const vertex$9 = "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

  const fragment$9 = "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

  const vertex$8 = "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}";

  const fragment$8 = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

  const vertex$7 = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}";

  const fragment$7 = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}";

  const vertex$6 = "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

  const fragment$6 = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

  const vertex$5 = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}";

  const fragment$5 = "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef USE_SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULAR_COLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_DISPERSION\n\tuniform float dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\tuniform vec2 anisotropyVector;\n\t#ifdef USE_ANISOTROPYMAP\n\t\tuniform sampler2D anisotropyMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n\t#endif\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

  const vertex$4 = "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

  const fragment$4 = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

  const vertex$3 = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\nvoid main() {\n\t#ifdef USE_POINTS_UV\n\t\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\t#endif\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}";

  const fragment$3 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";

  const vertex$2 = "#include <common>\n#include <batching_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

  const fragment$2 = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}";

  const vertex$1 = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";

  const fragment$1 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}";

  const ShaderChunk = {
  	alphahash_fragment: alphahash_fragment,
  	alphahash_pars_fragment: alphahash_pars_fragment,
  	alphamap_fragment: alphamap_fragment,
  	alphamap_pars_fragment: alphamap_pars_fragment,
  	alphatest_fragment: alphatest_fragment,
  	alphatest_pars_fragment: alphatest_pars_fragment,
  	aomap_fragment: aomap_fragment,
  	aomap_pars_fragment: aomap_pars_fragment,
  	batching_pars_vertex: batching_pars_vertex,
  	batching_vertex: batching_vertex,
  	begin_vertex: begin_vertex,
  	beginnormal_vertex: beginnormal_vertex,
  	bsdfs: bsdfs,
  	iridescence_fragment: iridescence_fragment,
  	bumpmap_pars_fragment: bumpmap_pars_fragment,
  	clipping_planes_fragment: clipping_planes_fragment,
  	clipping_planes_pars_fragment: clipping_planes_pars_fragment,
  	clipping_planes_pars_vertex: clipping_planes_pars_vertex,
  	clipping_planes_vertex: clipping_planes_vertex,
  	color_fragment: color_fragment,
  	color_pars_fragment: color_pars_fragment,
  	color_pars_vertex: color_pars_vertex,
  	color_vertex: color_vertex,
  	common: common,
  	cube_uv_reflection_fragment: cube_uv_reflection_fragment,
  	defaultnormal_vertex: defaultnormal_vertex,
  	displacementmap_pars_vertex: displacementmap_pars_vertex,
  	displacementmap_vertex: displacementmap_vertex,
  	emissivemap_fragment: emissivemap_fragment,
  	emissivemap_pars_fragment: emissivemap_pars_fragment,
  	colorspace_fragment: colorspace_fragment,
  	colorspace_pars_fragment: colorspace_pars_fragment,
  	envmap_fragment: envmap_fragment,
  	envmap_common_pars_fragment: envmap_common_pars_fragment,
  	envmap_pars_fragment: envmap_pars_fragment,
  	envmap_pars_vertex: envmap_pars_vertex,
  	envmap_physical_pars_fragment: envmap_physical_pars_fragment,
  	envmap_vertex: envmap_vertex,
  	fog_vertex: fog_vertex,
  	fog_pars_vertex: fog_pars_vertex,
  	fog_fragment: fog_fragment,
  	fog_pars_fragment: fog_pars_fragment,
  	gradientmap_pars_fragment: gradientmap_pars_fragment,
  	lightmap_pars_fragment: lightmap_pars_fragment,
  	lights_lambert_fragment: lights_lambert_fragment,
  	lights_lambert_pars_fragment: lights_lambert_pars_fragment,
  	lights_pars_begin: lights_pars_begin,
  	lights_toon_fragment: lights_toon_fragment,
  	lights_toon_pars_fragment: lights_toon_pars_fragment,
  	lights_phong_fragment: lights_phong_fragment,
  	lights_phong_pars_fragment: lights_phong_pars_fragment,
  	lights_physical_fragment: lights_physical_fragment,
  	lights_physical_pars_fragment: lights_physical_pars_fragment,
  	lights_fragment_begin: lights_fragment_begin,
  	lights_fragment_maps: lights_fragment_maps,
  	lights_fragment_end: lights_fragment_end,
  	logdepthbuf_fragment: logdepthbuf_fragment,
  	logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
  	logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
  	logdepthbuf_vertex: logdepthbuf_vertex,
  	map_fragment: map_fragment,
  	map_pars_fragment: map_pars_fragment,
  	map_particle_fragment: map_particle_fragment,
  	map_particle_pars_fragment: map_particle_pars_fragment,
  	metalnessmap_fragment: metalnessmap_fragment,
  	metalnessmap_pars_fragment: metalnessmap_pars_fragment,
  	morphinstance_vertex: morphinstance_vertex,
  	morphcolor_vertex: morphcolor_vertex,
  	morphnormal_vertex: morphnormal_vertex,
  	morphtarget_pars_vertex: morphtarget_pars_vertex,
  	morphtarget_vertex: morphtarget_vertex,
  	normal_fragment_begin: normal_fragment_begin,
  	normal_fragment_maps: normal_fragment_maps,
  	normal_pars_fragment: normal_pars_fragment,
  	normal_pars_vertex: normal_pars_vertex,
  	normal_vertex: normal_vertex,
  	normalmap_pars_fragment: normalmap_pars_fragment,
  	clearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin,
  	clearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps,
  	clearcoat_pars_fragment: clearcoat_pars_fragment,
  	iridescence_pars_fragment: iridescence_pars_fragment,
  	opaque_fragment: opaque_fragment,
  	packing: packing,
  	premultiplied_alpha_fragment: premultiplied_alpha_fragment,
  	project_vertex: project_vertex,
  	dithering_fragment: dithering_fragment,
  	dithering_pars_fragment: dithering_pars_fragment,
  	roughnessmap_fragment: roughnessmap_fragment,
  	roughnessmap_pars_fragment: roughnessmap_pars_fragment,
  	shadowmap_pars_fragment: shadowmap_pars_fragment,
  	shadowmap_pars_vertex: shadowmap_pars_vertex,
  	shadowmap_vertex: shadowmap_vertex,
  	shadowmask_pars_fragment: shadowmask_pars_fragment,
  	skinbase_vertex: skinbase_vertex,
  	skinning_pars_vertex: skinning_pars_vertex,
  	skinning_vertex: skinning_vertex,
  	skinnormal_vertex: skinnormal_vertex,
  	specularmap_fragment: specularmap_fragment,
  	specularmap_pars_fragment: specularmap_pars_fragment,
  	tonemapping_fragment: tonemapping_fragment,
  	tonemapping_pars_fragment: tonemapping_pars_fragment,
  	transmission_fragment: transmission_fragment,
  	transmission_pars_fragment: transmission_pars_fragment,
  	uv_pars_fragment: uv_pars_fragment,
  	uv_pars_vertex: uv_pars_vertex,
  	uv_vertex: uv_vertex,
  	worldpos_vertex: worldpos_vertex,

  	background_vert: vertex$h,
  	background_frag: fragment$h,
  	backgroundCube_vert: vertex$g,
  	backgroundCube_frag: fragment$g,
  	cube_vert: vertex$f,
  	cube_frag: fragment$f,
  	depth_vert: vertex$e,
  	depth_frag: fragment$e,
  	distanceRGBA_vert: vertex$d,
  	distanceRGBA_frag: fragment$d,
  	equirect_vert: vertex$c,
  	equirect_frag: fragment$c,
  	linedashed_vert: vertex$b,
  	linedashed_frag: fragment$b,
  	meshbasic_vert: vertex$a,
  	meshbasic_frag: fragment$a,
  	meshlambert_vert: vertex$9,
  	meshlambert_frag: fragment$9,
  	meshmatcap_vert: vertex$8,
  	meshmatcap_frag: fragment$8,
  	meshnormal_vert: vertex$7,
  	meshnormal_frag: fragment$7,
  	meshphong_vert: vertex$6,
  	meshphong_frag: fragment$6,
  	meshphysical_vert: vertex$5,
  	meshphysical_frag: fragment$5,
  	meshtoon_vert: vertex$4,
  	meshtoon_frag: fragment$4,
  	points_vert: vertex$3,
  	points_frag: fragment$3,
  	shadow_vert: vertex$2,
  	shadow_frag: fragment$2,
  	sprite_vert: vertex$1,
  	sprite_frag: fragment$1
  };

  /**
   * Uniforms library for shared webgl shaders
   */

  const UniformsLib = {

  	common: {

  		diffuse: { value: /*@__PURE__*/ new Color( 0xffffff ) },
  		opacity: { value: 1.0 },

  		map: { value: null },
  		mapTransform: { value: /*@__PURE__*/ new Matrix3() },

  		alphaMap: { value: null },
  		alphaMapTransform: { value: /*@__PURE__*/ new Matrix3() },

  		alphaTest: { value: 0 }

  	},

  	specularmap: {

  		specularMap: { value: null },
  		specularMapTransform: { value: /*@__PURE__*/ new Matrix3() }

  	},

  	envmap: {

  		envMap: { value: null },
  		envMapRotation: { value: /*@__PURE__*/ new Matrix3() },
  		flipEnvMap: { value: - 1 },
  		reflectivity: { value: 1.0 }, // basic, lambert, phong
  		ior: { value: 1.5 }, // physical
  		refractionRatio: { value: 0.98 }, // basic, lambert, phong

  	},

  	aomap: {

  		aoMap: { value: null },
  		aoMapIntensity: { value: 1 },
  		aoMapTransform: { value: /*@__PURE__*/ new Matrix3() }

  	},

  	lightmap: {

  		lightMap: { value: null },
  		lightMapIntensity: { value: 1 },
  		lightMapTransform: { value: /*@__PURE__*/ new Matrix3() }

  	},

  	bumpmap: {

  		bumpMap: { value: null },
  		bumpMapTransform: { value: /*@__PURE__*/ new Matrix3() },
  		bumpScale: { value: 1 }

  	},

  	normalmap: {

  		normalMap: { value: null },
  		normalMapTransform: { value: /*@__PURE__*/ new Matrix3() },
  		normalScale: { value: /*@__PURE__*/ new Vector2( 1, 1 ) }

  	},

  	displacementmap: {

  		displacementMap: { value: null },
  		displacementMapTransform: { value: /*@__PURE__*/ new Matrix3() },
  		displacementScale: { value: 1 },
  		displacementBias: { value: 0 }

  	},

  	emissivemap: {

  		emissiveMap: { value: null },
  		emissiveMapTransform: { value: /*@__PURE__*/ new Matrix3() }

  	},

  	metalnessmap: {

  		metalnessMap: { value: null },
  		metalnessMapTransform: { value: /*@__PURE__*/ new Matrix3() }

  	},

  	roughnessmap: {

  		roughnessMap: { value: null },
  		roughnessMapTransform: { value: /*@__PURE__*/ new Matrix3() }

  	},

  	gradientmap: {

  		gradientMap: { value: null }

  	},

  	fog: {

  		fogDensity: { value: 0.00025 },
  		fogNear: { value: 1 },
  		fogFar: { value: 2000 },
  		fogColor: { value: /*@__PURE__*/ new Color( 0xffffff ) }

  	},

  	lights: {

  		ambientLightColor: { value: [] },

  		lightProbe: { value: [] },

  		directionalLights: { value: [], properties: {
  			direction: {},
  			color: {}
  		} },

  		directionalLightShadows: { value: [], properties: {
  			shadowIntensity: 1,
  			shadowBias: {},
  			shadowNormalBias: {},
  			shadowRadius: {},
  			shadowMapSize: {}
  		} },

  		directionalShadowMap: { value: [] },
  		directionalShadowMatrix: { value: [] },

  		spotLights: { value: [], properties: {
  			color: {},
  			position: {},
  			direction: {},
  			distance: {},
  			coneCos: {},
  			penumbraCos: {},
  			decay: {}
  		} },

  		spotLightShadows: { value: [], properties: {
  			shadowIntensity: 1,
  			shadowBias: {},
  			shadowNormalBias: {},
  			shadowRadius: {},
  			shadowMapSize: {}
  		} },

  		spotLightMap: { value: [] },
  		spotShadowMap: { value: [] },
  		spotLightMatrix: { value: [] },

  		pointLights: { value: [], properties: {
  			color: {},
  			position: {},
  			decay: {},
  			distance: {}
  		} },

  		pointLightShadows: { value: [], properties: {
  			shadowIntensity: 1,
  			shadowBias: {},
  			shadowNormalBias: {},
  			shadowRadius: {},
  			shadowMapSize: {},
  			shadowCameraNear: {},
  			shadowCameraFar: {}
  		} },

  		pointShadowMap: { value: [] },
  		pointShadowMatrix: { value: [] },

  		hemisphereLights: { value: [], properties: {
  			direction: {},
  			skyColor: {},
  			groundColor: {}
  		} },

  		// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
  		rectAreaLights: { value: [], properties: {
  			color: {},
  			position: {},
  			width: {},
  			height: {}
  		} },

  		ltc_1: { value: null },
  		ltc_2: { value: null }

  	},

  	points: {

  		diffuse: { value: /*@__PURE__*/ new Color( 0xffffff ) },
  		opacity: { value: 1.0 },
  		size: { value: 1.0 },
  		scale: { value: 1.0 },
  		map: { value: null },
  		alphaMap: { value: null },
  		alphaMapTransform: { value: /*@__PURE__*/ new Matrix3() },
  		alphaTest: { value: 0 },
  		uvTransform: { value: /*@__PURE__*/ new Matrix3() }

  	},

  	sprite: {

  		diffuse: { value: /*@__PURE__*/ new Color( 0xffffff ) },
  		opacity: { value: 1.0 },
  		center: { value: /*@__PURE__*/ new Vector2( 0.5, 0.5 ) },
  		rotation: { value: 0.0 },
  		map: { value: null },
  		mapTransform: { value: /*@__PURE__*/ new Matrix3() },
  		alphaMap: { value: null },
  		alphaMapTransform: { value: /*@__PURE__*/ new Matrix3() },
  		alphaTest: { value: 0 }

  	}

  };

  const ShaderLib = {

  	basic: {

  		uniforms: /*@__PURE__*/ mergeUniforms( [
  			UniformsLib.common,
  			UniformsLib.specularmap,
  			UniformsLib.envmap,
  			UniformsLib.aomap,
  			UniformsLib.lightmap,
  			UniformsLib.fog
  		] ),

  		vertexShader: ShaderChunk.meshbasic_vert,
  		fragmentShader: ShaderChunk.meshbasic_frag

  	},

  	lambert: {

  		uniforms: /*@__PURE__*/ mergeUniforms( [
  			UniformsLib.common,
  			UniformsLib.specularmap,
  			UniformsLib.envmap,
  			UniformsLib.aomap,
  			UniformsLib.lightmap,
  			UniformsLib.emissivemap,
  			UniformsLib.bumpmap,
  			UniformsLib.normalmap,
  			UniformsLib.displacementmap,
  			UniformsLib.fog,
  			UniformsLib.lights,
  			{
  				emissive: { value: /*@__PURE__*/ new Color( 0x000000 ) }
  			}
  		] ),

  		vertexShader: ShaderChunk.meshlambert_vert,
  		fragmentShader: ShaderChunk.meshlambert_frag

  	},

  	phong: {

  		uniforms: /*@__PURE__*/ mergeUniforms( [
  			UniformsLib.common,
  			UniformsLib.specularmap,
  			UniformsLib.envmap,
  			UniformsLib.aomap,
  			UniformsLib.lightmap,
  			UniformsLib.emissivemap,
  			UniformsLib.bumpmap,
  			UniformsLib.normalmap,
  			UniformsLib.displacementmap,
  			UniformsLib.fog,
  			UniformsLib.lights,
  			{
  				emissive: { value: /*@__PURE__*/ new Color( 0x000000 ) },
  				specular: { value: /*@__PURE__*/ new Color( 0x111111 ) },
  				shininess: { value: 30 }
  			}
  		] ),

  		vertexShader: ShaderChunk.meshphong_vert,
  		fragmentShader: ShaderChunk.meshphong_frag

  	},

  	standard: {

  		uniforms: /*@__PURE__*/ mergeUniforms( [
  			UniformsLib.common,
  			UniformsLib.envmap,
  			UniformsLib.aomap,
  			UniformsLib.lightmap,
  			UniformsLib.emissivemap,
  			UniformsLib.bumpmap,
  			UniformsLib.normalmap,
  			UniformsLib.displacementmap,
  			UniformsLib.roughnessmap,
  			UniformsLib.metalnessmap,
  			UniformsLib.fog,
  			UniformsLib.lights,
  			{
  				emissive: { value: /*@__PURE__*/ new Color( 0x000000 ) },
  				roughness: { value: 1.0 },
  				metalness: { value: 0.0 },
  				envMapIntensity: { value: 1 }
  			}
  		] ),

  		vertexShader: ShaderChunk.meshphysical_vert,
  		fragmentShader: ShaderChunk.meshphysical_frag

  	},

  	toon: {

  		uniforms: /*@__PURE__*/ mergeUniforms( [
  			UniformsLib.common,
  			UniformsLib.aomap,
  			UniformsLib.lightmap,
  			UniformsLib.emissivemap,
  			UniformsLib.bumpmap,
  			UniformsLib.normalmap,
  			UniformsLib.displacementmap,
  			UniformsLib.gradientmap,
  			UniformsLib.fog,
  			UniformsLib.lights,
  			{
  				emissive: { value: /*@__PURE__*/ new Color( 0x000000 ) }
  			}
  		] ),

  		vertexShader: ShaderChunk.meshtoon_vert,
  		fragmentShader: ShaderChunk.meshtoon_frag

  	},

  	matcap: {

  		uniforms: /*@__PURE__*/ mergeUniforms( [
  			UniformsLib.common,
  			UniformsLib.bumpmap,
  			UniformsLib.normalmap,
  			UniformsLib.displacementmap,
  			UniformsLib.fog,
  			{
  				matcap: { value: null }
  			}
  		] ),

  		vertexShader: ShaderChunk.meshmatcap_vert,
  		fragmentShader: ShaderChunk.meshmatcap_frag

  	},

  	points: {

  		uniforms: /*@__PURE__*/ mergeUniforms( [
  			UniformsLib.points,
  			UniformsLib.fog
  		] ),

  		vertexShader: ShaderChunk.points_vert,
  		fragmentShader: ShaderChunk.points_frag

  	},

  	dashed: {

  		uniforms: /*@__PURE__*/ mergeUniforms( [
  			UniformsLib.common,
  			UniformsLib.fog,
  			{
  				scale: { value: 1 },
  				dashSize: { value: 1 },
  				totalSize: { value: 2 }
  			}
  		] ),

  		vertexShader: ShaderChunk.linedashed_vert,
  		fragmentShader: ShaderChunk.linedashed_frag

  	},

  	depth: {

  		uniforms: /*@__PURE__*/ mergeUniforms( [
  			UniformsLib.common,
  			UniformsLib.displacementmap
  		] ),

  		vertexShader: ShaderChunk.depth_vert,
  		fragmentShader: ShaderChunk.depth_frag

  	},

  	normal: {

  		uniforms: /*@__PURE__*/ mergeUniforms( [
  			UniformsLib.common,
  			UniformsLib.bumpmap,
  			UniformsLib.normalmap,
  			UniformsLib.displacementmap,
  			{
  				opacity: { value: 1.0 }
  			}
  		] ),

  		vertexShader: ShaderChunk.meshnormal_vert,
  		fragmentShader: ShaderChunk.meshnormal_frag

  	},

  	sprite: {

  		uniforms: /*@__PURE__*/ mergeUniforms( [
  			UniformsLib.sprite,
  			UniformsLib.fog
  		] ),

  		vertexShader: ShaderChunk.sprite_vert,
  		fragmentShader: ShaderChunk.sprite_frag

  	},

  	background: {

  		uniforms: {
  			uvTransform: { value: /*@__PURE__*/ new Matrix3() },
  			t2D: { value: null },
  			backgroundIntensity: { value: 1 }
  		},

  		vertexShader: ShaderChunk.background_vert,
  		fragmentShader: ShaderChunk.background_frag

  	},

  	backgroundCube: {

  		uniforms: {
  			envMap: { value: null },
  			flipEnvMap: { value: - 1 },
  			backgroundBlurriness: { value: 0 },
  			backgroundIntensity: { value: 1 },
  			backgroundRotation: { value: /*@__PURE__*/ new Matrix3() }
  		},

  		vertexShader: ShaderChunk.backgroundCube_vert,
  		fragmentShader: ShaderChunk.backgroundCube_frag

  	},

  	cube: {

  		uniforms: {
  			tCube: { value: null },
  			tFlip: { value: - 1 },
  			opacity: { value: 1.0 }
  		},

  		vertexShader: ShaderChunk.cube_vert,
  		fragmentShader: ShaderChunk.cube_frag

  	},

  	equirect: {

  		uniforms: {
  			tEquirect: { value: null },
  		},

  		vertexShader: ShaderChunk.equirect_vert,
  		fragmentShader: ShaderChunk.equirect_frag

  	},

  	distanceRGBA: {

  		uniforms: /*@__PURE__*/ mergeUniforms( [
  			UniformsLib.common,
  			UniformsLib.displacementmap,
  			{
  				referencePosition: { value: /*@__PURE__*/ new Vector3() },
  				nearDistance: { value: 1 },
  				farDistance: { value: 1000 }
  			}
  		] ),

  		vertexShader: ShaderChunk.distanceRGBA_vert,
  		fragmentShader: ShaderChunk.distanceRGBA_frag

  	},

  	shadow: {

  		uniforms: /*@__PURE__*/ mergeUniforms( [
  			UniformsLib.lights,
  			UniformsLib.fog,
  			{
  				color: { value: /*@__PURE__*/ new Color( 0x00000 ) },
  				opacity: { value: 1.0 }
  			},
  		] ),

  		vertexShader: ShaderChunk.shadow_vert,
  		fragmentShader: ShaderChunk.shadow_frag

  	}

  };

  ShaderLib.physical = {

  	uniforms: /*@__PURE__*/ mergeUniforms( [
  		ShaderLib.standard.uniforms,
  		{
  			clearcoat: { value: 0 },
  			clearcoatMap: { value: null },
  			clearcoatMapTransform: { value: /*@__PURE__*/ new Matrix3() },
  			clearcoatNormalMap: { value: null },
  			clearcoatNormalMapTransform: { value: /*@__PURE__*/ new Matrix3() },
  			clearcoatNormalScale: { value: /*@__PURE__*/ new Vector2( 1, 1 ) },
  			clearcoatRoughness: { value: 0 },
  			clearcoatRoughnessMap: { value: null },
  			clearcoatRoughnessMapTransform: { value: /*@__PURE__*/ new Matrix3() },
  			dispersion: { value: 0 },
  			iridescence: { value: 0 },
  			iridescenceMap: { value: null },
  			iridescenceMapTransform: { value: /*@__PURE__*/ new Matrix3() },
  			iridescenceIOR: { value: 1.3 },
  			iridescenceThicknessMinimum: { value: 100 },
  			iridescenceThicknessMaximum: { value: 400 },
  			iridescenceThicknessMap: { value: null },
  			iridescenceThicknessMapTransform: { value: /*@__PURE__*/ new Matrix3() },
  			sheen: { value: 0 },
  			sheenColor: { value: /*@__PURE__*/ new Color( 0x000000 ) },
  			sheenColorMap: { value: null },
  			sheenColorMapTransform: { value: /*@__PURE__*/ new Matrix3() },
  			sheenRoughness: { value: 1 },
  			sheenRoughnessMap: { value: null },
  			sheenRoughnessMapTransform: { value: /*@__PURE__*/ new Matrix3() },
  			transmission: { value: 0 },
  			transmissionMap: { value: null },
  			transmissionMapTransform: { value: /*@__PURE__*/ new Matrix3() },
  			transmissionSamplerSize: { value: /*@__PURE__*/ new Vector2() },
  			transmissionSamplerMap: { value: null },
  			thickness: { value: 0 },
  			thicknessMap: { value: null },
  			thicknessMapTransform: { value: /*@__PURE__*/ new Matrix3() },
  			attenuationDistance: { value: 0 },
  			attenuationColor: { value: /*@__PURE__*/ new Color( 0x000000 ) },
  			specularColor: { value: /*@__PURE__*/ new Color( 1, 1, 1 ) },
  			specularColorMap: { value: null },
  			specularColorMapTransform: { value: /*@__PURE__*/ new Matrix3() },
  			specularIntensity: { value: 1 },
  			specularIntensityMap: { value: null },
  			specularIntensityMapTransform: { value: /*@__PURE__*/ new Matrix3() },
  			anisotropyVector: { value: /*@__PURE__*/ new Vector2() },
  			anisotropyMap: { value: null },
  			anisotropyMapTransform: { value: /*@__PURE__*/ new Matrix3() },
  		}
  	] ),

  	vertexShader: ShaderChunk.meshphysical_vert,
  	fragmentShader: ShaderChunk.meshphysical_frag

  };

  const _rgb = { r: 0, b: 0, g: 0 };
  const _e1$1 = /*@__PURE__*/ new Euler();
  const _m1$1 = /*@__PURE__*/ new Matrix4();

  function WebGLBackground( renderer, cubemaps, cubeuvmaps, state, objects, alpha, premultipliedAlpha ) {

  	const clearColor = new Color( 0x000000 );
  	let clearAlpha = alpha === true ? 0 : 1;

  	let planeMesh;
  	let boxMesh;

  	let currentBackground = null;
  	let currentBackgroundVersion = 0;
  	let currentTonemapping = null;

  	function getBackground( scene ) {

  		let background = scene.isScene === true ? scene.background : null;

  		if ( background && background.isTexture ) {

  			const usePMREM = scene.backgroundBlurriness > 0; // use PMREM if the user wants to blur the background
  			background = ( usePMREM ? cubeuvmaps : cubemaps ).get( background );

  		}

  		return background;

  	}

  	function render( scene ) {

  		let forceClear = false;
  		const background = getBackground( scene );

  		if ( background === null ) {

  			setClear( clearColor, clearAlpha );

  		} else if ( background && background.isColor ) {

  			setClear( background, 1 );
  			forceClear = true;

  		}

  		const environmentBlendMode = renderer.xr.getEnvironmentBlendMode();

  		if ( environmentBlendMode === 'additive' ) {

  			state.buffers.color.setClear( 0, 0, 0, 1, premultipliedAlpha );

  		} else if ( environmentBlendMode === 'alpha-blend' ) {

  			state.buffers.color.setClear( 0, 0, 0, 0, premultipliedAlpha );

  		}

  		if ( renderer.autoClear || forceClear ) {

  			// buffers might not be writable which is required to ensure a correct clear

  			state.buffers.depth.setTest( true );
  			state.buffers.depth.setMask( true );
  			state.buffers.color.setMask( true );

  			renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );

  		}

  	}

  	function addToRenderList( renderList, scene ) {

  		const background = getBackground( scene );

  		if ( background && ( background.isCubeTexture || background.mapping === CubeUVReflectionMapping ) ) {

  			if ( boxMesh === undefined ) {

  				boxMesh = new Mesh(
  					new BoxGeometry( 1, 1, 1 ),
  					new ShaderMaterial( {
  						name: 'BackgroundCubeMaterial',
  						uniforms: cloneUniforms( ShaderLib.backgroundCube.uniforms ),
  						vertexShader: ShaderLib.backgroundCube.vertexShader,
  						fragmentShader: ShaderLib.backgroundCube.fragmentShader,
  						side: BackSide,
  						depthTest: false,
  						depthWrite: false,
  						fog: false
  					} )
  				);

  				boxMesh.geometry.deleteAttribute( 'normal' );
  				boxMesh.geometry.deleteAttribute( 'uv' );

  				boxMesh.onBeforeRender = function ( renderer, scene, camera ) {

  					this.matrixWorld.copyPosition( camera.matrixWorld );

  				};

  				// add "envMap" material property so the renderer can evaluate it like for built-in materials
  				Object.defineProperty( boxMesh.material, 'envMap', {

  					get: function () {

  						return this.uniforms.envMap.value;

  					}

  				} );

  				objects.update( boxMesh );

  			}

  			_e1$1.copy( scene.backgroundRotation );

  			// accommodate left-handed frame
  			_e1$1.x *= - 1; _e1$1.y *= - 1; _e1$1.z *= - 1;

  			if ( background.isCubeTexture && background.isRenderTargetTexture === false ) {

  				// environment maps which are not cube render targets or PMREMs follow a different convention
  				_e1$1.y *= - 1;
  				_e1$1.z *= - 1;

  			}

  			boxMesh.material.uniforms.envMap.value = background;
  			boxMesh.material.uniforms.flipEnvMap.value = ( background.isCubeTexture && background.isRenderTargetTexture === false ) ? - 1 : 1;
  			boxMesh.material.uniforms.backgroundBlurriness.value = scene.backgroundBlurriness;
  			boxMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity;
  			boxMesh.material.uniforms.backgroundRotation.value.setFromMatrix4( _m1$1.makeRotationFromEuler( _e1$1 ) );
  			boxMesh.material.toneMapped = ColorManagement.getTransfer( background.colorSpace ) !== SRGBTransfer;

  			if ( currentBackground !== background ||
  				currentBackgroundVersion !== background.version ||
  				currentTonemapping !== renderer.toneMapping ) {

  				boxMesh.material.needsUpdate = true;

  				currentBackground = background;
  				currentBackgroundVersion = background.version;
  				currentTonemapping = renderer.toneMapping;

  			}

  			boxMesh.layers.enableAll();

  			// push to the pre-sorted opaque render list
  			renderList.unshift( boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null );

  		} else if ( background && background.isTexture ) {

  			if ( planeMesh === undefined ) {

  				planeMesh = new Mesh(
  					new PlaneGeometry( 2, 2 ),
  					new ShaderMaterial( {
  						name: 'BackgroundMaterial',
  						uniforms: cloneUniforms( ShaderLib.background.uniforms ),
  						vertexShader: ShaderLib.background.vertexShader,
  						fragmentShader: ShaderLib.background.fragmentShader,
  						side: FrontSide,
  						depthTest: false,
  						depthWrite: false,
  						fog: false
  					} )
  				);

  				planeMesh.geometry.deleteAttribute( 'normal' );

  				// add "map" material property so the renderer can evaluate it like for built-in materials
  				Object.defineProperty( planeMesh.material, 'map', {

  					get: function () {

  						return this.uniforms.t2D.value;

  					}

  				} );

  				objects.update( planeMesh );

  			}

  			planeMesh.material.uniforms.t2D.value = background;
  			planeMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity;
  			planeMesh.material.toneMapped = ColorManagement.getTransfer( background.colorSpace ) !== SRGBTransfer;

  			if ( background.matrixAutoUpdate === true ) {

  				background.updateMatrix();

  			}

  			planeMesh.material.uniforms.uvTransform.value.copy( background.matrix );

  			if ( currentBackground !== background ||
  				currentBackgroundVersion !== background.version ||
  				currentTonemapping !== renderer.toneMapping ) {

  				planeMesh.material.needsUpdate = true;

  				currentBackground = background;
  				currentBackgroundVersion = background.version;
  				currentTonemapping = renderer.toneMapping;

  			}

  			planeMesh.layers.enableAll();

  			// push to the pre-sorted opaque render list
  			renderList.unshift( planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null );

  		}

  	}

  	function setClear( color, alpha ) {

  		color.getRGB( _rgb, getUnlitUniformColorSpace( renderer ) );

  		state.buffers.color.setClear( _rgb.r, _rgb.g, _rgb.b, alpha, premultipliedAlpha );

  	}

  	return {

  		getClearColor: function () {

  			return clearColor;

  		},
  		setClearColor: function ( color, alpha = 1 ) {

  			clearColor.set( color );
  			clearAlpha = alpha;
  			setClear( clearColor, clearAlpha );

  		},
  		getClearAlpha: function () {

  			return clearAlpha;

  		},
  		setClearAlpha: function ( alpha ) {

  			clearAlpha = alpha;
  			setClear( clearColor, clearAlpha );

  		},
  		render: render,
  		addToRenderList: addToRenderList

  	};

  }

  function WebGLBindingStates( gl, attributes ) {

  	const maxVertexAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );

  	const bindingStates = {};

  	const defaultState = createBindingState( null );
  	let currentState = defaultState;
  	let forceUpdate = false;

  	function setup( object, material, program, geometry, index ) {

  		let updateBuffers = false;

  		const state = getBindingState( geometry, program, material );

  		if ( currentState !== state ) {

  			currentState = state;
  			bindVertexArrayObject( currentState.object );

  		}

  		updateBuffers = needsUpdate( object, geometry, program, index );

  		if ( updateBuffers ) saveCache( object, geometry, program, index );

  		if ( index !== null ) {

  			attributes.update( index, gl.ELEMENT_ARRAY_BUFFER );

  		}

  		if ( updateBuffers || forceUpdate ) {

  			forceUpdate = false;

  			setupVertexAttributes( object, material, program, geometry );

  			if ( index !== null ) {

  				gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, attributes.get( index ).buffer );

  			}

  		}

  	}

  	function createVertexArrayObject() {

  		return gl.createVertexArray();

  	}

  	function bindVertexArrayObject( vao ) {

  		return gl.bindVertexArray( vao );

  	}

  	function deleteVertexArrayObject( vao ) {

  		return gl.deleteVertexArray( vao );

  	}

  	function getBindingState( geometry, program, material ) {

  		const wireframe = ( material.wireframe === true );

  		let programMap = bindingStates[ geometry.id ];

  		if ( programMap === undefined ) {

  			programMap = {};
  			bindingStates[ geometry.id ] = programMap;

  		}

  		let stateMap = programMap[ program.id ];

  		if ( stateMap === undefined ) {

  			stateMap = {};
  			programMap[ program.id ] = stateMap;

  		}

  		let state = stateMap[ wireframe ];

  		if ( state === undefined ) {

  			state = createBindingState( createVertexArrayObject() );
  			stateMap[ wireframe ] = state;

  		}

  		return state;

  	}

  	function createBindingState( vao ) {

  		const newAttributes = [];
  		const enabledAttributes = [];
  		const attributeDivisors = [];

  		for ( let i = 0; i < maxVertexAttributes; i ++ ) {

  			newAttributes[ i ] = 0;
  			enabledAttributes[ i ] = 0;
  			attributeDivisors[ i ] = 0;

  		}

  		return {

  			// for backward compatibility on non-VAO support browser
  			geometry: null,
  			program: null,
  			wireframe: false,

  			newAttributes: newAttributes,
  			enabledAttributes: enabledAttributes,
  			attributeDivisors: attributeDivisors,
  			object: vao,
  			attributes: {},
  			index: null

  		};

  	}

  	function needsUpdate( object, geometry, program, index ) {

  		const cachedAttributes = currentState.attributes;
  		const geometryAttributes = geometry.attributes;

  		let attributesNum = 0;

  		const programAttributes = program.getAttributes();

  		for ( const name in programAttributes ) {

  			const programAttribute = programAttributes[ name ];

  			if ( programAttribute.location >= 0 ) {

  				const cachedAttribute = cachedAttributes[ name ];
  				let geometryAttribute = geometryAttributes[ name ];

  				if ( geometryAttribute === undefined ) {

  					if ( name === 'instanceMatrix' && object.instanceMatrix ) geometryAttribute = object.instanceMatrix;
  					if ( name === 'instanceColor' && object.instanceColor ) geometryAttribute = object.instanceColor;

  				}

  				if ( cachedAttribute === undefined ) return true;

  				if ( cachedAttribute.attribute !== geometryAttribute ) return true;

  				if ( geometryAttribute && cachedAttribute.data !== geometryAttribute.data ) return true;

  				attributesNum ++;

  			}

  		}

  		if ( currentState.attributesNum !== attributesNum ) return true;

  		if ( currentState.index !== index ) return true;

  		return false;

  	}

  	function saveCache( object, geometry, program, index ) {

  		const cache = {};
  		const attributes = geometry.attributes;
  		let attributesNum = 0;

  		const programAttributes = program.getAttributes();

  		for ( const name in programAttributes ) {

  			const programAttribute = programAttributes[ name ];

  			if ( programAttribute.location >= 0 ) {

  				let attribute = attributes[ name ];

  				if ( attribute === undefined ) {

  					if ( name === 'instanceMatrix' && object.instanceMatrix ) attribute = object.instanceMatrix;
  					if ( name === 'instanceColor' && object.instanceColor ) attribute = object.instanceColor;

  				}

  				const data = {};
  				data.attribute = attribute;

  				if ( attribute && attribute.data ) {

  					data.data = attribute.data;

  				}

  				cache[ name ] = data;

  				attributesNum ++;

  			}

  		}

  		currentState.attributes = cache;
  		currentState.attributesNum = attributesNum;

  		currentState.index = index;

  	}

  	function initAttributes() {

  		const newAttributes = currentState.newAttributes;

  		for ( let i = 0, il = newAttributes.length; i < il; i ++ ) {

  			newAttributes[ i ] = 0;

  		}

  	}

  	function enableAttribute( attribute ) {

  		enableAttributeAndDivisor( attribute, 0 );

  	}

  	function enableAttributeAndDivisor( attribute, meshPerAttribute ) {

  		const newAttributes = currentState.newAttributes;
  		const enabledAttributes = currentState.enabledAttributes;
  		const attributeDivisors = currentState.attributeDivisors;

  		newAttributes[ attribute ] = 1;

  		if ( enabledAttributes[ attribute ] === 0 ) {

  			gl.enableVertexAttribArray( attribute );
  			enabledAttributes[ attribute ] = 1;

  		}

  		if ( attributeDivisors[ attribute ] !== meshPerAttribute ) {

  			gl.vertexAttribDivisor( attribute, meshPerAttribute );
  			attributeDivisors[ attribute ] = meshPerAttribute;

  		}

  	}

  	function disableUnusedAttributes() {

  		const newAttributes = currentState.newAttributes;
  		const enabledAttributes = currentState.enabledAttributes;

  		for ( let i = 0, il = enabledAttributes.length; i < il; i ++ ) {

  			if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {

  				gl.disableVertexAttribArray( i );
  				enabledAttributes[ i ] = 0;

  			}

  		}

  	}

  	function vertexAttribPointer( index, size, type, normalized, stride, offset, integer ) {

  		if ( integer === true ) {

  			gl.vertexAttribIPointer( index, size, type, stride, offset );

  		} else {

  			gl.vertexAttribPointer( index, size, type, normalized, stride, offset );

  		}

  	}

  	function setupVertexAttributes( object, material, program, geometry ) {

  		initAttributes();

  		const geometryAttributes = geometry.attributes;

  		const programAttributes = program.getAttributes();

  		const materialDefaultAttributeValues = material.defaultAttributeValues;

  		for ( const name in programAttributes ) {

  			const programAttribute = programAttributes[ name ];

  			if ( programAttribute.location >= 0 ) {

  				let geometryAttribute = geometryAttributes[ name ];

  				if ( geometryAttribute === undefined ) {

  					if ( name === 'instanceMatrix' && object.instanceMatrix ) geometryAttribute = object.instanceMatrix;
  					if ( name === 'instanceColor' && object.instanceColor ) geometryAttribute = object.instanceColor;

  				}

  				if ( geometryAttribute !== undefined ) {

  					const normalized = geometryAttribute.normalized;
  					const size = geometryAttribute.itemSize;

  					const attribute = attributes.get( geometryAttribute );

  					// TODO Attribute may not be available on context restore

  					if ( attribute === undefined ) continue;

  					const buffer = attribute.buffer;
  					const type = attribute.type;
  					const bytesPerElement = attribute.bytesPerElement;

  					// check for integer attributes

  					const integer = ( type === gl.INT || type === gl.UNSIGNED_INT || geometryAttribute.gpuType === IntType );

  					if ( geometryAttribute.isInterleavedBufferAttribute ) {

  						const data = geometryAttribute.data;
  						const stride = data.stride;
  						const offset = geometryAttribute.offset;

  						if ( data.isInstancedInterleavedBuffer ) {

  							for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

  								enableAttributeAndDivisor( programAttribute.location + i, data.meshPerAttribute );

  							}

  							if ( object.isInstancedMesh !== true && geometry._maxInstanceCount === undefined ) {

  								geometry._maxInstanceCount = data.meshPerAttribute * data.count;

  							}

  						} else {

  							for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

  								enableAttribute( programAttribute.location + i );

  							}

  						}

  						gl.bindBuffer( gl.ARRAY_BUFFER, buffer );

  						for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

  							vertexAttribPointer(
  								programAttribute.location + i,
  								size / programAttribute.locationSize,
  								type,
  								normalized,
  								stride * bytesPerElement,
  								( offset + ( size / programAttribute.locationSize ) * i ) * bytesPerElement,
  								integer
  							);

  						}

  					} else {

  						if ( geometryAttribute.isInstancedBufferAttribute ) {

  							for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

  								enableAttributeAndDivisor( programAttribute.location + i, geometryAttribute.meshPerAttribute );

  							}

  							if ( object.isInstancedMesh !== true && geometry._maxInstanceCount === undefined ) {

  								geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;

  							}

  						} else {

  							for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

  								enableAttribute( programAttribute.location + i );

  							}

  						}

  						gl.bindBuffer( gl.ARRAY_BUFFER, buffer );

  						for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

  							vertexAttribPointer(
  								programAttribute.location + i,
  								size / programAttribute.locationSize,
  								type,
  								normalized,
  								size * bytesPerElement,
  								( size / programAttribute.locationSize ) * i * bytesPerElement,
  								integer
  							);

  						}

  					}

  				} else if ( materialDefaultAttributeValues !== undefined ) {

  					const value = materialDefaultAttributeValues[ name ];

  					if ( value !== undefined ) {

  						switch ( value.length ) {

  							case 2:
  								gl.vertexAttrib2fv( programAttribute.location, value );
  								break;

  							case 3:
  								gl.vertexAttrib3fv( programAttribute.location, value );
  								break;

  							case 4:
  								gl.vertexAttrib4fv( programAttribute.location, value );
  								break;

  							default:
  								gl.vertexAttrib1fv( programAttribute.location, value );

  						}

  					}

  				}

  			}

  		}

  		disableUnusedAttributes();

  	}

  	function dispose() {

  		reset();

  		for ( const geometryId in bindingStates ) {

  			const programMap = bindingStates[ geometryId ];

  			for ( const programId in programMap ) {

  				const stateMap = programMap[ programId ];

  				for ( const wireframe in stateMap ) {

  					deleteVertexArrayObject( stateMap[ wireframe ].object );

  					delete stateMap[ wireframe ];

  				}

  				delete programMap[ programId ];

  			}

  			delete bindingStates[ geometryId ];

  		}

  	}

  	function releaseStatesOfGeometry( geometry ) {

  		if ( bindingStates[ geometry.id ] === undefined ) return;

  		const programMap = bindingStates[ geometry.id ];

  		for ( const programId in programMap ) {

  			const stateMap = programMap[ programId ];

  			for ( const wireframe in stateMap ) {

  				deleteVertexArrayObject( stateMap[ wireframe ].object );

  				delete stateMap[ wireframe ];

  			}

  			delete programMap[ programId ];

  		}

  		delete bindingStates[ geometry.id ];

  	}

  	function releaseStatesOfProgram( program ) {

  		for ( const geometryId in bindingStates ) {

  			const programMap = bindingStates[ geometryId ];

  			if ( programMap[ program.id ] === undefined ) continue;

  			const stateMap = programMap[ program.id ];

  			for ( const wireframe in stateMap ) {

  				deleteVertexArrayObject( stateMap[ wireframe ].object );

  				delete stateMap[ wireframe ];

  			}

  			delete programMap[ program.id ];

  		}

  	}

  	function reset() {

  		resetDefaultState();
  		forceUpdate = true;

  		if ( currentState === defaultState ) return;

  		currentState = defaultState;
  		bindVertexArrayObject( currentState.object );

  	}

  	// for backward-compatibility

  	function resetDefaultState() {

  		defaultState.geometry = null;
  		defaultState.program = null;
  		defaultState.wireframe = false;

  	}

  	return {

  		setup: setup,
  		reset: reset,
  		resetDefaultState: resetDefaultState,
  		dispose: dispose,
  		releaseStatesOfGeometry: releaseStatesOfGeometry,
  		releaseStatesOfProgram: releaseStatesOfProgram,

  		initAttributes: initAttributes,
  		enableAttribute: enableAttribute,
  		disableUnusedAttributes: disableUnusedAttributes

  	};

  }

  function WebGLBufferRenderer( gl, extensions, info ) {

  	let mode;

  	function setMode( value ) {

  		mode = value;

  	}

  	function render( start, count ) {

  		gl.drawArrays( mode, start, count );

  		info.update( count, mode, 1 );

  	}

  	function renderInstances( start, count, primcount ) {

  		if ( primcount === 0 ) return;

  		gl.drawArraysInstanced( mode, start, count, primcount );

  		info.update( count, mode, primcount );

  	}

  	function renderMultiDraw( starts, counts, drawCount ) {

  		if ( drawCount === 0 ) return;

  		const extension = extensions.get( 'WEBGL_multi_draw' );
  		extension.multiDrawArraysWEBGL( mode, starts, 0, counts, 0, drawCount );

  		let elementCount = 0;
  		for ( let i = 0; i < drawCount; i ++ ) {

  			elementCount += counts[ i ];

  		}

  		info.update( elementCount, mode, 1 );

  	}

  	function renderMultiDrawInstances( starts, counts, drawCount, primcount ) {

  		if ( drawCount === 0 ) return;

  		const extension = extensions.get( 'WEBGL_multi_draw' );

  		if ( extension === null ) {

  			for ( let i = 0; i < starts.length; i ++ ) {

  				renderInstances( starts[ i ], counts[ i ], primcount[ i ] );

  			}

  		} else {

  			extension.multiDrawArraysInstancedWEBGL( mode, starts, 0, counts, 0, primcount, 0, drawCount );

  			let elementCount = 0;
  			for ( let i = 0; i < drawCount; i ++ ) {

  				elementCount += counts[ i ];

  			}

  			for ( let i = 0; i < primcount.length; i ++ ) {

  				info.update( elementCount, mode, primcount[ i ] );

  			}

  		}

  	}

  	//

  	this.setMode = setMode;
  	this.render = render;
  	this.renderInstances = renderInstances;
  	this.renderMultiDraw = renderMultiDraw;
  	this.renderMultiDrawInstances = renderMultiDrawInstances;

  }

  function WebGLCapabilities( gl, extensions, parameters, utils ) {

  	let maxAnisotropy;

  	function getMaxAnisotropy() {

  		if ( maxAnisotropy !== undefined ) return maxAnisotropy;

  		if ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {

  			const extension = extensions.get( 'EXT_texture_filter_anisotropic' );

  			maxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );

  		} else {

  			maxAnisotropy = 0;

  		}

  		return maxAnisotropy;

  	}

  	function textureFormatReadable( textureFormat ) {

  		if ( textureFormat !== RGBAFormat && utils.convert( textureFormat ) !== gl.getParameter( gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {

  			return false;

  		}

  		return true;

  	}

  	function textureTypeReadable( textureType ) {

  		const halfFloatSupportedByExt = ( textureType === HalfFloatType ) && ( extensions.has( 'EXT_color_buffer_half_float' ) || extensions.has( 'EXT_color_buffer_float' ) );

  		if ( textureType !== UnsignedByteType && utils.convert( textureType ) !== gl.getParameter( gl.IMPLEMENTATION_COLOR_READ_TYPE ) && // Edge and Chrome Mac < 52 (#9513)
  			textureType !== FloatType && ! halfFloatSupportedByExt ) {

  			return false;

  		}

  		return true;

  	}

  	function getMaxPrecision( precision ) {

  		if ( precision === 'highp' ) {

  			if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&
  				gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {

  				return 'highp';

  			}

  			precision = 'mediump';

  		}

  		if ( precision === 'mediump' ) {

  			if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&
  				gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {

  				return 'mediump';

  			}

  		}

  		return 'lowp';

  	}

  	let precision = parameters.precision !== undefined ? parameters.precision : 'highp';
  	const maxPrecision = getMaxPrecision( precision );

  	if ( maxPrecision !== precision ) {

  		console.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );
  		precision = maxPrecision;

  	}

  	const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;

  	const maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );
  	const maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
  	const maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );
  	const maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );

  	const maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
  	const maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );
  	const maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );
  	const maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );

  	const vertexTextures = maxVertexTextures > 0;

  	const maxSamples = gl.getParameter( gl.MAX_SAMPLES );

  	return {

  		isWebGL2: true, // keeping this for backwards compatibility

  		getMaxAnisotropy: getMaxAnisotropy,
  		getMaxPrecision: getMaxPrecision,

  		textureFormatReadable: textureFormatReadable,
  		textureTypeReadable: textureTypeReadable,

  		precision: precision,
  		logarithmicDepthBuffer: logarithmicDepthBuffer,

  		maxTextures: maxTextures,
  		maxVertexTextures: maxVertexTextures,
  		maxTextureSize: maxTextureSize,
  		maxCubemapSize: maxCubemapSize,

  		maxAttributes: maxAttributes,
  		maxVertexUniforms: maxVertexUniforms,
  		maxVaryings: maxVaryings,
  		maxFragmentUniforms: maxFragmentUniforms,

  		vertexTextures: vertexTextures,

  		maxSamples: maxSamples

  	};

  }

  function WebGLClipping( properties ) {

  	const scope = this;

  	let globalState = null,
  		numGlobalPlanes = 0,
  		localClippingEnabled = false,
  		renderingShadows = false;

  	const plane = new Plane(),
  		viewNormalMatrix = new Matrix3(),

  		uniform = { value: null, needsUpdate: false };

  	this.uniform = uniform;
  	this.numPlanes = 0;
  	this.numIntersection = 0;

  	this.init = function ( planes, enableLocalClipping ) {

  		const enabled =
  			planes.length !== 0 ||
  			enableLocalClipping ||
  			// enable state of previous frame - the clipping code has to
  			// run another frame in order to reset the state:
  			numGlobalPlanes !== 0 ||
  			localClippingEnabled;

  		localClippingEnabled = enableLocalClipping;

  		numGlobalPlanes = planes.length;

  		return enabled;

  	};

  	this.beginShadows = function () {

  		renderingShadows = true;
  		projectPlanes( null );

  	};

  	this.endShadows = function () {

  		renderingShadows = false;

  	};

  	this.setGlobalState = function ( planes, camera ) {

  		globalState = projectPlanes( planes, camera, 0 );

  	};

  	this.setState = function ( material, camera, useCache ) {

  		const planes = material.clippingPlanes,
  			clipIntersection = material.clipIntersection,
  			clipShadows = material.clipShadows;

  		const materialProperties = properties.get( material );

  		if ( ! localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && ! clipShadows ) {

  			// there's no local clipping

  			if ( renderingShadows ) {

  				// there's no global clipping

  				projectPlanes( null );

  			} else {

  				resetGlobalState();

  			}

  		} else {

  			const nGlobal = renderingShadows ? 0 : numGlobalPlanes,
  				lGlobal = nGlobal * 4;

  			let dstArray = materialProperties.clippingState || null;

  			uniform.value = dstArray; // ensure unique state

  			dstArray = projectPlanes( planes, camera, lGlobal, useCache );

  			for ( let i = 0; i !== lGlobal; ++ i ) {

  				dstArray[ i ] = globalState[ i ];

  			}

  			materialProperties.clippingState = dstArray;
  			this.numIntersection = clipIntersection ? this.numPlanes : 0;
  			this.numPlanes += nGlobal;

  		}


  	};

  	function resetGlobalState() {

  		if ( uniform.value !== globalState ) {

  			uniform.value = globalState;
  			uniform.needsUpdate = numGlobalPlanes > 0;

  		}

  		scope.numPlanes = numGlobalPlanes;
  		scope.numIntersection = 0;

  	}

  	function projectPlanes( planes, camera, dstOffset, skipTransform ) {

  		const nPlanes = planes !== null ? planes.length : 0;
  		let dstArray = null;

  		if ( nPlanes !== 0 ) {

  			dstArray = uniform.value;

  			if ( skipTransform !== true || dstArray === null ) {

  				const flatSize = dstOffset + nPlanes * 4,
  					viewMatrix = camera.matrixWorldInverse;

  				viewNormalMatrix.getNormalMatrix( viewMatrix );

  				if ( dstArray === null || dstArray.length < flatSize ) {

  					dstArray = new Float32Array( flatSize );

  				}

  				for ( let i = 0, i4 = dstOffset; i !== nPlanes; ++ i, i4 += 4 ) {

  					plane.copy( planes[ i ] ).applyMatrix4( viewMatrix, viewNormalMatrix );

  					plane.normal.toArray( dstArray, i4 );
  					dstArray[ i4 + 3 ] = plane.constant;

  				}

  			}

  			uniform.value = dstArray;
  			uniform.needsUpdate = true;

  		}

  		scope.numPlanes = nPlanes;
  		scope.numIntersection = 0;

  		return dstArray;

  	}

  }

  function WebGLCubeMaps( renderer ) {

  	let cubemaps = new WeakMap();

  	function mapTextureMapping( texture, mapping ) {

  		if ( mapping === EquirectangularReflectionMapping ) {

  			texture.mapping = CubeReflectionMapping;

  		} else if ( mapping === EquirectangularRefractionMapping ) {

  			texture.mapping = CubeRefractionMapping;

  		}

  		return texture;

  	}

  	function get( texture ) {

  		if ( texture && texture.isTexture ) {

  			const mapping = texture.mapping;

  			if ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping ) {

  				if ( cubemaps.has( texture ) ) {

  					const cubemap = cubemaps.get( texture ).texture;
  					return mapTextureMapping( cubemap, texture.mapping );

  				} else {

  					const image = texture.image;

  					if ( image && image.height > 0 ) {

  						const renderTarget = new WebGLCubeRenderTarget( image.height );
  						renderTarget.fromEquirectangularTexture( renderer, texture );
  						cubemaps.set( texture, renderTarget );

  						texture.addEventListener( 'dispose', onTextureDispose );

  						return mapTextureMapping( renderTarget.texture, texture.mapping );

  					} else {

  						// image not yet ready. try the conversion next frame

  						return null;

  					}

  				}

  			}

  		}

  		return texture;

  	}

  	function onTextureDispose( event ) {

  		const texture = event.target;

  		texture.removeEventListener( 'dispose', onTextureDispose );

  		const cubemap = cubemaps.get( texture );

  		if ( cubemap !== undefined ) {

  			cubemaps.delete( texture );
  			cubemap.dispose();

  		}

  	}

  	function dispose() {

  		cubemaps = new WeakMap();

  	}

  	return {
  		get: get,
  		dispose: dispose
  	};

  }

  class OrthographicCamera extends Camera {

  	constructor( left = - 1, right = 1, top = 1, bottom = - 1, near = 0.1, far = 2000 ) {

  		super();

  		this.isOrthographicCamera = true;

  		this.type = 'OrthographicCamera';

  		this.zoom = 1;
  		this.view = null;

  		this.left = left;
  		this.right = right;
  		this.top = top;
  		this.bottom = bottom;

  		this.near = near;
  		this.far = far;

  		this.updateProjectionMatrix();

  	}

  	copy( source, recursive ) {

  		super.copy( source, recursive );

  		this.left = source.left;
  		this.right = source.right;
  		this.top = source.top;
  		this.bottom = source.bottom;
  		this.near = source.near;
  		this.far = source.far;

  		this.zoom = source.zoom;
  		this.view = source.view === null ? null : Object.assign( {}, source.view );

  		return this;

  	}

  	setViewOffset( fullWidth, fullHeight, x, y, width, height ) {

  		if ( this.view === null ) {

  			this.view = {
  				enabled: true,
  				fullWidth: 1,
  				fullHeight: 1,
  				offsetX: 0,
  				offsetY: 0,
  				width: 1,
  				height: 1
  			};

  		}

  		this.view.enabled = true;
  		this.view.fullWidth = fullWidth;
  		this.view.fullHeight = fullHeight;
  		this.view.offsetX = x;
  		this.view.offsetY = y;
  		this.view.width = width;
  		this.view.height = height;

  		this.updateProjectionMatrix();

  	}

  	clearViewOffset() {

  		if ( this.view !== null ) {

  			this.view.enabled = false;

  		}

  		this.updateProjectionMatrix();

  	}

  	updateProjectionMatrix() {

  		const dx = ( this.right - this.left ) / ( 2 * this.zoom );
  		const dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
  		const cx = ( this.right + this.left ) / 2;
  		const cy = ( this.top + this.bottom ) / 2;

  		let left = cx - dx;
  		let right = cx + dx;
  		let top = cy + dy;
  		let bottom = cy - dy;

  		if ( this.view !== null && this.view.enabled ) {

  			const scaleW = ( this.right - this.left ) / this.view.fullWidth / this.zoom;
  			const scaleH = ( this.top - this.bottom ) / this.view.fullHeight / this.zoom;

  			left += scaleW * this.view.offsetX;
  			right = left + scaleW * this.view.width;
  			top -= scaleH * this.view.offsetY;
  			bottom = top - scaleH * this.view.height;

  		}

  		this.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far, this.coordinateSystem );

  		this.projectionMatrixInverse.copy( this.projectionMatrix ).invert();

  	}

  	toJSON( meta ) {

  		const data = super.toJSON( meta );

  		data.object.zoom = this.zoom;
  		data.object.left = this.left;
  		data.object.right = this.right;
  		data.object.top = this.top;
  		data.object.bottom = this.bottom;
  		data.object.near = this.near;
  		data.object.far = this.far;

  		if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

  		return data;

  	}

  }

  const LOD_MIN = 4;

  // The standard deviations (radians) associated with the extra mips. These are
  // chosen to approximate a Trowbridge-Reitz distribution function times the
  // geometric shadowing function. These sigma values squared must match the
  // variance #defines in cube_uv_reflection_fragment.glsl.js.
  const EXTRA_LOD_SIGMA = [ 0.125, 0.215, 0.35, 0.446, 0.526, 0.582 ];

  // The maximum length of the blur for loop. Smaller sigmas will use fewer
  // samples and exit early, but not recompile the shader.
  const MAX_SAMPLES = 20;

  const _flatCamera = /*@__PURE__*/ new OrthographicCamera();
  const _clearColor = /*@__PURE__*/ new Color();
  let _oldTarget = null;
  let _oldActiveCubeFace = 0;
  let _oldActiveMipmapLevel = 0;
  let _oldXrEnabled = false;

  // Golden Ratio
  const PHI = ( 1 + Math.sqrt( 5 ) ) / 2;
  const INV_PHI = 1 / PHI;

  // Vertices of a dodecahedron (except the opposites, which represent the
  // same axis), used as axis directions evenly spread on a sphere.
  const _axisDirections = [
  	/*@__PURE__*/ new Vector3( - PHI, INV_PHI, 0 ),
  	/*@__PURE__*/ new Vector3( PHI, INV_PHI, 0 ),
  	/*@__PURE__*/ new Vector3( - INV_PHI, 0, PHI ),
  	/*@__PURE__*/ new Vector3( INV_PHI, 0, PHI ),
  	/*@__PURE__*/ new Vector3( 0, PHI, - INV_PHI ),
  	/*@__PURE__*/ new Vector3( 0, PHI, INV_PHI ),
  	/*@__PURE__*/ new Vector3( - 1, 1, - 1 ),
  	/*@__PURE__*/ new Vector3( 1, 1, - 1 ),
  	/*@__PURE__*/ new Vector3( - 1, 1, 1 ),
  	/*@__PURE__*/ new Vector3( 1, 1, 1 ) ];

  /**
   * This class generates a Prefiltered, Mipmapped Radiance Environment Map
   * (PMREM) from a cubeMap environment texture. This allows different levels of
   * blur to be quickly accessed based on material roughness. It is packed into a
   * special CubeUV format that allows us to perform custom interpolation so that
   * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap
   * chain, it only goes down to the LOD_MIN level (above), and then creates extra
   * even more filtered 'mips' at the same LOD_MIN resolution, associated with
   * higher roughness levels. In this way we maintain resolution to smoothly
   * interpolate diffuse lighting while limiting sampling computation.
   *
   * Paper: Fast, Accurate Image-Based Lighting
   * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view
  */

  class PMREMGenerator {

  	constructor( renderer ) {

  		this._renderer = renderer;
  		this._pingPongRenderTarget = null;

  		this._lodMax = 0;
  		this._cubeSize = 0;
  		this._lodPlanes = [];
  		this._sizeLods = [];
  		this._sigmas = [];

  		this._blurMaterial = null;
  		this._cubemapMaterial = null;
  		this._equirectMaterial = null;

  		this._compileMaterial( this._blurMaterial );

  	}

  	/**
  	 * Generates a PMREM from a supplied Scene, which can be faster than using an
  	 * image if networking bandwidth is low. Optional sigma specifies a blur radius
  	 * in radians to be applied to the scene before PMREM generation. Optional near
  	 * and far planes ensure the scene is rendered in its entirety (the cubeCamera
  	 * is placed at the origin).
  	 */
  	fromScene( scene, sigma = 0, near = 0.1, far = 100 ) {

  		_oldTarget = this._renderer.getRenderTarget();
  		_oldActiveCubeFace = this._renderer.getActiveCubeFace();
  		_oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();
  		_oldXrEnabled = this._renderer.xr.enabled;

  		this._renderer.xr.enabled = false;

  		this._setSize( 256 );

  		const cubeUVRenderTarget = this._allocateTargets();
  		cubeUVRenderTarget.depthBuffer = true;

  		this._sceneToCubeUV( scene, near, far, cubeUVRenderTarget );

  		if ( sigma > 0 ) {

  			this._blur( cubeUVRenderTarget, 0, 0, sigma );

  		}

  		this._applyPMREM( cubeUVRenderTarget );
  		this._cleanup( cubeUVRenderTarget );

  		return cubeUVRenderTarget;

  	}

  	/**
  	 * Generates a PMREM from an equirectangular texture, which can be either LDR
  	 * or HDR. The ideal input image size is 1k (1024 x 512),
  	 * as this matches best with the 256 x 256 cubemap output.
  	 * The smallest supported equirectangular image size is 64 x 32.
  	 */
  	fromEquirectangular( equirectangular, renderTarget = null ) {

  		return this._fromTexture( equirectangular, renderTarget );

  	}

  	/**
  	 * Generates a PMREM from an cubemap texture, which can be either LDR
  	 * or HDR. The ideal input cube size is 256 x 256,
  	 * as this matches best with the 256 x 256 cubemap output.
  	 * The smallest supported cube size is 16 x 16.
  	 */
  	fromCubemap( cubemap, renderTarget = null ) {

  		return this._fromTexture( cubemap, renderTarget );

  	}

  	/**
  	 * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
  	 * your texture's network fetch for increased concurrency.
  	 */
  	compileCubemapShader() {

  		if ( this._cubemapMaterial === null ) {

  			this._cubemapMaterial = _getCubemapMaterial();
  			this._compileMaterial( this._cubemapMaterial );

  		}

  	}

  	/**
  	 * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
  	 * your texture's network fetch for increased concurrency.
  	 */
  	compileEquirectangularShader() {

  		if ( this._equirectMaterial === null ) {

  			this._equirectMaterial = _getEquirectMaterial();
  			this._compileMaterial( this._equirectMaterial );

  		}

  	}

  	/**
  	 * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
  	 * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
  	 * one of them will cause any others to also become unusable.
  	 */
  	dispose() {

  		this._dispose();

  		if ( this._cubemapMaterial !== null ) this._cubemapMaterial.dispose();
  		if ( this._equirectMaterial !== null ) this._equirectMaterial.dispose();

  	}

  	// private interface

  	_setSize( cubeSize ) {

  		this._lodMax = Math.floor( Math.log2( cubeSize ) );
  		this._cubeSize = Math.pow( 2, this._lodMax );

  	}

  	_dispose() {

  		if ( this._blurMaterial !== null ) this._blurMaterial.dispose();

  		if ( this._pingPongRenderTarget !== null ) this._pingPongRenderTarget.dispose();

  		for ( let i = 0; i < this._lodPlanes.length; i ++ ) {

  			this._lodPlanes[ i ].dispose();

  		}

  	}

  	_cleanup( outputTarget ) {

  		this._renderer.setRenderTarget( _oldTarget, _oldActiveCubeFace, _oldActiveMipmapLevel );
  		this._renderer.xr.enabled = _oldXrEnabled;

  		outputTarget.scissorTest = false;
  		_setViewport( outputTarget, 0, 0, outputTarget.width, outputTarget.height );

  	}

  	_fromTexture( texture, renderTarget ) {

  		if ( texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping ) {

  			this._setSize( texture.image.length === 0 ? 16 : ( texture.image[ 0 ].width || texture.image[ 0 ].image.width ) );

  		} else { // Equirectangular

  			this._setSize( texture.image.width / 4 );

  		}

  		_oldTarget = this._renderer.getRenderTarget();
  		_oldActiveCubeFace = this._renderer.getActiveCubeFace();
  		_oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();
  		_oldXrEnabled = this._renderer.xr.enabled;

  		this._renderer.xr.enabled = false;

  		const cubeUVRenderTarget = renderTarget || this._allocateTargets();
  		this._textureToCubeUV( texture, cubeUVRenderTarget );
  		this._applyPMREM( cubeUVRenderTarget );
  		this._cleanup( cubeUVRenderTarget );

  		return cubeUVRenderTarget;

  	}

  	_allocateTargets() {

  		const width = 3 * Math.max( this._cubeSize, 16 * 7 );
  		const height = 4 * this._cubeSize;

  		const params = {
  			magFilter: LinearFilter,
  			minFilter: LinearFilter,
  			generateMipmaps: false,
  			type: HalfFloatType,
  			format: RGBAFormat,
  			colorSpace: LinearSRGBColorSpace,
  			depthBuffer: false
  		};

  		const cubeUVRenderTarget = _createRenderTarget( width, height, params );

  		if ( this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== width || this._pingPongRenderTarget.height !== height ) {

  			if ( this._pingPongRenderTarget !== null ) {

  				this._dispose();

  			}

  			this._pingPongRenderTarget = _createRenderTarget( width, height, params );

  			const { _lodMax } = this;
  			( { sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = _createPlanes( _lodMax ) );

  			this._blurMaterial = _getBlurShader( _lodMax, width, height );

  		}

  		return cubeUVRenderTarget;

  	}

  	_compileMaterial( material ) {

  		const tmpMesh = new Mesh( this._lodPlanes[ 0 ], material );
  		this._renderer.compile( tmpMesh, _flatCamera );

  	}

  	_sceneToCubeUV( scene, near, far, cubeUVRenderTarget ) {

  		const fov = 90;
  		const aspect = 1;
  		const cubeCamera = new PerspectiveCamera( fov, aspect, near, far );
  		const upSign = [ 1, - 1, 1, 1, 1, 1 ];
  		const forwardSign = [ 1, 1, 1, - 1, - 1, - 1 ];
  		const renderer = this._renderer;

  		const originalAutoClear = renderer.autoClear;
  		const toneMapping = renderer.toneMapping;
  		renderer.getClearColor( _clearColor );

  		renderer.toneMapping = NoToneMapping;
  		renderer.autoClear = false;

  		const backgroundMaterial = new MeshBasicMaterial( {
  			name: 'PMREM.Background',
  			side: BackSide,
  			depthWrite: false,
  			depthTest: false,
  		} );

  		const backgroundBox = new Mesh( new BoxGeometry(), backgroundMaterial );

  		let useSolidColor = false;
  		const background = scene.background;

  		if ( background ) {

  			if ( background.isColor ) {

  				backgroundMaterial.color.copy( background );
  				scene.background = null;
  				useSolidColor = true;

  			}

  		} else {

  			backgroundMaterial.color.copy( _clearColor );
  			useSolidColor = true;

  		}

  		for ( let i = 0; i < 6; i ++ ) {

  			const col = i % 3;

  			if ( col === 0 ) {

  				cubeCamera.up.set( 0, upSign[ i ], 0 );
  				cubeCamera.lookAt( forwardSign[ i ], 0, 0 );

  			} else if ( col === 1 ) {

  				cubeCamera.up.set( 0, 0, upSign[ i ] );
  				cubeCamera.lookAt( 0, forwardSign[ i ], 0 );

  			} else {

  				cubeCamera.up.set( 0, upSign[ i ], 0 );
  				cubeCamera.lookAt( 0, 0, forwardSign[ i ] );

  			}

  			const size = this._cubeSize;

  			_setViewport( cubeUVRenderTarget, col * size, i > 2 ? size : 0, size, size );

  			renderer.setRenderTarget( cubeUVRenderTarget );

  			if ( useSolidColor ) {

  				renderer.render( backgroundBox, cubeCamera );

  			}

  			renderer.render( scene, cubeCamera );

  		}

  		backgroundBox.geometry.dispose();
  		backgroundBox.material.dispose();

  		renderer.toneMapping = toneMapping;
  		renderer.autoClear = originalAutoClear;
  		scene.background = background;

  	}

  	_textureToCubeUV( texture, cubeUVRenderTarget ) {

  		const renderer = this._renderer;

  		const isCubeTexture = ( texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping );

  		if ( isCubeTexture ) {

  			if ( this._cubemapMaterial === null ) {

  				this._cubemapMaterial = _getCubemapMaterial();

  			}

  			this._cubemapMaterial.uniforms.flipEnvMap.value = ( texture.isRenderTargetTexture === false ) ? - 1 : 1;

  		} else {

  			if ( this._equirectMaterial === null ) {

  				this._equirectMaterial = _getEquirectMaterial();

  			}

  		}

  		const material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;
  		const mesh = new Mesh( this._lodPlanes[ 0 ], material );

  		const uniforms = material.uniforms;

  		uniforms[ 'envMap' ].value = texture;

  		const size = this._cubeSize;

  		_setViewport( cubeUVRenderTarget, 0, 0, 3 * size, 2 * size );

  		renderer.setRenderTarget( cubeUVRenderTarget );
  		renderer.render( mesh, _flatCamera );

  	}

  	_applyPMREM( cubeUVRenderTarget ) {

  		const renderer = this._renderer;
  		const autoClear = renderer.autoClear;
  		renderer.autoClear = false;
  		const n = this._lodPlanes.length;

  		for ( let i = 1; i < n; i ++ ) {

  			const sigma = Math.sqrt( this._sigmas[ i ] * this._sigmas[ i ] - this._sigmas[ i - 1 ] * this._sigmas[ i - 1 ] );

  			const poleAxis = _axisDirections[ ( n - i - 1 ) % _axisDirections.length ];

  			this._blur( cubeUVRenderTarget, i - 1, i, sigma, poleAxis );

  		}

  		renderer.autoClear = autoClear;

  	}

  	/**
  	 * This is a two-pass Gaussian blur for a cubemap. Normally this is done
  	 * vertically and horizontally, but this breaks down on a cube. Here we apply
  	 * the blur latitudinally (around the poles), and then longitudinally (towards
  	 * the poles) to approximate the orthogonally-separable blur. It is least
  	 * accurate at the poles, but still does a decent job.
  	 */
  	_blur( cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis ) {

  		const pingPongRenderTarget = this._pingPongRenderTarget;

  		this._halfBlur(
  			cubeUVRenderTarget,
  			pingPongRenderTarget,
  			lodIn,
  			lodOut,
  			sigma,
  			'latitudinal',
  			poleAxis );

  		this._halfBlur(
  			pingPongRenderTarget,
  			cubeUVRenderTarget,
  			lodOut,
  			lodOut,
  			sigma,
  			'longitudinal',
  			poleAxis );

  	}

  	_halfBlur( targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis ) {

  		const renderer = this._renderer;
  		const blurMaterial = this._blurMaterial;

  		if ( direction !== 'latitudinal' && direction !== 'longitudinal' ) {

  			console.error(
  				'blur direction must be either latitudinal or longitudinal!' );

  		}

  		// Number of standard deviations at which to cut off the discrete approximation.
  		const STANDARD_DEVIATIONS = 3;

  		const blurMesh = new Mesh( this._lodPlanes[ lodOut ], blurMaterial );
  		const blurUniforms = blurMaterial.uniforms;

  		const pixels = this._sizeLods[ lodIn ] - 1;
  		const radiansPerPixel = isFinite( sigmaRadians ) ? Math.PI / ( 2 * pixels ) : 2 * Math.PI / ( 2 * MAX_SAMPLES - 1 );
  		const sigmaPixels = sigmaRadians / radiansPerPixel;
  		const samples = isFinite( sigmaRadians ) ? 1 + Math.floor( STANDARD_DEVIATIONS * sigmaPixels ) : MAX_SAMPLES;

  		if ( samples > MAX_SAMPLES ) {

  			console.warn( `sigmaRadians, ${
				sigmaRadians}, is too large and will clip, as it requested ${
				samples} samples when the maximum is set to ${MAX_SAMPLES}` );

  		}

  		const weights = [];
  		let sum = 0;

  		for ( let i = 0; i < MAX_SAMPLES; ++ i ) {

  			const x = i / sigmaPixels;
  			const weight = Math.exp( - x * x / 2 );
  			weights.push( weight );

  			if ( i === 0 ) {

  				sum += weight;

  			} else if ( i < samples ) {

  				sum += 2 * weight;

  			}

  		}

  		for ( let i = 0; i < weights.length; i ++ ) {

  			weights[ i ] = weights[ i ] / sum;

  		}

  		blurUniforms[ 'envMap' ].value = targetIn.texture;
  		blurUniforms[ 'samples' ].value = samples;
  		blurUniforms[ 'weights' ].value = weights;
  		blurUniforms[ 'latitudinal' ].value = direction === 'latitudinal';

  		if ( poleAxis ) {

  			blurUniforms[ 'poleAxis' ].value = poleAxis;

  		}

  		const { _lodMax } = this;
  		blurUniforms[ 'dTheta' ].value = radiansPerPixel;
  		blurUniforms[ 'mipInt' ].value = _lodMax - lodIn;

  		const outputSize = this._sizeLods[ lodOut ];
  		const x = 3 * outputSize * ( lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0 );
  		const y = 4 * ( this._cubeSize - outputSize );

  		_setViewport( targetOut, x, y, 3 * outputSize, 2 * outputSize );
  		renderer.setRenderTarget( targetOut );
  		renderer.render( blurMesh, _flatCamera );

  	}

  }



  function _createPlanes( lodMax ) {

  	const lodPlanes = [];
  	const sizeLods = [];
  	const sigmas = [];

  	let lod = lodMax;

  	const totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;

  	for ( let i = 0; i < totalLods; i ++ ) {

  		const sizeLod = Math.pow( 2, lod );
  		sizeLods.push( sizeLod );
  		let sigma = 1.0 / sizeLod;

  		if ( i > lodMax - LOD_MIN ) {

  			sigma = EXTRA_LOD_SIGMA[ i - lodMax + LOD_MIN - 1 ];

  		} else if ( i === 0 ) {

  			sigma = 0;

  		}

  		sigmas.push( sigma );

  		const texelSize = 1.0 / ( sizeLod - 2 );
  		const min = - texelSize;
  		const max = 1 + texelSize;
  		const uv1 = [ min, min, max, min, max, max, min, min, max, max, min, max ];

  		const cubeFaces = 6;
  		const vertices = 6;
  		const positionSize = 3;
  		const uvSize = 2;
  		const faceIndexSize = 1;

  		const position = new Float32Array( positionSize * vertices * cubeFaces );
  		const uv = new Float32Array( uvSize * vertices * cubeFaces );
  		const faceIndex = new Float32Array( faceIndexSize * vertices * cubeFaces );

  		for ( let face = 0; face < cubeFaces; face ++ ) {

  			const x = ( face % 3 ) * 2 / 3 - 1;
  			const y = face > 2 ? 0 : - 1;
  			const coordinates = [
  				x, y, 0,
  				x + 2 / 3, y, 0,
  				x + 2 / 3, y + 1, 0,
  				x, y, 0,
  				x + 2 / 3, y + 1, 0,
  				x, y + 1, 0
  			];
  			position.set( coordinates, positionSize * vertices * face );
  			uv.set( uv1, uvSize * vertices * face );
  			const fill = [ face, face, face, face, face, face ];
  			faceIndex.set( fill, faceIndexSize * vertices * face );

  		}

  		const planes = new BufferGeometry();
  		planes.setAttribute( 'position', new BufferAttribute( position, positionSize ) );
  		planes.setAttribute( 'uv', new BufferAttribute( uv, uvSize ) );
  		planes.setAttribute( 'faceIndex', new BufferAttribute( faceIndex, faceIndexSize ) );
  		lodPlanes.push( planes );

  		if ( lod > LOD_MIN ) {

  			lod --;

  		}

  	}

  	return { lodPlanes, sizeLods, sigmas };

  }

  function _createRenderTarget( width, height, params ) {

  	const cubeUVRenderTarget = new WebGLRenderTarget( width, height, params );
  	cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
  	cubeUVRenderTarget.texture.name = 'PMREM.cubeUv';
  	cubeUVRenderTarget.scissorTest = true;
  	return cubeUVRenderTarget;

  }

  function _setViewport( target, x, y, width, height ) {

  	target.viewport.set( x, y, width, height );
  	target.scissor.set( x, y, width, height );

  }

  function _getBlurShader( lodMax, width, height ) {

  	const weights = new Float32Array( MAX_SAMPLES );
  	const poleAxis = new Vector3( 0, 1, 0 );
  	const shaderMaterial = new ShaderMaterial( {

  		name: 'SphericalGaussianBlur',

  		defines: {
  			'n': MAX_SAMPLES,
  			'CUBEUV_TEXEL_WIDTH': 1.0 / width,
  			'CUBEUV_TEXEL_HEIGHT': 1.0 / height,
  			'CUBEUV_MAX_MIP': `${lodMax}.0`,
  		},

  		uniforms: {
  			'envMap': { value: null },
  			'samples': { value: 1 },
  			'weights': { value: weights },
  			'latitudinal': { value: false },
  			'dTheta': { value: 0 },
  			'mipInt': { value: 0 },
  			'poleAxis': { value: poleAxis }
  		},

  		vertexShader: _getCommonVertexShader(),

  		fragmentShader: /* glsl */`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,

  		blending: NoBlending,
  		depthTest: false,
  		depthWrite: false

  	} );

  	return shaderMaterial;

  }

  function _getEquirectMaterial() {

  	return new ShaderMaterial( {

  		name: 'EquirectangularToCubeUV',

  		uniforms: {
  			'envMap': { value: null }
  		},

  		vertexShader: _getCommonVertexShader(),

  		fragmentShader: /* glsl */`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,

  		blending: NoBlending,
  		depthTest: false,
  		depthWrite: false

  	} );

  }

  function _getCubemapMaterial() {

  	return new ShaderMaterial( {

  		name: 'CubemapToCubeUV',

  		uniforms: {
  			'envMap': { value: null },
  			'flipEnvMap': { value: - 1 }
  		},

  		vertexShader: _getCommonVertexShader(),

  		fragmentShader: /* glsl */`

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,

  		blending: NoBlending,
  		depthTest: false,
  		depthWrite: false

  	} );

  }

  function _getCommonVertexShader() {

  	return /* glsl */`

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;

  }

  function WebGLCubeUVMaps( renderer ) {

  	let cubeUVmaps = new WeakMap();

  	let pmremGenerator = null;

  	function get( texture ) {

  		if ( texture && texture.isTexture ) {

  			const mapping = texture.mapping;

  			const isEquirectMap = ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping );
  			const isCubeMap = ( mapping === CubeReflectionMapping || mapping === CubeRefractionMapping );

  			// equirect/cube map to cubeUV conversion

  			if ( isEquirectMap || isCubeMap ) {

  				let renderTarget = cubeUVmaps.get( texture );

  				const currentPMREMVersion = renderTarget !== undefined ? renderTarget.texture.pmremVersion : 0;

  				if ( texture.isRenderTargetTexture && texture.pmremVersion !== currentPMREMVersion ) {

  					if ( pmremGenerator === null ) pmremGenerator = new PMREMGenerator( renderer );

  					renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular( texture, renderTarget ) : pmremGenerator.fromCubemap( texture, renderTarget );
  					renderTarget.texture.pmremVersion = texture.pmremVersion;

  					cubeUVmaps.set( texture, renderTarget );

  					return renderTarget.texture;

  				} else {

  					if ( renderTarget !== undefined ) {

  						return renderTarget.texture;

  					} else {

  						const image = texture.image;

  						if ( ( isEquirectMap && image && image.height > 0 ) || ( isCubeMap && image && isCubeTextureComplete( image ) ) ) {

  							if ( pmremGenerator === null ) pmremGenerator = new PMREMGenerator( renderer );

  							renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular( texture ) : pmremGenerator.fromCubemap( texture );
  							renderTarget.texture.pmremVersion = texture.pmremVersion;

  							cubeUVmaps.set( texture, renderTarget );

  							texture.addEventListener( 'dispose', onTextureDispose );

  							return renderTarget.texture;

  						} else {

  							// image not yet ready. try the conversion next frame

  							return null;

  						}

  					}

  				}

  			}

  		}

  		return texture;

  	}

  	function isCubeTextureComplete( image ) {

  		let count = 0;
  		const length = 6;

  		for ( let i = 0; i < length; i ++ ) {

  			if ( image[ i ] !== undefined ) count ++;

  		}

  		return count === length;


  	}

  	function onTextureDispose( event ) {

  		const texture = event.target;

  		texture.removeEventListener( 'dispose', onTextureDispose );

  		const cubemapUV = cubeUVmaps.get( texture );

  		if ( cubemapUV !== undefined ) {

  			cubeUVmaps.delete( texture );
  			cubemapUV.dispose();

  		}

  	}

  	function dispose() {

  		cubeUVmaps = new WeakMap();

  		if ( pmremGenerator !== null ) {

  			pmremGenerator.dispose();
  			pmremGenerator = null;

  		}

  	}

  	return {
  		get: get,
  		dispose: dispose
  	};

  }

  function WebGLExtensions( gl ) {

  	const extensions = {};

  	function getExtension( name ) {

  		if ( extensions[ name ] !== undefined ) {

  			return extensions[ name ];

  		}

  		let extension;

  		switch ( name ) {

  			case 'WEBGL_depth_texture':
  				extension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );
  				break;

  			case 'EXT_texture_filter_anisotropic':
  				extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
  				break;

  			case 'WEBGL_compressed_texture_s3tc':
  				extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
  				break;

  			case 'WEBGL_compressed_texture_pvrtc':
  				extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
  				break;

  			default:
  				extension = gl.getExtension( name );

  		}

  		extensions[ name ] = extension;

  		return extension;

  	}

  	return {

  		has: function ( name ) {

  			return getExtension( name ) !== null;

  		},

  		init: function () {

  			getExtension( 'EXT_color_buffer_float' );
  			getExtension( 'WEBGL_clip_cull_distance' );
  			getExtension( 'OES_texture_float_linear' );
  			getExtension( 'EXT_color_buffer_half_float' );
  			getExtension( 'WEBGL_multisampled_render_to_texture' );
  			getExtension( 'WEBGL_render_shared_exponent' );

  		},

  		get: function ( name ) {

  			const extension = getExtension( name );

  			if ( extension === null ) {

  				warnOnce( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );

  			}

  			return extension;

  		}

  	};

  }

  function WebGLGeometries( gl, attributes, info, bindingStates ) {

  	const geometries = {};
  	const wireframeAttributes = new WeakMap();

  	function onGeometryDispose( event ) {

  		const geometry = event.target;

  		if ( geometry.index !== null ) {

  			attributes.remove( geometry.index );

  		}

  		for ( const name in geometry.attributes ) {

  			attributes.remove( geometry.attributes[ name ] );

  		}

  		for ( const name in geometry.morphAttributes ) {

  			const array = geometry.morphAttributes[ name ];

  			for ( let i = 0, l = array.length; i < l; i ++ ) {

  				attributes.remove( array[ i ] );

  			}

  		}

  		geometry.removeEventListener( 'dispose', onGeometryDispose );

  		delete geometries[ geometry.id ];

  		const attribute = wireframeAttributes.get( geometry );

  		if ( attribute ) {

  			attributes.remove( attribute );
  			wireframeAttributes.delete( geometry );

  		}

  		bindingStates.releaseStatesOfGeometry( geometry );

  		if ( geometry.isInstancedBufferGeometry === true ) {

  			delete geometry._maxInstanceCount;

  		}

  		//

  		info.memory.geometries --;

  	}

  	function get( object, geometry ) {

  		if ( geometries[ geometry.id ] === true ) return geometry;

  		geometry.addEventListener( 'dispose', onGeometryDispose );

  		geometries[ geometry.id ] = true;

  		info.memory.geometries ++;

  		return geometry;

  	}

  	function update( geometry ) {

  		const geometryAttributes = geometry.attributes;

  		// Updating index buffer in VAO now. See WebGLBindingStates.

  		for ( const name in geometryAttributes ) {

  			attributes.update( geometryAttributes[ name ], gl.ARRAY_BUFFER );

  		}

  		// morph targets

  		const morphAttributes = geometry.morphAttributes;

  		for ( const name in morphAttributes ) {

  			const array = morphAttributes[ name ];

  			for ( let i = 0, l = array.length; i < l; i ++ ) {

  				attributes.update( array[ i ], gl.ARRAY_BUFFER );

  			}

  		}

  	}

  	function updateWireframeAttribute( geometry ) {

  		const indices = [];

  		const geometryIndex = geometry.index;
  		const geometryPosition = geometry.attributes.position;
  		let version = 0;

  		if ( geometryIndex !== null ) {

  			const array = geometryIndex.array;
  			version = geometryIndex.version;

  			for ( let i = 0, l = array.length; i < l; i += 3 ) {

  				const a = array[ i + 0 ];
  				const b = array[ i + 1 ];
  				const c = array[ i + 2 ];

  				indices.push( a, b, b, c, c, a );

  			}

  		} else if ( geometryPosition !== undefined ) {

  			const array = geometryPosition.array;
  			version = geometryPosition.version;

  			for ( let i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {

  				const a = i + 0;
  				const b = i + 1;
  				const c = i + 2;

  				indices.push( a, b, b, c, c, a );

  			}

  		} else {

  			return;

  		}

  		const attribute = new ( arrayNeedsUint32( indices ) ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 );
  		attribute.version = version;

  		// Updating index buffer in VAO now. See WebGLBindingStates

  		//

  		const previousAttribute = wireframeAttributes.get( geometry );

  		if ( previousAttribute ) attributes.remove( previousAttribute );

  		//

  		wireframeAttributes.set( geometry, attribute );

  	}

  	function getWireframeAttribute( geometry ) {

  		const currentAttribute = wireframeAttributes.get( geometry );

  		if ( currentAttribute ) {

  			const geometryIndex = geometry.index;

  			if ( geometryIndex !== null ) {

  				// if the attribute is obsolete, create a new one

  				if ( currentAttribute.version < geometryIndex.version ) {

  					updateWireframeAttribute( geometry );

  				}

  			}

  		} else {

  			updateWireframeAttribute( geometry );

  		}

  		return wireframeAttributes.get( geometry );

  	}

  	return {

  		get: get,
  		update: update,

  		getWireframeAttribute: getWireframeAttribute

  	};

  }

  function WebGLIndexedBufferRenderer( gl, extensions, info ) {

  	let mode;

  	function setMode( value ) {

  		mode = value;

  	}

  	let type, bytesPerElement;

  	function setIndex( value ) {

  		type = value.type;
  		bytesPerElement = value.bytesPerElement;

  	}

  	function render( start, count ) {

  		gl.drawElements( mode, count, type, start * bytesPerElement );

  		info.update( count, mode, 1 );

  	}

  	function renderInstances( start, count, primcount ) {

  		if ( primcount === 0 ) return;

  		gl.drawElementsInstanced( mode, count, type, start * bytesPerElement, primcount );

  		info.update( count, mode, primcount );

  	}

  	function renderMultiDraw( starts, counts, drawCount ) {

  		if ( drawCount === 0 ) return;

  		const extension = extensions.get( 'WEBGL_multi_draw' );
  		extension.multiDrawElementsWEBGL( mode, counts, 0, type, starts, 0, drawCount );

  		let elementCount = 0;
  		for ( let i = 0; i < drawCount; i ++ ) {

  			elementCount += counts[ i ];

  		}

  		info.update( elementCount, mode, 1 );


  	}

  	function renderMultiDrawInstances( starts, counts, drawCount, primcount ) {

  		if ( drawCount === 0 ) return;

  		const extension = extensions.get( 'WEBGL_multi_draw' );

  		if ( extension === null ) {

  			for ( let i = 0; i < starts.length; i ++ ) {

  				renderInstances( starts[ i ] / bytesPerElement, counts[ i ], primcount[ i ] );

  			}

  		} else {

  			extension.multiDrawElementsInstancedWEBGL( mode, counts, 0, type, starts, 0, primcount, 0, drawCount );

  			let elementCount = 0;
  			for ( let i = 0; i < drawCount; i ++ ) {

  				elementCount += counts[ i ];

  			}

  			for ( let i = 0; i < primcount.length; i ++ ) {

  				info.update( elementCount, mode, primcount[ i ] );

  			}

  		}

  	}

  	//

  	this.setMode = setMode;
  	this.setIndex = setIndex;
  	this.render = render;
  	this.renderInstances = renderInstances;
  	this.renderMultiDraw = renderMultiDraw;
  	this.renderMultiDrawInstances = renderMultiDrawInstances;

  }

  function WebGLInfo( gl ) {

  	const memory = {
  		geometries: 0,
  		textures: 0
  	};

  	const render = {
  		frame: 0,
  		calls: 0,
  		triangles: 0,
  		points: 0,
  		lines: 0
  	};

  	function update( count, mode, instanceCount ) {

  		render.calls ++;

  		switch ( mode ) {

  			case gl.TRIANGLES:
  				render.triangles += instanceCount * ( count / 3 );
  				break;

  			case gl.LINES:
  				render.lines += instanceCount * ( count / 2 );
  				break;

  			case gl.LINE_STRIP:
  				render.lines += instanceCount * ( count - 1 );
  				break;

  			case gl.LINE_LOOP:
  				render.lines += instanceCount * count;
  				break;

  			case gl.POINTS:
  				render.points += instanceCount * count;
  				break;

  			default:
  				console.error( 'THREE.WebGLInfo: Unknown draw mode:', mode );
  				break;

  		}

  	}

  	function reset() {

  		render.calls = 0;
  		render.triangles = 0;
  		render.points = 0;
  		render.lines = 0;

  	}

  	return {
  		memory: memory,
  		render: render,
  		programs: null,
  		autoReset: true,
  		reset: reset,
  		update: update
  	};

  }

  function WebGLMorphtargets( gl, capabilities, textures ) {

  	const morphTextures = new WeakMap();
  	const morph = new Vector4();

  	function update( object, geometry, program ) {

  		const objectInfluences = object.morphTargetInfluences;

  		// the following encodes morph targets into an array of data textures. Each layer represents a single morph target.

  		const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
  		const morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;

  		let entry = morphTextures.get( geometry );

  		if ( entry === undefined || entry.count !== morphTargetsCount ) {

  			if ( entry !== undefined ) entry.texture.dispose();

  			const hasMorphPosition = geometry.morphAttributes.position !== undefined;
  			const hasMorphNormals = geometry.morphAttributes.normal !== undefined;
  			const hasMorphColors = geometry.morphAttributes.color !== undefined;

  			const morphTargets = geometry.morphAttributes.position || [];
  			const morphNormals = geometry.morphAttributes.normal || [];
  			const morphColors = geometry.morphAttributes.color || [];

  			let vertexDataCount = 0;

  			if ( hasMorphPosition === true ) vertexDataCount = 1;
  			if ( hasMorphNormals === true ) vertexDataCount = 2;
  			if ( hasMorphColors === true ) vertexDataCount = 3;

  			let width = geometry.attributes.position.count * vertexDataCount;
  			let height = 1;

  			if ( width > capabilities.maxTextureSize ) {

  				height = Math.ceil( width / capabilities.maxTextureSize );
  				width = capabilities.maxTextureSize;

  			}

  			const buffer = new Float32Array( width * height * 4 * morphTargetsCount );

  			const texture = new DataArrayTexture( buffer, width, height, morphTargetsCount );
  			texture.type = FloatType;
  			texture.needsUpdate = true;

  			// fill buffer

  			const vertexDataStride = vertexDataCount * 4;

  			for ( let i = 0; i < morphTargetsCount; i ++ ) {

  				const morphTarget = morphTargets[ i ];
  				const morphNormal = morphNormals[ i ];
  				const morphColor = morphColors[ i ];

  				const offset = width * height * 4 * i;

  				for ( let j = 0; j < morphTarget.count; j ++ ) {

  					const stride = j * vertexDataStride;

  					if ( hasMorphPosition === true ) {

  						morph.fromBufferAttribute( morphTarget, j );

  						buffer[ offset + stride + 0 ] = morph.x;
  						buffer[ offset + stride + 1 ] = morph.y;
  						buffer[ offset + stride + 2 ] = morph.z;
  						buffer[ offset + stride + 3 ] = 0;

  					}

  					if ( hasMorphNormals === true ) {

  						morph.fromBufferAttribute( morphNormal, j );

  						buffer[ offset + stride + 4 ] = morph.x;
  						buffer[ offset + stride + 5 ] = morph.y;
  						buffer[ offset + stride + 6 ] = morph.z;
  						buffer[ offset + stride + 7 ] = 0;

  					}

  					if ( hasMorphColors === true ) {

  						morph.fromBufferAttribute( morphColor, j );

  						buffer[ offset + stride + 8 ] = morph.x;
  						buffer[ offset + stride + 9 ] = morph.y;
  						buffer[ offset + stride + 10 ] = morph.z;
  						buffer[ offset + stride + 11 ] = ( morphColor.itemSize === 4 ) ? morph.w : 1;

  					}

  				}

  			}

  			entry = {
  				count: morphTargetsCount,
  				texture: texture,
  				size: new Vector2( width, height )
  			};

  			morphTextures.set( geometry, entry );

  			function disposeTexture() {

  				texture.dispose();

  				morphTextures.delete( geometry );

  				geometry.removeEventListener( 'dispose', disposeTexture );

  			}

  			geometry.addEventListener( 'dispose', disposeTexture );

  		}

  		//
  		if ( object.isInstancedMesh === true && object.morphTexture !== null ) {

  			program.getUniforms().setValue( gl, 'morphTexture', object.morphTexture, textures );

  		} else {

  			let morphInfluencesSum = 0;

  			for ( let i = 0; i < objectInfluences.length; i ++ ) {

  				morphInfluencesSum += objectInfluences[ i ];

  			}

  			const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;


  			program.getUniforms().setValue( gl, 'morphTargetBaseInfluence', morphBaseInfluence );
  			program.getUniforms().setValue( gl, 'morphTargetInfluences', objectInfluences );

  		}

  		program.getUniforms().setValue( gl, 'morphTargetsTexture', entry.texture, textures );
  		program.getUniforms().setValue( gl, 'morphTargetsTextureSize', entry.size );

  	}

  	return {

  		update: update

  	};

  }

  function WebGLObjects( gl, geometries, attributes, info ) {

  	let updateMap = new WeakMap();

  	function update( object ) {

  		const frame = info.render.frame;

  		const geometry = object.geometry;
  		const buffergeometry = geometries.get( object, geometry );

  		// Update once per frame

  		if ( updateMap.get( buffergeometry ) !== frame ) {

  			geometries.update( buffergeometry );

  			updateMap.set( buffergeometry, frame );

  		}

  		if ( object.isInstancedMesh ) {

  			if ( object.hasEventListener( 'dispose', onInstancedMeshDispose ) === false ) {

  				object.addEventListener( 'dispose', onInstancedMeshDispose );

  			}

  			if ( updateMap.get( object ) !== frame ) {

  				attributes.update( object.instanceMatrix, gl.ARRAY_BUFFER );

  				if ( object.instanceColor !== null ) {

  					attributes.update( object.instanceColor, gl.ARRAY_BUFFER );

  				}

  				updateMap.set( object, frame );

  			}

  		}

  		if ( object.isSkinnedMesh ) {

  			const skeleton = object.skeleton;

  			if ( updateMap.get( skeleton ) !== frame ) {

  				skeleton.update();

  				updateMap.set( skeleton, frame );

  			}

  		}

  		return buffergeometry;

  	}

  	function dispose() {

  		updateMap = new WeakMap();

  	}

  	function onInstancedMeshDispose( event ) {

  		const instancedMesh = event.target;

  		instancedMesh.removeEventListener( 'dispose', onInstancedMeshDispose );

  		attributes.remove( instancedMesh.instanceMatrix );

  		if ( instancedMesh.instanceColor !== null ) attributes.remove( instancedMesh.instanceColor );

  	}

  	return {

  		update: update,
  		dispose: dispose

  	};

  }

  class DepthTexture extends Texture {

  	constructor( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format = DepthFormat ) {

  		if ( format !== DepthFormat && format !== DepthStencilFormat ) {

  			throw new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' );

  		}

  		if ( type === undefined && format === DepthFormat ) type = UnsignedIntType;
  		if ( type === undefined && format === DepthStencilFormat ) type = UnsignedInt248Type;

  		super( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

  		this.isDepthTexture = true;

  		this.image = { width: width, height: height };

  		this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
  		this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

  		this.flipY = false;
  		this.generateMipmaps = false;

  		this.compareFunction = null;

  	}


  	copy( source ) {

  		super.copy( source );

  		this.compareFunction = source.compareFunction;

  		return this;

  	}

  	toJSON( meta ) {

  		const data = super.toJSON( meta );

  		if ( this.compareFunction !== null ) data.compareFunction = this.compareFunction;

  		return data;

  	}

  }

  /**
   * Uniforms of a program.
   * Those form a tree structure with a special top-level container for the root,
   * which you get by calling 'new WebGLUniforms( gl, program )'.
   *
   *
   * Properties of inner nodes including the top-level container:
   *
   * .seq - array of nested uniforms
   * .map - nested uniforms by name
   *
   *
   * Methods of all nodes except the top-level container:
   *
   * .setValue( gl, value, [textures] )
   *
   * 		uploads a uniform value(s)
   *  	the 'textures' parameter is needed for sampler uniforms
   *
   *
   * Static methods of the top-level container (textures factorizations):
   *
   * .upload( gl, seq, values, textures )
   *
   * 		sets uniforms in 'seq' to 'values[id].value'
   *
   * .seqWithValue( seq, values ) : filteredSeq
   *
   * 		filters 'seq' entries with corresponding entry in values
   *
   *
   * Methods of the top-level container (textures factorizations):
   *
   * .setValue( gl, name, value, textures )
   *
   * 		sets uniform with  name 'name' to 'value'
   *
   * .setOptional( gl, obj, prop )
   *
   * 		like .set for an optional property of the object
   *
   */


  const emptyTexture = /*@__PURE__*/ new Texture();

  const emptyShadowTexture = /*@__PURE__*/ new DepthTexture( 1, 1 );

  const emptyArrayTexture = /*@__PURE__*/ new DataArrayTexture();
  const empty3dTexture = /*@__PURE__*/ new Data3DTexture();
  const emptyCubeTexture = /*@__PURE__*/ new CubeTexture();

  // --- Utilities ---

  // Array Caches (provide typed arrays for temporary by size)

  const arrayCacheF32 = [];
  const arrayCacheI32 = [];

  // Float32Array caches used for uploading Matrix uniforms

  const mat4array = new Float32Array( 16 );
  const mat3array = new Float32Array( 9 );
  const mat2array = new Float32Array( 4 );

  // Flattening for arrays of vectors and matrices

  function flatten( array, nBlocks, blockSize ) {

  	const firstElem = array[ 0 ];

  	if ( firstElem <= 0 || firstElem > 0 ) return array;
  	// unoptimized: ! isNaN( firstElem )
  	// see http://jacksondunstan.com/articles/983

  	const n = nBlocks * blockSize;
  	let r = arrayCacheF32[ n ];

  	if ( r === undefined ) {

  		r = new Float32Array( n );
  		arrayCacheF32[ n ] = r;

  	}

  	if ( nBlocks !== 0 ) {

  		firstElem.toArray( r, 0 );

  		for ( let i = 1, offset = 0; i !== nBlocks; ++ i ) {

  			offset += blockSize;
  			array[ i ].toArray( r, offset );

  		}

  	}

  	return r;

  }

  function arraysEqual( a, b ) {

  	if ( a.length !== b.length ) return false;

  	for ( let i = 0, l = a.length; i < l; i ++ ) {

  		if ( a[ i ] !== b[ i ] ) return false;

  	}

  	return true;

  }

  function copyArray( a, b ) {

  	for ( let i = 0, l = b.length; i < l; i ++ ) {

  		a[ i ] = b[ i ];

  	}

  }

  // Texture unit allocation

  function allocTexUnits( textures, n ) {

  	let r = arrayCacheI32[ n ];

  	if ( r === undefined ) {

  		r = new Int32Array( n );
  		arrayCacheI32[ n ] = r;

  	}

  	for ( let i = 0; i !== n; ++ i ) {

  		r[ i ] = textures.allocateTextureUnit();

  	}

  	return r;

  }

  // --- Setters ---

  // Note: Defining these methods externally, because they come in a bunch
  // and this way their names minify.

  // Single scalar

  function setValueV1f( gl, v ) {

  	const cache = this.cache;

  	if ( cache[ 0 ] === v ) return;

  	gl.uniform1f( this.addr, v );

  	cache[ 0 ] = v;

  }

  // Single float vector (from flat array or THREE.VectorN)

  function setValueV2f( gl, v ) {

  	const cache = this.cache;

  	if ( v.x !== undefined ) {

  		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {

  			gl.uniform2f( this.addr, v.x, v.y );

  			cache[ 0 ] = v.x;
  			cache[ 1 ] = v.y;

  		}

  	} else {

  		if ( arraysEqual( cache, v ) ) return;

  		gl.uniform2fv( this.addr, v );

  		copyArray( cache, v );

  	}

  }

  function setValueV3f( gl, v ) {

  	const cache = this.cache;

  	if ( v.x !== undefined ) {

  		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {

  			gl.uniform3f( this.addr, v.x, v.y, v.z );

  			cache[ 0 ] = v.x;
  			cache[ 1 ] = v.y;
  			cache[ 2 ] = v.z;

  		}

  	} else if ( v.r !== undefined ) {

  		if ( cache[ 0 ] !== v.r || cache[ 1 ] !== v.g || cache[ 2 ] !== v.b ) {

  			gl.uniform3f( this.addr, v.r, v.g, v.b );

  			cache[ 0 ] = v.r;
  			cache[ 1 ] = v.g;
  			cache[ 2 ] = v.b;

  		}

  	} else {

  		if ( arraysEqual( cache, v ) ) return;

  		gl.uniform3fv( this.addr, v );

  		copyArray( cache, v );

  	}

  }

  function setValueV4f( gl, v ) {

  	const cache = this.cache;

  	if ( v.x !== undefined ) {

  		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {

  			gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );

  			cache[ 0 ] = v.x;
  			cache[ 1 ] = v.y;
  			cache[ 2 ] = v.z;
  			cache[ 3 ] = v.w;

  		}

  	} else {

  		if ( arraysEqual( cache, v ) ) return;

  		gl.uniform4fv( this.addr, v );

  		copyArray( cache, v );

  	}

  }

  // Single matrix (from flat array or THREE.MatrixN)

  function setValueM2( gl, v ) {

  	const cache = this.cache;
  	const elements = v.elements;

  	if ( elements === undefined ) {

  		if ( arraysEqual( cache, v ) ) return;

  		gl.uniformMatrix2fv( this.addr, false, v );

  		copyArray( cache, v );

  	} else {

  		if ( arraysEqual( cache, elements ) ) return;

  		mat2array.set( elements );

  		gl.uniformMatrix2fv( this.addr, false, mat2array );

  		copyArray( cache, elements );

  	}

  }

  function setValueM3( gl, v ) {

  	const cache = this.cache;
  	const elements = v.elements;

  	if ( elements === undefined ) {

  		if ( arraysEqual( cache, v ) ) return;

  		gl.uniformMatrix3fv( this.addr, false, v );

  		copyArray( cache, v );

  	} else {

  		if ( arraysEqual( cache, elements ) ) return;

  		mat3array.set( elements );

  		gl.uniformMatrix3fv( this.addr, false, mat3array );

  		copyArray( cache, elements );

  	}

  }

  function setValueM4( gl, v ) {

  	const cache = this.cache;
  	const elements = v.elements;

  	if ( elements === undefined ) {

  		if ( arraysEqual( cache, v ) ) return;

  		gl.uniformMatrix4fv( this.addr, false, v );

  		copyArray( cache, v );

  	} else {

  		if ( arraysEqual( cache, elements ) ) return;

  		mat4array.set( elements );

  		gl.uniformMatrix4fv( this.addr, false, mat4array );

  		copyArray( cache, elements );

  	}

  }

  // Single integer / boolean

  function setValueV1i( gl, v ) {

  	const cache = this.cache;

  	if ( cache[ 0 ] === v ) return;

  	gl.uniform1i( this.addr, v );

  	cache[ 0 ] = v;

  }

  // Single integer / boolean vector (from flat array or THREE.VectorN)

  function setValueV2i( gl, v ) {

  	const cache = this.cache;

  	if ( v.x !== undefined ) {

  		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {

  			gl.uniform2i( this.addr, v.x, v.y );

  			cache[ 0 ] = v.x;
  			cache[ 1 ] = v.y;

  		}

  	} else {

  		if ( arraysEqual( cache, v ) ) return;

  		gl.uniform2iv( this.addr, v );

  		copyArray( cache, v );

  	}

  }

  function setValueV3i( gl, v ) {

  	const cache = this.cache;

  	if ( v.x !== undefined ) {

  		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {

  			gl.uniform3i( this.addr, v.x, v.y, v.z );

  			cache[ 0 ] = v.x;
  			cache[ 1 ] = v.y;
  			cache[ 2 ] = v.z;

  		}

  	} else {

  		if ( arraysEqual( cache, v ) ) return;

  		gl.uniform3iv( this.addr, v );

  		copyArray( cache, v );

  	}

  }

  function setValueV4i( gl, v ) {

  	const cache = this.cache;

  	if ( v.x !== undefined ) {

  		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {

  			gl.uniform4i( this.addr, v.x, v.y, v.z, v.w );

  			cache[ 0 ] = v.x;
  			cache[ 1 ] = v.y;
  			cache[ 2 ] = v.z;
  			cache[ 3 ] = v.w;

  		}

  	} else {

  		if ( arraysEqual( cache, v ) ) return;

  		gl.uniform4iv( this.addr, v );

  		copyArray( cache, v );

  	}

  }

  // Single unsigned integer

  function setValueV1ui( gl, v ) {

  	const cache = this.cache;

  	if ( cache[ 0 ] === v ) return;

  	gl.uniform1ui( this.addr, v );

  	cache[ 0 ] = v;

  }

  // Single unsigned integer vector (from flat array or THREE.VectorN)

  function setValueV2ui( gl, v ) {

  	const cache = this.cache;

  	if ( v.x !== undefined ) {

  		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {

  			gl.uniform2ui( this.addr, v.x, v.y );

  			cache[ 0 ] = v.x;
  			cache[ 1 ] = v.y;

  		}

  	} else {

  		if ( arraysEqual( cache, v ) ) return;

  		gl.uniform2uiv( this.addr, v );

  		copyArray( cache, v );

  	}

  }

  function setValueV3ui( gl, v ) {

  	const cache = this.cache;

  	if ( v.x !== undefined ) {

  		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {

  			gl.uniform3ui( this.addr, v.x, v.y, v.z );

  			cache[ 0 ] = v.x;
  			cache[ 1 ] = v.y;
  			cache[ 2 ] = v.z;

  		}

  	} else {

  		if ( arraysEqual( cache, v ) ) return;

  		gl.uniform3uiv( this.addr, v );

  		copyArray( cache, v );

  	}

  }

  function setValueV4ui( gl, v ) {

  	const cache = this.cache;

  	if ( v.x !== undefined ) {

  		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {

  			gl.uniform4ui( this.addr, v.x, v.y, v.z, v.w );

  			cache[ 0 ] = v.x;
  			cache[ 1 ] = v.y;
  			cache[ 2 ] = v.z;
  			cache[ 3 ] = v.w;

  		}

  	} else {

  		if ( arraysEqual( cache, v ) ) return;

  		gl.uniform4uiv( this.addr, v );

  		copyArray( cache, v );

  	}

  }


  // Single texture (2D / Cube)

  function setValueT1( gl, v, textures ) {

  	const cache = this.cache;
  	const unit = textures.allocateTextureUnit();

  	if ( cache[ 0 ] !== unit ) {

  		gl.uniform1i( this.addr, unit );
  		cache[ 0 ] = unit;

  	}

  	let emptyTexture2D;

  	if ( this.type === gl.SAMPLER_2D_SHADOW ) {

  		emptyShadowTexture.compareFunction = LessEqualCompare; // #28670
  		emptyTexture2D = emptyShadowTexture;

  	} else {

  		emptyTexture2D = emptyTexture;

  	}

  	textures.setTexture2D( v || emptyTexture2D, unit );

  }

  function setValueT3D1( gl, v, textures ) {

  	const cache = this.cache;
  	const unit = textures.allocateTextureUnit();

  	if ( cache[ 0 ] !== unit ) {

  		gl.uniform1i( this.addr, unit );
  		cache[ 0 ] = unit;

  	}

  	textures.setTexture3D( v || empty3dTexture, unit );

  }

  function setValueT6( gl, v, textures ) {

  	const cache = this.cache;
  	const unit = textures.allocateTextureUnit();

  	if ( cache[ 0 ] !== unit ) {

  		gl.uniform1i( this.addr, unit );
  		cache[ 0 ] = unit;

  	}

  	textures.setTextureCube( v || emptyCubeTexture, unit );

  }

  function setValueT2DArray1( gl, v, textures ) {

  	const cache = this.cache;
  	const unit = textures.allocateTextureUnit();

  	if ( cache[ 0 ] !== unit ) {

  		gl.uniform1i( this.addr, unit );
  		cache[ 0 ] = unit;

  	}

  	textures.setTexture2DArray( v || emptyArrayTexture, unit );

  }

  // Helper to pick the right setter for the singular case

  function getSingularSetter( type ) {

  	switch ( type ) {

  		case 0x1406: return setValueV1f; // FLOAT
  		case 0x8b50: return setValueV2f; // _VEC2
  		case 0x8b51: return setValueV3f; // _VEC3
  		case 0x8b52: return setValueV4f; // _VEC4

  		case 0x8b5a: return setValueM2; // _MAT2
  		case 0x8b5b: return setValueM3; // _MAT3
  		case 0x8b5c: return setValueM4; // _MAT4

  		case 0x1404: case 0x8b56: return setValueV1i; // INT, BOOL
  		case 0x8b53: case 0x8b57: return setValueV2i; // _VEC2
  		case 0x8b54: case 0x8b58: return setValueV3i; // _VEC3
  		case 0x8b55: case 0x8b59: return setValueV4i; // _VEC4

  		case 0x1405: return setValueV1ui; // UINT
  		case 0x8dc6: return setValueV2ui; // _VEC2
  		case 0x8dc7: return setValueV3ui; // _VEC3
  		case 0x8dc8: return setValueV4ui; // _VEC4

  		case 0x8b5e: // SAMPLER_2D
  		case 0x8d66: // SAMPLER_EXTERNAL_OES
  		case 0x8dca: // INT_SAMPLER_2D
  		case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
  		case 0x8b62: // SAMPLER_2D_SHADOW
  			return setValueT1;

  		case 0x8b5f: // SAMPLER_3D
  		case 0x8dcb: // INT_SAMPLER_3D
  		case 0x8dd3: // UNSIGNED_INT_SAMPLER_3D
  			return setValueT3D1;

  		case 0x8b60: // SAMPLER_CUBE
  		case 0x8dcc: // INT_SAMPLER_CUBE
  		case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
  		case 0x8dc5: // SAMPLER_CUBE_SHADOW
  			return setValueT6;

  		case 0x8dc1: // SAMPLER_2D_ARRAY
  		case 0x8dcf: // INT_SAMPLER_2D_ARRAY
  		case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY
  		case 0x8dc4: // SAMPLER_2D_ARRAY_SHADOW
  			return setValueT2DArray1;

  	}

  }


  // Array of scalars

  function setValueV1fArray( gl, v ) {

  	gl.uniform1fv( this.addr, v );

  }

  // Array of vectors (from flat array or array of THREE.VectorN)

  function setValueV2fArray( gl, v ) {

  	const data = flatten( v, this.size, 2 );

  	gl.uniform2fv( this.addr, data );

  }

  function setValueV3fArray( gl, v ) {

  	const data = flatten( v, this.size, 3 );

  	gl.uniform3fv( this.addr, data );

  }

  function setValueV4fArray( gl, v ) {

  	const data = flatten( v, this.size, 4 );

  	gl.uniform4fv( this.addr, data );

  }

  // Array of matrices (from flat array or array of THREE.MatrixN)

  function setValueM2Array( gl, v ) {

  	const data = flatten( v, this.size, 4 );

  	gl.uniformMatrix2fv( this.addr, false, data );

  }

  function setValueM3Array( gl, v ) {

  	const data = flatten( v, this.size, 9 );

  	gl.uniformMatrix3fv( this.addr, false, data );

  }

  function setValueM4Array( gl, v ) {

  	const data = flatten( v, this.size, 16 );

  	gl.uniformMatrix4fv( this.addr, false, data );

  }

  // Array of integer / boolean

  function setValueV1iArray( gl, v ) {

  	gl.uniform1iv( this.addr, v );

  }

  // Array of integer / boolean vectors (from flat array)

  function setValueV2iArray( gl, v ) {

  	gl.uniform2iv( this.addr, v );

  }

  function setValueV3iArray( gl, v ) {

  	gl.uniform3iv( this.addr, v );

  }

  function setValueV4iArray( gl, v ) {

  	gl.uniform4iv( this.addr, v );

  }

  // Array of unsigned integer

  function setValueV1uiArray( gl, v ) {

  	gl.uniform1uiv( this.addr, v );

  }

  // Array of unsigned integer vectors (from flat array)

  function setValueV2uiArray( gl, v ) {

  	gl.uniform2uiv( this.addr, v );

  }

  function setValueV3uiArray( gl, v ) {

  	gl.uniform3uiv( this.addr, v );

  }

  function setValueV4uiArray( gl, v ) {

  	gl.uniform4uiv( this.addr, v );

  }


  // Array of textures (2D / 3D / Cube / 2DArray)

  function setValueT1Array( gl, v, textures ) {

  	const cache = this.cache;

  	const n = v.length;

  	const units = allocTexUnits( textures, n );

  	if ( ! arraysEqual( cache, units ) ) {

  		gl.uniform1iv( this.addr, units );

  		copyArray( cache, units );

  	}

  	for ( let i = 0; i !== n; ++ i ) {

  		textures.setTexture2D( v[ i ] || emptyTexture, units[ i ] );

  	}

  }

  function setValueT3DArray( gl, v, textures ) {

  	const cache = this.cache;

  	const n = v.length;

  	const units = allocTexUnits( textures, n );

  	if ( ! arraysEqual( cache, units ) ) {

  		gl.uniform1iv( this.addr, units );

  		copyArray( cache, units );

  	}

  	for ( let i = 0; i !== n; ++ i ) {

  		textures.setTexture3D( v[ i ] || empty3dTexture, units[ i ] );

  	}

  }

  function setValueT6Array( gl, v, textures ) {

  	const cache = this.cache;

  	const n = v.length;

  	const units = allocTexUnits( textures, n );

  	if ( ! arraysEqual( cache, units ) ) {

  		gl.uniform1iv( this.addr, units );

  		copyArray( cache, units );

  	}

  	for ( let i = 0; i !== n; ++ i ) {

  		textures.setTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );

  	}

  }

  function setValueT2DArrayArray( gl, v, textures ) {

  	const cache = this.cache;

  	const n = v.length;

  	const units = allocTexUnits( textures, n );

  	if ( ! arraysEqual( cache, units ) ) {

  		gl.uniform1iv( this.addr, units );

  		copyArray( cache, units );

  	}

  	for ( let i = 0; i !== n; ++ i ) {

  		textures.setTexture2DArray( v[ i ] || emptyArrayTexture, units[ i ] );

  	}

  }


  // Helper to pick the right setter for a pure (bottom-level) array

  function getPureArraySetter( type ) {

  	switch ( type ) {

  		case 0x1406: return setValueV1fArray; // FLOAT
  		case 0x8b50: return setValueV2fArray; // _VEC2
  		case 0x8b51: return setValueV3fArray; // _VEC3
  		case 0x8b52: return setValueV4fArray; // _VEC4

  		case 0x8b5a: return setValueM2Array; // _MAT2
  		case 0x8b5b: return setValueM3Array; // _MAT3
  		case 0x8b5c: return setValueM4Array; // _MAT4

  		case 0x1404: case 0x8b56: return setValueV1iArray; // INT, BOOL
  		case 0x8b53: case 0x8b57: return setValueV2iArray; // _VEC2
  		case 0x8b54: case 0x8b58: return setValueV3iArray; // _VEC3
  		case 0x8b55: case 0x8b59: return setValueV4iArray; // _VEC4

  		case 0x1405: return setValueV1uiArray; // UINT
  		case 0x8dc6: return setValueV2uiArray; // _VEC2
  		case 0x8dc7: return setValueV3uiArray; // _VEC3
  		case 0x8dc8: return setValueV4uiArray; // _VEC4

  		case 0x8b5e: // SAMPLER_2D
  		case 0x8d66: // SAMPLER_EXTERNAL_OES
  		case 0x8dca: // INT_SAMPLER_2D
  		case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
  		case 0x8b62: // SAMPLER_2D_SHADOW
  			return setValueT1Array;

  		case 0x8b5f: // SAMPLER_3D
  		case 0x8dcb: // INT_SAMPLER_3D
  		case 0x8dd3: // UNSIGNED_INT_SAMPLER_3D
  			return setValueT3DArray;

  		case 0x8b60: // SAMPLER_CUBE
  		case 0x8dcc: // INT_SAMPLER_CUBE
  		case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
  		case 0x8dc5: // SAMPLER_CUBE_SHADOW
  			return setValueT6Array;

  		case 0x8dc1: // SAMPLER_2D_ARRAY
  		case 0x8dcf: // INT_SAMPLER_2D_ARRAY
  		case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY
  		case 0x8dc4: // SAMPLER_2D_ARRAY_SHADOW
  			return setValueT2DArrayArray;

  	}

  }

  // --- Uniform Classes ---

  class SingleUniform {

  	constructor( id, activeInfo, addr ) {

  		this.id = id;
  		this.addr = addr;
  		this.cache = [];
  		this.type = activeInfo.type;
  		this.setValue = getSingularSetter( activeInfo.type );

  		// this.path = activeInfo.name; // DEBUG

  	}

  }

  class PureArrayUniform {

  	constructor( id, activeInfo, addr ) {

  		this.id = id;
  		this.addr = addr;
  		this.cache = [];
  		this.type = activeInfo.type;
  		this.size = activeInfo.size;
  		this.setValue = getPureArraySetter( activeInfo.type );

  		// this.path = activeInfo.name; // DEBUG

  	}

  }

  class StructuredUniform {

  	constructor( id ) {

  		this.id = id;

  		this.seq = [];
  		this.map = {};

  	}

  	setValue( gl, value, textures ) {

  		const seq = this.seq;

  		for ( let i = 0, n = seq.length; i !== n; ++ i ) {

  			const u = seq[ i ];
  			u.setValue( gl, value[ u.id ], textures );

  		}

  	}

  }

  // --- Top-level ---

  // Parser - builds up the property tree from the path strings

  const RePathPart = /(\w+)(\])?(\[|\.)?/g;

  // extracts
  // 	- the identifier (member name or array index)
  //  - followed by an optional right bracket (found when array index)
  //  - followed by an optional left bracket or dot (type of subscript)
  //
  // Note: These portions can be read in a non-overlapping fashion and
  // allow straightforward parsing of the hierarchy that WebGL encodes
  // in the uniform names.

  function addUniform( container, uniformObject ) {

  	container.seq.push( uniformObject );
  	container.map[ uniformObject.id ] = uniformObject;

  }

  function parseUniform( activeInfo, addr, container ) {

  	const path = activeInfo.name,
  		pathLength = path.length;

  	// reset RegExp object, because of the early exit of a previous run
  	RePathPart.lastIndex = 0;

  	while ( true ) {

  		const match = RePathPart.exec( path ),
  			matchEnd = RePathPart.lastIndex;

  		let id = match[ 1 ];
  		const idIsIndex = match[ 2 ] === ']',
  			subscript = match[ 3 ];

  		if ( idIsIndex ) id = id | 0; // convert to integer

  		if ( subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength ) {

  			// bare name or "pure" bottom-level array "[0]" suffix

  			addUniform( container, subscript === undefined ?
  				new SingleUniform( id, activeInfo, addr ) :
  				new PureArrayUniform( id, activeInfo, addr ) );

  			break;

  		} else {

  			// step into inner node / create it in case it doesn't exist

  			const map = container.map;
  			let next = map[ id ];

  			if ( next === undefined ) {

  				next = new StructuredUniform( id );
  				addUniform( container, next );

  			}

  			container = next;

  		}

  	}

  }

  // Root Container

  class WebGLUniforms {

  	constructor( gl, program ) {

  		this.seq = [];
  		this.map = {};

  		const n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );

  		for ( let i = 0; i < n; ++ i ) {

  			const info = gl.getActiveUniform( program, i ),
  				addr = gl.getUniformLocation( program, info.name );

  			parseUniform( info, addr, this );

  		}

  	}

  	setValue( gl, name, value, textures ) {

  		const u = this.map[ name ];

  		if ( u !== undefined ) u.setValue( gl, value, textures );

  	}

  	setOptional( gl, object, name ) {

  		const v = object[ name ];

  		if ( v !== undefined ) this.setValue( gl, name, v );

  	}

  	static upload( gl, seq, values, textures ) {

  		for ( let i = 0, n = seq.length; i !== n; ++ i ) {

  			const u = seq[ i ],
  				v = values[ u.id ];

  			if ( v.needsUpdate !== false ) {

  				// note: always updating when .needsUpdate is undefined
  				u.setValue( gl, v.value, textures );

  			}

  		}

  	}

  	static seqWithValue( seq, values ) {

  		const r = [];

  		for ( let i = 0, n = seq.length; i !== n; ++ i ) {

  			const u = seq[ i ];
  			if ( u.id in values ) r.push( u );

  		}

  		return r;

  	}

  }

  function WebGLShader( gl, type, string ) {

  	const shader = gl.createShader( type );

  	gl.shaderSource( shader, string );
  	gl.compileShader( shader );

  	return shader;

  }

  // From https://www.khronos.org/registry/webgl/extensions/KHR_parallel_shader_compile/
  const COMPLETION_STATUS_KHR = 0x91B1;

  let programIdCount = 0;

  function handleSource( string, errorLine ) {

  	const lines = string.split( '\n' );
  	const lines2 = [];

  	const from = Math.max( errorLine - 6, 0 );
  	const to = Math.min( errorLine + 6, lines.length );

  	for ( let i = from; i < to; i ++ ) {

  		const line = i + 1;
  		lines2.push( `${line === errorLine ? '>' : ' '} ${line}: ${lines[ i ]}` );

  	}

  	return lines2.join( '\n' );

  }

  function getEncodingComponents( colorSpace ) {

  	const workingPrimaries = ColorManagement.getPrimaries( ColorManagement.workingColorSpace );
  	const encodingPrimaries = ColorManagement.getPrimaries( colorSpace );

  	let gamutMapping;

  	if ( workingPrimaries === encodingPrimaries ) {

  		gamutMapping = '';

  	} else if ( workingPrimaries === P3Primaries && encodingPrimaries === Rec709Primaries ) {

  		gamutMapping = 'LinearDisplayP3ToLinearSRGB';

  	} else if ( workingPrimaries === Rec709Primaries && encodingPrimaries === P3Primaries ) {

  		gamutMapping = 'LinearSRGBToLinearDisplayP3';

  	}

  	switch ( colorSpace ) {

  		case LinearSRGBColorSpace:
  		case LinearDisplayP3ColorSpace:
  			return [ gamutMapping, 'LinearTransferOETF' ];

  		case SRGBColorSpace:
  		case DisplayP3ColorSpace:
  			return [ gamutMapping, 'sRGBTransferOETF' ];

  		default:
  			console.warn( 'THREE.WebGLProgram: Unsupported color space:', colorSpace );
  			return [ gamutMapping, 'LinearTransferOETF' ];

  	}

  }

  function getShaderErrors( gl, shader, type ) {

  	const status = gl.getShaderParameter( shader, gl.COMPILE_STATUS );
  	const errors = gl.getShaderInfoLog( shader ).trim();

  	if ( status && errors === '' ) return '';

  	const errorMatches = /ERROR: 0:(\d+)/.exec( errors );
  	if ( errorMatches ) {

  		// --enable-privileged-webgl-extension
  		// console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

  		const errorLine = parseInt( errorMatches[ 1 ] );
  		return type.toUpperCase() + '\n\n' + errors + '\n\n' + handleSource( gl.getShaderSource( shader ), errorLine );

  	} else {

  		return errors;

  	}

  }

  function getTexelEncodingFunction( functionName, colorSpace ) {

  	const components = getEncodingComponents( colorSpace );
  	return `vec4 ${functionName}( vec4 value ) { return ${components[ 0 ]}( ${components[ 1 ]}( value ) ); }`;

  }

  function getToneMappingFunction( functionName, toneMapping ) {

  	let toneMappingName;

  	switch ( toneMapping ) {

  		case LinearToneMapping:
  			toneMappingName = 'Linear';
  			break;

  		case ReinhardToneMapping:
  			toneMappingName = 'Reinhard';
  			break;

  		case CineonToneMapping:
  			toneMappingName = 'OptimizedCineon';
  			break;

  		case ACESFilmicToneMapping:
  			toneMappingName = 'ACESFilmic';
  			break;

  		case AgXToneMapping:
  			toneMappingName = 'AgX';
  			break;

  		case NeutralToneMapping:
  			toneMappingName = 'Neutral';
  			break;

  		case CustomToneMapping:
  			toneMappingName = 'Custom';
  			break;

  		default:
  			console.warn( 'THREE.WebGLProgram: Unsupported toneMapping:', toneMapping );
  			toneMappingName = 'Linear';

  	}

  	return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';

  }

  const _v0$1 = /*@__PURE__*/ new Vector3();

  function getLuminanceFunction() {

  	ColorManagement.getLuminanceCoefficients( _v0$1 );

  	const r = _v0$1.x.toFixed( 4 );
  	const g = _v0$1.y.toFixed( 4 );
  	const b = _v0$1.z.toFixed( 4 );

  	return [

  		'float luminance( const in vec3 rgb ) {',

  		`	const vec3 weights = vec3( ${ r }, ${ g }, ${ b } );`,

  		'	return dot( weights, rgb );',

  		'}'

  	].join( '\n' );

  }

  function generateVertexExtensions( parameters ) {

  	const chunks = [
  		parameters.extensionClipCullDistance ? '#extension GL_ANGLE_clip_cull_distance : require' : '',
  		parameters.extensionMultiDraw ? '#extension GL_ANGLE_multi_draw : require' : '',
  	];

  	return chunks.filter( filterEmptyLine ).join( '\n' );

  }

  function generateDefines( defines ) {

  	const chunks = [];

  	for ( const name in defines ) {

  		const value = defines[ name ];

  		if ( value === false ) continue;

  		chunks.push( '#define ' + name + ' ' + value );

  	}

  	return chunks.join( '\n' );

  }

  function fetchAttributeLocations( gl, program ) {

  	const attributes = {};

  	const n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );

  	for ( let i = 0; i < n; i ++ ) {

  		const info = gl.getActiveAttrib( program, i );
  		const name = info.name;

  		let locationSize = 1;
  		if ( info.type === gl.FLOAT_MAT2 ) locationSize = 2;
  		if ( info.type === gl.FLOAT_MAT3 ) locationSize = 3;
  		if ( info.type === gl.FLOAT_MAT4 ) locationSize = 4;

  		// console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );

  		attributes[ name ] = {
  			type: info.type,
  			location: gl.getAttribLocation( program, name ),
  			locationSize: locationSize
  		};

  	}

  	return attributes;

  }

  function filterEmptyLine( string ) {

  	return string !== '';

  }

  function replaceLightNums( string, parameters ) {

  	const numSpotLightCoords = parameters.numSpotLightShadows + parameters.numSpotLightMaps - parameters.numSpotLightShadowsWithMaps;

  	return string
  		.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )
  		.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )
  		.replace( /NUM_SPOT_LIGHT_MAPS/g, parameters.numSpotLightMaps )
  		.replace( /NUM_SPOT_LIGHT_COORDS/g, numSpotLightCoords )
  		.replace( /NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights )
  		.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )
  		.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights )
  		.replace( /NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows )
  		.replace( /NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, parameters.numSpotLightShadowsWithMaps )
  		.replace( /NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows )
  		.replace( /NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows );

  }

  function replaceClippingPlaneNums( string, parameters ) {

  	return string
  		.replace( /NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes )
  		.replace( /UNION_CLIPPING_PLANES/g, ( parameters.numClippingPlanes - parameters.numClipIntersection ) );

  }

  // Resolve Includes

  const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;

  function resolveIncludes( string ) {

  	return string.replace( includePattern, includeReplacer );

  }

  const shaderChunkMap = new Map();

  function includeReplacer( match, include ) {

  	let string = ShaderChunk[ include ];

  	if ( string === undefined ) {

  		const newInclude = shaderChunkMap.get( include );

  		if ( newInclude !== undefined ) {

  			string = ShaderChunk[ newInclude ];
  			console.warn( 'THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', include, newInclude );

  		} else {

  			throw new Error( 'Can not resolve #include <' + include + '>' );

  		}

  	}

  	return resolveIncludes( string );

  }

  // Unroll Loops

  const unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

  function unrollLoops( string ) {

  	return string.replace( unrollLoopPattern, loopReplacer );

  }

  function loopReplacer( match, start, end, snippet ) {

  	let string = '';

  	for ( let i = parseInt( start ); i < parseInt( end ); i ++ ) {

  		string += snippet
  			.replace( /\[\s*i\s*\]/g, '[ ' + i + ' ]' )
  			.replace( /UNROLLED_LOOP_INDEX/g, i );

  	}

  	return string;

  }

  //

  function generatePrecision( parameters ) {

  	let precisionstring = `precision ${parameters.precision} float;
	precision ${parameters.precision} int;
	precision ${parameters.precision} sampler2D;
	precision ${parameters.precision} samplerCube;
	precision ${parameters.precision} sampler3D;
	precision ${parameters.precision} sampler2DArray;
	precision ${parameters.precision} sampler2DShadow;
	precision ${parameters.precision} samplerCubeShadow;
	precision ${parameters.precision} sampler2DArrayShadow;
	precision ${parameters.precision} isampler2D;
	precision ${parameters.precision} isampler3D;
	precision ${parameters.precision} isamplerCube;
	precision ${parameters.precision} isampler2DArray;
	precision ${parameters.precision} usampler2D;
	precision ${parameters.precision} usampler3D;
	precision ${parameters.precision} usamplerCube;
	precision ${parameters.precision} usampler2DArray;
	`;

  	if ( parameters.precision === 'highp' ) {

  		precisionstring += '\n#define HIGH_PRECISION';

  	} else if ( parameters.precision === 'mediump' ) {

  		precisionstring += '\n#define MEDIUM_PRECISION';

  	} else if ( parameters.precision === 'lowp' ) {

  		precisionstring += '\n#define LOW_PRECISION';

  	}

  	return precisionstring;

  }

  function generateShadowMapTypeDefine( parameters ) {

  	let shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

  	if ( parameters.shadowMapType === PCFShadowMap ) {

  		shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';

  	} else if ( parameters.shadowMapType === PCFSoftShadowMap ) {

  		shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';

  	} else if ( parameters.shadowMapType === VSMShadowMap ) {

  		shadowMapTypeDefine = 'SHADOWMAP_TYPE_VSM';

  	}

  	return shadowMapTypeDefine;

  }

  function generateEnvMapTypeDefine( parameters ) {

  	let envMapTypeDefine = 'ENVMAP_TYPE_CUBE';

  	if ( parameters.envMap ) {

  		switch ( parameters.envMapMode ) {

  			case CubeReflectionMapping:
  			case CubeRefractionMapping:
  				envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
  				break;

  			case CubeUVReflectionMapping:
  				envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
  				break;

  		}

  	}

  	return envMapTypeDefine;

  }

  function generateEnvMapModeDefine( parameters ) {

  	let envMapModeDefine = 'ENVMAP_MODE_REFLECTION';

  	if ( parameters.envMap ) {

  		switch ( parameters.envMapMode ) {

  			case CubeRefractionMapping:

  				envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
  				break;

  		}

  	}

  	return envMapModeDefine;

  }

  function generateEnvMapBlendingDefine( parameters ) {

  	let envMapBlendingDefine = 'ENVMAP_BLENDING_NONE';

  	if ( parameters.envMap ) {

  		switch ( parameters.combine ) {

  			case MultiplyOperation:
  				envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
  				break;

  			case MixOperation:
  				envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
  				break;

  			case AddOperation:
  				envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
  				break;

  		}

  	}

  	return envMapBlendingDefine;

  }

  function generateCubeUVSize( parameters ) {

  	const imageHeight = parameters.envMapCubeUVHeight;

  	if ( imageHeight === null ) return null;

  	const maxMip = Math.log2( imageHeight ) - 2;

  	const texelHeight = 1.0 / imageHeight;

  	const texelWidth = 1.0 / ( 3 * Math.max( Math.pow( 2, maxMip ), 7 * 16 ) );

  	return { texelWidth, texelHeight, maxMip };

  }

  function WebGLProgram( renderer, cacheKey, parameters, bindingStates ) {

  	// TODO Send this event to Three.js DevTools
  	// console.log( 'WebGLProgram', cacheKey );

  	const gl = renderer.getContext();

  	const defines = parameters.defines;

  	let vertexShader = parameters.vertexShader;
  	let fragmentShader = parameters.fragmentShader;

  	const shadowMapTypeDefine = generateShadowMapTypeDefine( parameters );
  	const envMapTypeDefine = generateEnvMapTypeDefine( parameters );
  	const envMapModeDefine = generateEnvMapModeDefine( parameters );
  	const envMapBlendingDefine = generateEnvMapBlendingDefine( parameters );
  	const envMapCubeUVSize = generateCubeUVSize( parameters );

  	const customVertexExtensions = generateVertexExtensions( parameters );

  	const customDefines = generateDefines( defines );

  	const program = gl.createProgram();

  	let prefixVertex, prefixFragment;
  	let versionString = parameters.glslVersion ? '#version ' + parameters.glslVersion + '\n' : '';

  	if ( parameters.isRawShaderMaterial ) {

  		prefixVertex = [

  			'#define SHADER_TYPE ' + parameters.shaderType,
  			'#define SHADER_NAME ' + parameters.shaderName,

  			customDefines

  		].filter( filterEmptyLine ).join( '\n' );

  		if ( prefixVertex.length > 0 ) {

  			prefixVertex += '\n';

  		}

  		prefixFragment = [

  			'#define SHADER_TYPE ' + parameters.shaderType,
  			'#define SHADER_NAME ' + parameters.shaderName,

  			customDefines

  		].filter( filterEmptyLine ).join( '\n' );

  		if ( prefixFragment.length > 0 ) {

  			prefixFragment += '\n';

  		}

  	} else {

  		prefixVertex = [

  			generatePrecision( parameters ),

  			'#define SHADER_TYPE ' + parameters.shaderType,
  			'#define SHADER_NAME ' + parameters.shaderName,

  			customDefines,

  			parameters.extensionClipCullDistance ? '#define USE_CLIP_DISTANCE' : '',
  			parameters.batching ? '#define USE_BATCHING' : '',
  			parameters.batchingColor ? '#define USE_BATCHING_COLOR' : '',
  			parameters.instancing ? '#define USE_INSTANCING' : '',
  			parameters.instancingColor ? '#define USE_INSTANCING_COLOR' : '',
  			parameters.instancingMorph ? '#define USE_INSTANCING_MORPH' : '',

  			parameters.useFog && parameters.fog ? '#define USE_FOG' : '',
  			parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '',

  			parameters.map ? '#define USE_MAP' : '',
  			parameters.envMap ? '#define USE_ENVMAP' : '',
  			parameters.envMap ? '#define ' + envMapModeDefine : '',
  			parameters.lightMap ? '#define USE_LIGHTMAP' : '',
  			parameters.aoMap ? '#define USE_AOMAP' : '',
  			parameters.bumpMap ? '#define USE_BUMPMAP' : '',
  			parameters.normalMap ? '#define USE_NORMALMAP' : '',
  			parameters.normalMapObjectSpace ? '#define USE_NORMALMAP_OBJECTSPACE' : '',
  			parameters.normalMapTangentSpace ? '#define USE_NORMALMAP_TANGENTSPACE' : '',
  			parameters.displacementMap ? '#define USE_DISPLACEMENTMAP' : '',
  			parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',

  			parameters.anisotropy ? '#define USE_ANISOTROPY' : '',
  			parameters.anisotropyMap ? '#define USE_ANISOTROPYMAP' : '',

  			parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
  			parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
  			parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',

  			parameters.iridescenceMap ? '#define USE_IRIDESCENCEMAP' : '',
  			parameters.iridescenceThicknessMap ? '#define USE_IRIDESCENCE_THICKNESSMAP' : '',

  			parameters.specularMap ? '#define USE_SPECULARMAP' : '',
  			parameters.specularColorMap ? '#define USE_SPECULAR_COLORMAP' : '',
  			parameters.specularIntensityMap ? '#define USE_SPECULAR_INTENSITYMAP' : '',

  			parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
  			parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
  			parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
  			parameters.alphaHash ? '#define USE_ALPHAHASH' : '',

  			parameters.transmission ? '#define USE_TRANSMISSION' : '',
  			parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
  			parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '',

  			parameters.sheenColorMap ? '#define USE_SHEEN_COLORMAP' : '',
  			parameters.sheenRoughnessMap ? '#define USE_SHEEN_ROUGHNESSMAP' : '',

  			//

  			parameters.mapUv ? '#define MAP_UV ' + parameters.mapUv : '',
  			parameters.alphaMapUv ? '#define ALPHAMAP_UV ' + parameters.alphaMapUv : '',
  			parameters.lightMapUv ? '#define LIGHTMAP_UV ' + parameters.lightMapUv : '',
  			parameters.aoMapUv ? '#define AOMAP_UV ' + parameters.aoMapUv : '',
  			parameters.emissiveMapUv ? '#define EMISSIVEMAP_UV ' + parameters.emissiveMapUv : '',
  			parameters.bumpMapUv ? '#define BUMPMAP_UV ' + parameters.bumpMapUv : '',
  			parameters.normalMapUv ? '#define NORMALMAP_UV ' + parameters.normalMapUv : '',
  			parameters.displacementMapUv ? '#define DISPLACEMENTMAP_UV ' + parameters.displacementMapUv : '',

  			parameters.metalnessMapUv ? '#define METALNESSMAP_UV ' + parameters.metalnessMapUv : '',
  			parameters.roughnessMapUv ? '#define ROUGHNESSMAP_UV ' + parameters.roughnessMapUv : '',

  			parameters.anisotropyMapUv ? '#define ANISOTROPYMAP_UV ' + parameters.anisotropyMapUv : '',

  			parameters.clearcoatMapUv ? '#define CLEARCOATMAP_UV ' + parameters.clearcoatMapUv : '',
  			parameters.clearcoatNormalMapUv ? '#define CLEARCOAT_NORMALMAP_UV ' + parameters.clearcoatNormalMapUv : '',
  			parameters.clearcoatRoughnessMapUv ? '#define CLEARCOAT_ROUGHNESSMAP_UV ' + parameters.clearcoatRoughnessMapUv : '',

  			parameters.iridescenceMapUv ? '#define IRIDESCENCEMAP_UV ' + parameters.iridescenceMapUv : '',
  			parameters.iridescenceThicknessMapUv ? '#define IRIDESCENCE_THICKNESSMAP_UV ' + parameters.iridescenceThicknessMapUv : '',

  			parameters.sheenColorMapUv ? '#define SHEEN_COLORMAP_UV ' + parameters.sheenColorMapUv : '',
  			parameters.sheenRoughnessMapUv ? '#define SHEEN_ROUGHNESSMAP_UV ' + parameters.sheenRoughnessMapUv : '',

  			parameters.specularMapUv ? '#define SPECULARMAP_UV ' + parameters.specularMapUv : '',
  			parameters.specularColorMapUv ? '#define SPECULAR_COLORMAP_UV ' + parameters.specularColorMapUv : '',
  			parameters.specularIntensityMapUv ? '#define SPECULAR_INTENSITYMAP_UV ' + parameters.specularIntensityMapUv : '',

  			parameters.transmissionMapUv ? '#define TRANSMISSIONMAP_UV ' + parameters.transmissionMapUv : '',
  			parameters.thicknessMapUv ? '#define THICKNESSMAP_UV ' + parameters.thicknessMapUv : '',

  			//

  			parameters.vertexTangents && parameters.flatShading === false ? '#define USE_TANGENT' : '',
  			parameters.vertexColors ? '#define USE_COLOR' : '',
  			parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
  			parameters.vertexUv1s ? '#define USE_UV1' : '',
  			parameters.vertexUv2s ? '#define USE_UV2' : '',
  			parameters.vertexUv3s ? '#define USE_UV3' : '',

  			parameters.pointsUvs ? '#define USE_POINTS_UV' : '',

  			parameters.flatShading ? '#define FLAT_SHADED' : '',

  			parameters.skinning ? '#define USE_SKINNING' : '',

  			parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
  			parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
  			( parameters.morphColors ) ? '#define USE_MORPHCOLORS' : '',
  			( parameters.morphTargetsCount > 0 ) ? '#define MORPHTARGETS_TEXTURE_STRIDE ' + parameters.morphTextureStride : '',
  			( parameters.morphTargetsCount > 0 ) ? '#define MORPHTARGETS_COUNT ' + parameters.morphTargetsCount : '',
  			parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
  			parameters.flipSided ? '#define FLIP_SIDED' : '',

  			parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
  			parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

  			parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',

  			parameters.numLightProbes > 0 ? '#define USE_LIGHT_PROBES' : '',

  			parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',

  			'uniform mat4 modelMatrix;',
  			'uniform mat4 modelViewMatrix;',
  			'uniform mat4 projectionMatrix;',
  			'uniform mat4 viewMatrix;',
  			'uniform mat3 normalMatrix;',
  			'uniform vec3 cameraPosition;',
  			'uniform bool isOrthographic;',

  			'#ifdef USE_INSTANCING',

  			'	attribute mat4 instanceMatrix;',

  			'#endif',

  			'#ifdef USE_INSTANCING_COLOR',

  			'	attribute vec3 instanceColor;',

  			'#endif',

  			'#ifdef USE_INSTANCING_MORPH',

  			'	uniform sampler2D morphTexture;',

  			'#endif',

  			'attribute vec3 position;',
  			'attribute vec3 normal;',
  			'attribute vec2 uv;',

  			'#ifdef USE_UV1',

  			'	attribute vec2 uv1;',

  			'#endif',

  			'#ifdef USE_UV2',

  			'	attribute vec2 uv2;',

  			'#endif',

  			'#ifdef USE_UV3',

  			'	attribute vec2 uv3;',

  			'#endif',

  			'#ifdef USE_TANGENT',

  			'	attribute vec4 tangent;',

  			'#endif',

  			'#if defined( USE_COLOR_ALPHA )',

  			'	attribute vec4 color;',

  			'#elif defined( USE_COLOR )',

  			'	attribute vec3 color;',

  			'#endif',

  			'#ifdef USE_SKINNING',

  			'	attribute vec4 skinIndex;',
  			'	attribute vec4 skinWeight;',

  			'#endif',

  			'\n'

  		].filter( filterEmptyLine ).join( '\n' );

  		prefixFragment = [

  			generatePrecision( parameters ),

  			'#define SHADER_TYPE ' + parameters.shaderType,
  			'#define SHADER_NAME ' + parameters.shaderName,

  			customDefines,

  			parameters.useFog && parameters.fog ? '#define USE_FOG' : '',
  			parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '',

  			parameters.alphaToCoverage ? '#define ALPHA_TO_COVERAGE' : '',
  			parameters.map ? '#define USE_MAP' : '',
  			parameters.matcap ? '#define USE_MATCAP' : '',
  			parameters.envMap ? '#define USE_ENVMAP' : '',
  			parameters.envMap ? '#define ' + envMapTypeDefine : '',
  			parameters.envMap ? '#define ' + envMapModeDefine : '',
  			parameters.envMap ? '#define ' + envMapBlendingDefine : '',
  			envMapCubeUVSize ? '#define CUBEUV_TEXEL_WIDTH ' + envMapCubeUVSize.texelWidth : '',
  			envMapCubeUVSize ? '#define CUBEUV_TEXEL_HEIGHT ' + envMapCubeUVSize.texelHeight : '',
  			envMapCubeUVSize ? '#define CUBEUV_MAX_MIP ' + envMapCubeUVSize.maxMip + '.0' : '',
  			parameters.lightMap ? '#define USE_LIGHTMAP' : '',
  			parameters.aoMap ? '#define USE_AOMAP' : '',
  			parameters.bumpMap ? '#define USE_BUMPMAP' : '',
  			parameters.normalMap ? '#define USE_NORMALMAP' : '',
  			parameters.normalMapObjectSpace ? '#define USE_NORMALMAP_OBJECTSPACE' : '',
  			parameters.normalMapTangentSpace ? '#define USE_NORMALMAP_TANGENTSPACE' : '',
  			parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',

  			parameters.anisotropy ? '#define USE_ANISOTROPY' : '',
  			parameters.anisotropyMap ? '#define USE_ANISOTROPYMAP' : '',

  			parameters.clearcoat ? '#define USE_CLEARCOAT' : '',
  			parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
  			parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
  			parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',

  			parameters.dispersion ? '#define USE_DISPERSION' : '',

  			parameters.iridescence ? '#define USE_IRIDESCENCE' : '',
  			parameters.iridescenceMap ? '#define USE_IRIDESCENCEMAP' : '',
  			parameters.iridescenceThicknessMap ? '#define USE_IRIDESCENCE_THICKNESSMAP' : '',

  			parameters.specularMap ? '#define USE_SPECULARMAP' : '',
  			parameters.specularColorMap ? '#define USE_SPECULAR_COLORMAP' : '',
  			parameters.specularIntensityMap ? '#define USE_SPECULAR_INTENSITYMAP' : '',

  			parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
  			parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',

  			parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
  			parameters.alphaTest ? '#define USE_ALPHATEST' : '',
  			parameters.alphaHash ? '#define USE_ALPHAHASH' : '',

  			parameters.sheen ? '#define USE_SHEEN' : '',
  			parameters.sheenColorMap ? '#define USE_SHEEN_COLORMAP' : '',
  			parameters.sheenRoughnessMap ? '#define USE_SHEEN_ROUGHNESSMAP' : '',

  			parameters.transmission ? '#define USE_TRANSMISSION' : '',
  			parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
  			parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '',

  			parameters.vertexTangents && parameters.flatShading === false ? '#define USE_TANGENT' : '',
  			parameters.vertexColors || parameters.instancingColor || parameters.batchingColor ? '#define USE_COLOR' : '',
  			parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
  			parameters.vertexUv1s ? '#define USE_UV1' : '',
  			parameters.vertexUv2s ? '#define USE_UV2' : '',
  			parameters.vertexUv3s ? '#define USE_UV3' : '',

  			parameters.pointsUvs ? '#define USE_POINTS_UV' : '',

  			parameters.gradientMap ? '#define USE_GRADIENTMAP' : '',

  			parameters.flatShading ? '#define FLAT_SHADED' : '',

  			parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
  			parameters.flipSided ? '#define FLIP_SIDED' : '',

  			parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
  			parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

  			parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',

  			parameters.numLightProbes > 0 ? '#define USE_LIGHT_PROBES' : '',

  			parameters.decodeVideoTexture ? '#define DECODE_VIDEO_TEXTURE' : '',

  			parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',

  			'uniform mat4 viewMatrix;',
  			'uniform vec3 cameraPosition;',
  			'uniform bool isOrthographic;',

  			( parameters.toneMapping !== NoToneMapping ) ? '#define TONE_MAPPING' : '',
  			( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '', // this code is required here because it is used by the toneMapping() function defined below
  			( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( 'toneMapping', parameters.toneMapping ) : '',

  			parameters.dithering ? '#define DITHERING' : '',
  			parameters.opaque ? '#define OPAQUE' : '',

  			ShaderChunk[ 'colorspace_pars_fragment' ], // this code is required here because it is used by the various encoding/decoding function defined below
  			getTexelEncodingFunction( 'linearToOutputTexel', parameters.outputColorSpace ),
  			getLuminanceFunction(),

  			parameters.useDepthPacking ? '#define DEPTH_PACKING ' + parameters.depthPacking : '',

  			'\n'

  		].filter( filterEmptyLine ).join( '\n' );

  	}

  	vertexShader = resolveIncludes( vertexShader );
  	vertexShader = replaceLightNums( vertexShader, parameters );
  	vertexShader = replaceClippingPlaneNums( vertexShader, parameters );

  	fragmentShader = resolveIncludes( fragmentShader );
  	fragmentShader = replaceLightNums( fragmentShader, parameters );
  	fragmentShader = replaceClippingPlaneNums( fragmentShader, parameters );

  	vertexShader = unrollLoops( vertexShader );
  	fragmentShader = unrollLoops( fragmentShader );

  	if ( parameters.isRawShaderMaterial !== true ) {

  		// GLSL 3.0 conversion for built-in materials and ShaderMaterial

  		versionString = '#version 300 es\n';

  		prefixVertex = [
  			customVertexExtensions,
  			'#define attribute in',
  			'#define varying out',
  			'#define texture2D texture'
  		].join( '\n' ) + '\n' + prefixVertex;

  		prefixFragment = [
  			'#define varying in',
  			( parameters.glslVersion === GLSL3 ) ? '' : 'layout(location = 0) out highp vec4 pc_fragColor;',
  			( parameters.glslVersion === GLSL3 ) ? '' : '#define gl_FragColor pc_fragColor',
  			'#define gl_FragDepthEXT gl_FragDepth',
  			'#define texture2D texture',
  			'#define textureCube texture',
  			'#define texture2DProj textureProj',
  			'#define texture2DLodEXT textureLod',
  			'#define texture2DProjLodEXT textureProjLod',
  			'#define textureCubeLodEXT textureLod',
  			'#define texture2DGradEXT textureGrad',
  			'#define texture2DProjGradEXT textureProjGrad',
  			'#define textureCubeGradEXT textureGrad'
  		].join( '\n' ) + '\n' + prefixFragment;

  	}

  	const vertexGlsl = versionString + prefixVertex + vertexShader;
  	const fragmentGlsl = versionString + prefixFragment + fragmentShader;

  	// console.log( '*VERTEX*', vertexGlsl );
  	// console.log( '*FRAGMENT*', fragmentGlsl );

  	const glVertexShader = WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );
  	const glFragmentShader = WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );

  	gl.attachShader( program, glVertexShader );
  	gl.attachShader( program, glFragmentShader );

  	// Force a particular attribute to index 0.

  	if ( parameters.index0AttributeName !== undefined ) {

  		gl.bindAttribLocation( program, 0, parameters.index0AttributeName );

  	} else if ( parameters.morphTargets === true ) {

  		// programs with morphTargets displace position out of attribute 0
  		gl.bindAttribLocation( program, 0, 'position' );

  	}

  	gl.linkProgram( program );

  	function onFirstUse( self ) {

  		// check for link errors
  		if ( renderer.debug.checkShaderErrors ) {

  			const programLog = gl.getProgramInfoLog( program ).trim();
  			const vertexLog = gl.getShaderInfoLog( glVertexShader ).trim();
  			const fragmentLog = gl.getShaderInfoLog( glFragmentShader ).trim();

  			let runnable = true;
  			let haveDiagnostics = true;

  			if ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {

  				runnable = false;

  				if ( typeof renderer.debug.onShaderError === 'function' ) {

  					renderer.debug.onShaderError( gl, program, glVertexShader, glFragmentShader );

  				} else {

  					// default error reporting

  					const vertexErrors = getShaderErrors( gl, glVertexShader, 'vertex' );
  					const fragmentErrors = getShaderErrors( gl, glFragmentShader, 'fragment' );

  					console.error(
  						'THREE.WebGLProgram: Shader Error ' + gl.getError() + ' - ' +
  						'VALIDATE_STATUS ' + gl.getProgramParameter( program, gl.VALIDATE_STATUS ) + '\n\n' +
  						'Material Name: ' + self.name + '\n' +
  						'Material Type: ' + self.type + '\n\n' +
  						'Program Info Log: ' + programLog + '\n' +
  						vertexErrors + '\n' +
  						fragmentErrors
  					);

  				}

  			} else if ( programLog !== '' ) {

  				console.warn( 'THREE.WebGLProgram: Program Info Log:', programLog );

  			} else if ( vertexLog === '' || fragmentLog === '' ) {

  				haveDiagnostics = false;

  			}

  			if ( haveDiagnostics ) {

  				self.diagnostics = {

  					runnable: runnable,

  					programLog: programLog,

  					vertexShader: {

  						log: vertexLog,
  						prefix: prefixVertex

  					},

  					fragmentShader: {

  						log: fragmentLog,
  						prefix: prefixFragment

  					}

  				};

  			}

  		}

  		// Clean up

  		// Crashes in iOS9 and iOS10. #18402
  		// gl.detachShader( program, glVertexShader );
  		// gl.detachShader( program, glFragmentShader );

  		gl.deleteShader( glVertexShader );
  		gl.deleteShader( glFragmentShader );

  		cachedUniforms = new WebGLUniforms( gl, program );
  		cachedAttributes = fetchAttributeLocations( gl, program );

  	}

  	// set up caching for uniform locations

  	let cachedUniforms;

  	this.getUniforms = function () {

  		if ( cachedUniforms === undefined ) {

  			// Populates cachedUniforms and cachedAttributes
  			onFirstUse( this );

  		}

  		return cachedUniforms;

  	};

  	// set up caching for attribute locations

  	let cachedAttributes;

  	this.getAttributes = function () {

  		if ( cachedAttributes === undefined ) {

  			// Populates cachedAttributes and cachedUniforms
  			onFirstUse( this );

  		}

  		return cachedAttributes;

  	};

  	// indicate when the program is ready to be used. if the KHR_parallel_shader_compile extension isn't supported,
  	// flag the program as ready immediately. It may cause a stall when it's first used.

  	let programReady = ( parameters.rendererExtensionParallelShaderCompile === false );

  	this.isReady = function () {

  		if ( programReady === false ) {

  			programReady = gl.getProgramParameter( program, COMPLETION_STATUS_KHR );

  		}

  		return programReady;

  	};

  	// free resource

  	this.destroy = function () {

  		bindingStates.releaseStatesOfProgram( this );

  		gl.deleteProgram( program );
  		this.program = undefined;

  	};

  	//

  	this.type = parameters.shaderType;
  	this.name = parameters.shaderName;
  	this.id = programIdCount ++;
  	this.cacheKey = cacheKey;
  	this.usedTimes = 1;
  	this.program = program;
  	this.vertexShader = glVertexShader;
  	this.fragmentShader = glFragmentShader;

  	return this;

  }

  let _id$1 = 0;

  class WebGLShaderCache {

  	constructor() {

  		this.shaderCache = new Map();
  		this.materialCache = new Map();

  	}

  	update( material ) {

  		const vertexShader = material.vertexShader;
  		const fragmentShader = material.fragmentShader;

  		const vertexShaderStage = this._getShaderStage( vertexShader );
  		const fragmentShaderStage = this._getShaderStage( fragmentShader );

  		const materialShaders = this._getShaderCacheForMaterial( material );

  		if ( materialShaders.has( vertexShaderStage ) === false ) {

  			materialShaders.add( vertexShaderStage );
  			vertexShaderStage.usedTimes ++;

  		}

  		if ( materialShaders.has( fragmentShaderStage ) === false ) {

  			materialShaders.add( fragmentShaderStage );
  			fragmentShaderStage.usedTimes ++;

  		}

  		return this;

  	}

  	remove( material ) {

  		const materialShaders = this.materialCache.get( material );

  		for ( const shaderStage of materialShaders ) {

  			shaderStage.usedTimes --;

  			if ( shaderStage.usedTimes === 0 ) this.shaderCache.delete( shaderStage.code );

  		}

  		this.materialCache.delete( material );

  		return this;

  	}

  	getVertexShaderID( material ) {

  		return this._getShaderStage( material.vertexShader ).id;

  	}

  	getFragmentShaderID( material ) {

  		return this._getShaderStage( material.fragmentShader ).id;

  	}

  	dispose() {

  		this.shaderCache.clear();
  		this.materialCache.clear();

  	}

  	_getShaderCacheForMaterial( material ) {

  		const cache = this.materialCache;
  		let set = cache.get( material );

  		if ( set === undefined ) {

  			set = new Set();
  			cache.set( material, set );

  		}

  		return set;

  	}

  	_getShaderStage( code ) {

  		const cache = this.shaderCache;
  		let stage = cache.get( code );

  		if ( stage === undefined ) {

  			stage = new WebGLShaderStage( code );
  			cache.set( code, stage );

  		}

  		return stage;

  	}

  }

  class WebGLShaderStage {

  	constructor( code ) {

  		this.id = _id$1 ++;

  		this.code = code;
  		this.usedTimes = 0;

  	}

  }

  function WebGLPrograms( renderer, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping ) {

  	const _programLayers = new Layers();
  	const _customShaders = new WebGLShaderCache();
  	const _activeChannels = new Set();
  	const programs = [];

  	const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
  	const SUPPORTS_VERTEX_TEXTURES = capabilities.vertexTextures;

  	let precision = capabilities.precision;

  	const shaderIDs = {
  		MeshDepthMaterial: 'depth',
  		MeshDistanceMaterial: 'distanceRGBA',
  		MeshNormalMaterial: 'normal',
  		MeshBasicMaterial: 'basic',
  		MeshLambertMaterial: 'lambert',
  		MeshPhongMaterial: 'phong',
  		MeshToonMaterial: 'toon',
  		MeshStandardMaterial: 'physical',
  		MeshPhysicalMaterial: 'physical',
  		MeshMatcapMaterial: 'matcap',
  		LineBasicMaterial: 'basic',
  		LineDashedMaterial: 'dashed',
  		PointsMaterial: 'points',
  		ShadowMaterial: 'shadow',
  		SpriteMaterial: 'sprite'
  	};

  	function getChannel( value ) {

  		_activeChannels.add( value );

  		if ( value === 0 ) return 'uv';

  		return `uv${ value }`;

  	}

  	function getParameters( material, lights, shadows, scene, object ) {

  		const fog = scene.fog;
  		const geometry = object.geometry;
  		const environment = material.isMeshStandardMaterial ? scene.environment : null;

  		const envMap = ( material.isMeshStandardMaterial ? cubeuvmaps : cubemaps ).get( material.envMap || environment );
  		const envMapCubeUVHeight = ( !! envMap ) && ( envMap.mapping === CubeUVReflectionMapping ) ? envMap.image.height : null;

  		const shaderID = shaderIDs[ material.type ];

  		// heuristics to create shader parameters according to lights in the scene
  		// (not to blow over maxLights budget)

  		if ( material.precision !== null ) {

  			precision = capabilities.getMaxPrecision( material.precision );

  			if ( precision !== material.precision ) {

  				console.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );

  			}

  		}

  		//

  		const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
  		const morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;

  		let morphTextureStride = 0;

  		if ( geometry.morphAttributes.position !== undefined ) morphTextureStride = 1;
  		if ( geometry.morphAttributes.normal !== undefined ) morphTextureStride = 2;
  		if ( geometry.morphAttributes.color !== undefined ) morphTextureStride = 3;

  		//

  		let vertexShader, fragmentShader;
  		let customVertexShaderID, customFragmentShaderID;

  		if ( shaderID ) {

  			const shader = ShaderLib[ shaderID ];

  			vertexShader = shader.vertexShader;
  			fragmentShader = shader.fragmentShader;

  		} else {

  			vertexShader = material.vertexShader;
  			fragmentShader = material.fragmentShader;

  			_customShaders.update( material );

  			customVertexShaderID = _customShaders.getVertexShaderID( material );
  			customFragmentShaderID = _customShaders.getFragmentShaderID( material );

  		}

  		const currentRenderTarget = renderer.getRenderTarget();

  		const IS_INSTANCEDMESH = object.isInstancedMesh === true;
  		const IS_BATCHEDMESH = object.isBatchedMesh === true;

  		const HAS_MAP = !! material.map;
  		const HAS_MATCAP = !! material.matcap;
  		const HAS_ENVMAP = !! envMap;
  		const HAS_AOMAP = !! material.aoMap;
  		const HAS_LIGHTMAP = !! material.lightMap;
  		const HAS_BUMPMAP = !! material.bumpMap;
  		const HAS_NORMALMAP = !! material.normalMap;
  		const HAS_DISPLACEMENTMAP = !! material.displacementMap;
  		const HAS_EMISSIVEMAP = !! material.emissiveMap;

  		const HAS_METALNESSMAP = !! material.metalnessMap;
  		const HAS_ROUGHNESSMAP = !! material.roughnessMap;

  		const HAS_ANISOTROPY = material.anisotropy > 0;
  		const HAS_CLEARCOAT = material.clearcoat > 0;
  		const HAS_DISPERSION = material.dispersion > 0;
  		const HAS_IRIDESCENCE = material.iridescence > 0;
  		const HAS_SHEEN = material.sheen > 0;
  		const HAS_TRANSMISSION = material.transmission > 0;

  		const HAS_ANISOTROPYMAP = HAS_ANISOTROPY && !! material.anisotropyMap;

  		const HAS_CLEARCOATMAP = HAS_CLEARCOAT && !! material.clearcoatMap;
  		const HAS_CLEARCOAT_NORMALMAP = HAS_CLEARCOAT && !! material.clearcoatNormalMap;
  		const HAS_CLEARCOAT_ROUGHNESSMAP = HAS_CLEARCOAT && !! material.clearcoatRoughnessMap;

  		const HAS_IRIDESCENCEMAP = HAS_IRIDESCENCE && !! material.iridescenceMap;
  		const HAS_IRIDESCENCE_THICKNESSMAP = HAS_IRIDESCENCE && !! material.iridescenceThicknessMap;

  		const HAS_SHEEN_COLORMAP = HAS_SHEEN && !! material.sheenColorMap;
  		const HAS_SHEEN_ROUGHNESSMAP = HAS_SHEEN && !! material.sheenRoughnessMap;

  		const HAS_SPECULARMAP = !! material.specularMap;
  		const HAS_SPECULAR_COLORMAP = !! material.specularColorMap;
  		const HAS_SPECULAR_INTENSITYMAP = !! material.specularIntensityMap;

  		const HAS_TRANSMISSIONMAP = HAS_TRANSMISSION && !! material.transmissionMap;
  		const HAS_THICKNESSMAP = HAS_TRANSMISSION && !! material.thicknessMap;

  		const HAS_GRADIENTMAP = !! material.gradientMap;

  		const HAS_ALPHAMAP = !! material.alphaMap;

  		const HAS_ALPHATEST = material.alphaTest > 0;

  		const HAS_ALPHAHASH = !! material.alphaHash;

  		const HAS_EXTENSIONS = !! material.extensions;

  		let toneMapping = NoToneMapping;

  		if ( material.toneMapped ) {

  			if ( currentRenderTarget === null || currentRenderTarget.isXRRenderTarget === true ) {

  				toneMapping = renderer.toneMapping;

  			}

  		}

  		const parameters = {

  			shaderID: shaderID,
  			shaderType: material.type,
  			shaderName: material.name,

  			vertexShader: vertexShader,
  			fragmentShader: fragmentShader,
  			defines: material.defines,

  			customVertexShaderID: customVertexShaderID,
  			customFragmentShaderID: customFragmentShaderID,

  			isRawShaderMaterial: material.isRawShaderMaterial === true,
  			glslVersion: material.glslVersion,

  			precision: precision,

  			batching: IS_BATCHEDMESH,
  			batchingColor: IS_BATCHEDMESH && object._colorsTexture !== null,
  			instancing: IS_INSTANCEDMESH,
  			instancingColor: IS_INSTANCEDMESH && object.instanceColor !== null,
  			instancingMorph: IS_INSTANCEDMESH && object.morphTexture !== null,

  			supportsVertexTextures: SUPPORTS_VERTEX_TEXTURES,
  			outputColorSpace: ( currentRenderTarget === null ) ? renderer.outputColorSpace : ( currentRenderTarget.isXRRenderTarget === true ? currentRenderTarget.texture.colorSpace : LinearSRGBColorSpace ),
  			alphaToCoverage: !! material.alphaToCoverage,

  			map: HAS_MAP,
  			matcap: HAS_MATCAP,
  			envMap: HAS_ENVMAP,
  			envMapMode: HAS_ENVMAP && envMap.mapping,
  			envMapCubeUVHeight: envMapCubeUVHeight,
  			aoMap: HAS_AOMAP,
  			lightMap: HAS_LIGHTMAP,
  			bumpMap: HAS_BUMPMAP,
  			normalMap: HAS_NORMALMAP,
  			displacementMap: SUPPORTS_VERTEX_TEXTURES && HAS_DISPLACEMENTMAP,
  			emissiveMap: HAS_EMISSIVEMAP,

  			normalMapObjectSpace: HAS_NORMALMAP && material.normalMapType === ObjectSpaceNormalMap,
  			normalMapTangentSpace: HAS_NORMALMAP && material.normalMapType === TangentSpaceNormalMap,

  			metalnessMap: HAS_METALNESSMAP,
  			roughnessMap: HAS_ROUGHNESSMAP,

  			anisotropy: HAS_ANISOTROPY,
  			anisotropyMap: HAS_ANISOTROPYMAP,

  			clearcoat: HAS_CLEARCOAT,
  			clearcoatMap: HAS_CLEARCOATMAP,
  			clearcoatNormalMap: HAS_CLEARCOAT_NORMALMAP,
  			clearcoatRoughnessMap: HAS_CLEARCOAT_ROUGHNESSMAP,

  			dispersion: HAS_DISPERSION,

  			iridescence: HAS_IRIDESCENCE,
  			iridescenceMap: HAS_IRIDESCENCEMAP,
  			iridescenceThicknessMap: HAS_IRIDESCENCE_THICKNESSMAP,

  			sheen: HAS_SHEEN,
  			sheenColorMap: HAS_SHEEN_COLORMAP,
  			sheenRoughnessMap: HAS_SHEEN_ROUGHNESSMAP,

  			specularMap: HAS_SPECULARMAP,
  			specularColorMap: HAS_SPECULAR_COLORMAP,
  			specularIntensityMap: HAS_SPECULAR_INTENSITYMAP,

  			transmission: HAS_TRANSMISSION,
  			transmissionMap: HAS_TRANSMISSIONMAP,
  			thicknessMap: HAS_THICKNESSMAP,

  			gradientMap: HAS_GRADIENTMAP,

  			opaque: material.transparent === false && material.blending === NormalBlending && material.alphaToCoverage === false,

  			alphaMap: HAS_ALPHAMAP,
  			alphaTest: HAS_ALPHATEST,
  			alphaHash: HAS_ALPHAHASH,

  			combine: material.combine,

  			//

  			mapUv: HAS_MAP && getChannel( material.map.channel ),
  			aoMapUv: HAS_AOMAP && getChannel( material.aoMap.channel ),
  			lightMapUv: HAS_LIGHTMAP && getChannel( material.lightMap.channel ),
  			bumpMapUv: HAS_BUMPMAP && getChannel( material.bumpMap.channel ),
  			normalMapUv: HAS_NORMALMAP && getChannel( material.normalMap.channel ),
  			displacementMapUv: HAS_DISPLACEMENTMAP && getChannel( material.displacementMap.channel ),
  			emissiveMapUv: HAS_EMISSIVEMAP && getChannel( material.emissiveMap.channel ),

  			metalnessMapUv: HAS_METALNESSMAP && getChannel( material.metalnessMap.channel ),
  			roughnessMapUv: HAS_ROUGHNESSMAP && getChannel( material.roughnessMap.channel ),

  			anisotropyMapUv: HAS_ANISOTROPYMAP && getChannel( material.anisotropyMap.channel ),

  			clearcoatMapUv: HAS_CLEARCOATMAP && getChannel( material.clearcoatMap.channel ),
  			clearcoatNormalMapUv: HAS_CLEARCOAT_NORMALMAP && getChannel( material.clearcoatNormalMap.channel ),
  			clearcoatRoughnessMapUv: HAS_CLEARCOAT_ROUGHNESSMAP && getChannel( material.clearcoatRoughnessMap.channel ),

  			iridescenceMapUv: HAS_IRIDESCENCEMAP && getChannel( material.iridescenceMap.channel ),
  			iridescenceThicknessMapUv: HAS_IRIDESCENCE_THICKNESSMAP && getChannel( material.iridescenceThicknessMap.channel ),

  			sheenColorMapUv: HAS_SHEEN_COLORMAP && getChannel( material.sheenColorMap.channel ),
  			sheenRoughnessMapUv: HAS_SHEEN_ROUGHNESSMAP && getChannel( material.sheenRoughnessMap.channel ),

  			specularMapUv: HAS_SPECULARMAP && getChannel( material.specularMap.channel ),
  			specularColorMapUv: HAS_SPECULAR_COLORMAP && getChannel( material.specularColorMap.channel ),
  			specularIntensityMapUv: HAS_SPECULAR_INTENSITYMAP && getChannel( material.specularIntensityMap.channel ),

  			transmissionMapUv: HAS_TRANSMISSIONMAP && getChannel( material.transmissionMap.channel ),
  			thicknessMapUv: HAS_THICKNESSMAP && getChannel( material.thicknessMap.channel ),

  			alphaMapUv: HAS_ALPHAMAP && getChannel( material.alphaMap.channel ),

  			//

  			vertexTangents: !! geometry.attributes.tangent && ( HAS_NORMALMAP || HAS_ANISOTROPY ),
  			vertexColors: material.vertexColors,
  			vertexAlphas: material.vertexColors === true && !! geometry.attributes.color && geometry.attributes.color.itemSize === 4,

  			pointsUvs: object.isPoints === true && !! geometry.attributes.uv && ( HAS_MAP || HAS_ALPHAMAP ),

  			fog: !! fog,
  			useFog: material.fog === true,
  			fogExp2: ( !! fog && fog.isFogExp2 ),

  			flatShading: material.flatShading === true,

  			sizeAttenuation: material.sizeAttenuation === true,
  			logarithmicDepthBuffer: logarithmicDepthBuffer,

  			skinning: object.isSkinnedMesh === true,

  			morphTargets: geometry.morphAttributes.position !== undefined,
  			morphNormals: geometry.morphAttributes.normal !== undefined,
  			morphColors: geometry.morphAttributes.color !== undefined,
  			morphTargetsCount: morphTargetsCount,
  			morphTextureStride: morphTextureStride,

  			numDirLights: lights.directional.length,
  			numPointLights: lights.point.length,
  			numSpotLights: lights.spot.length,
  			numSpotLightMaps: lights.spotLightMap.length,
  			numRectAreaLights: lights.rectArea.length,
  			numHemiLights: lights.hemi.length,

  			numDirLightShadows: lights.directionalShadowMap.length,
  			numPointLightShadows: lights.pointShadowMap.length,
  			numSpotLightShadows: lights.spotShadowMap.length,
  			numSpotLightShadowsWithMaps: lights.numSpotLightShadowsWithMaps,

  			numLightProbes: lights.numLightProbes,

  			numClippingPlanes: clipping.numPlanes,
  			numClipIntersection: clipping.numIntersection,

  			dithering: material.dithering,

  			shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
  			shadowMapType: renderer.shadowMap.type,

  			toneMapping: toneMapping,

  			decodeVideoTexture: HAS_MAP && ( material.map.isVideoTexture === true ) && ( ColorManagement.getTransfer( material.map.colorSpace ) === SRGBTransfer ),

  			premultipliedAlpha: material.premultipliedAlpha,

  			doubleSided: material.side === DoubleSide,
  			flipSided: material.side === BackSide,

  			useDepthPacking: material.depthPacking >= 0,
  			depthPacking: material.depthPacking || 0,

  			index0AttributeName: material.index0AttributeName,

  			extensionClipCullDistance: HAS_EXTENSIONS && material.extensions.clipCullDistance === true && extensions.has( 'WEBGL_clip_cull_distance' ),
  			extensionMultiDraw: ( HAS_EXTENSIONS && material.extensions.multiDraw === true || IS_BATCHEDMESH ) && extensions.has( 'WEBGL_multi_draw' ),

  			rendererExtensionParallelShaderCompile: extensions.has( 'KHR_parallel_shader_compile' ),

  			customProgramCacheKey: material.customProgramCacheKey()

  		};

  		// the usage of getChannel() determines the active texture channels for this shader

  		parameters.vertexUv1s = _activeChannels.has( 1 );
  		parameters.vertexUv2s = _activeChannels.has( 2 );
  		parameters.vertexUv3s = _activeChannels.has( 3 );

  		_activeChannels.clear();

  		return parameters;

  	}

  	function getProgramCacheKey( parameters ) {

  		const array = [];

  		if ( parameters.shaderID ) {

  			array.push( parameters.shaderID );

  		} else {

  			array.push( parameters.customVertexShaderID );
  			array.push( parameters.customFragmentShaderID );

  		}

  		if ( parameters.defines !== undefined ) {

  			for ( const name in parameters.defines ) {

  				array.push( name );
  				array.push( parameters.defines[ name ] );

  			}

  		}

  		if ( parameters.isRawShaderMaterial === false ) {

  			getProgramCacheKeyParameters( array, parameters );
  			getProgramCacheKeyBooleans( array, parameters );
  			array.push( renderer.outputColorSpace );

  		}

  		array.push( parameters.customProgramCacheKey );

  		return array.join();

  	}

  	function getProgramCacheKeyParameters( array, parameters ) {

  		array.push( parameters.precision );
  		array.push( parameters.outputColorSpace );
  		array.push( parameters.envMapMode );
  		array.push( parameters.envMapCubeUVHeight );
  		array.push( parameters.mapUv );
  		array.push( parameters.alphaMapUv );
  		array.push( parameters.lightMapUv );
  		array.push( parameters.aoMapUv );
  		array.push( parameters.bumpMapUv );
  		array.push( parameters.normalMapUv );
  		array.push( parameters.displacementMapUv );
  		array.push( parameters.emissiveMapUv );
  		array.push( parameters.metalnessMapUv );
  		array.push( parameters.roughnessMapUv );
  		array.push( parameters.anisotropyMapUv );
  		array.push( parameters.clearcoatMapUv );
  		array.push( parameters.clearcoatNormalMapUv );
  		array.push( parameters.clearcoatRoughnessMapUv );
  		array.push( parameters.iridescenceMapUv );
  		array.push( parameters.iridescenceThicknessMapUv );
  		array.push( parameters.sheenColorMapUv );
  		array.push( parameters.sheenRoughnessMapUv );
  		array.push( parameters.specularMapUv );
  		array.push( parameters.specularColorMapUv );
  		array.push( parameters.specularIntensityMapUv );
  		array.push( parameters.transmissionMapUv );
  		array.push( parameters.thicknessMapUv );
  		array.push( parameters.combine );
  		array.push( parameters.fogExp2 );
  		array.push( parameters.sizeAttenuation );
  		array.push( parameters.morphTargetsCount );
  		array.push( parameters.morphAttributeCount );
  		array.push( parameters.numDirLights );
  		array.push( parameters.numPointLights );
  		array.push( parameters.numSpotLights );
  		array.push( parameters.numSpotLightMaps );
  		array.push( parameters.numHemiLights );
  		array.push( parameters.numRectAreaLights );
  		array.push( parameters.numDirLightShadows );
  		array.push( parameters.numPointLightShadows );
  		array.push( parameters.numSpotLightShadows );
  		array.push( parameters.numSpotLightShadowsWithMaps );
  		array.push( parameters.numLightProbes );
  		array.push( parameters.shadowMapType );
  		array.push( parameters.toneMapping );
  		array.push( parameters.numClippingPlanes );
  		array.push( parameters.numClipIntersection );
  		array.push( parameters.depthPacking );

  	}

  	function getProgramCacheKeyBooleans( array, parameters ) {

  		_programLayers.disableAll();

  		if ( parameters.supportsVertexTextures )
  			_programLayers.enable( 0 );
  		if ( parameters.instancing )
  			_programLayers.enable( 1 );
  		if ( parameters.instancingColor )
  			_programLayers.enable( 2 );
  		if ( parameters.instancingMorph )
  			_programLayers.enable( 3 );
  		if ( parameters.matcap )
  			_programLayers.enable( 4 );
  		if ( parameters.envMap )
  			_programLayers.enable( 5 );
  		if ( parameters.normalMapObjectSpace )
  			_programLayers.enable( 6 );
  		if ( parameters.normalMapTangentSpace )
  			_programLayers.enable( 7 );
  		if ( parameters.clearcoat )
  			_programLayers.enable( 8 );
  		if ( parameters.iridescence )
  			_programLayers.enable( 9 );
  		if ( parameters.alphaTest )
  			_programLayers.enable( 10 );
  		if ( parameters.vertexColors )
  			_programLayers.enable( 11 );
  		if ( parameters.vertexAlphas )
  			_programLayers.enable( 12 );
  		if ( parameters.vertexUv1s )
  			_programLayers.enable( 13 );
  		if ( parameters.vertexUv2s )
  			_programLayers.enable( 14 );
  		if ( parameters.vertexUv3s )
  			_programLayers.enable( 15 );
  		if ( parameters.vertexTangents )
  			_programLayers.enable( 16 );
  		if ( parameters.anisotropy )
  			_programLayers.enable( 17 );
  		if ( parameters.alphaHash )
  			_programLayers.enable( 18 );
  		if ( parameters.batching )
  			_programLayers.enable( 19 );
  		if ( parameters.dispersion )
  			_programLayers.enable( 20 );
  		if ( parameters.batchingColor )
  			_programLayers.enable( 21 );

  		array.push( _programLayers.mask );
  		_programLayers.disableAll();

  		if ( parameters.fog )
  			_programLayers.enable( 0 );
  		if ( parameters.useFog )
  			_programLayers.enable( 1 );
  		if ( parameters.flatShading )
  			_programLayers.enable( 2 );
  		if ( parameters.logarithmicDepthBuffer )
  			_programLayers.enable( 3 );
  		if ( parameters.skinning )
  			_programLayers.enable( 4 );
  		if ( parameters.morphTargets )
  			_programLayers.enable( 5 );
  		if ( parameters.morphNormals )
  			_programLayers.enable( 6 );
  		if ( parameters.morphColors )
  			_programLayers.enable( 7 );
  		if ( parameters.premultipliedAlpha )
  			_programLayers.enable( 8 );
  		if ( parameters.shadowMapEnabled )
  			_programLayers.enable( 9 );
  		if ( parameters.doubleSided )
  			_programLayers.enable( 10 );
  		if ( parameters.flipSided )
  			_programLayers.enable( 11 );
  		if ( parameters.useDepthPacking )
  			_programLayers.enable( 12 );
  		if ( parameters.dithering )
  			_programLayers.enable( 13 );
  		if ( parameters.transmission )
  			_programLayers.enable( 14 );
  		if ( parameters.sheen )
  			_programLayers.enable( 15 );
  		if ( parameters.opaque )
  			_programLayers.enable( 16 );
  		if ( parameters.pointsUvs )
  			_programLayers.enable( 17 );
  		if ( parameters.decodeVideoTexture )
  			_programLayers.enable( 18 );
  		if ( parameters.alphaToCoverage )
  			_programLayers.enable( 19 );

  		array.push( _programLayers.mask );

  	}

  	function getUniforms( material ) {

  		const shaderID = shaderIDs[ material.type ];
  		let uniforms;

  		if ( shaderID ) {

  			const shader = ShaderLib[ shaderID ];
  			uniforms = UniformsUtils.clone( shader.uniforms );

  		} else {

  			uniforms = material.uniforms;

  		}

  		return uniforms;

  	}

  	function acquireProgram( parameters, cacheKey ) {

  		let program;

  		// Check if code has been already compiled
  		for ( let p = 0, pl = programs.length; p < pl; p ++ ) {

  			const preexistingProgram = programs[ p ];

  			if ( preexistingProgram.cacheKey === cacheKey ) {

  				program = preexistingProgram;
  				++ program.usedTimes;

  				break;

  			}

  		}

  		if ( program === undefined ) {

  			program = new WebGLProgram( renderer, cacheKey, parameters, bindingStates );
  			programs.push( program );

  		}

  		return program;

  	}

  	function releaseProgram( program ) {

  		if ( -- program.usedTimes === 0 ) {

  			// Remove from unordered set
  			const i = programs.indexOf( program );
  			programs[ i ] = programs[ programs.length - 1 ];
  			programs.pop();

  			// Free WebGL resources
  			program.destroy();

  		}

  	}

  	function releaseShaderCache( material ) {

  		_customShaders.remove( material );

  	}

  	function dispose() {

  		_customShaders.dispose();

  	}

  	return {
  		getParameters: getParameters,
  		getProgramCacheKey: getProgramCacheKey,
  		getUniforms: getUniforms,
  		acquireProgram: acquireProgram,
  		releaseProgram: releaseProgram,
  		releaseShaderCache: releaseShaderCache,
  		// Exposed for resource monitoring & error feedback via renderer.info:
  		programs: programs,
  		dispose: dispose
  	};

  }

  function WebGLProperties() {

  	let properties = new WeakMap();

  	function get( object ) {

  		let map = properties.get( object );

  		if ( map === undefined ) {

  			map = {};
  			properties.set( object, map );

  		}

  		return map;

  	}

  	function remove( object ) {

  		properties.delete( object );

  	}

  	function update( object, key, value ) {

  		properties.get( object )[ key ] = value;

  	}

  	function dispose() {

  		properties = new WeakMap();

  	}

  	return {
  		get: get,
  		remove: remove,
  		update: update,
  		dispose: dispose
  	};

  }

  function painterSortStable( a, b ) {

  	if ( a.groupOrder !== b.groupOrder ) {

  		return a.groupOrder - b.groupOrder;

  	} else if ( a.renderOrder !== b.renderOrder ) {

  		return a.renderOrder - b.renderOrder;

  	} else if ( a.material.id !== b.material.id ) {

  		return a.material.id - b.material.id;

  	} else if ( a.z !== b.z ) {

  		return a.z - b.z;

  	} else {

  		return a.id - b.id;

  	}

  }

  function reversePainterSortStable( a, b ) {

  	if ( a.groupOrder !== b.groupOrder ) {

  		return a.groupOrder - b.groupOrder;

  	} else if ( a.renderOrder !== b.renderOrder ) {

  		return a.renderOrder - b.renderOrder;

  	} else if ( a.z !== b.z ) {

  		return b.z - a.z;

  	} else {

  		return a.id - b.id;

  	}

  }


  function WebGLRenderList() {

  	const renderItems = [];
  	let renderItemsIndex = 0;

  	const opaque = [];
  	const transmissive = [];
  	const transparent = [];

  	function init() {

  		renderItemsIndex = 0;

  		opaque.length = 0;
  		transmissive.length = 0;
  		transparent.length = 0;

  	}

  	function getNextRenderItem( object, geometry, material, groupOrder, z, group ) {

  		let renderItem = renderItems[ renderItemsIndex ];

  		if ( renderItem === undefined ) {

  			renderItem = {
  				id: object.id,
  				object: object,
  				geometry: geometry,
  				material: material,
  				groupOrder: groupOrder,
  				renderOrder: object.renderOrder,
  				z: z,
  				group: group
  			};

  			renderItems[ renderItemsIndex ] = renderItem;

  		} else {

  			renderItem.id = object.id;
  			renderItem.object = object;
  			renderItem.geometry = geometry;
  			renderItem.material = material;
  			renderItem.groupOrder = groupOrder;
  			renderItem.renderOrder = object.renderOrder;
  			renderItem.z = z;
  			renderItem.group = group;

  		}

  		renderItemsIndex ++;

  		return renderItem;

  	}

  	function push( object, geometry, material, groupOrder, z, group ) {

  		const renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );

  		if ( material.transmission > 0.0 ) {

  			transmissive.push( renderItem );

  		} else if ( material.transparent === true ) {

  			transparent.push( renderItem );

  		} else {

  			opaque.push( renderItem );

  		}

  	}

  	function unshift( object, geometry, material, groupOrder, z, group ) {

  		const renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );

  		if ( material.transmission > 0.0 ) {

  			transmissive.unshift( renderItem );

  		} else if ( material.transparent === true ) {

  			transparent.unshift( renderItem );

  		} else {

  			opaque.unshift( renderItem );

  		}

  	}

  	function sort( customOpaqueSort, customTransparentSort ) {

  		if ( opaque.length > 1 ) opaque.sort( customOpaqueSort || painterSortStable );
  		if ( transmissive.length > 1 ) transmissive.sort( customTransparentSort || reversePainterSortStable );
  		if ( transparent.length > 1 ) transparent.sort( customTransparentSort || reversePainterSortStable );

  	}

  	function finish() {

  		// Clear references from inactive renderItems in the list

  		for ( let i = renderItemsIndex, il = renderItems.length; i < il; i ++ ) {

  			const renderItem = renderItems[ i ];

  			if ( renderItem.id === null ) break;

  			renderItem.id = null;
  			renderItem.object = null;
  			renderItem.geometry = null;
  			renderItem.material = null;
  			renderItem.group = null;

  		}

  	}

  	return {

  		opaque: opaque,
  		transmissive: transmissive,
  		transparent: transparent,

  		init: init,
  		push: push,
  		unshift: unshift,
  		finish: finish,

  		sort: sort
  	};

  }

  function WebGLRenderLists() {

  	let lists = new WeakMap();

  	function get( scene, renderCallDepth ) {

  		const listArray = lists.get( scene );
  		let list;

  		if ( listArray === undefined ) {

  			list = new WebGLRenderList();
  			lists.set( scene, [ list ] );

  		} else {

  			if ( renderCallDepth >= listArray.length ) {

  				list = new WebGLRenderList();
  				listArray.push( list );

  			} else {

  				list = listArray[ renderCallDepth ];

  			}

  		}

  		return list;

  	}

  	function dispose() {

  		lists = new WeakMap();

  	}

  	return {
  		get: get,
  		dispose: dispose
  	};

  }

  function UniformsCache() {

  	const lights = {};

  	return {

  		get: function ( light ) {

  			if ( lights[ light.id ] !== undefined ) {

  				return lights[ light.id ];

  			}

  			let uniforms;

  			switch ( light.type ) {

  				case 'DirectionalLight':
  					uniforms = {
  						direction: new Vector3(),
  						color: new Color()
  					};
  					break;

  				case 'SpotLight':
  					uniforms = {
  						position: new Vector3(),
  						direction: new Vector3(),
  						color: new Color(),
  						distance: 0,
  						coneCos: 0,
  						penumbraCos: 0,
  						decay: 0
  					};
  					break;

  				case 'PointLight':
  					uniforms = {
  						position: new Vector3(),
  						color: new Color(),
  						distance: 0,
  						decay: 0
  					};
  					break;

  				case 'HemisphereLight':
  					uniforms = {
  						direction: new Vector3(),
  						skyColor: new Color(),
  						groundColor: new Color()
  					};
  					break;

  				case 'RectAreaLight':
  					uniforms = {
  						color: new Color(),
  						position: new Vector3(),
  						halfWidth: new Vector3(),
  						halfHeight: new Vector3()
  					};
  					break;

  			}

  			lights[ light.id ] = uniforms;

  			return uniforms;

  		}

  	};

  }

  function ShadowUniformsCache() {

  	const lights = {};

  	return {

  		get: function ( light ) {

  			if ( lights[ light.id ] !== undefined ) {

  				return lights[ light.id ];

  			}

  			let uniforms;

  			switch ( light.type ) {

  				case 'DirectionalLight':
  					uniforms = {
  						shadowIntensity: 1,
  						shadowBias: 0,
  						shadowNormalBias: 0,
  						shadowRadius: 1,
  						shadowMapSize: new Vector2()
  					};
  					break;

  				case 'SpotLight':
  					uniforms = {
  						shadowIntensity: 1,
  						shadowBias: 0,
  						shadowNormalBias: 0,
  						shadowRadius: 1,
  						shadowMapSize: new Vector2()
  					};
  					break;

  				case 'PointLight':
  					uniforms = {
  						shadowIntensity: 1,
  						shadowBias: 0,
  						shadowNormalBias: 0,
  						shadowRadius: 1,
  						shadowMapSize: new Vector2(),
  						shadowCameraNear: 1,
  						shadowCameraFar: 1000
  					};
  					break;

  				// TODO (abelnation): set RectAreaLight shadow uniforms

  			}

  			lights[ light.id ] = uniforms;

  			return uniforms;

  		}

  	};

  }



  let nextVersion = 0;

  function shadowCastingAndTexturingLightsFirst( lightA, lightB ) {

  	return ( lightB.castShadow ? 2 : 0 ) - ( lightA.castShadow ? 2 : 0 ) + ( lightB.map ? 1 : 0 ) - ( lightA.map ? 1 : 0 );

  }

  function WebGLLights( extensions ) {

  	const cache = new UniformsCache();

  	const shadowCache = ShadowUniformsCache();

  	const state = {

  		version: 0,

  		hash: {
  			directionalLength: - 1,
  			pointLength: - 1,
  			spotLength: - 1,
  			rectAreaLength: - 1,
  			hemiLength: - 1,

  			numDirectionalShadows: - 1,
  			numPointShadows: - 1,
  			numSpotShadows: - 1,
  			numSpotMaps: - 1,

  			numLightProbes: - 1
  		},

  		ambient: [ 0, 0, 0 ],
  		probe: [],
  		directional: [],
  		directionalShadow: [],
  		directionalShadowMap: [],
  		directionalShadowMatrix: [],
  		spot: [],
  		spotLightMap: [],
  		spotShadow: [],
  		spotShadowMap: [],
  		spotLightMatrix: [],
  		rectArea: [],
  		rectAreaLTC1: null,
  		rectAreaLTC2: null,
  		point: [],
  		pointShadow: [],
  		pointShadowMap: [],
  		pointShadowMatrix: [],
  		hemi: [],
  		numSpotLightShadowsWithMaps: 0,
  		numLightProbes: 0

  	};

  	for ( let i = 0; i < 9; i ++ ) state.probe.push( new Vector3() );

  	const vector3 = new Vector3();
  	const matrix4 = new Matrix4();
  	const matrix42 = new Matrix4();

  	function setup( lights ) {

  		let r = 0, g = 0, b = 0;

  		for ( let i = 0; i < 9; i ++ ) state.probe[ i ].set( 0, 0, 0 );

  		let directionalLength = 0;
  		let pointLength = 0;
  		let spotLength = 0;
  		let rectAreaLength = 0;
  		let hemiLength = 0;

  		let numDirectionalShadows = 0;
  		let numPointShadows = 0;
  		let numSpotShadows = 0;
  		let numSpotMaps = 0;
  		let numSpotShadowsWithMaps = 0;

  		let numLightProbes = 0;

  		// ordering : [shadow casting + map texturing, map texturing, shadow casting, none ]
  		lights.sort( shadowCastingAndTexturingLightsFirst );

  		for ( let i = 0, l = lights.length; i < l; i ++ ) {

  			const light = lights[ i ];

  			const color = light.color;
  			const intensity = light.intensity;
  			const distance = light.distance;

  			const shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;

  			if ( light.isAmbientLight ) {

  				r += color.r * intensity;
  				g += color.g * intensity;
  				b += color.b * intensity;

  			} else if ( light.isLightProbe ) {

  				for ( let j = 0; j < 9; j ++ ) {

  					state.probe[ j ].addScaledVector( light.sh.coefficients[ j ], intensity );

  				}

  				numLightProbes ++;

  			} else if ( light.isDirectionalLight ) {

  				const uniforms = cache.get( light );

  				uniforms.color.copy( light.color ).multiplyScalar( light.intensity );

  				if ( light.castShadow ) {

  					const shadow = light.shadow;

  					const shadowUniforms = shadowCache.get( light );

  					shadowUniforms.shadowIntensity = shadow.intensity;
  					shadowUniforms.shadowBias = shadow.bias;
  					shadowUniforms.shadowNormalBias = shadow.normalBias;
  					shadowUniforms.shadowRadius = shadow.radius;
  					shadowUniforms.shadowMapSize = shadow.mapSize;

  					state.directionalShadow[ directionalLength ] = shadowUniforms;
  					state.directionalShadowMap[ directionalLength ] = shadowMap;
  					state.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;

  					numDirectionalShadows ++;

  				}

  				state.directional[ directionalLength ] = uniforms;

  				directionalLength ++;

  			} else if ( light.isSpotLight ) {

  				const uniforms = cache.get( light );

  				uniforms.position.setFromMatrixPosition( light.matrixWorld );

  				uniforms.color.copy( color ).multiplyScalar( intensity );
  				uniforms.distance = distance;

  				uniforms.coneCos = Math.cos( light.angle );
  				uniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );
  				uniforms.decay = light.decay;

  				state.spot[ spotLength ] = uniforms;

  				const shadow = light.shadow;

  				if ( light.map ) {

  					state.spotLightMap[ numSpotMaps ] = light.map;
  					numSpotMaps ++;

  					// make sure the lightMatrix is up to date
  					// TODO : do it if required only
  					shadow.updateMatrices( light );

  					if ( light.castShadow ) numSpotShadowsWithMaps ++;

  				}

  				state.spotLightMatrix[ spotLength ] = shadow.matrix;

  				if ( light.castShadow ) {

  					const shadowUniforms = shadowCache.get( light );

  					shadowUniforms.shadowIntensity = shadow.intensity;
  					shadowUniforms.shadowBias = shadow.bias;
  					shadowUniforms.shadowNormalBias = shadow.normalBias;
  					shadowUniforms.shadowRadius = shadow.radius;
  					shadowUniforms.shadowMapSize = shadow.mapSize;

  					state.spotShadow[ spotLength ] = shadowUniforms;
  					state.spotShadowMap[ spotLength ] = shadowMap;

  					numSpotShadows ++;

  				}

  				spotLength ++;

  			} else if ( light.isRectAreaLight ) {

  				const uniforms = cache.get( light );

  				uniforms.color.copy( color ).multiplyScalar( intensity );

  				uniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );
  				uniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );

  				state.rectArea[ rectAreaLength ] = uniforms;

  				rectAreaLength ++;

  			} else if ( light.isPointLight ) {

  				const uniforms = cache.get( light );

  				uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
  				uniforms.distance = light.distance;
  				uniforms.decay = light.decay;

  				if ( light.castShadow ) {

  					const shadow = light.shadow;

  					const shadowUniforms = shadowCache.get( light );

  					shadowUniforms.shadowIntensity = shadow.intensity;
  					shadowUniforms.shadowBias = shadow.bias;
  					shadowUniforms.shadowNormalBias = shadow.normalBias;
  					shadowUniforms.shadowRadius = shadow.radius;
  					shadowUniforms.shadowMapSize = shadow.mapSize;
  					shadowUniforms.shadowCameraNear = shadow.camera.near;
  					shadowUniforms.shadowCameraFar = shadow.camera.far;

  					state.pointShadow[ pointLength ] = shadowUniforms;
  					state.pointShadowMap[ pointLength ] = shadowMap;
  					state.pointShadowMatrix[ pointLength ] = light.shadow.matrix;

  					numPointShadows ++;

  				}

  				state.point[ pointLength ] = uniforms;

  				pointLength ++;

  			} else if ( light.isHemisphereLight ) {

  				const uniforms = cache.get( light );

  				uniforms.skyColor.copy( light.color ).multiplyScalar( intensity );
  				uniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );

  				state.hemi[ hemiLength ] = uniforms;

  				hemiLength ++;

  			}

  		}

  		if ( rectAreaLength > 0 ) {

  			if ( extensions.has( 'OES_texture_float_linear' ) === true ) {

  				state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
  				state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;

  			} else {

  				state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
  				state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;

  			}

  		}

  		state.ambient[ 0 ] = r;
  		state.ambient[ 1 ] = g;
  		state.ambient[ 2 ] = b;

  		const hash = state.hash;

  		if ( hash.directionalLength !== directionalLength ||
  			hash.pointLength !== pointLength ||
  			hash.spotLength !== spotLength ||
  			hash.rectAreaLength !== rectAreaLength ||
  			hash.hemiLength !== hemiLength ||
  			hash.numDirectionalShadows !== numDirectionalShadows ||
  			hash.numPointShadows !== numPointShadows ||
  			hash.numSpotShadows !== numSpotShadows ||
  			hash.numSpotMaps !== numSpotMaps ||
  			hash.numLightProbes !== numLightProbes ) {

  			state.directional.length = directionalLength;
  			state.spot.length = spotLength;
  			state.rectArea.length = rectAreaLength;
  			state.point.length = pointLength;
  			state.hemi.length = hemiLength;

  			state.directionalShadow.length = numDirectionalShadows;
  			state.directionalShadowMap.length = numDirectionalShadows;
  			state.pointShadow.length = numPointShadows;
  			state.pointShadowMap.length = numPointShadows;
  			state.spotShadow.length = numSpotShadows;
  			state.spotShadowMap.length = numSpotShadows;
  			state.directionalShadowMatrix.length = numDirectionalShadows;
  			state.pointShadowMatrix.length = numPointShadows;
  			state.spotLightMatrix.length = numSpotShadows + numSpotMaps - numSpotShadowsWithMaps;
  			state.spotLightMap.length = numSpotMaps;
  			state.numSpotLightShadowsWithMaps = numSpotShadowsWithMaps;
  			state.numLightProbes = numLightProbes;

  			hash.directionalLength = directionalLength;
  			hash.pointLength = pointLength;
  			hash.spotLength = spotLength;
  			hash.rectAreaLength = rectAreaLength;
  			hash.hemiLength = hemiLength;

  			hash.numDirectionalShadows = numDirectionalShadows;
  			hash.numPointShadows = numPointShadows;
  			hash.numSpotShadows = numSpotShadows;
  			hash.numSpotMaps = numSpotMaps;

  			hash.numLightProbes = numLightProbes;

  			state.version = nextVersion ++;

  		}

  	}

  	function setupView( lights, camera ) {

  		let directionalLength = 0;
  		let pointLength = 0;
  		let spotLength = 0;
  		let rectAreaLength = 0;
  		let hemiLength = 0;

  		const viewMatrix = camera.matrixWorldInverse;

  		for ( let i = 0, l = lights.length; i < l; i ++ ) {

  			const light = lights[ i ];

  			if ( light.isDirectionalLight ) {

  				const uniforms = state.directional[ directionalLength ];

  				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
  				vector3.setFromMatrixPosition( light.target.matrixWorld );
  				uniforms.direction.sub( vector3 );
  				uniforms.direction.transformDirection( viewMatrix );

  				directionalLength ++;

  			} else if ( light.isSpotLight ) {

  				const uniforms = state.spot[ spotLength ];

  				uniforms.position.setFromMatrixPosition( light.matrixWorld );
  				uniforms.position.applyMatrix4( viewMatrix );

  				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
  				vector3.setFromMatrixPosition( light.target.matrixWorld );
  				uniforms.direction.sub( vector3 );
  				uniforms.direction.transformDirection( viewMatrix );

  				spotLength ++;

  			} else if ( light.isRectAreaLight ) {

  				const uniforms = state.rectArea[ rectAreaLength ];

  				uniforms.position.setFromMatrixPosition( light.matrixWorld );
  				uniforms.position.applyMatrix4( viewMatrix );

  				// extract local rotation of light to derive width/height half vectors
  				matrix42.identity();
  				matrix4.copy( light.matrixWorld );
  				matrix4.premultiply( viewMatrix );
  				matrix42.extractRotation( matrix4 );

  				uniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );
  				uniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );

  				uniforms.halfWidth.applyMatrix4( matrix42 );
  				uniforms.halfHeight.applyMatrix4( matrix42 );

  				rectAreaLength ++;

  			} else if ( light.isPointLight ) {

  				const uniforms = state.point[ pointLength ];

  				uniforms.position.setFromMatrixPosition( light.matrixWorld );
  				uniforms.position.applyMatrix4( viewMatrix );

  				pointLength ++;

  			} else if ( light.isHemisphereLight ) {

  				const uniforms = state.hemi[ hemiLength ];

  				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
  				uniforms.direction.transformDirection( viewMatrix );

  				hemiLength ++;

  			}

  		}

  	}

  	return {
  		setup: setup,
  		setupView: setupView,
  		state: state
  	};

  }

  function WebGLRenderState( extensions ) {

  	const lights = new WebGLLights( extensions );

  	const lightsArray = [];
  	const shadowsArray = [];

  	function init( camera ) {

  		state.camera = camera;

  		lightsArray.length = 0;
  		shadowsArray.length = 0;

  	}

  	function pushLight( light ) {

  		lightsArray.push( light );

  	}

  	function pushShadow( shadowLight ) {

  		shadowsArray.push( shadowLight );

  	}

  	function setupLights() {

  		lights.setup( lightsArray );

  	}

  	function setupLightsView( camera ) {

  		lights.setupView( lightsArray, camera );

  	}

  	const state = {
  		lightsArray: lightsArray,
  		shadowsArray: shadowsArray,

  		camera: null,

  		lights: lights,

  		transmissionRenderTarget: {}
  	};

  	return {
  		init: init,
  		state: state,
  		setupLights: setupLights,
  		setupLightsView: setupLightsView,

  		pushLight: pushLight,
  		pushShadow: pushShadow
  	};

  }

  function WebGLRenderStates( extensions ) {

  	let renderStates = new WeakMap();

  	function get( scene, renderCallDepth = 0 ) {

  		const renderStateArray = renderStates.get( scene );
  		let renderState;

  		if ( renderStateArray === undefined ) {

  			renderState = new WebGLRenderState( extensions );
  			renderStates.set( scene, [ renderState ] );

  		} else {

  			if ( renderCallDepth >= renderStateArray.length ) {

  				renderState = new WebGLRenderState( extensions );
  				renderStateArray.push( renderState );

  			} else {

  				renderState = renderStateArray[ renderCallDepth ];

  			}

  		}

  		return renderState;

  	}

  	function dispose() {

  		renderStates = new WeakMap();

  	}

  	return {
  		get: get,
  		dispose: dispose
  	};

  }

  class MeshDepthMaterial extends Material {

  	constructor( parameters ) {

  		super();

  		this.isMeshDepthMaterial = true;

  		this.type = 'MeshDepthMaterial';

  		this.depthPacking = BasicDepthPacking;

  		this.map = null;

  		this.alphaMap = null;

  		this.displacementMap = null;
  		this.displacementScale = 1;
  		this.displacementBias = 0;

  		this.wireframe = false;
  		this.wireframeLinewidth = 1;

  		this.setValues( parameters );

  	}

  	copy( source ) {

  		super.copy( source );

  		this.depthPacking = source.depthPacking;

  		this.map = source.map;

  		this.alphaMap = source.alphaMap;

  		this.displacementMap = source.displacementMap;
  		this.displacementScale = source.displacementScale;
  		this.displacementBias = source.displacementBias;

  		this.wireframe = source.wireframe;
  		this.wireframeLinewidth = source.wireframeLinewidth;

  		return this;

  	}

  }

  class MeshDistanceMaterial extends Material {

  	constructor( parameters ) {

  		super();

  		this.isMeshDistanceMaterial = true;

  		this.type = 'MeshDistanceMaterial';

  		this.map = null;

  		this.alphaMap = null;

  		this.displacementMap = null;
  		this.displacementScale = 1;
  		this.displacementBias = 0;

  		this.setValues( parameters );

  	}

  	copy( source ) {

  		super.copy( source );

  		this.map = source.map;

  		this.alphaMap = source.alphaMap;

  		this.displacementMap = source.displacementMap;
  		this.displacementScale = source.displacementScale;
  		this.displacementBias = source.displacementBias;

  		return this;

  	}

  }

  const vertex = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";

  const fragment = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";

  function WebGLShadowMap( renderer, objects, capabilities ) {

  	let _frustum = new Frustum();

  	const _shadowMapSize = new Vector2(),
  		_viewportSize = new Vector2(),

  		_viewport = new Vector4(),

  		_depthMaterial = new MeshDepthMaterial( { depthPacking: RGBADepthPacking } ),
  		_distanceMaterial = new MeshDistanceMaterial(),

  		_materialCache = {},

  		_maxTextureSize = capabilities.maxTextureSize;

  	const shadowSide = { [ FrontSide ]: BackSide, [ BackSide ]: FrontSide, [ DoubleSide ]: DoubleSide };

  	const shadowMaterialVertical = new ShaderMaterial( {
  		defines: {
  			VSM_SAMPLES: 8
  		},
  		uniforms: {
  			shadow_pass: { value: null },
  			resolution: { value: new Vector2() },
  			radius: { value: 4.0 }
  		},

  		vertexShader: vertex,
  		fragmentShader: fragment

  	} );

  	const shadowMaterialHorizontal = shadowMaterialVertical.clone();
  	shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;

  	const fullScreenTri = new BufferGeometry();
  	fullScreenTri.setAttribute(
  		'position',
  		new BufferAttribute(
  			new Float32Array( [ - 1, - 1, 0.5, 3, - 1, 0.5, - 1, 3, 0.5 ] ),
  			3
  		)
  	);

  	const fullScreenMesh = new Mesh( fullScreenTri, shadowMaterialVertical );

  	const scope = this;

  	this.enabled = false;

  	this.autoUpdate = true;
  	this.needsUpdate = false;

  	this.type = PCFShadowMap;
  	let _previousType = this.type;

  	this.render = function ( lights, scene, camera ) {

  		if ( scope.enabled === false ) return;
  		if ( scope.autoUpdate === false && scope.needsUpdate === false ) return;

  		if ( lights.length === 0 ) return;

  		const currentRenderTarget = renderer.getRenderTarget();
  		const activeCubeFace = renderer.getActiveCubeFace();
  		const activeMipmapLevel = renderer.getActiveMipmapLevel();

  		const _state = renderer.state;

  		// Set GL state for depth map.
  		_state.setBlending( NoBlending );
  		_state.buffers.color.setClear( 1, 1, 1, 1 );
  		_state.buffers.depth.setTest( true );
  		_state.setScissorTest( false );

  		// check for shadow map type changes

  		const toVSM = ( _previousType !== VSMShadowMap && this.type === VSMShadowMap );
  		const fromVSM = ( _previousType === VSMShadowMap && this.type !== VSMShadowMap );

  		// render depth map

  		for ( let i = 0, il = lights.length; i < il; i ++ ) {

  			const light = lights[ i ];
  			const shadow = light.shadow;

  			if ( shadow === undefined ) {

  				console.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );
  				continue;

  			}

  			if ( shadow.autoUpdate === false && shadow.needsUpdate === false ) continue;

  			_shadowMapSize.copy( shadow.mapSize );

  			const shadowFrameExtents = shadow.getFrameExtents();

  			_shadowMapSize.multiply( shadowFrameExtents );

  			_viewportSize.copy( shadow.mapSize );

  			if ( _shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize ) {

  				if ( _shadowMapSize.x > _maxTextureSize ) {

  					_viewportSize.x = Math.floor( _maxTextureSize / shadowFrameExtents.x );
  					_shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
  					shadow.mapSize.x = _viewportSize.x;

  				}

  				if ( _shadowMapSize.y > _maxTextureSize ) {

  					_viewportSize.y = Math.floor( _maxTextureSize / shadowFrameExtents.y );
  					_shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
  					shadow.mapSize.y = _viewportSize.y;

  				}

  			}

  			if ( shadow.map === null || toVSM === true || fromVSM === true ) {

  				const pars = ( this.type !== VSMShadowMap ) ? { minFilter: NearestFilter, magFilter: NearestFilter } : {};

  				if ( shadow.map !== null ) {

  					shadow.map.dispose();

  				}

  				shadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );
  				shadow.map.texture.name = light.name + '.shadowMap';

  				shadow.camera.updateProjectionMatrix();

  			}

  			renderer.setRenderTarget( shadow.map );
  			renderer.clear();

  			const viewportCount = shadow.getViewportCount();

  			for ( let vp = 0; vp < viewportCount; vp ++ ) {

  				const viewport = shadow.getViewport( vp );

  				_viewport.set(
  					_viewportSize.x * viewport.x,
  					_viewportSize.y * viewport.y,
  					_viewportSize.x * viewport.z,
  					_viewportSize.y * viewport.w
  				);

  				_state.viewport( _viewport );

  				shadow.updateMatrices( light, vp );

  				_frustum = shadow.getFrustum();

  				renderObject( scene, camera, shadow.camera, light, this.type );

  			}

  			// do blur pass for VSM

  			if ( shadow.isPointLightShadow !== true && this.type === VSMShadowMap ) {

  				VSMPass( shadow, camera );

  			}

  			shadow.needsUpdate = false;

  		}

  		_previousType = this.type;

  		scope.needsUpdate = false;

  		renderer.setRenderTarget( currentRenderTarget, activeCubeFace, activeMipmapLevel );

  	};

  	function VSMPass( shadow, camera ) {

  		const geometry = objects.update( fullScreenMesh );

  		if ( shadowMaterialVertical.defines.VSM_SAMPLES !== shadow.blurSamples ) {

  			shadowMaterialVertical.defines.VSM_SAMPLES = shadow.blurSamples;
  			shadowMaterialHorizontal.defines.VSM_SAMPLES = shadow.blurSamples;

  			shadowMaterialVertical.needsUpdate = true;
  			shadowMaterialHorizontal.needsUpdate = true;

  		}

  		if ( shadow.mapPass === null ) {

  			shadow.mapPass = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y );

  		}

  		// vertical pass

  		shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
  		shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
  		shadowMaterialVertical.uniforms.radius.value = shadow.radius;
  		renderer.setRenderTarget( shadow.mapPass );
  		renderer.clear();
  		renderer.renderBufferDirect( camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null );

  		// horizontal pass

  		shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
  		shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
  		shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
  		renderer.setRenderTarget( shadow.map );
  		renderer.clear();
  		renderer.renderBufferDirect( camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null );

  	}

  	function getDepthMaterial( object, material, light, type ) {

  		let result = null;

  		const customMaterial = ( light.isPointLight === true ) ? object.customDistanceMaterial : object.customDepthMaterial;

  		if ( customMaterial !== undefined ) {

  			result = customMaterial;

  		} else {

  			result = ( light.isPointLight === true ) ? _distanceMaterial : _depthMaterial;

  			if ( ( renderer.localClippingEnabled && material.clipShadows === true && Array.isArray( material.clippingPlanes ) && material.clippingPlanes.length !== 0 ) ||
  				( material.displacementMap && material.displacementScale !== 0 ) ||
  				( material.alphaMap && material.alphaTest > 0 ) ||
  				( material.map && material.alphaTest > 0 ) ) {

  				// in this case we need a unique material instance reflecting the
  				// appropriate state

  				const keyA = result.uuid, keyB = material.uuid;

  				let materialsForVariant = _materialCache[ keyA ];

  				if ( materialsForVariant === undefined ) {

  					materialsForVariant = {};
  					_materialCache[ keyA ] = materialsForVariant;

  				}

  				let cachedMaterial = materialsForVariant[ keyB ];

  				if ( cachedMaterial === undefined ) {

  					cachedMaterial = result.clone();
  					materialsForVariant[ keyB ] = cachedMaterial;
  					material.addEventListener( 'dispose', onMaterialDispose );

  				}

  				result = cachedMaterial;

  			}

  		}

  		result.visible = material.visible;
  		result.wireframe = material.wireframe;

  		if ( type === VSMShadowMap ) {

  			result.side = ( material.shadowSide !== null ) ? material.shadowSide : material.side;

  		} else {

  			result.side = ( material.shadowSide !== null ) ? material.shadowSide : shadowSide[ material.side ];

  		}

  		result.alphaMap = material.alphaMap;
  		result.alphaTest = material.alphaTest;
  		result.map = material.map;

  		result.clipShadows = material.clipShadows;
  		result.clippingPlanes = material.clippingPlanes;
  		result.clipIntersection = material.clipIntersection;

  		result.displacementMap = material.displacementMap;
  		result.displacementScale = material.displacementScale;
  		result.displacementBias = material.displacementBias;

  		result.wireframeLinewidth = material.wireframeLinewidth;
  		result.linewidth = material.linewidth;

  		if ( light.isPointLight === true && result.isMeshDistanceMaterial === true ) {

  			const materialProperties = renderer.properties.get( result );
  			materialProperties.light = light;

  		}

  		return result;

  	}

  	function renderObject( object, camera, shadowCamera, light, type ) {

  		if ( object.visible === false ) return;

  		const visible = object.layers.test( camera.layers );

  		if ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {

  			if ( ( object.castShadow || ( object.receiveShadow && type === VSMShadowMap ) ) && ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) ) {

  				object.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );

  				const geometry = objects.update( object );
  				const material = object.material;

  				if ( Array.isArray( material ) ) {

  					const groups = geometry.groups;

  					for ( let k = 0, kl = groups.length; k < kl; k ++ ) {

  						const group = groups[ k ];
  						const groupMaterial = material[ group.materialIndex ];

  						if ( groupMaterial && groupMaterial.visible ) {

  							const depthMaterial = getDepthMaterial( object, groupMaterial, light, type );

  							object.onBeforeShadow( renderer, object, camera, shadowCamera, geometry, depthMaterial, group );

  							renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );

  							object.onAfterShadow( renderer, object, camera, shadowCamera, geometry, depthMaterial, group );

  						}

  					}

  				} else if ( material.visible ) {

  					const depthMaterial = getDepthMaterial( object, material, light, type );

  					object.onBeforeShadow( renderer, object, camera, shadowCamera, geometry, depthMaterial, null );

  					renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );

  					object.onAfterShadow( renderer, object, camera, shadowCamera, geometry, depthMaterial, null );

  				}

  			}

  		}

  		const children = object.children;

  		for ( let i = 0, l = children.length; i < l; i ++ ) {

  			renderObject( children[ i ], camera, shadowCamera, light, type );

  		}

  	}

  	function onMaterialDispose( event ) {

  		const material = event.target;

  		material.removeEventListener( 'dispose', onMaterialDispose );

  		// make sure to remove the unique distance/depth materials used for shadow map rendering

  		for ( const id in _materialCache ) {

  			const cache = _materialCache[ id ];

  			const uuid = event.target.uuid;

  			if ( uuid in cache ) {

  				const shadowMaterial = cache[ uuid ];
  				shadowMaterial.dispose();
  				delete cache[ uuid ];

  			}

  		}

  	}

  }

  function WebGLState( gl ) {

  	function ColorBuffer() {

  		let locked = false;

  		const color = new Vector4();
  		let currentColorMask = null;
  		const currentColorClear = new Vector4( 0, 0, 0, 0 );

  		return {

  			setMask: function ( colorMask ) {

  				if ( currentColorMask !== colorMask && ! locked ) {

  					gl.colorMask( colorMask, colorMask, colorMask, colorMask );
  					currentColorMask = colorMask;

  				}

  			},

  			setLocked: function ( lock ) {

  				locked = lock;

  			},

  			setClear: function ( r, g, b, a, premultipliedAlpha ) {

  				if ( premultipliedAlpha === true ) {

  					r *= a; g *= a; b *= a;

  				}

  				color.set( r, g, b, a );

  				if ( currentColorClear.equals( color ) === false ) {

  					gl.clearColor( r, g, b, a );
  					currentColorClear.copy( color );

  				}

  			},

  			reset: function () {

  				locked = false;

  				currentColorMask = null;
  				currentColorClear.set( - 1, 0, 0, 0 ); // set to invalid state

  			}

  		};

  	}

  	function DepthBuffer() {

  		let locked = false;

  		let currentDepthMask = null;
  		let currentDepthFunc = null;
  		let currentDepthClear = null;

  		return {

  			setTest: function ( depthTest ) {

  				if ( depthTest ) {

  					enable( gl.DEPTH_TEST );

  				} else {

  					disable( gl.DEPTH_TEST );

  				}

  			},

  			setMask: function ( depthMask ) {

  				if ( currentDepthMask !== depthMask && ! locked ) {

  					gl.depthMask( depthMask );
  					currentDepthMask = depthMask;

  				}

  			},

  			setFunc: function ( depthFunc ) {

  				if ( currentDepthFunc !== depthFunc ) {

  					switch ( depthFunc ) {

  						case NeverDepth:

  							gl.depthFunc( gl.NEVER );
  							break;

  						case AlwaysDepth:

  							gl.depthFunc( gl.ALWAYS );
  							break;

  						case LessDepth:

  							gl.depthFunc( gl.LESS );
  							break;

  						case LessEqualDepth:

  							gl.depthFunc( gl.LEQUAL );
  							break;

  						case EqualDepth:

  							gl.depthFunc( gl.EQUAL );
  							break;

  						case GreaterEqualDepth:

  							gl.depthFunc( gl.GEQUAL );
  							break;

  						case GreaterDepth:

  							gl.depthFunc( gl.GREATER );
  							break;

  						case NotEqualDepth:

  							gl.depthFunc( gl.NOTEQUAL );
  							break;

  						default:

  							gl.depthFunc( gl.LEQUAL );

  					}

  					currentDepthFunc = depthFunc;

  				}

  			},

  			setLocked: function ( lock ) {

  				locked = lock;

  			},

  			setClear: function ( depth ) {

  				if ( currentDepthClear !== depth ) {

  					gl.clearDepth( depth );
  					currentDepthClear = depth;

  				}

  			},

  			reset: function () {

  				locked = false;

  				currentDepthMask = null;
  				currentDepthFunc = null;
  				currentDepthClear = null;

  			}

  		};

  	}

  	function StencilBuffer() {

  		let locked = false;

  		let currentStencilMask = null;
  		let currentStencilFunc = null;
  		let currentStencilRef = null;
  		let currentStencilFuncMask = null;
  		let currentStencilFail = null;
  		let currentStencilZFail = null;
  		let currentStencilZPass = null;
  		let currentStencilClear = null;

  		return {

  			setTest: function ( stencilTest ) {

  				if ( ! locked ) {

  					if ( stencilTest ) {

  						enable( gl.STENCIL_TEST );

  					} else {

  						disable( gl.STENCIL_TEST );

  					}

  				}

  			},

  			setMask: function ( stencilMask ) {

  				if ( currentStencilMask !== stencilMask && ! locked ) {

  					gl.stencilMask( stencilMask );
  					currentStencilMask = stencilMask;

  				}

  			},

  			setFunc: function ( stencilFunc, stencilRef, stencilMask ) {

  				if ( currentStencilFunc !== stencilFunc ||
  				     currentStencilRef !== stencilRef ||
  				     currentStencilFuncMask !== stencilMask ) {

  					gl.stencilFunc( stencilFunc, stencilRef, stencilMask );

  					currentStencilFunc = stencilFunc;
  					currentStencilRef = stencilRef;
  					currentStencilFuncMask = stencilMask;

  				}

  			},

  			setOp: function ( stencilFail, stencilZFail, stencilZPass ) {

  				if ( currentStencilFail !== stencilFail ||
  				     currentStencilZFail !== stencilZFail ||
  				     currentStencilZPass !== stencilZPass ) {

  					gl.stencilOp( stencilFail, stencilZFail, stencilZPass );

  					currentStencilFail = stencilFail;
  					currentStencilZFail = stencilZFail;
  					currentStencilZPass = stencilZPass;

  				}

  			},

  			setLocked: function ( lock ) {

  				locked = lock;

  			},

  			setClear: function ( stencil ) {

  				if ( currentStencilClear !== stencil ) {

  					gl.clearStencil( stencil );
  					currentStencilClear = stencil;

  				}

  			},

  			reset: function () {

  				locked = false;

  				currentStencilMask = null;
  				currentStencilFunc = null;
  				currentStencilRef = null;
  				currentStencilFuncMask = null;
  				currentStencilFail = null;
  				currentStencilZFail = null;
  				currentStencilZPass = null;
  				currentStencilClear = null;

  			}

  		};

  	}

  	//

  	const colorBuffer = new ColorBuffer();
  	const depthBuffer = new DepthBuffer();
  	const stencilBuffer = new StencilBuffer();

  	const uboBindings = new WeakMap();
  	const uboProgramMap = new WeakMap();

  	let enabledCapabilities = {};

  	let currentBoundFramebuffers = {};
  	let currentDrawbuffers = new WeakMap();
  	let defaultDrawbuffers = [];

  	let currentProgram = null;

  	let currentBlendingEnabled = false;
  	let currentBlending = null;
  	let currentBlendEquation = null;
  	let currentBlendSrc = null;
  	let currentBlendDst = null;
  	let currentBlendEquationAlpha = null;
  	let currentBlendSrcAlpha = null;
  	let currentBlendDstAlpha = null;
  	let currentBlendColor = new Color( 0, 0, 0 );
  	let currentBlendAlpha = 0;
  	let currentPremultipledAlpha = false;

  	let currentFlipSided = null;
  	let currentCullFace = null;

  	let currentLineWidth = null;

  	let currentPolygonOffsetFactor = null;
  	let currentPolygonOffsetUnits = null;

  	const maxTextures = gl.getParameter( gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS );

  	let lineWidthAvailable = false;
  	let version = 0;
  	const glVersion = gl.getParameter( gl.VERSION );

  	if ( glVersion.indexOf( 'WebGL' ) !== - 1 ) {

  		version = parseFloat( /^WebGL (\d)/.exec( glVersion )[ 1 ] );
  		lineWidthAvailable = ( version >= 1.0 );

  	} else if ( glVersion.indexOf( 'OpenGL ES' ) !== - 1 ) {

  		version = parseFloat( /^OpenGL ES (\d)/.exec( glVersion )[ 1 ] );
  		lineWidthAvailable = ( version >= 2.0 );

  	}

  	let currentTextureSlot = null;
  	let currentBoundTextures = {};

  	const scissorParam = gl.getParameter( gl.SCISSOR_BOX );
  	const viewportParam = gl.getParameter( gl.VIEWPORT );

  	const currentScissor = new Vector4().fromArray( scissorParam );
  	const currentViewport = new Vector4().fromArray( viewportParam );

  	function createTexture( type, target, count, dimensions ) {

  		const data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.
  		const texture = gl.createTexture();

  		gl.bindTexture( type, texture );
  		gl.texParameteri( type, gl.TEXTURE_MIN_FILTER, gl.NEAREST );
  		gl.texParameteri( type, gl.TEXTURE_MAG_FILTER, gl.NEAREST );

  		for ( let i = 0; i < count; i ++ ) {

  			if ( type === gl.TEXTURE_3D || type === gl.TEXTURE_2D_ARRAY ) {

  				gl.texImage3D( target, 0, gl.RGBA, 1, 1, dimensions, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );

  			} else {

  				gl.texImage2D( target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );

  			}

  		}

  		return texture;

  	}

  	const emptyTextures = {};
  	emptyTextures[ gl.TEXTURE_2D ] = createTexture( gl.TEXTURE_2D, gl.TEXTURE_2D, 1 );
  	emptyTextures[ gl.TEXTURE_CUBE_MAP ] = createTexture( gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6 );
  	emptyTextures[ gl.TEXTURE_2D_ARRAY ] = createTexture( gl.TEXTURE_2D_ARRAY, gl.TEXTURE_2D_ARRAY, 1, 1 );
  	emptyTextures[ gl.TEXTURE_3D ] = createTexture( gl.TEXTURE_3D, gl.TEXTURE_3D, 1, 1 );

  	// init

  	colorBuffer.setClear( 0, 0, 0, 1 );
  	depthBuffer.setClear( 1 );
  	stencilBuffer.setClear( 0 );

  	enable( gl.DEPTH_TEST );
  	depthBuffer.setFunc( LessEqualDepth );

  	setFlipSided( false );
  	setCullFace( CullFaceBack );
  	enable( gl.CULL_FACE );

  	setBlending( NoBlending );

  	//

  	function enable( id ) {

  		if ( enabledCapabilities[ id ] !== true ) {

  			gl.enable( id );
  			enabledCapabilities[ id ] = true;

  		}

  	}

  	function disable( id ) {

  		if ( enabledCapabilities[ id ] !== false ) {

  			gl.disable( id );
  			enabledCapabilities[ id ] = false;

  		}

  	}

  	function bindFramebuffer( target, framebuffer ) {

  		if ( currentBoundFramebuffers[ target ] !== framebuffer ) {

  			gl.bindFramebuffer( target, framebuffer );

  			currentBoundFramebuffers[ target ] = framebuffer;

  			// gl.DRAW_FRAMEBUFFER is equivalent to gl.FRAMEBUFFER

  			if ( target === gl.DRAW_FRAMEBUFFER ) {

  				currentBoundFramebuffers[ gl.FRAMEBUFFER ] = framebuffer;

  			}

  			if ( target === gl.FRAMEBUFFER ) {

  				currentBoundFramebuffers[ gl.DRAW_FRAMEBUFFER ] = framebuffer;

  			}

  			return true;

  		}

  		return false;

  	}

  	function drawBuffers( renderTarget, framebuffer ) {

  		let drawBuffers = defaultDrawbuffers;

  		let needsUpdate = false;

  		if ( renderTarget ) {

  			drawBuffers = currentDrawbuffers.get( framebuffer );

  			if ( drawBuffers === undefined ) {

  				drawBuffers = [];
  				currentDrawbuffers.set( framebuffer, drawBuffers );

  			}

  			const textures = renderTarget.textures;

  			if ( drawBuffers.length !== textures.length || drawBuffers[ 0 ] !== gl.COLOR_ATTACHMENT0 ) {

  				for ( let i = 0, il = textures.length; i < il; i ++ ) {

  					drawBuffers[ i ] = gl.COLOR_ATTACHMENT0 + i;

  				}

  				drawBuffers.length = textures.length;

  				needsUpdate = true;

  			}

  		} else {

  			if ( drawBuffers[ 0 ] !== gl.BACK ) {

  				drawBuffers[ 0 ] = gl.BACK;

  				needsUpdate = true;

  			}

  		}

  		if ( needsUpdate ) {

  			gl.drawBuffers( drawBuffers );

  		}

  	}

  	function useProgram( program ) {

  		if ( currentProgram !== program ) {

  			gl.useProgram( program );

  			currentProgram = program;

  			return true;

  		}

  		return false;

  	}

  	const equationToGL = {
  		[ AddEquation ]: gl.FUNC_ADD,
  		[ SubtractEquation ]: gl.FUNC_SUBTRACT,
  		[ ReverseSubtractEquation ]: gl.FUNC_REVERSE_SUBTRACT
  	};

  	equationToGL[ MinEquation ] = gl.MIN;
  	equationToGL[ MaxEquation ] = gl.MAX;

  	const factorToGL = {
  		[ ZeroFactor ]: gl.ZERO,
  		[ OneFactor ]: gl.ONE,
  		[ SrcColorFactor ]: gl.SRC_COLOR,
  		[ SrcAlphaFactor ]: gl.SRC_ALPHA,
  		[ SrcAlphaSaturateFactor ]: gl.SRC_ALPHA_SATURATE,
  		[ DstColorFactor ]: gl.DST_COLOR,
  		[ DstAlphaFactor ]: gl.DST_ALPHA,
  		[ OneMinusSrcColorFactor ]: gl.ONE_MINUS_SRC_COLOR,
  		[ OneMinusSrcAlphaFactor ]: gl.ONE_MINUS_SRC_ALPHA,
  		[ OneMinusDstColorFactor ]: gl.ONE_MINUS_DST_COLOR,
  		[ OneMinusDstAlphaFactor ]: gl.ONE_MINUS_DST_ALPHA,
  		[ ConstantColorFactor ]: gl.CONSTANT_COLOR,
  		[ OneMinusConstantColorFactor ]: gl.ONE_MINUS_CONSTANT_COLOR,
  		[ ConstantAlphaFactor ]: gl.CONSTANT_ALPHA,
  		[ OneMinusConstantAlphaFactor ]: gl.ONE_MINUS_CONSTANT_ALPHA
  	};

  	function setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, blendColor, blendAlpha, premultipliedAlpha ) {

  		if ( blending === NoBlending ) {

  			if ( currentBlendingEnabled === true ) {

  				disable( gl.BLEND );
  				currentBlendingEnabled = false;

  			}

  			return;

  		}

  		if ( currentBlendingEnabled === false ) {

  			enable( gl.BLEND );
  			currentBlendingEnabled = true;

  		}

  		if ( blending !== CustomBlending ) {

  			if ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {

  				if ( currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation ) {

  					gl.blendEquation( gl.FUNC_ADD );

  					currentBlendEquation = AddEquation;
  					currentBlendEquationAlpha = AddEquation;

  				}

  				if ( premultipliedAlpha ) {

  					switch ( blending ) {

  						case NormalBlending:
  							gl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );
  							break;

  						case AdditiveBlending:
  							gl.blendFunc( gl.ONE, gl.ONE );
  							break;

  						case SubtractiveBlending:
  							gl.blendFuncSeparate( gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE );
  							break;

  						case MultiplyBlending:
  							gl.blendFuncSeparate( gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA );
  							break;

  						default:
  							console.error( 'THREE.WebGLState: Invalid blending: ', blending );
  							break;

  					}

  				} else {

  					switch ( blending ) {

  						case NormalBlending:
  							gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );
  							break;

  						case AdditiveBlending:
  							gl.blendFunc( gl.SRC_ALPHA, gl.ONE );
  							break;

  						case SubtractiveBlending:
  							gl.blendFuncSeparate( gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE );
  							break;

  						case MultiplyBlending:
  							gl.blendFunc( gl.ZERO, gl.SRC_COLOR );
  							break;

  						default:
  							console.error( 'THREE.WebGLState: Invalid blending: ', blending );
  							break;

  					}

  				}

  				currentBlendSrc = null;
  				currentBlendDst = null;
  				currentBlendSrcAlpha = null;
  				currentBlendDstAlpha = null;
  				currentBlendColor.set( 0, 0, 0 );
  				currentBlendAlpha = 0;

  				currentBlending = blending;
  				currentPremultipledAlpha = premultipliedAlpha;

  			}

  			return;

  		}

  		// custom blending

  		blendEquationAlpha = blendEquationAlpha || blendEquation;
  		blendSrcAlpha = blendSrcAlpha || blendSrc;
  		blendDstAlpha = blendDstAlpha || blendDst;

  		if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {

  			gl.blendEquationSeparate( equationToGL[ blendEquation ], equationToGL[ blendEquationAlpha ] );

  			currentBlendEquation = blendEquation;
  			currentBlendEquationAlpha = blendEquationAlpha;

  		}

  		if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {

  			gl.blendFuncSeparate( factorToGL[ blendSrc ], factorToGL[ blendDst ], factorToGL[ blendSrcAlpha ], factorToGL[ blendDstAlpha ] );

  			currentBlendSrc = blendSrc;
  			currentBlendDst = blendDst;
  			currentBlendSrcAlpha = blendSrcAlpha;
  			currentBlendDstAlpha = blendDstAlpha;

  		}

  		if ( blendColor.equals( currentBlendColor ) === false || blendAlpha !== currentBlendAlpha ) {

  			gl.blendColor( blendColor.r, blendColor.g, blendColor.b, blendAlpha );

  			currentBlendColor.copy( blendColor );
  			currentBlendAlpha = blendAlpha;

  		}

  		currentBlending = blending;
  		currentPremultipledAlpha = false;

  	}

  	function setMaterial( material, frontFaceCW ) {

  		material.side === DoubleSide
  			? disable( gl.CULL_FACE )
  			: enable( gl.CULL_FACE );

  		let flipSided = ( material.side === BackSide );
  		if ( frontFaceCW ) flipSided = ! flipSided;

  		setFlipSided( flipSided );

  		( material.blending === NormalBlending && material.transparent === false )
  			? setBlending( NoBlending )
  			: setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.blendColor, material.blendAlpha, material.premultipliedAlpha );

  		depthBuffer.setFunc( material.depthFunc );
  		depthBuffer.setTest( material.depthTest );
  		depthBuffer.setMask( material.depthWrite );
  		colorBuffer.setMask( material.colorWrite );

  		const stencilWrite = material.stencilWrite;
  		stencilBuffer.setTest( stencilWrite );
  		if ( stencilWrite ) {

  			stencilBuffer.setMask( material.stencilWriteMask );
  			stencilBuffer.setFunc( material.stencilFunc, material.stencilRef, material.stencilFuncMask );
  			stencilBuffer.setOp( material.stencilFail, material.stencilZFail, material.stencilZPass );

  		}

  		setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

  		material.alphaToCoverage === true
  			? enable( gl.SAMPLE_ALPHA_TO_COVERAGE )
  			: disable( gl.SAMPLE_ALPHA_TO_COVERAGE );

  	}

  	//

  	function setFlipSided( flipSided ) {

  		if ( currentFlipSided !== flipSided ) {

  			if ( flipSided ) {

  				gl.frontFace( gl.CW );

  			} else {

  				gl.frontFace( gl.CCW );

  			}

  			currentFlipSided = flipSided;

  		}

  	}

  	function setCullFace( cullFace ) {

  		if ( cullFace !== CullFaceNone ) {

  			enable( gl.CULL_FACE );

  			if ( cullFace !== currentCullFace ) {

  				if ( cullFace === CullFaceBack ) {

  					gl.cullFace( gl.BACK );

  				} else if ( cullFace === CullFaceFront ) {

  					gl.cullFace( gl.FRONT );

  				} else {

  					gl.cullFace( gl.FRONT_AND_BACK );

  				}

  			}

  		} else {

  			disable( gl.CULL_FACE );

  		}

  		currentCullFace = cullFace;

  	}

  	function setLineWidth( width ) {

  		if ( width !== currentLineWidth ) {

  			if ( lineWidthAvailable ) gl.lineWidth( width );

  			currentLineWidth = width;

  		}

  	}

  	function setPolygonOffset( polygonOffset, factor, units ) {

  		if ( polygonOffset ) {

  			enable( gl.POLYGON_OFFSET_FILL );

  			if ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {

  				gl.polygonOffset( factor, units );

  				currentPolygonOffsetFactor = factor;
  				currentPolygonOffsetUnits = units;

  			}

  		} else {

  			disable( gl.POLYGON_OFFSET_FILL );

  		}

  	}

  	function setScissorTest( scissorTest ) {

  		if ( scissorTest ) {

  			enable( gl.SCISSOR_TEST );

  		} else {

  			disable( gl.SCISSOR_TEST );

  		}

  	}

  	// texture

  	function activeTexture( webglSlot ) {

  		if ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;

  		if ( currentTextureSlot !== webglSlot ) {

  			gl.activeTexture( webglSlot );
  			currentTextureSlot = webglSlot;

  		}

  	}

  	function bindTexture( webglType, webglTexture, webglSlot ) {

  		if ( webglSlot === undefined ) {

  			if ( currentTextureSlot === null ) {

  				webglSlot = gl.TEXTURE0 + maxTextures - 1;

  			} else {

  				webglSlot = currentTextureSlot;

  			}

  		}

  		let boundTexture = currentBoundTextures[ webglSlot ];

  		if ( boundTexture === undefined ) {

  			boundTexture = { type: undefined, texture: undefined };
  			currentBoundTextures[ webglSlot ] = boundTexture;

  		}

  		if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {

  			if ( currentTextureSlot !== webglSlot ) {

  				gl.activeTexture( webglSlot );
  				currentTextureSlot = webglSlot;

  			}

  			gl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );

  			boundTexture.type = webglType;
  			boundTexture.texture = webglTexture;

  		}

  	}

  	function unbindTexture() {

  		const boundTexture = currentBoundTextures[ currentTextureSlot ];

  		if ( boundTexture !== undefined && boundTexture.type !== undefined ) {

  			gl.bindTexture( boundTexture.type, null );

  			boundTexture.type = undefined;
  			boundTexture.texture = undefined;

  		}

  	}

  	function compressedTexImage2D() {

  		try {

  			gl.compressedTexImage2D.apply( gl, arguments );

  		} catch ( error ) {

  			console.error( 'THREE.WebGLState:', error );

  		}

  	}

  	function compressedTexImage3D() {

  		try {

  			gl.compressedTexImage3D.apply( gl, arguments );

  		} catch ( error ) {

  			console.error( 'THREE.WebGLState:', error );

  		}

  	}

  	function texSubImage2D() {

  		try {

  			gl.texSubImage2D.apply( gl, arguments );

  		} catch ( error ) {

  			console.error( 'THREE.WebGLState:', error );

  		}

  	}

  	function texSubImage3D() {

  		try {

  			gl.texSubImage3D.apply( gl, arguments );

  		} catch ( error ) {

  			console.error( 'THREE.WebGLState:', error );

  		}

  	}

  	function compressedTexSubImage2D() {

  		try {

  			gl.compressedTexSubImage2D.apply( gl, arguments );

  		} catch ( error ) {

  			console.error( 'THREE.WebGLState:', error );

  		}

  	}

  	function compressedTexSubImage3D() {

  		try {

  			gl.compressedTexSubImage3D.apply( gl, arguments );

  		} catch ( error ) {

  			console.error( 'THREE.WebGLState:', error );

  		}

  	}

  	function texStorage2D() {

  		try {

  			gl.texStorage2D.apply( gl, arguments );

  		} catch ( error ) {

  			console.error( 'THREE.WebGLState:', error );

  		}

  	}

  	function texStorage3D() {

  		try {

  			gl.texStorage3D.apply( gl, arguments );

  		} catch ( error ) {

  			console.error( 'THREE.WebGLState:', error );

  		}

  	}

  	function texImage2D() {

  		try {

  			gl.texImage2D.apply( gl, arguments );

  		} catch ( error ) {

  			console.error( 'THREE.WebGLState:', error );

  		}

  	}

  	function texImage3D() {

  		try {

  			gl.texImage3D.apply( gl, arguments );

  		} catch ( error ) {

  			console.error( 'THREE.WebGLState:', error );

  		}

  	}

  	//

  	function scissor( scissor ) {

  		if ( currentScissor.equals( scissor ) === false ) {

  			gl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );
  			currentScissor.copy( scissor );

  		}

  	}

  	function viewport( viewport ) {

  		if ( currentViewport.equals( viewport ) === false ) {

  			gl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );
  			currentViewport.copy( viewport );

  		}

  	}

  	function updateUBOMapping( uniformsGroup, program ) {

  		let mapping = uboProgramMap.get( program );

  		if ( mapping === undefined ) {

  			mapping = new WeakMap();

  			uboProgramMap.set( program, mapping );

  		}

  		let blockIndex = mapping.get( uniformsGroup );

  		if ( blockIndex === undefined ) {

  			blockIndex = gl.getUniformBlockIndex( program, uniformsGroup.name );

  			mapping.set( uniformsGroup, blockIndex );

  		}

  	}

  	function uniformBlockBinding( uniformsGroup, program ) {

  		const mapping = uboProgramMap.get( program );
  		const blockIndex = mapping.get( uniformsGroup );

  		if ( uboBindings.get( program ) !== blockIndex ) {

  			// bind shader specific block index to global block point
  			gl.uniformBlockBinding( program, blockIndex, uniformsGroup.__bindingPointIndex );

  			uboBindings.set( program, blockIndex );

  		}

  	}

  	//

  	function reset() {

  		// reset state

  		gl.disable( gl.BLEND );
  		gl.disable( gl.CULL_FACE );
  		gl.disable( gl.DEPTH_TEST );
  		gl.disable( gl.POLYGON_OFFSET_FILL );
  		gl.disable( gl.SCISSOR_TEST );
  		gl.disable( gl.STENCIL_TEST );
  		gl.disable( gl.SAMPLE_ALPHA_TO_COVERAGE );

  		gl.blendEquation( gl.FUNC_ADD );
  		gl.blendFunc( gl.ONE, gl.ZERO );
  		gl.blendFuncSeparate( gl.ONE, gl.ZERO, gl.ONE, gl.ZERO );
  		gl.blendColor( 0, 0, 0, 0 );

  		gl.colorMask( true, true, true, true );
  		gl.clearColor( 0, 0, 0, 0 );

  		gl.depthMask( true );
  		gl.depthFunc( gl.LESS );
  		gl.clearDepth( 1 );

  		gl.stencilMask( 0xffffffff );
  		gl.stencilFunc( gl.ALWAYS, 0, 0xffffffff );
  		gl.stencilOp( gl.KEEP, gl.KEEP, gl.KEEP );
  		gl.clearStencil( 0 );

  		gl.cullFace( gl.BACK );
  		gl.frontFace( gl.CCW );

  		gl.polygonOffset( 0, 0 );

  		gl.activeTexture( gl.TEXTURE0 );

  		gl.bindFramebuffer( gl.FRAMEBUFFER, null );
  		gl.bindFramebuffer( gl.DRAW_FRAMEBUFFER, null );
  		gl.bindFramebuffer( gl.READ_FRAMEBUFFER, null );

  		gl.useProgram( null );

  		gl.lineWidth( 1 );

  		gl.scissor( 0, 0, gl.canvas.width, gl.canvas.height );
  		gl.viewport( 0, 0, gl.canvas.width, gl.canvas.height );

  		// reset internals

  		enabledCapabilities = {};

  		currentTextureSlot = null;
  		currentBoundTextures = {};

  		currentBoundFramebuffers = {};
  		currentDrawbuffers = new WeakMap();
  		defaultDrawbuffers = [];

  		currentProgram = null;

  		currentBlendingEnabled = false;
  		currentBlending = null;
  		currentBlendEquation = null;
  		currentBlendSrc = null;
  		currentBlendDst = null;
  		currentBlendEquationAlpha = null;
  		currentBlendSrcAlpha = null;
  		currentBlendDstAlpha = null;
  		currentBlendColor = new Color( 0, 0, 0 );
  		currentBlendAlpha = 0;
  		currentPremultipledAlpha = false;

  		currentFlipSided = null;
  		currentCullFace = null;

  		currentLineWidth = null;

  		currentPolygonOffsetFactor = null;
  		currentPolygonOffsetUnits = null;

  		currentScissor.set( 0, 0, gl.canvas.width, gl.canvas.height );
  		currentViewport.set( 0, 0, gl.canvas.width, gl.canvas.height );

  		colorBuffer.reset();
  		depthBuffer.reset();
  		stencilBuffer.reset();

  	}

  	return {

  		buffers: {
  			color: colorBuffer,
  			depth: depthBuffer,
  			stencil: stencilBuffer
  		},

  		enable: enable,
  		disable: disable,

  		bindFramebuffer: bindFramebuffer,
  		drawBuffers: drawBuffers,

  		useProgram: useProgram,

  		setBlending: setBlending,
  		setMaterial: setMaterial,

  		setFlipSided: setFlipSided,
  		setCullFace: setCullFace,

  		setLineWidth: setLineWidth,
  		setPolygonOffset: setPolygonOffset,

  		setScissorTest: setScissorTest,

  		activeTexture: activeTexture,
  		bindTexture: bindTexture,
  		unbindTexture: unbindTexture,
  		compressedTexImage2D: compressedTexImage2D,
  		compressedTexImage3D: compressedTexImage3D,
  		texImage2D: texImage2D,
  		texImage3D: texImage3D,

  		updateUBOMapping: updateUBOMapping,
  		uniformBlockBinding: uniformBlockBinding,

  		texStorage2D: texStorage2D,
  		texStorage3D: texStorage3D,
  		texSubImage2D: texSubImage2D,
  		texSubImage3D: texSubImage3D,
  		compressedTexSubImage2D: compressedTexSubImage2D,
  		compressedTexSubImage3D: compressedTexSubImage3D,

  		scissor: scissor,
  		viewport: viewport,

  		reset: reset

  	};

  }



  /**
   * Given the width, height, format, and type of a texture. Determines how many
   * bytes must be used to represent the texture.
   */
  function getByteLength( width, height, format, type ) {

  	const typeByteLength = getTextureTypeByteLength( type );

  	switch ( format ) {

  		// https://registry.khronos.org/OpenGL-Refpages/es3.0/html/glTexImage2D.xhtml
  		case AlphaFormat:
  			return width * height;
  		case LuminanceFormat:
  			return width * height;
  		case LuminanceAlphaFormat:
  			return width * height * 2;
  		case RedFormat:
  			return ( ( width * height ) / typeByteLength.components ) * typeByteLength.byteLength;
  		case RedIntegerFormat:
  			return ( ( width * height ) / typeByteLength.components ) * typeByteLength.byteLength;
  		case RGFormat:
  			return ( ( width * height * 2 ) / typeByteLength.components ) * typeByteLength.byteLength;
  		case RGIntegerFormat:
  			return ( ( width * height * 2 ) / typeByteLength.components ) * typeByteLength.byteLength;
  		case RGBFormat:
  			return ( ( width * height * 3 ) / typeByteLength.components ) * typeByteLength.byteLength;
  		case RGBAFormat:
  			return ( ( width * height * 4 ) / typeByteLength.components ) * typeByteLength.byteLength;
  		case RGBAIntegerFormat:
  			return ( ( width * height * 4 ) / typeByteLength.components ) * typeByteLength.byteLength;

  		// https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_s3tc_srgb/
  		case RGB_S3TC_DXT1_Format:
  		case RGBA_S3TC_DXT1_Format:
  			return Math.floor( ( width + 3 ) / 4 ) * Math.floor( ( height + 3 ) / 4 ) * 8;
  		case RGBA_S3TC_DXT3_Format:
  		case RGBA_S3TC_DXT5_Format:
  			return Math.floor( ( width + 3 ) / 4 ) * Math.floor( ( height + 3 ) / 4 ) * 16;

  		// https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_pvrtc/
  		case RGB_PVRTC_2BPPV1_Format:
  		case RGBA_PVRTC_2BPPV1_Format:
  			return ( Math.max( width, 16 ) * Math.max( height, 8 ) ) / 4;
  		case RGB_PVRTC_4BPPV1_Format:
  		case RGBA_PVRTC_4BPPV1_Format:
  			return ( Math.max( width, 8 ) * Math.max( height, 8 ) ) / 2;

  		// https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_etc/
  		case RGB_ETC1_Format:
  		case RGB_ETC2_Format:
  			return Math.floor( ( width + 3 ) / 4 ) * Math.floor( ( height + 3 ) / 4 ) * 8;
  		case RGBA_ETC2_EAC_Format:
  			return Math.floor( ( width + 3 ) / 4 ) * Math.floor( ( height + 3 ) / 4 ) * 16;

  		// https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_astc/
  		case RGBA_ASTC_4x4_Format:
  			return Math.floor( ( width + 3 ) / 4 ) * Math.floor( ( height + 3 ) / 4 ) * 16;
  		case RGBA_ASTC_5x4_Format:
  			return Math.floor( ( width + 4 ) / 5 ) * Math.floor( ( height + 3 ) / 4 ) * 16;
  		case RGBA_ASTC_5x5_Format:
  			return Math.floor( ( width + 4 ) / 5 ) * Math.floor( ( height + 4 ) / 5 ) * 16;
  		case RGBA_ASTC_6x5_Format:
  			return Math.floor( ( width + 5 ) / 6 ) * Math.floor( ( height + 4 ) / 5 ) * 16;
  		case RGBA_ASTC_6x6_Format:
  			return Math.floor( ( width + 5 ) / 6 ) * Math.floor( ( height + 5 ) / 6 ) * 16;
  		case RGBA_ASTC_8x5_Format:
  			return Math.floor( ( width + 7 ) / 8 ) * Math.floor( ( height + 4 ) / 5 ) * 16;
  		case RGBA_ASTC_8x6_Format:
  			return Math.floor( ( width + 7 ) / 8 ) * Math.floor( ( height + 5 ) / 6 ) * 16;
  		case RGBA_ASTC_8x8_Format:
  			return Math.floor( ( width + 7 ) / 8 ) * Math.floor( ( height + 7 ) / 8 ) * 16;
  		case RGBA_ASTC_10x5_Format:
  			return Math.floor( ( width + 9 ) / 10 ) * Math.floor( ( height + 4 ) / 5 ) * 16;
  		case RGBA_ASTC_10x6_Format:
  			return Math.floor( ( width + 9 ) / 10 ) * Math.floor( ( height + 5 ) / 6 ) * 16;
  		case RGBA_ASTC_10x8_Format:
  			return Math.floor( ( width + 9 ) / 10 ) * Math.floor( ( height + 7 ) / 8 ) * 16;
  		case RGBA_ASTC_10x10_Format:
  			return Math.floor( ( width + 9 ) / 10 ) * Math.floor( ( height + 9 ) / 10 ) * 16;
  		case RGBA_ASTC_12x10_Format:
  			return Math.floor( ( width + 11 ) / 12 ) * Math.floor( ( height + 9 ) / 10 ) * 16;
  		case RGBA_ASTC_12x12_Format:
  			return Math.floor( ( width + 11 ) / 12 ) * Math.floor( ( height + 11 ) / 12 ) * 16;

  		// https://registry.khronos.org/webgl/extensions/EXT_texture_compression_bptc/
  		case RGBA_BPTC_Format:
  		case RGB_BPTC_SIGNED_Format:
  		case RGB_BPTC_UNSIGNED_Format:
  			return Math.ceil( width / 4 ) * Math.ceil( height / 4 ) * 16;

  		// https://registry.khronos.org/webgl/extensions/EXT_texture_compression_rgtc/
  		case RED_RGTC1_Format:
  		case SIGNED_RED_RGTC1_Format:
  			return Math.ceil( width / 4 ) * Math.ceil( height / 4 ) * 8;
  		case RED_GREEN_RGTC2_Format:
  		case SIGNED_RED_GREEN_RGTC2_Format:
  			return Math.ceil( width / 4 ) * Math.ceil( height / 4 ) * 16;

  	}

  	throw new Error(
  		`Unable to determine texture byte length for ${format} format.`,
  	);

  }

  function getTextureTypeByteLength( type ) {

  	switch ( type ) {

  		case UnsignedByteType:
  		case ByteType:
  			return { byteLength: 1, components: 1 };
  		case UnsignedShortType:
  		case ShortType:
  		case HalfFloatType:
  			return { byteLength: 2, components: 1 };
  		case UnsignedShort4444Type:
  		case UnsignedShort5551Type:
  			return { byteLength: 2, components: 4 };
  		case UnsignedIntType:
  		case IntType:
  		case FloatType:
  			return { byteLength: 4, components: 1 };
  		case UnsignedInt5999Type:
  			return { byteLength: 4, components: 3 };

  	}

  	throw new Error( `Unknown texture type ${type}.` );

  }

  function WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info ) {

  	const multisampledRTTExt = extensions.has( 'WEBGL_multisampled_render_to_texture' ) ? extensions.get( 'WEBGL_multisampled_render_to_texture' ) : null;
  	const supportsInvalidateFramebuffer = typeof navigator === 'undefined' ? false : /OculusBrowser/g.test( navigator.userAgent );

  	const _imageDimensions = new Vector2();
  	const _videoTextures = new WeakMap();
  	let _canvas;

  	const _sources = new WeakMap(); // maps WebglTexture objects to instances of Source

  	// cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,
  	// also OffscreenCanvas.getContext("webgl"), but not OffscreenCanvas.getContext("2d")!
  	// Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).

  	let useOffscreenCanvas = false;

  	try {

  		useOffscreenCanvas = typeof OffscreenCanvas !== 'undefined'
  			// eslint-disable-next-line compat/compat
  			&& ( new OffscreenCanvas( 1, 1 ).getContext( '2d' ) ) !== null;

  	} catch ( err ) {

  		// Ignore any errors

  	}

  	function createCanvas( width, height ) {

  		// Use OffscreenCanvas when available. Specially needed in web workers

  		return useOffscreenCanvas ?
  			// eslint-disable-next-line compat/compat
  			new OffscreenCanvas( width, height ) : createElementNS( 'canvas' );

  	}

  	function resizeImage( image, needsNewCanvas, maxSize ) {

  		let scale = 1;

  		const dimensions = getDimensions( image );

  		// handle case if texture exceeds max size

  		if ( dimensions.width > maxSize || dimensions.height > maxSize ) {

  			scale = maxSize / Math.max( dimensions.width, dimensions.height );

  		}

  		// only perform resize if necessary

  		if ( scale < 1 ) {

  			// only perform resize for certain image types

  			if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
  				( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
  				( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ||
  				( typeof VideoFrame !== 'undefined' && image instanceof VideoFrame ) ) {

  				const width = Math.floor( scale * dimensions.width );
  				const height = Math.floor( scale * dimensions.height );

  				if ( _canvas === undefined ) _canvas = createCanvas( width, height );

  				// cube textures can't reuse the same canvas

  				const canvas = needsNewCanvas ? createCanvas( width, height ) : _canvas;

  				canvas.width = width;
  				canvas.height = height;

  				const context = canvas.getContext( '2d' );
  				context.drawImage( image, 0, 0, width, height );

  				console.warn( 'THREE.WebGLRenderer: Texture has been resized from (' + dimensions.width + 'x' + dimensions.height + ') to (' + width + 'x' + height + ').' );

  				return canvas;

  			} else {

  				if ( 'data' in image ) {

  					console.warn( 'THREE.WebGLRenderer: Image in DataTexture is too big (' + dimensions.width + 'x' + dimensions.height + ').' );

  				}

  				return image;

  			}

  		}

  		return image;

  	}

  	function textureNeedsGenerateMipmaps( texture ) {

  		return texture.generateMipmaps && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;

  	}

  	function generateMipmap( target ) {

  		_gl.generateMipmap( target );

  	}

  	function getInternalFormat( internalFormatName, glFormat, glType, colorSpace, forceLinearTransfer = false ) {

  		if ( internalFormatName !== null ) {

  			if ( _gl[ internalFormatName ] !== undefined ) return _gl[ internalFormatName ];

  			console.warn( 'THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \'' + internalFormatName + '\'' );

  		}

  		let internalFormat = glFormat;

  		if ( glFormat === _gl.RED ) {

  			if ( glType === _gl.FLOAT ) internalFormat = _gl.R32F;
  			if ( glType === _gl.HALF_FLOAT ) internalFormat = _gl.R16F;
  			if ( glType === _gl.UNSIGNED_BYTE ) internalFormat = _gl.R8;

  		}

  		if ( glFormat === _gl.RED_INTEGER ) {

  			if ( glType === _gl.UNSIGNED_BYTE ) internalFormat = _gl.R8UI;
  			if ( glType === _gl.UNSIGNED_SHORT ) internalFormat = _gl.R16UI;
  			if ( glType === _gl.UNSIGNED_INT ) internalFormat = _gl.R32UI;
  			if ( glType === _gl.BYTE ) internalFormat = _gl.R8I;
  			if ( glType === _gl.SHORT ) internalFormat = _gl.R16I;
  			if ( glType === _gl.INT ) internalFormat = _gl.R32I;

  		}

  		if ( glFormat === _gl.RG ) {

  			if ( glType === _gl.FLOAT ) internalFormat = _gl.RG32F;
  			if ( glType === _gl.HALF_FLOAT ) internalFormat = _gl.RG16F;
  			if ( glType === _gl.UNSIGNED_BYTE ) internalFormat = _gl.RG8;

  		}

  		if ( glFormat === _gl.RG_INTEGER ) {

  			if ( glType === _gl.UNSIGNED_BYTE ) internalFormat = _gl.RG8UI;
  			if ( glType === _gl.UNSIGNED_SHORT ) internalFormat = _gl.RG16UI;
  			if ( glType === _gl.UNSIGNED_INT ) internalFormat = _gl.RG32UI;
  			if ( glType === _gl.BYTE ) internalFormat = _gl.RG8I;
  			if ( glType === _gl.SHORT ) internalFormat = _gl.RG16I;
  			if ( glType === _gl.INT ) internalFormat = _gl.RG32I;

  		}

  		if ( glFormat === _gl.RGB ) {

  			if ( glType === _gl.UNSIGNED_INT_5_9_9_9_REV ) internalFormat = _gl.RGB9_E5;

  		}

  		if ( glFormat === _gl.RGBA ) {

  			const transfer = forceLinearTransfer ? LinearTransfer : ColorManagement.getTransfer( colorSpace );

  			if ( glType === _gl.FLOAT ) internalFormat = _gl.RGBA32F;
  			if ( glType === _gl.HALF_FLOAT ) internalFormat = _gl.RGBA16F;
  			if ( glType === _gl.UNSIGNED_BYTE ) internalFormat = ( transfer === SRGBTransfer ) ? _gl.SRGB8_ALPHA8 : _gl.RGBA8;
  			if ( glType === _gl.UNSIGNED_SHORT_4_4_4_4 ) internalFormat = _gl.RGBA4;
  			if ( glType === _gl.UNSIGNED_SHORT_5_5_5_1 ) internalFormat = _gl.RGB5_A1;

  		}

  		if ( internalFormat === _gl.R16F || internalFormat === _gl.R32F ||
  			internalFormat === _gl.RG16F || internalFormat === _gl.RG32F ||
  			internalFormat === _gl.RGBA16F || internalFormat === _gl.RGBA32F ) {

  			extensions.get( 'EXT_color_buffer_float' );

  		}

  		return internalFormat;

  	}

  	function getInternalDepthFormat( useStencil, depthType ) {

  		let glInternalFormat;
  		if ( useStencil ) {

  			if ( depthType === null || depthType === UnsignedIntType || depthType === UnsignedInt248Type ) {

  				glInternalFormat = _gl.DEPTH24_STENCIL8;

  			} else if ( depthType === FloatType ) {

  				glInternalFormat = _gl.DEPTH32F_STENCIL8;

  			} else if ( depthType === UnsignedShortType ) {

  				glInternalFormat = _gl.DEPTH24_STENCIL8;
  				console.warn( 'DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.' );

  			}

  		} else {

  			if ( depthType === null || depthType === UnsignedIntType || depthType === UnsignedInt248Type ) {

  				glInternalFormat = _gl.DEPTH_COMPONENT24;

  			} else if ( depthType === FloatType ) {

  				glInternalFormat = _gl.DEPTH_COMPONENT32F;

  			} else if ( depthType === UnsignedShortType ) {

  				glInternalFormat = _gl.DEPTH_COMPONENT16;

  			}

  		}

  		return glInternalFormat;

  	}

  	function getMipLevels( texture, image ) {

  		if ( textureNeedsGenerateMipmaps( texture ) === true || ( texture.isFramebufferTexture && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) ) {

  			return Math.log2( Math.max( image.width, image.height ) ) + 1;

  		} else if ( texture.mipmaps !== undefined && texture.mipmaps.length > 0 ) {

  			// user-defined mipmaps

  			return texture.mipmaps.length;

  		} else if ( texture.isCompressedTexture && Array.isArray( texture.image ) ) {

  			return image.mipmaps.length;

  		} else {

  			// texture without mipmaps (only base level)

  			return 1;

  		}

  	}

  	//

  	function onTextureDispose( event ) {

  		const texture = event.target;

  		texture.removeEventListener( 'dispose', onTextureDispose );

  		deallocateTexture( texture );

  		if ( texture.isVideoTexture ) {

  			_videoTextures.delete( texture );

  		}

  	}

  	function onRenderTargetDispose( event ) {

  		const renderTarget = event.target;

  		renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

  		deallocateRenderTarget( renderTarget );

  	}

  	//

  	function deallocateTexture( texture ) {

  		const textureProperties = properties.get( texture );

  		if ( textureProperties.__webglInit === undefined ) return;

  		// check if it's necessary to remove the WebGLTexture object

  		const source = texture.source;
  		const webglTextures = _sources.get( source );

  		if ( webglTextures ) {

  			const webglTexture = webglTextures[ textureProperties.__cacheKey ];
  			webglTexture.usedTimes --;

  			// the WebGLTexture object is not used anymore, remove it

  			if ( webglTexture.usedTimes === 0 ) {

  				deleteTexture( texture );

  			}

  			// remove the weak map entry if no WebGLTexture uses the source anymore

  			if ( Object.keys( webglTextures ).length === 0 ) {

  				_sources.delete( source );

  			}

  		}

  		properties.remove( texture );

  	}

  	function deleteTexture( texture ) {

  		const textureProperties = properties.get( texture );
  		_gl.deleteTexture( textureProperties.__webglTexture );

  		const source = texture.source;
  		const webglTextures = _sources.get( source );
  		delete webglTextures[ textureProperties.__cacheKey ];

  		info.memory.textures --;

  	}

  	function deallocateRenderTarget( renderTarget ) {

  		const renderTargetProperties = properties.get( renderTarget );

  		if ( renderTarget.depthTexture ) {

  			renderTarget.depthTexture.dispose();

  		}

  		if ( renderTarget.isWebGLCubeRenderTarget ) {

  			for ( let i = 0; i < 6; i ++ ) {

  				if ( Array.isArray( renderTargetProperties.__webglFramebuffer[ i ] ) ) {

  					for ( let level = 0; level < renderTargetProperties.__webglFramebuffer[ i ].length; level ++ ) _gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ][ level ] );

  				} else {

  					_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );

  				}

  				if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );

  			}

  		} else {

  			if ( Array.isArray( renderTargetProperties.__webglFramebuffer ) ) {

  				for ( let level = 0; level < renderTargetProperties.__webglFramebuffer.length; level ++ ) _gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ level ] );

  			} else {

  				_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );

  			}

  			if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );
  			if ( renderTargetProperties.__webglMultisampledFramebuffer ) _gl.deleteFramebuffer( renderTargetProperties.__webglMultisampledFramebuffer );

  			if ( renderTargetProperties.__webglColorRenderbuffer ) {

  				for ( let i = 0; i < renderTargetProperties.__webglColorRenderbuffer.length; i ++ ) {

  					if ( renderTargetProperties.__webglColorRenderbuffer[ i ] ) _gl.deleteRenderbuffer( renderTargetProperties.__webglColorRenderbuffer[ i ] );

  				}

  			}

  			if ( renderTargetProperties.__webglDepthRenderbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthRenderbuffer );

  		}

  		const textures = renderTarget.textures;

  		for ( let i = 0, il = textures.length; i < il; i ++ ) {

  			const attachmentProperties = properties.get( textures[ i ] );

  			if ( attachmentProperties.__webglTexture ) {

  				_gl.deleteTexture( attachmentProperties.__webglTexture );

  				info.memory.textures --;

  			}

  			properties.remove( textures[ i ] );

  		}

  		properties.remove( renderTarget );

  	}

  	//

  	let textureUnits = 0;

  	function resetTextureUnits() {

  		textureUnits = 0;

  	}

  	function allocateTextureUnit() {

  		const textureUnit = textureUnits;

  		if ( textureUnit >= capabilities.maxTextures ) {

  			console.warn( 'THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );

  		}

  		textureUnits += 1;

  		return textureUnit;

  	}

  	function getTextureCacheKey( texture ) {

  		const array = [];

  		array.push( texture.wrapS );
  		array.push( texture.wrapT );
  		array.push( texture.wrapR || 0 );
  		array.push( texture.magFilter );
  		array.push( texture.minFilter );
  		array.push( texture.anisotropy );
  		array.push( texture.internalFormat );
  		array.push( texture.format );
  		array.push( texture.type );
  		array.push( texture.generateMipmaps );
  		array.push( texture.premultiplyAlpha );
  		array.push( texture.flipY );
  		array.push( texture.unpackAlignment );
  		array.push( texture.colorSpace );

  		return array.join();

  	}

  	//

  	function setTexture2D( texture, slot ) {

  		const textureProperties = properties.get( texture );

  		if ( texture.isVideoTexture ) updateVideoTexture( texture );

  		if ( texture.isRenderTargetTexture === false && texture.version > 0 && textureProperties.__version !== texture.version ) {

  			const image = texture.image;

  			if ( image === null ) {

  				console.warn( 'THREE.WebGLRenderer: Texture marked for update but no image data found.' );

  			} else if ( image.complete === false ) {

  				console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete' );

  			} else {

  				uploadTexture( textureProperties, texture, slot );
  				return;

  			}

  		}

  		state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture, _gl.TEXTURE0 + slot );

  	}

  	function setTexture2DArray( texture, slot ) {

  		const textureProperties = properties.get( texture );

  		if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

  			uploadTexture( textureProperties, texture, slot );
  			return;

  		}

  		state.bindTexture( _gl.TEXTURE_2D_ARRAY, textureProperties.__webglTexture, _gl.TEXTURE0 + slot );

  	}

  	function setTexture3D( texture, slot ) {

  		const textureProperties = properties.get( texture );

  		if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

  			uploadTexture( textureProperties, texture, slot );
  			return;

  		}

  		state.bindTexture( _gl.TEXTURE_3D, textureProperties.__webglTexture, _gl.TEXTURE0 + slot );

  	}

  	function setTextureCube( texture, slot ) {

  		const textureProperties = properties.get( texture );

  		if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

  			uploadCubeTexture( textureProperties, texture, slot );
  			return;

  		}

  		state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture, _gl.TEXTURE0 + slot );

  	}

  	const wrappingToGL = {
  		[ RepeatWrapping ]: _gl.REPEAT,
  		[ ClampToEdgeWrapping ]: _gl.CLAMP_TO_EDGE,
  		[ MirroredRepeatWrapping ]: _gl.MIRRORED_REPEAT
  	};

  	const filterToGL = {
  		[ NearestFilter ]: _gl.NEAREST,
  		[ NearestMipmapNearestFilter ]: _gl.NEAREST_MIPMAP_NEAREST,
  		[ NearestMipmapLinearFilter ]: _gl.NEAREST_MIPMAP_LINEAR,

  		[ LinearFilter ]: _gl.LINEAR,
  		[ LinearMipmapNearestFilter ]: _gl.LINEAR_MIPMAP_NEAREST,
  		[ LinearMipmapLinearFilter ]: _gl.LINEAR_MIPMAP_LINEAR
  	};

  	const compareToGL = {
  		[ NeverCompare ]: _gl.NEVER,
  		[ AlwaysCompare ]: _gl.ALWAYS,
  		[ LessCompare ]: _gl.LESS,
  		[ LessEqualCompare ]: _gl.LEQUAL,
  		[ EqualCompare ]: _gl.EQUAL,
  		[ GreaterEqualCompare ]: _gl.GEQUAL,
  		[ GreaterCompare ]: _gl.GREATER,
  		[ NotEqualCompare ]: _gl.NOTEQUAL
  	};

  	function setTextureParameters( textureType, texture ) {

  		if ( texture.type === FloatType && extensions.has( 'OES_texture_float_linear' ) === false &&
  			( texture.magFilter === LinearFilter || texture.magFilter === LinearMipmapNearestFilter || texture.magFilter === NearestMipmapLinearFilter || texture.magFilter === LinearMipmapLinearFilter ||
  			texture.minFilter === LinearFilter || texture.minFilter === LinearMipmapNearestFilter || texture.minFilter === NearestMipmapLinearFilter || texture.minFilter === LinearMipmapLinearFilter ) ) {

  			console.warn( 'THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device.' );

  		}

  		_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, wrappingToGL[ texture.wrapS ] );
  		_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, wrappingToGL[ texture.wrapT ] );

  		if ( textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY ) {

  			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_R, wrappingToGL[ texture.wrapR ] );

  		}

  		_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterToGL[ texture.magFilter ] );
  		_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterToGL[ texture.minFilter ] );

  		if ( texture.compareFunction ) {

  			_gl.texParameteri( textureType, _gl.TEXTURE_COMPARE_MODE, _gl.COMPARE_REF_TO_TEXTURE );
  			_gl.texParameteri( textureType, _gl.TEXTURE_COMPARE_FUNC, compareToGL[ texture.compareFunction ] );

  		}

  		if ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {

  			if ( texture.magFilter === NearestFilter ) return;
  			if ( texture.minFilter !== NearestMipmapLinearFilter && texture.minFilter !== LinearMipmapLinearFilter ) return;
  			if ( texture.type === FloatType && extensions.has( 'OES_texture_float_linear' ) === false ) return; // verify extension

  			if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {

  				const extension = extensions.get( 'EXT_texture_filter_anisotropic' );
  				_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );
  				properties.get( texture ).__currentAnisotropy = texture.anisotropy;

  			}

  		}

  	}

  	function initTexture( textureProperties, texture ) {

  		let forceUpload = false;

  		if ( textureProperties.__webglInit === undefined ) {

  			textureProperties.__webglInit = true;

  			texture.addEventListener( 'dispose', onTextureDispose );

  		}

  		// create Source <-> WebGLTextures mapping if necessary

  		const source = texture.source;
  		let webglTextures = _sources.get( source );

  		if ( webglTextures === undefined ) {

  			webglTextures = {};
  			_sources.set( source, webglTextures );

  		}

  		// check if there is already a WebGLTexture object for the given texture parameters

  		const textureCacheKey = getTextureCacheKey( texture );

  		if ( textureCacheKey !== textureProperties.__cacheKey ) {

  			// if not, create a new instance of WebGLTexture

  			if ( webglTextures[ textureCacheKey ] === undefined ) {

  				// create new entry

  				webglTextures[ textureCacheKey ] = {
  					texture: _gl.createTexture(),
  					usedTimes: 0
  				};

  				info.memory.textures ++;

  				// when a new instance of WebGLTexture was created, a texture upload is required
  				// even if the image contents are identical

  				forceUpload = true;

  			}

  			webglTextures[ textureCacheKey ].usedTimes ++;

  			// every time the texture cache key changes, it's necessary to check if an instance of
  			// WebGLTexture can be deleted in order to avoid a memory leak.

  			const webglTexture = webglTextures[ textureProperties.__cacheKey ];

  			if ( webglTexture !== undefined ) {

  				webglTextures[ textureProperties.__cacheKey ].usedTimes --;

  				if ( webglTexture.usedTimes === 0 ) {

  					deleteTexture( texture );

  				}

  			}

  			// store references to cache key and WebGLTexture object

  			textureProperties.__cacheKey = textureCacheKey;
  			textureProperties.__webglTexture = webglTextures[ textureCacheKey ].texture;

  		}

  		return forceUpload;

  	}

  	function uploadTexture( textureProperties, texture, slot ) {

  		let textureType = _gl.TEXTURE_2D;

  		if ( texture.isDataArrayTexture || texture.isCompressedArrayTexture ) textureType = _gl.TEXTURE_2D_ARRAY;
  		if ( texture.isData3DTexture ) textureType = _gl.TEXTURE_3D;

  		const forceUpload = initTexture( textureProperties, texture );
  		const source = texture.source;

  		state.bindTexture( textureType, textureProperties.__webglTexture, _gl.TEXTURE0 + slot );

  		const sourceProperties = properties.get( source );

  		if ( source.version !== sourceProperties.__version || forceUpload === true ) {

  			state.activeTexture( _gl.TEXTURE0 + slot );

  			const workingPrimaries = ColorManagement.getPrimaries( ColorManagement.workingColorSpace );
  			const texturePrimaries = texture.colorSpace === NoColorSpace ? null : ColorManagement.getPrimaries( texture.colorSpace );
  			const unpackConversion = texture.colorSpace === NoColorSpace || workingPrimaries === texturePrimaries ? _gl.NONE : _gl.BROWSER_DEFAULT_WEBGL;

  			_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
  			_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
  			_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );
  			_gl.pixelStorei( _gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, unpackConversion );

  			let image = resizeImage( texture.image, false, capabilities.maxTextureSize );
  			image = verifyColorSpace( texture, image );

  			const glFormat = utils.convert( texture.format, texture.colorSpace );

  			const glType = utils.convert( texture.type );
  			let glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.colorSpace, texture.isVideoTexture );

  			setTextureParameters( textureType, texture );

  			let mipmap;
  			const mipmaps = texture.mipmaps;

  			const useTexStorage = ( texture.isVideoTexture !== true );
  			const allocateMemory = ( sourceProperties.__version === undefined ) || ( forceUpload === true );
  			const dataReady = source.dataReady;
  			const levels = getMipLevels( texture, image );

  			if ( texture.isDepthTexture ) {

  				glInternalFormat = getInternalDepthFormat( texture.format === DepthStencilFormat, texture.type );

  				//

  				if ( allocateMemory ) {

  					if ( useTexStorage ) {

  						state.texStorage2D( _gl.TEXTURE_2D, 1, glInternalFormat, image.width, image.height );

  					} else {

  						state.texImage2D( _gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null );

  					}

  				}

  			} else if ( texture.isDataTexture ) {

  				// use manually created mipmaps if available
  				// if there are no manual mipmaps
  				// set 0 level mipmap and then use GL to generate other mipmap levels

  				if ( mipmaps.length > 0 ) {

  					if ( useTexStorage && allocateMemory ) {

  						state.texStorage2D( _gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[ 0 ].width, mipmaps[ 0 ].height );

  					}

  					for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

  						mipmap = mipmaps[ i ];

  						if ( useTexStorage ) {

  							if ( dataReady ) {

  								state.texSubImage2D( _gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data );

  							}

  						} else {

  							state.texImage2D( _gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

  						}

  					}

  					texture.generateMipmaps = false;

  				} else {

  					if ( useTexStorage ) {

  						if ( allocateMemory ) {

  							state.texStorage2D( _gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height );

  						}

  						if ( dataReady ) {

  							state.texSubImage2D( _gl.TEXTURE_2D, 0, 0, 0, image.width, image.height, glFormat, glType, image.data );

  						}

  					} else {

  						state.texImage2D( _gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data );

  					}

  				}

  			} else if ( texture.isCompressedTexture ) {

  				if ( texture.isCompressedArrayTexture ) {

  					if ( useTexStorage && allocateMemory ) {

  						state.texStorage3D( _gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, mipmaps[ 0 ].width, mipmaps[ 0 ].height, image.depth );

  					}

  					for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

  						mipmap = mipmaps[ i ];

  						if ( texture.format !== RGBAFormat ) {

  							if ( glFormat !== null ) {

  								if ( useTexStorage ) {

  									if ( dataReady ) {

  										if ( texture.layerUpdates.size > 0 ) {

  											const layerByteLength = getByteLength( mipmap.width, mipmap.height, texture.format, texture.type );

  											for ( const layerIndex of texture.layerUpdates ) {

  												const layerData = mipmap.data.subarray(
  													layerIndex * layerByteLength / mipmap.data.BYTES_PER_ELEMENT,
  													( layerIndex + 1 ) * layerByteLength / mipmap.data.BYTES_PER_ELEMENT
  												);
  												state.compressedTexSubImage3D( _gl.TEXTURE_2D_ARRAY, i, 0, 0, layerIndex, mipmap.width, mipmap.height, 1, glFormat, layerData, 0, 0 );

  											}

  											texture.clearLayerUpdates();

  										} else {

  											state.compressedTexSubImage3D( _gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, mipmap.data, 0, 0 );

  										}

  									}

  								} else {

  									state.compressedTexImage3D( _gl.TEXTURE_2D_ARRAY, i, glInternalFormat, mipmap.width, mipmap.height, image.depth, 0, mipmap.data, 0, 0 );

  								}

  							} else {

  								console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );

  							}

  						} else {

  							if ( useTexStorage ) {

  								if ( dataReady ) {

  									state.texSubImage3D( _gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, glType, mipmap.data );

  								}

  							} else {

  								state.texImage3D( _gl.TEXTURE_2D_ARRAY, i, glInternalFormat, mipmap.width, mipmap.height, image.depth, 0, glFormat, glType, mipmap.data );

  							}

  						}

  					}

  				} else {

  					if ( useTexStorage && allocateMemory ) {

  						state.texStorage2D( _gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[ 0 ].width, mipmaps[ 0 ].height );

  					}

  					for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

  						mipmap = mipmaps[ i ];

  						if ( texture.format !== RGBAFormat ) {

  							if ( glFormat !== null ) {

  								if ( useTexStorage ) {

  									if ( dataReady ) {

  										state.compressedTexSubImage2D( _gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data );

  									}

  								} else {

  									state.compressedTexImage2D( _gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );

  								}

  							} else {

  								console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );

  							}

  						} else {

  							if ( useTexStorage ) {

  								if ( dataReady ) {

  									state.texSubImage2D( _gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data );

  								}

  							} else {

  								state.texImage2D( _gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

  							}

  						}

  					}

  				}

  			} else if ( texture.isDataArrayTexture ) {

  				if ( useTexStorage ) {

  					if ( allocateMemory ) {

  						state.texStorage3D( _gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, image.width, image.height, image.depth );

  					}

  					if ( dataReady ) {

  						if ( texture.layerUpdates.size > 0 ) {

  							const layerByteLength = getByteLength( image.width, image.height, texture.format, texture.type );

  							for ( const layerIndex of texture.layerUpdates ) {

  								const layerData = image.data.subarray(
  									layerIndex * layerByteLength / image.data.BYTES_PER_ELEMENT,
  									( layerIndex + 1 ) * layerByteLength / image.data.BYTES_PER_ELEMENT
  								);
  								state.texSubImage3D( _gl.TEXTURE_2D_ARRAY, 0, 0, 0, layerIndex, image.width, image.height, 1, glFormat, glType, layerData );

  							}

  							texture.clearLayerUpdates();

  						} else {

  							state.texSubImage3D( _gl.TEXTURE_2D_ARRAY, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data );

  						}

  					}

  				} else {

  					state.texImage3D( _gl.TEXTURE_2D_ARRAY, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );

  				}

  			} else if ( texture.isData3DTexture ) {

  				if ( useTexStorage ) {

  					if ( allocateMemory ) {

  						state.texStorage3D( _gl.TEXTURE_3D, levels, glInternalFormat, image.width, image.height, image.depth );

  					}

  					if ( dataReady ) {

  						state.texSubImage3D( _gl.TEXTURE_3D, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data );

  					}

  				} else {

  					state.texImage3D( _gl.TEXTURE_3D, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );

  				}

  			} else if ( texture.isFramebufferTexture ) {

  				if ( allocateMemory ) {

  					if ( useTexStorage ) {

  						state.texStorage2D( _gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height );

  					} else {

  						let width = image.width, height = image.height;

  						for ( let i = 0; i < levels; i ++ ) {

  							state.texImage2D( _gl.TEXTURE_2D, i, glInternalFormat, width, height, 0, glFormat, glType, null );

  							width >>= 1;
  							height >>= 1;

  						}

  					}

  				}

  			} else {

  				// regular Texture (image, video, canvas)

  				// use manually created mipmaps if available
  				// if there are no manual mipmaps
  				// set 0 level mipmap and then use GL to generate other mipmap levels

  				if ( mipmaps.length > 0 ) {

  					if ( useTexStorage && allocateMemory ) {

  						const dimensions = getDimensions( mipmaps[ 0 ] );

  						state.texStorage2D( _gl.TEXTURE_2D, levels, glInternalFormat, dimensions.width, dimensions.height );

  					}

  					for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

  						mipmap = mipmaps[ i ];

  						if ( useTexStorage ) {

  							if ( dataReady ) {

  								state.texSubImage2D( _gl.TEXTURE_2D, i, 0, 0, glFormat, glType, mipmap );

  							}

  						} else {

  							state.texImage2D( _gl.TEXTURE_2D, i, glInternalFormat, glFormat, glType, mipmap );

  						}

  					}

  					texture.generateMipmaps = false;

  				} else {

  					if ( useTexStorage ) {

  						if ( allocateMemory ) {

  							const dimensions = getDimensions( image );

  							state.texStorage2D( _gl.TEXTURE_2D, levels, glInternalFormat, dimensions.width, dimensions.height );

  						}

  						if ( dataReady ) {

  							state.texSubImage2D( _gl.TEXTURE_2D, 0, 0, 0, glFormat, glType, image );

  						}

  					} else {

  						state.texImage2D( _gl.TEXTURE_2D, 0, glInternalFormat, glFormat, glType, image );

  					}

  				}

  			}

  			if ( textureNeedsGenerateMipmaps( texture ) ) {

  				generateMipmap( textureType );

  			}

  			sourceProperties.__version = source.version;

  			if ( texture.onUpdate ) texture.onUpdate( texture );

  		}

  		textureProperties.__version = texture.version;

  	}

  	function uploadCubeTexture( textureProperties, texture, slot ) {

  		if ( texture.image.length !== 6 ) return;

  		const forceUpload = initTexture( textureProperties, texture );
  		const source = texture.source;

  		state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture, _gl.TEXTURE0 + slot );

  		const sourceProperties = properties.get( source );

  		if ( source.version !== sourceProperties.__version || forceUpload === true ) {

  			state.activeTexture( _gl.TEXTURE0 + slot );

  			const workingPrimaries = ColorManagement.getPrimaries( ColorManagement.workingColorSpace );
  			const texturePrimaries = texture.colorSpace === NoColorSpace ? null : ColorManagement.getPrimaries( texture.colorSpace );
  			const unpackConversion = texture.colorSpace === NoColorSpace || workingPrimaries === texturePrimaries ? _gl.NONE : _gl.BROWSER_DEFAULT_WEBGL;

  			_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
  			_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
  			_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );
  			_gl.pixelStorei( _gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, unpackConversion );

  			const isCompressed = ( texture.isCompressedTexture || texture.image[ 0 ].isCompressedTexture );
  			const isDataTexture = ( texture.image[ 0 ] && texture.image[ 0 ].isDataTexture );

  			const cubeImage = [];

  			for ( let i = 0; i < 6; i ++ ) {

  				if ( ! isCompressed && ! isDataTexture ) {

  					cubeImage[ i ] = resizeImage( texture.image[ i ], true, capabilities.maxCubemapSize );

  				} else {

  					cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];

  				}

  				cubeImage[ i ] = verifyColorSpace( texture, cubeImage[ i ] );

  			}

  			const image = cubeImage[ 0 ],
  				glFormat = utils.convert( texture.format, texture.colorSpace ),
  				glType = utils.convert( texture.type ),
  				glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.colorSpace );

  			const useTexStorage = ( texture.isVideoTexture !== true );
  			const allocateMemory = ( sourceProperties.__version === undefined ) || ( forceUpload === true );
  			const dataReady = source.dataReady;
  			let levels = getMipLevels( texture, image );

  			setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture );

  			let mipmaps;

  			if ( isCompressed ) {

  				if ( useTexStorage && allocateMemory ) {

  					state.texStorage2D( _gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, image.width, image.height );

  				}

  				for ( let i = 0; i < 6; i ++ ) {

  					mipmaps = cubeImage[ i ].mipmaps;

  					for ( let j = 0; j < mipmaps.length; j ++ ) {

  						const mipmap = mipmaps[ j ];

  						if ( texture.format !== RGBAFormat ) {

  							if ( glFormat !== null ) {

  								if ( useTexStorage ) {

  									if ( dataReady ) {

  										state.compressedTexSubImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data );

  									}

  								} else {

  									state.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );

  								}

  							} else {

  								console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()' );

  							}

  						} else {

  							if ( useTexStorage ) {

  								if ( dataReady ) {

  									state.texSubImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data );

  								}

  							} else {

  								state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

  							}

  						}

  					}

  				}

  			} else {

  				mipmaps = texture.mipmaps;

  				if ( useTexStorage && allocateMemory ) {

  					// TODO: Uniformly handle mipmap definitions
  					// Normal textures and compressed cube textures define base level + mips with their mipmap array
  					// Uncompressed cube textures use their mipmap array only for mips (no base level)

  					if ( mipmaps.length > 0 ) levels ++;

  					const dimensions = getDimensions( cubeImage[ 0 ] );

  					state.texStorage2D( _gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, dimensions.width, dimensions.height );

  				}

  				for ( let i = 0; i < 6; i ++ ) {

  					if ( isDataTexture ) {

  						if ( useTexStorage ) {

  							if ( dataReady ) {

  								state.texSubImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, 0, 0, cubeImage[ i ].width, cubeImage[ i ].height, glFormat, glType, cubeImage[ i ].data );

  							}

  						} else {

  							state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );

  						}

  						for ( let j = 0; j < mipmaps.length; j ++ ) {

  							const mipmap = mipmaps[ j ];
  							const mipmapImage = mipmap.image[ i ].image;

  							if ( useTexStorage ) {

  								if ( dataReady ) {

  									state.texSubImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, 0, 0, mipmapImage.width, mipmapImage.height, glFormat, glType, mipmapImage.data );

  								}

  							} else {

  								state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data );

  							}

  						}

  					} else {

  						if ( useTexStorage ) {

  							if ( dataReady ) {

  								state.texSubImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, 0, 0, glFormat, glType, cubeImage[ i ] );

  							}

  						} else {

  							state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, glFormat, glType, cubeImage[ i ] );

  						}

  						for ( let j = 0; j < mipmaps.length; j ++ ) {

  							const mipmap = mipmaps[ j ];

  							if ( useTexStorage ) {

  								if ( dataReady ) {

  									state.texSubImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, 0, 0, glFormat, glType, mipmap.image[ i ] );

  								}

  							} else {

  								state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[ i ] );

  							}

  						}

  					}

  				}

  			}

  			if ( textureNeedsGenerateMipmaps( texture ) ) {

  				// We assume images for cube map have the same size.
  				generateMipmap( _gl.TEXTURE_CUBE_MAP );

  			}

  			sourceProperties.__version = source.version;

  			if ( texture.onUpdate ) texture.onUpdate( texture );

  		}

  		textureProperties.__version = texture.version;

  	}

  	// Render targets

  	// Setup storage for target texture and bind it to correct framebuffer
  	function setupFrameBufferTexture( framebuffer, renderTarget, texture, attachment, textureTarget, level ) {

  		const glFormat = utils.convert( texture.format, texture.colorSpace );
  		const glType = utils.convert( texture.type );
  		const glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.colorSpace );
  		const renderTargetProperties = properties.get( renderTarget );

  		if ( ! renderTargetProperties.__hasExternalTextures ) {

  			const width = Math.max( 1, renderTarget.width >> level );
  			const height = Math.max( 1, renderTarget.height >> level );

  			if ( textureTarget === _gl.TEXTURE_3D || textureTarget === _gl.TEXTURE_2D_ARRAY ) {

  				state.texImage3D( textureTarget, level, glInternalFormat, width, height, renderTarget.depth, 0, glFormat, glType, null );

  			} else {

  				state.texImage2D( textureTarget, level, glInternalFormat, width, height, 0, glFormat, glType, null );

  			}

  		}

  		state.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

  		if ( useMultisampledRTT( renderTarget ) ) {

  			multisampledRTTExt.framebufferTexture2DMultisampleEXT( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( texture ).__webglTexture, 0, getRenderTargetSamples( renderTarget ) );

  		} else if ( textureTarget === _gl.TEXTURE_2D || ( textureTarget >= _gl.TEXTURE_CUBE_MAP_POSITIVE_X && textureTarget <= _gl.TEXTURE_CUBE_MAP_NEGATIVE_Z ) ) { // see #24753

  			_gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( texture ).__webglTexture, level );

  		}

  		state.bindFramebuffer( _gl.FRAMEBUFFER, null );

  	}

  	// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
  	function setupRenderBufferStorage( renderbuffer, renderTarget, isMultisample ) {

  		_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );

  		if ( renderTarget.depthBuffer ) {

  			// retrieve the depth attachment types
  			const depthTexture = renderTarget.depthTexture;
  			const depthType = depthTexture && depthTexture.isDepthTexture ? depthTexture.type : null;
  			const glInternalFormat = getInternalDepthFormat( renderTarget.stencilBuffer, depthType );
  			const glAttachmentType = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;

  			// set up the attachment
  			const samples = getRenderTargetSamples( renderTarget );
  			const isUseMultisampledRTT = useMultisampledRTT( renderTarget );
  			if ( isUseMultisampledRTT ) {

  				multisampledRTTExt.renderbufferStorageMultisampleEXT( _gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height );

  			} else if ( isMultisample ) {

  				_gl.renderbufferStorageMultisample( _gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height );

  			} else {

  				_gl.renderbufferStorage( _gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height );

  			}

  			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, glAttachmentType, _gl.RENDERBUFFER, renderbuffer );

  		} else {

  			const textures = renderTarget.textures;

  			for ( let i = 0; i < textures.length; i ++ ) {

  				const texture = textures[ i ];

  				const glFormat = utils.convert( texture.format, texture.colorSpace );
  				const glType = utils.convert( texture.type );
  				const glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.colorSpace );
  				const samples = getRenderTargetSamples( renderTarget );

  				if ( isMultisample && useMultisampledRTT( renderTarget ) === false ) {

  					_gl.renderbufferStorageMultisample( _gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height );

  				} else if ( useMultisampledRTT( renderTarget ) ) {

  					multisampledRTTExt.renderbufferStorageMultisampleEXT( _gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height );

  				} else {

  					_gl.renderbufferStorage( _gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height );

  				}

  			}

  		}

  		_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );

  	}

  	// Setup resources for a Depth Texture for a FBO (needs an extension)
  	function setupDepthTexture( framebuffer, renderTarget ) {

  		const isCube = ( renderTarget && renderTarget.isWebGLCubeRenderTarget );
  		if ( isCube ) throw new Error( 'Depth Texture with cube render targets is not supported' );

  		state.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

  		if ( ! ( renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture ) ) {

  			throw new Error( 'renderTarget.depthTexture must be an instance of THREE.DepthTexture' );

  		}

  		// upload an empty depth texture with framebuffer size
  		if ( ! properties.get( renderTarget.depthTexture ).__webglTexture ||
  				renderTarget.depthTexture.image.width !== renderTarget.width ||
  				renderTarget.depthTexture.image.height !== renderTarget.height ) {

  			renderTarget.depthTexture.image.width = renderTarget.width;
  			renderTarget.depthTexture.image.height = renderTarget.height;
  			renderTarget.depthTexture.needsUpdate = true;

  		}

  		setTexture2D( renderTarget.depthTexture, 0 );

  		const webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;
  		const samples = getRenderTargetSamples( renderTarget );

  		if ( renderTarget.depthTexture.format === DepthFormat ) {

  			if ( useMultisampledRTT( renderTarget ) ) {

  				multisampledRTTExt.framebufferTexture2DMultisampleEXT( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples );

  			} else {

  				_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );

  			}

  		} else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {

  			if ( useMultisampledRTT( renderTarget ) ) {

  				multisampledRTTExt.framebufferTexture2DMultisampleEXT( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples );

  			} else {

  				_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );

  			}

  		} else {

  			throw new Error( 'Unknown depthTexture format' );

  		}

  	}

  	// Setup GL resources for a non-texture depth buffer
  	function setupDepthRenderbuffer( renderTarget ) {

  		const renderTargetProperties = properties.get( renderTarget );
  		const isCube = ( renderTarget.isWebGLCubeRenderTarget === true );

  		if ( renderTarget.depthTexture && ! renderTargetProperties.__autoAllocateDepthBuffer ) {

  			if ( isCube ) throw new Error( 'target.depthTexture not supported in Cube render targets' );

  			setupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );

  		} else {

  			if ( isCube ) {

  				renderTargetProperties.__webglDepthbuffer = [];

  				for ( let i = 0; i < 6; i ++ ) {

  					state.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ i ] );
  					renderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();
  					setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget, false );

  				}

  			} else {

  				state.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );
  				renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
  				setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget, false );

  			}

  		}

  		state.bindFramebuffer( _gl.FRAMEBUFFER, null );

  	}

  	// rebind framebuffer with external textures
  	function rebindTextures( renderTarget, colorTexture, depthTexture ) {

  		const renderTargetProperties = properties.get( renderTarget );

  		if ( colorTexture !== undefined ) {

  			setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, renderTarget.texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, 0 );

  		}

  		if ( depthTexture !== undefined ) {

  			setupDepthRenderbuffer( renderTarget );

  		}

  	}

  	// Set up GL resources for the render target
  	function setupRenderTarget( renderTarget ) {

  		const texture = renderTarget.texture;

  		const renderTargetProperties = properties.get( renderTarget );
  		const textureProperties = properties.get( texture );

  		renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

  		const textures = renderTarget.textures;

  		const isCube = ( renderTarget.isWebGLCubeRenderTarget === true );
  		const isMultipleRenderTargets = ( textures.length > 1 );

  		if ( ! isMultipleRenderTargets ) {

  			if ( textureProperties.__webglTexture === undefined ) {

  				textureProperties.__webglTexture = _gl.createTexture();

  			}

  			textureProperties.__version = texture.version;
  			info.memory.textures ++;

  		}

  		// Setup framebuffer

  		if ( isCube ) {

  			renderTargetProperties.__webglFramebuffer = [];

  			for ( let i = 0; i < 6; i ++ ) {

  				if ( texture.mipmaps && texture.mipmaps.length > 0 ) {

  					renderTargetProperties.__webglFramebuffer[ i ] = [];

  					for ( let level = 0; level < texture.mipmaps.length; level ++ ) {

  						renderTargetProperties.__webglFramebuffer[ i ][ level ] = _gl.createFramebuffer();

  					}

  				} else {

  					renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();

  				}

  			}

  		} else {

  			if ( texture.mipmaps && texture.mipmaps.length > 0 ) {

  				renderTargetProperties.__webglFramebuffer = [];

  				for ( let level = 0; level < texture.mipmaps.length; level ++ ) {

  					renderTargetProperties.__webglFramebuffer[ level ] = _gl.createFramebuffer();

  				}

  			} else {

  				renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

  			}

  			if ( isMultipleRenderTargets ) {

  				for ( let i = 0, il = textures.length; i < il; i ++ ) {

  					const attachmentProperties = properties.get( textures[ i ] );

  					if ( attachmentProperties.__webglTexture === undefined ) {

  						attachmentProperties.__webglTexture = _gl.createTexture();

  						info.memory.textures ++;

  					}

  				}

  			}

  			if ( ( renderTarget.samples > 0 ) && useMultisampledRTT( renderTarget ) === false ) {

  				renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
  				renderTargetProperties.__webglColorRenderbuffer = [];

  				state.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer );

  				for ( let i = 0; i < textures.length; i ++ ) {

  					const texture = textures[ i ];
  					renderTargetProperties.__webglColorRenderbuffer[ i ] = _gl.createRenderbuffer();

  					_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[ i ] );

  					const glFormat = utils.convert( texture.format, texture.colorSpace );
  					const glType = utils.convert( texture.type );
  					const glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.colorSpace, renderTarget.isXRRenderTarget === true );
  					const samples = getRenderTargetSamples( renderTarget );
  					_gl.renderbufferStorageMultisample( _gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height );

  					_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[ i ] );

  				}

  				_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );

  				if ( renderTarget.depthBuffer ) {

  					renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
  					setupRenderBufferStorage( renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true );

  				}

  				state.bindFramebuffer( _gl.FRAMEBUFFER, null );

  			}

  		}

  		// Setup color buffer

  		if ( isCube ) {

  			state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );
  			setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture );

  			for ( let i = 0; i < 6; i ++ ) {

  				if ( texture.mipmaps && texture.mipmaps.length > 0 ) {

  					for ( let level = 0; level < texture.mipmaps.length; level ++ ) {

  						setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ][ level ], renderTarget, texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, level );

  					}

  				} else {

  					setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0 );

  				}

  			}

  			if ( textureNeedsGenerateMipmaps( texture ) ) {

  				generateMipmap( _gl.TEXTURE_CUBE_MAP );

  			}

  			state.unbindTexture();

  		} else if ( isMultipleRenderTargets ) {

  			for ( let i = 0, il = textures.length; i < il; i ++ ) {

  				const attachment = textures[ i ];
  				const attachmentProperties = properties.get( attachment );

  				state.bindTexture( _gl.TEXTURE_2D, attachmentProperties.__webglTexture );
  				setTextureParameters( _gl.TEXTURE_2D, attachment );
  				setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, attachment, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D, 0 );

  				if ( textureNeedsGenerateMipmaps( attachment ) ) {

  					generateMipmap( _gl.TEXTURE_2D );

  				}

  			}

  			state.unbindTexture();

  		} else {

  			let glTextureType = _gl.TEXTURE_2D;

  			if ( renderTarget.isWebGL3DRenderTarget || renderTarget.isWebGLArrayRenderTarget ) {

  				glTextureType = renderTarget.isWebGL3DRenderTarget ? _gl.TEXTURE_3D : _gl.TEXTURE_2D_ARRAY;

  			}

  			state.bindTexture( glTextureType, textureProperties.__webglTexture );
  			setTextureParameters( glTextureType, texture );

  			if ( texture.mipmaps && texture.mipmaps.length > 0 ) {

  				for ( let level = 0; level < texture.mipmaps.length; level ++ ) {

  					setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ level ], renderTarget, texture, _gl.COLOR_ATTACHMENT0, glTextureType, level );

  				}

  			} else {

  				setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, texture, _gl.COLOR_ATTACHMENT0, glTextureType, 0 );

  			}

  			if ( textureNeedsGenerateMipmaps( texture ) ) {

  				generateMipmap( glTextureType );

  			}

  			state.unbindTexture();

  		}

  		// Setup depth and stencil buffers

  		if ( renderTarget.depthBuffer ) {

  			setupDepthRenderbuffer( renderTarget );

  		}

  	}

  	function updateRenderTargetMipmap( renderTarget ) {

  		const textures = renderTarget.textures;

  		for ( let i = 0, il = textures.length; i < il; i ++ ) {

  			const texture = textures[ i ];

  			if ( textureNeedsGenerateMipmaps( texture ) ) {

  				const target = renderTarget.isWebGLCubeRenderTarget ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
  				const webglTexture = properties.get( texture ).__webglTexture;

  				state.bindTexture( target, webglTexture );
  				generateMipmap( target );
  				state.unbindTexture();

  			}

  		}

  	}

  	const invalidationArrayRead = [];
  	const invalidationArrayDraw = [];

  	function updateMultisampleRenderTarget( renderTarget ) {

  		if ( renderTarget.samples > 0 ) {

  			if ( useMultisampledRTT( renderTarget ) === false ) {

  				const textures = renderTarget.textures;
  				const width = renderTarget.width;
  				const height = renderTarget.height;
  				let mask = _gl.COLOR_BUFFER_BIT;
  				const depthStyle = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;
  				const renderTargetProperties = properties.get( renderTarget );
  				const isMultipleRenderTargets = ( textures.length > 1 );

  				// If MRT we need to remove FBO attachments
  				if ( isMultipleRenderTargets ) {

  					for ( let i = 0; i < textures.length; i ++ ) {

  						state.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer );
  						_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, null );

  						state.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );
  						_gl.framebufferTexture2D( _gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D, null, 0 );

  					}

  				}

  				state.bindFramebuffer( _gl.READ_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer );
  				state.bindFramebuffer( _gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );

  				for ( let i = 0; i < textures.length; i ++ ) {

  					if ( renderTarget.resolveDepthBuffer ) {

  						if ( renderTarget.depthBuffer ) mask |= _gl.DEPTH_BUFFER_BIT;

  						// resolving stencil is slow with a D3D backend. disable it for all transmission render targets (see #27799)

  						if ( renderTarget.stencilBuffer && renderTarget.resolveStencilBuffer ) mask |= _gl.STENCIL_BUFFER_BIT;

  					}

  					if ( isMultipleRenderTargets ) {

  						_gl.framebufferRenderbuffer( _gl.READ_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[ i ] );

  						const webglTexture = properties.get( textures[ i ] ).__webglTexture;
  						_gl.framebufferTexture2D( _gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, webglTexture, 0 );

  					}

  					_gl.blitFramebuffer( 0, 0, width, height, 0, 0, width, height, mask, _gl.NEAREST );

  					if ( supportsInvalidateFramebuffer === true ) {

  						invalidationArrayRead.length = 0;
  						invalidationArrayDraw.length = 0;

  						invalidationArrayRead.push( _gl.COLOR_ATTACHMENT0 + i );

  						if ( renderTarget.depthBuffer && renderTarget.resolveDepthBuffer === false ) {

  							invalidationArrayRead.push( depthStyle );
  							invalidationArrayDraw.push( depthStyle );

  							_gl.invalidateFramebuffer( _gl.DRAW_FRAMEBUFFER, invalidationArrayDraw );

  						}

  						_gl.invalidateFramebuffer( _gl.READ_FRAMEBUFFER, invalidationArrayRead );

  					}

  				}

  				state.bindFramebuffer( _gl.READ_FRAMEBUFFER, null );
  				state.bindFramebuffer( _gl.DRAW_FRAMEBUFFER, null );

  				// If MRT since pre-blit we removed the FBO we need to reconstruct the attachments
  				if ( isMultipleRenderTargets ) {

  					for ( let i = 0; i < textures.length; i ++ ) {

  						state.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer );
  						_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[ i ] );

  						const webglTexture = properties.get( textures[ i ] ).__webglTexture;

  						state.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );
  						_gl.framebufferTexture2D( _gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D, webglTexture, 0 );

  					}

  				}

  				state.bindFramebuffer( _gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer );

  			} else {

  				if ( renderTarget.depthBuffer && renderTarget.resolveDepthBuffer === false && supportsInvalidateFramebuffer ) {

  					const depthStyle = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;

  					_gl.invalidateFramebuffer( _gl.DRAW_FRAMEBUFFER, [ depthStyle ] );

  				}

  			}

  		}

  	}

  	function getRenderTargetSamples( renderTarget ) {

  		return Math.min( capabilities.maxSamples, renderTarget.samples );

  	}

  	function useMultisampledRTT( renderTarget ) {

  		const renderTargetProperties = properties.get( renderTarget );

  		return renderTarget.samples > 0 && extensions.has( 'WEBGL_multisampled_render_to_texture' ) === true && renderTargetProperties.__useRenderToTexture !== false;

  	}

  	function updateVideoTexture( texture ) {

  		const frame = info.render.frame;

  		// Check the last frame we updated the VideoTexture

  		if ( _videoTextures.get( texture ) !== frame ) {

  			_videoTextures.set( texture, frame );
  			texture.update();

  		}

  	}

  	function verifyColorSpace( texture, image ) {

  		const colorSpace = texture.colorSpace;
  		const format = texture.format;
  		const type = texture.type;

  		if ( texture.isCompressedTexture === true || texture.isVideoTexture === true ) return image;

  		if ( colorSpace !== LinearSRGBColorSpace && colorSpace !== NoColorSpace ) {

  			// sRGB

  			if ( ColorManagement.getTransfer( colorSpace ) === SRGBTransfer ) {

  				// in WebGL 2 uncompressed textures can only be sRGB encoded if they have the RGBA8 format

  				if ( format !== RGBAFormat || type !== UnsignedByteType ) {

  					console.warn( 'THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.' );

  				}

  			} else {

  				console.error( 'THREE.WebGLTextures: Unsupported texture color space:', colorSpace );

  			}

  		}

  		return image;

  	}

  	function getDimensions( image ) {

  		if ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) {

  			// if intrinsic data are not available, fallback to width/height

  			_imageDimensions.width = image.naturalWidth || image.width;
  			_imageDimensions.height = image.naturalHeight || image.height;

  		} else if ( typeof VideoFrame !== 'undefined' && image instanceof VideoFrame ) {

  			_imageDimensions.width = image.displayWidth;
  			_imageDimensions.height = image.displayHeight;

  		} else {

  			_imageDimensions.width = image.width;
  			_imageDimensions.height = image.height;

  		}

  		return _imageDimensions;

  	}

  	//

  	this.allocateTextureUnit = allocateTextureUnit;
  	this.resetTextureUnits = resetTextureUnits;

  	this.setTexture2D = setTexture2D;
  	this.setTexture2DArray = setTexture2DArray;
  	this.setTexture3D = setTexture3D;
  	this.setTextureCube = setTextureCube;
  	this.rebindTextures = rebindTextures;
  	this.setupRenderTarget = setupRenderTarget;
  	this.updateRenderTargetMipmap = updateRenderTargetMipmap;
  	this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
  	this.setupDepthRenderbuffer = setupDepthRenderbuffer;
  	this.setupFrameBufferTexture = setupFrameBufferTexture;
  	this.useMultisampledRTT = useMultisampledRTT;

  }

  function WebGLUtils( gl, extensions ) {

  	function convert( p, colorSpace = NoColorSpace ) {

  		let extension;

  		const transfer = ColorManagement.getTransfer( colorSpace );

  		if ( p === UnsignedByteType ) return gl.UNSIGNED_BYTE;
  		if ( p === UnsignedShort4444Type ) return gl.UNSIGNED_SHORT_4_4_4_4;
  		if ( p === UnsignedShort5551Type ) return gl.UNSIGNED_SHORT_5_5_5_1;
  		if ( p === UnsignedInt5999Type ) return gl.UNSIGNED_INT_5_9_9_9_REV;

  		if ( p === ByteType ) return gl.BYTE;
  		if ( p === ShortType ) return gl.SHORT;
  		if ( p === UnsignedShortType ) return gl.UNSIGNED_SHORT;
  		if ( p === IntType ) return gl.INT;
  		if ( p === UnsignedIntType ) return gl.UNSIGNED_INT;
  		if ( p === FloatType ) return gl.FLOAT;
  		if ( p === HalfFloatType ) return gl.HALF_FLOAT;

  		if ( p === AlphaFormat ) return gl.ALPHA;
  		if ( p === RGBFormat ) return gl.RGB;
  		if ( p === RGBAFormat ) return gl.RGBA;
  		if ( p === LuminanceFormat ) return gl.LUMINANCE;
  		if ( p === LuminanceAlphaFormat ) return gl.LUMINANCE_ALPHA;
  		if ( p === DepthFormat ) return gl.DEPTH_COMPONENT;
  		if ( p === DepthStencilFormat ) return gl.DEPTH_STENCIL;

  		// WebGL2 formats.

  		if ( p === RedFormat ) return gl.RED;
  		if ( p === RedIntegerFormat ) return gl.RED_INTEGER;
  		if ( p === RGFormat ) return gl.RG;
  		if ( p === RGIntegerFormat ) return gl.RG_INTEGER;
  		if ( p === RGBAIntegerFormat ) return gl.RGBA_INTEGER;

  		// S3TC

  		if ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {

  			if ( transfer === SRGBTransfer ) {

  				extension = extensions.get( 'WEBGL_compressed_texture_s3tc_srgb' );

  				if ( extension !== null ) {

  					if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;
  					if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
  					if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
  					if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;

  				} else {

  					return null;

  				}

  			} else {

  				extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

  				if ( extension !== null ) {

  					if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
  					if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
  					if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
  					if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

  				} else {

  					return null;

  				}

  			}

  		}

  		// PVRTC

  		if ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {

  			extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

  			if ( extension !== null ) {

  				if ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
  				if ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
  				if ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
  				if ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

  			} else {

  				return null;

  			}

  		}

  		// ETC

  		if ( p === RGB_ETC1_Format || p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format ) {

  			extension = extensions.get( 'WEBGL_compressed_texture_etc' );

  			if ( extension !== null ) {

  				if ( p === RGB_ETC1_Format || p === RGB_ETC2_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ETC2 : extension.COMPRESSED_RGB8_ETC2;
  				if ( p === RGBA_ETC2_EAC_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension.COMPRESSED_RGBA8_ETC2_EAC;

  			} else {

  				return null;

  			}

  		}

  		// ASTC

  		if ( p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format ||
  			p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format ||
  			p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format ||
  			p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format ||
  			p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format ) {

  			extension = extensions.get( 'WEBGL_compressed_texture_astc' );

  			if ( extension !== null ) {

  				if ( p === RGBA_ASTC_4x4_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;
  				if ( p === RGBA_ASTC_5x4_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;
  				if ( p === RGBA_ASTC_5x5_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;
  				if ( p === RGBA_ASTC_6x5_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;
  				if ( p === RGBA_ASTC_6x6_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;
  				if ( p === RGBA_ASTC_8x5_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;
  				if ( p === RGBA_ASTC_8x6_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;
  				if ( p === RGBA_ASTC_8x8_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;
  				if ( p === RGBA_ASTC_10x5_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;
  				if ( p === RGBA_ASTC_10x6_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;
  				if ( p === RGBA_ASTC_10x8_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;
  				if ( p === RGBA_ASTC_10x10_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;
  				if ( p === RGBA_ASTC_12x10_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;
  				if ( p === RGBA_ASTC_12x12_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension.COMPRESSED_RGBA_ASTC_12x12_KHR;

  			} else {

  				return null;

  			}

  		}

  		// BPTC

  		if ( p === RGBA_BPTC_Format || p === RGB_BPTC_SIGNED_Format || p === RGB_BPTC_UNSIGNED_Format ) {

  			extension = extensions.get( 'EXT_texture_compression_bptc' );

  			if ( extension !== null ) {

  				if ( p === RGBA_BPTC_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;
  				if ( p === RGB_BPTC_SIGNED_Format ) return extension.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
  				if ( p === RGB_BPTC_UNSIGNED_Format ) return extension.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;

  			} else {

  				return null;

  			}

  		}

  		// RGTC

  		if ( p === RED_RGTC1_Format || p === SIGNED_RED_RGTC1_Format || p === RED_GREEN_RGTC2_Format || p === SIGNED_RED_GREEN_RGTC2_Format ) {

  			extension = extensions.get( 'EXT_texture_compression_rgtc' );

  			if ( extension !== null ) {

  				if ( p === RGBA_BPTC_Format ) return extension.COMPRESSED_RED_RGTC1_EXT;
  				if ( p === SIGNED_RED_RGTC1_Format ) return extension.COMPRESSED_SIGNED_RED_RGTC1_EXT;
  				if ( p === RED_GREEN_RGTC2_Format ) return extension.COMPRESSED_RED_GREEN_RGTC2_EXT;
  				if ( p === SIGNED_RED_GREEN_RGTC2_Format ) return extension.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;

  			} else {

  				return null;

  			}

  		}

  		//

  		if ( p === UnsignedInt248Type ) return gl.UNSIGNED_INT_24_8;

  		// if "p" can't be resolved, assume the user defines a WebGL constant as a string (fallback/workaround for packed RGB formats)

  		return ( gl[ p ] !== undefined ) ? gl[ p ] : null;

  	}

  	return { convert: convert };

  }

  class ArrayCamera extends PerspectiveCamera {

  	constructor( array = [] ) {

  		super();

  		this.isArrayCamera = true;

  		this.cameras = array;

  	}

  }

  class Group extends Object3D {

  	constructor() {

  		super();

  		this.isGroup = true;

  		this.type = 'Group';

  	}

  }

  const _moveEvent = { type: 'move' };

  class WebXRController {

  	constructor() {

  		this._targetRay = null;
  		this._grip = null;
  		this._hand = null;

  	}

  	getHandSpace() {

  		if ( this._hand === null ) {

  			this._hand = new Group();
  			this._hand.matrixAutoUpdate = false;
  			this._hand.visible = false;

  			this._hand.joints = {};
  			this._hand.inputState = { pinching: false };

  		}

  		return this._hand;

  	}

  	getTargetRaySpace() {

  		if ( this._targetRay === null ) {

  			this._targetRay = new Group();
  			this._targetRay.matrixAutoUpdate = false;
  			this._targetRay.visible = false;
  			this._targetRay.hasLinearVelocity = false;
  			this._targetRay.linearVelocity = new Vector3();
  			this._targetRay.hasAngularVelocity = false;
  			this._targetRay.angularVelocity = new Vector3();

  		}

  		return this._targetRay;

  	}

  	getGripSpace() {

  		if ( this._grip === null ) {

  			this._grip = new Group();
  			this._grip.matrixAutoUpdate = false;
  			this._grip.visible = false;
  			this._grip.hasLinearVelocity = false;
  			this._grip.linearVelocity = new Vector3();
  			this._grip.hasAngularVelocity = false;
  			this._grip.angularVelocity = new Vector3();

  		}

  		return this._grip;

  	}

  	dispatchEvent( event ) {

  		if ( this._targetRay !== null ) {

  			this._targetRay.dispatchEvent( event );

  		}

  		if ( this._grip !== null ) {

  			this._grip.dispatchEvent( event );

  		}

  		if ( this._hand !== null ) {

  			this._hand.dispatchEvent( event );

  		}

  		return this;

  	}

  	connect( inputSource ) {

  		if ( inputSource && inputSource.hand ) {

  			const hand = this._hand;

  			if ( hand ) {

  				for ( const inputjoint of inputSource.hand.values() ) {

  					// Initialize hand with joints when connected
  					this._getHandJoint( hand, inputjoint );

  				}

  			}

  		}

  		this.dispatchEvent( { type: 'connected', data: inputSource } );

  		return this;

  	}

  	disconnect( inputSource ) {

  		this.dispatchEvent( { type: 'disconnected', data: inputSource } );

  		if ( this._targetRay !== null ) {

  			this._targetRay.visible = false;

  		}

  		if ( this._grip !== null ) {

  			this._grip.visible = false;

  		}

  		if ( this._hand !== null ) {

  			this._hand.visible = false;

  		}

  		return this;

  	}

  	update( inputSource, frame, referenceSpace ) {

  		let inputPose = null;
  		let gripPose = null;
  		let handPose = null;

  		const targetRay = this._targetRay;
  		const grip = this._grip;
  		const hand = this._hand;

  		if ( inputSource && frame.session.visibilityState !== 'visible-blurred' ) {

  			if ( hand && inputSource.hand ) {

  				handPose = true;

  				for ( const inputjoint of inputSource.hand.values() ) {

  					// Update the joints groups with the XRJoint poses
  					const jointPose = frame.getJointPose( inputjoint, referenceSpace );

  					// The transform of this joint will be updated with the joint pose on each frame
  					const joint = this._getHandJoint( hand, inputjoint );

  					if ( jointPose !== null ) {

  						joint.matrix.fromArray( jointPose.transform.matrix );
  						joint.matrix.decompose( joint.position, joint.rotation, joint.scale );
  						joint.matrixWorldNeedsUpdate = true;
  						joint.jointRadius = jointPose.radius;

  					}

  					joint.visible = jointPose !== null;

  				}

  				// Custom events

  				// Check pinchz
  				const indexTip = hand.joints[ 'index-finger-tip' ];
  				const thumbTip = hand.joints[ 'thumb-tip' ];
  				const distance = indexTip.position.distanceTo( thumbTip.position );

  				const distanceToPinch = 0.02;
  				const threshold = 0.005;

  				if ( hand.inputState.pinching && distance > distanceToPinch + threshold ) {

  					hand.inputState.pinching = false;
  					this.dispatchEvent( {
  						type: 'pinchend',
  						handedness: inputSource.handedness,
  						target: this
  					} );

  				} else if ( ! hand.inputState.pinching && distance <= distanceToPinch - threshold ) {

  					hand.inputState.pinching = true;
  					this.dispatchEvent( {
  						type: 'pinchstart',
  						handedness: inputSource.handedness,
  						target: this
  					} );

  				}

  			} else {

  				if ( grip !== null && inputSource.gripSpace ) {

  					gripPose = frame.getPose( inputSource.gripSpace, referenceSpace );

  					if ( gripPose !== null ) {

  						grip.matrix.fromArray( gripPose.transform.matrix );
  						grip.matrix.decompose( grip.position, grip.rotation, grip.scale );
  						grip.matrixWorldNeedsUpdate = true;

  						if ( gripPose.linearVelocity ) {

  							grip.hasLinearVelocity = true;
  							grip.linearVelocity.copy( gripPose.linearVelocity );

  						} else {

  							grip.hasLinearVelocity = false;

  						}

  						if ( gripPose.angularVelocity ) {

  							grip.hasAngularVelocity = true;
  							grip.angularVelocity.copy( gripPose.angularVelocity );

  						} else {

  							grip.hasAngularVelocity = false;

  						}

  					}

  				}

  			}

  			if ( targetRay !== null ) {

  				inputPose = frame.getPose( inputSource.targetRaySpace, referenceSpace );

  				// Some runtimes (namely Vive Cosmos with Vive OpenXR Runtime) have only grip space and ray space is equal to it
  				if ( inputPose === null && gripPose !== null ) {

  					inputPose = gripPose;

  				}

  				if ( inputPose !== null ) {

  					targetRay.matrix.fromArray( inputPose.transform.matrix );
  					targetRay.matrix.decompose( targetRay.position, targetRay.rotation, targetRay.scale );
  					targetRay.matrixWorldNeedsUpdate = true;

  					if ( inputPose.linearVelocity ) {

  						targetRay.hasLinearVelocity = true;
  						targetRay.linearVelocity.copy( inputPose.linearVelocity );

  					} else {

  						targetRay.hasLinearVelocity = false;

  					}

  					if ( inputPose.angularVelocity ) {

  						targetRay.hasAngularVelocity = true;
  						targetRay.angularVelocity.copy( inputPose.angularVelocity );

  					} else {

  						targetRay.hasAngularVelocity = false;

  					}

  					this.dispatchEvent( _moveEvent );

  				}

  			}


  		}

  		if ( targetRay !== null ) {

  			targetRay.visible = ( inputPose !== null );

  		}

  		if ( grip !== null ) {

  			grip.visible = ( gripPose !== null );

  		}

  		if ( hand !== null ) {

  			hand.visible = ( handPose !== null );

  		}

  		return this;

  	}

  	// private method

  	_getHandJoint( hand, inputjoint ) {

  		if ( hand.joints[ inputjoint.jointName ] === undefined ) {

  			const joint = new Group();
  			joint.matrixAutoUpdate = false;
  			joint.visible = false;
  			hand.joints[ inputjoint.jointName ] = joint;

  			hand.add( joint );

  		}

  		return hand.joints[ inputjoint.jointName ];

  	}

  }

  const _occlusion_vertex = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`;

  const _occlusion_fragment = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;

  class WebXRDepthSensing {

  	constructor() {

  		this.texture = null;
  		this.mesh = null;

  		this.depthNear = 0;
  		this.depthFar = 0;

  	}

  	init( renderer, depthData, renderState ) {

  		if ( this.texture === null ) {

  			const texture = new Texture();

  			const texProps = renderer.properties.get( texture );
  			texProps.__webglTexture = depthData.texture;

  			if ( ( depthData.depthNear != renderState.depthNear ) || ( depthData.depthFar != renderState.depthFar ) ) {

  				this.depthNear = depthData.depthNear;
  				this.depthFar = depthData.depthFar;

  			}

  			this.texture = texture;

  		}

  	}

  	getMesh( cameraXR ) {

  		if ( this.texture !== null ) {

  			if ( this.mesh === null ) {

  				const viewport = cameraXR.cameras[ 0 ].viewport;
  				const material = new ShaderMaterial( {
  					vertexShader: _occlusion_vertex,
  					fragmentShader: _occlusion_fragment,
  					uniforms: {
  						depthColor: { value: this.texture },
  						depthWidth: { value: viewport.z },
  						depthHeight: { value: viewport.w }
  					}
  				} );

  				this.mesh = new Mesh( new PlaneGeometry( 20, 20 ), material );

  			}

  		}

  		return this.mesh;

  	}

  	reset() {

  		this.texture = null;
  		this.mesh = null;

  	}

  	getDepthTexture() {

  		return this.texture;

  	}

  }

  class WebXRManager extends EventDispatcher {

  	constructor( renderer, gl ) {

  		super();

  		const scope = this;

  		let session = null;

  		let framebufferScaleFactor = 1.0;

  		let referenceSpace = null;
  		let referenceSpaceType = 'local-floor';
  		// Set default foveation to maximum.
  		let foveation = 1.0;
  		let customReferenceSpace = null;

  		let pose = null;
  		let glBinding = null;
  		let glProjLayer = null;
  		let glBaseLayer = null;
  		let xrFrame = null;

  		const depthSensing = new WebXRDepthSensing();
  		const attributes = gl.getContextAttributes();

  		let initialRenderTarget = null;
  		let newRenderTarget = null;

  		const controllers = [];
  		const controllerInputSources = [];

  		const currentSize = new Vector2();
  		let currentPixelRatio = null;

  		//

  		const cameraL = new PerspectiveCamera();
  		cameraL.layers.enable( 1 );
  		cameraL.viewport = new Vector4();

  		const cameraR = new PerspectiveCamera();
  		cameraR.layers.enable( 2 );
  		cameraR.viewport = new Vector4();

  		const cameras = [ cameraL, cameraR ];

  		const cameraXR = new ArrayCamera();
  		cameraXR.layers.enable( 1 );
  		cameraXR.layers.enable( 2 );

  		let _currentDepthNear = null;
  		let _currentDepthFar = null;

  		//

  		this.cameraAutoUpdate = true;
  		this.enabled = false;

  		this.isPresenting = false;

  		this.getController = function ( index ) {

  			let controller = controllers[ index ];

  			if ( controller === undefined ) {

  				controller = new WebXRController();
  				controllers[ index ] = controller;

  			}

  			return controller.getTargetRaySpace();

  		};

  		this.getControllerGrip = function ( index ) {

  			let controller = controllers[ index ];

  			if ( controller === undefined ) {

  				controller = new WebXRController();
  				controllers[ index ] = controller;

  			}

  			return controller.getGripSpace();

  		};

  		this.getHand = function ( index ) {

  			let controller = controllers[ index ];

  			if ( controller === undefined ) {

  				controller = new WebXRController();
  				controllers[ index ] = controller;

  			}

  			return controller.getHandSpace();

  		};

  		//

  		function onSessionEvent( event ) {

  			const controllerIndex = controllerInputSources.indexOf( event.inputSource );

  			if ( controllerIndex === - 1 ) {

  				return;

  			}

  			const controller = controllers[ controllerIndex ];

  			if ( controller !== undefined ) {

  				controller.update( event.inputSource, event.frame, customReferenceSpace || referenceSpace );
  				controller.dispatchEvent( { type: event.type, data: event.inputSource } );

  			}

  		}

  		function onSessionEnd() {

  			session.removeEventListener( 'select', onSessionEvent );
  			session.removeEventListener( 'selectstart', onSessionEvent );
  			session.removeEventListener( 'selectend', onSessionEvent );
  			session.removeEventListener( 'squeeze', onSessionEvent );
  			session.removeEventListener( 'squeezestart', onSessionEvent );
  			session.removeEventListener( 'squeezeend', onSessionEvent );
  			session.removeEventListener( 'end', onSessionEnd );
  			session.removeEventListener( 'inputsourceschange', onInputSourcesChange );

  			for ( let i = 0; i < controllers.length; i ++ ) {

  				const inputSource = controllerInputSources[ i ];

  				if ( inputSource === null ) continue;

  				controllerInputSources[ i ] = null;

  				controllers[ i ].disconnect( inputSource );

  			}

  			_currentDepthNear = null;
  			_currentDepthFar = null;

  			depthSensing.reset();

  			// restore framebuffer/rendering state

  			renderer.setRenderTarget( initialRenderTarget );

  			glBaseLayer = null;
  			glProjLayer = null;
  			glBinding = null;
  			session = null;
  			newRenderTarget = null;

  			//

  			animation.stop();

  			scope.isPresenting = false;

  			renderer.setPixelRatio( currentPixelRatio );
  			renderer.setSize( currentSize.width, currentSize.height, false );

  			scope.dispatchEvent( { type: 'sessionend' } );

  		}

  		this.setFramebufferScaleFactor = function ( value ) {

  			framebufferScaleFactor = value;

  			if ( scope.isPresenting === true ) {

  				console.warn( 'THREE.WebXRManager: Cannot change framebuffer scale while presenting.' );

  			}

  		};

  		this.setReferenceSpaceType = function ( value ) {

  			referenceSpaceType = value;

  			if ( scope.isPresenting === true ) {

  				console.warn( 'THREE.WebXRManager: Cannot change reference space type while presenting.' );

  			}

  		};

  		this.getReferenceSpace = function () {

  			return customReferenceSpace || referenceSpace;

  		};

  		this.setReferenceSpace = function ( space ) {

  			customReferenceSpace = space;

  		};

  		this.getBaseLayer = function () {

  			return glProjLayer !== null ? glProjLayer : glBaseLayer;

  		};

  		this.getBinding = function () {

  			return glBinding;

  		};

  		this.getFrame = function () {

  			return xrFrame;

  		};

  		this.getSession = function () {

  			return session;

  		};

  		this.setSession = async function ( value ) {

  			session = value;

  			if ( session !== null ) {

  				initialRenderTarget = renderer.getRenderTarget();

  				session.addEventListener( 'select', onSessionEvent );
  				session.addEventListener( 'selectstart', onSessionEvent );
  				session.addEventListener( 'selectend', onSessionEvent );
  				session.addEventListener( 'squeeze', onSessionEvent );
  				session.addEventListener( 'squeezestart', onSessionEvent );
  				session.addEventListener( 'squeezeend', onSessionEvent );
  				session.addEventListener( 'end', onSessionEnd );
  				session.addEventListener( 'inputsourceschange', onInputSourcesChange );

  				if ( attributes.xrCompatible !== true ) {

  					await gl.makeXRCompatible();

  				}

  				currentPixelRatio = renderer.getPixelRatio();
  				renderer.getSize( currentSize );

  				if ( session.renderState.layers === undefined ) {

  					const layerInit = {
  						antialias: attributes.antialias,
  						alpha: true,
  						depth: attributes.depth,
  						stencil: attributes.stencil,
  						framebufferScaleFactor: framebufferScaleFactor
  					};

  					glBaseLayer = new XRWebGLLayer( session, gl, layerInit );

  					session.updateRenderState( { baseLayer: glBaseLayer } );

  					renderer.setPixelRatio( 1 );
  					renderer.setSize( glBaseLayer.framebufferWidth, glBaseLayer.framebufferHeight, false );

  					newRenderTarget = new WebGLRenderTarget(
  						glBaseLayer.framebufferWidth,
  						glBaseLayer.framebufferHeight,
  						{
  							format: RGBAFormat,
  							type: UnsignedByteType,
  							colorSpace: renderer.outputColorSpace,
  							stencilBuffer: attributes.stencil
  						}
  					);

  				} else {

  					let depthFormat = null;
  					let depthType = null;
  					let glDepthFormat = null;

  					if ( attributes.depth ) {

  						glDepthFormat = attributes.stencil ? gl.DEPTH24_STENCIL8 : gl.DEPTH_COMPONENT24;
  						depthFormat = attributes.stencil ? DepthStencilFormat : DepthFormat;
  						depthType = attributes.stencil ? UnsignedInt248Type : UnsignedIntType;

  					}

  					const projectionlayerInit = {
  						colorFormat: gl.RGBA8,
  						depthFormat: glDepthFormat,
  						scaleFactor: framebufferScaleFactor
  					};

  					glBinding = new XRWebGLBinding( session, gl );

  					glProjLayer = glBinding.createProjectionLayer( projectionlayerInit );

  					session.updateRenderState( { layers: [ glProjLayer ] } );

  					renderer.setPixelRatio( 1 );
  					renderer.setSize( glProjLayer.textureWidth, glProjLayer.textureHeight, false );

  					newRenderTarget = new WebGLRenderTarget(
  						glProjLayer.textureWidth,
  						glProjLayer.textureHeight,
  						{
  							format: RGBAFormat,
  							type: UnsignedByteType,
  							depthTexture: new DepthTexture( glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, undefined, undefined, undefined, undefined, undefined, undefined, depthFormat ),
  							stencilBuffer: attributes.stencil,
  							colorSpace: renderer.outputColorSpace,
  							samples: attributes.antialias ? 4 : 0,
  							resolveDepthBuffer: ( glProjLayer.ignoreDepthValues === false )
  						} );

  				}

  				newRenderTarget.isXRRenderTarget = true; // TODO Remove this when possible, see #23278

  				this.setFoveation( foveation );

  				customReferenceSpace = null;
  				referenceSpace = await session.requestReferenceSpace( referenceSpaceType );

  				animation.setContext( session );
  				animation.start();

  				scope.isPresenting = true;

  				scope.dispatchEvent( { type: 'sessionstart' } );

  			}

  		};

  		this.getEnvironmentBlendMode = function () {

  			if ( session !== null ) {

  				return session.environmentBlendMode;

  			}

  		};

  		this.getDepthTexture = function () {

  			return depthSensing.getDepthTexture();

  		};

  		function onInputSourcesChange( event ) {

  			// Notify disconnected

  			for ( let i = 0; i < event.removed.length; i ++ ) {

  				const inputSource = event.removed[ i ];
  				const index = controllerInputSources.indexOf( inputSource );

  				if ( index >= 0 ) {

  					controllerInputSources[ index ] = null;
  					controllers[ index ].disconnect( inputSource );

  				}

  			}

  			// Notify connected

  			for ( let i = 0; i < event.added.length; i ++ ) {

  				const inputSource = event.added[ i ];

  				let controllerIndex = controllerInputSources.indexOf( inputSource );

  				if ( controllerIndex === - 1 ) {

  					// Assign input source a controller that currently has no input source

  					for ( let i = 0; i < controllers.length; i ++ ) {

  						if ( i >= controllerInputSources.length ) {

  							controllerInputSources.push( inputSource );
  							controllerIndex = i;
  							break;

  						} else if ( controllerInputSources[ i ] === null ) {

  							controllerInputSources[ i ] = inputSource;
  							controllerIndex = i;
  							break;

  						}

  					}

  					// If all controllers do currently receive input we ignore new ones

  					if ( controllerIndex === - 1 ) break;

  				}

  				const controller = controllers[ controllerIndex ];

  				if ( controller ) {

  					controller.connect( inputSource );

  				}

  			}

  		}

  		//

  		const cameraLPos = new Vector3();
  		const cameraRPos = new Vector3();

  		/**
  		 * Assumes 2 cameras that are parallel and share an X-axis, and that
  		 * the cameras' projection and world matrices have already been set.
  		 * And that near and far planes are identical for both cameras.
  		 * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
  		 */
  		function setProjectionFromUnion( camera, cameraL, cameraR ) {

  			cameraLPos.setFromMatrixPosition( cameraL.matrixWorld );
  			cameraRPos.setFromMatrixPosition( cameraR.matrixWorld );

  			const ipd = cameraLPos.distanceTo( cameraRPos );

  			const projL = cameraL.projectionMatrix.elements;
  			const projR = cameraR.projectionMatrix.elements;

  			// VR systems will have identical far and near planes, and
  			// most likely identical top and bottom frustum extents.
  			// Use the left camera for these values.
  			const near = projL[ 14 ] / ( projL[ 10 ] - 1 );
  			const far = projL[ 14 ] / ( projL[ 10 ] + 1 );
  			const topFov = ( projL[ 9 ] + 1 ) / projL[ 5 ];
  			const bottomFov = ( projL[ 9 ] - 1 ) / projL[ 5 ];

  			const leftFov = ( projL[ 8 ] - 1 ) / projL[ 0 ];
  			const rightFov = ( projR[ 8 ] + 1 ) / projR[ 0 ];
  			const left = near * leftFov;
  			const right = near * rightFov;

  			// Calculate the new camera's position offset from the
  			// left camera. xOffset should be roughly half `ipd`.
  			const zOffset = ipd / ( - leftFov + rightFov );
  			const xOffset = zOffset * - leftFov;

  			// TODO: Better way to apply this offset?
  			cameraL.matrixWorld.decompose( camera.position, camera.quaternion, camera.scale );
  			camera.translateX( xOffset );
  			camera.translateZ( zOffset );
  			camera.matrixWorld.compose( camera.position, camera.quaternion, camera.scale );
  			camera.matrixWorldInverse.copy( camera.matrixWorld ).invert();

  			// Find the union of the frustum values of the cameras and scale
  			// the values so that the near plane's position does not change in world space,
  			// although must now be relative to the new union camera.
  			const near2 = near + zOffset;
  			const far2 = far + zOffset;
  			const left2 = left - xOffset;
  			const right2 = right + ( ipd - xOffset );
  			const top2 = topFov * far / far2 * near2;
  			const bottom2 = bottomFov * far / far2 * near2;

  			camera.projectionMatrix.makePerspective( left2, right2, top2, bottom2, near2, far2 );
  			camera.projectionMatrixInverse.copy( camera.projectionMatrix ).invert();

  		}

  		function updateCamera( camera, parent ) {

  			if ( parent === null ) {

  				camera.matrixWorld.copy( camera.matrix );

  			} else {

  				camera.matrixWorld.multiplyMatrices( parent.matrixWorld, camera.matrix );

  			}

  			camera.matrixWorldInverse.copy( camera.matrixWorld ).invert();

  		}

  		this.updateCamera = function ( camera ) {

  			if ( session === null ) return;

  			if ( depthSensing.texture !== null ) {

  				camera.near = depthSensing.depthNear;
  				camera.far = depthSensing.depthFar;

  			}

  			cameraXR.near = cameraR.near = cameraL.near = camera.near;
  			cameraXR.far = cameraR.far = cameraL.far = camera.far;

  			if ( _currentDepthNear !== cameraXR.near || _currentDepthFar !== cameraXR.far ) {

  				// Note that the new renderState won't apply until the next frame. See #18320

  				session.updateRenderState( {
  					depthNear: cameraXR.near,
  					depthFar: cameraXR.far
  				} );

  				_currentDepthNear = cameraXR.near;
  				_currentDepthFar = cameraXR.far;

  				cameraL.near = _currentDepthNear;
  				cameraL.far = _currentDepthFar;
  				cameraR.near = _currentDepthNear;
  				cameraR.far = _currentDepthFar;

  				cameraL.updateProjectionMatrix();
  				cameraR.updateProjectionMatrix();
  				camera.updateProjectionMatrix();

  			}

  			const parent = camera.parent;
  			const cameras = cameraXR.cameras;

  			updateCamera( cameraXR, parent );

  			for ( let i = 0; i < cameras.length; i ++ ) {

  				updateCamera( cameras[ i ], parent );

  			}

  			// update projection matrix for proper view frustum culling

  			if ( cameras.length === 2 ) {

  				setProjectionFromUnion( cameraXR, cameraL, cameraR );

  			} else {

  				// assume single camera setup (AR)

  				cameraXR.projectionMatrix.copy( cameraL.projectionMatrix );

  			}

  			// update user camera and its children

  			updateUserCamera( camera, cameraXR, parent );

  		};

  		function updateUserCamera( camera, cameraXR, parent ) {

  			if ( parent === null ) {

  				camera.matrix.copy( cameraXR.matrixWorld );

  			} else {

  				camera.matrix.copy( parent.matrixWorld );
  				camera.matrix.invert();
  				camera.matrix.multiply( cameraXR.matrixWorld );

  			}

  			camera.matrix.decompose( camera.position, camera.quaternion, camera.scale );
  			camera.updateMatrixWorld( true );

  			camera.projectionMatrix.copy( cameraXR.projectionMatrix );
  			camera.projectionMatrixInverse.copy( cameraXR.projectionMatrixInverse );

  			if ( camera.isPerspectiveCamera ) {

  				camera.fov = RAD2DEG$1 * 2 * Math.atan( 1 / camera.projectionMatrix.elements[ 5 ] );
  				camera.zoom = 1;

  			}

  		}

  		this.getCamera = function () {

  			return cameraXR;

  		};

  		this.getFoveation = function () {

  			if ( glProjLayer === null && glBaseLayer === null ) {

  				return undefined;

  			}

  			return foveation;

  		};

  		this.setFoveation = function ( value ) {

  			// 0 = no foveation = full resolution
  			// 1 = maximum foveation = the edges render at lower resolution

  			foveation = value;

  			if ( glProjLayer !== null ) {

  				glProjLayer.fixedFoveation = value;

  			}

  			if ( glBaseLayer !== null && glBaseLayer.fixedFoveation !== undefined ) {

  				glBaseLayer.fixedFoveation = value;

  			}

  		};

  		this.hasDepthSensing = function () {

  			return depthSensing.texture !== null;

  		};

  		this.getDepthSensingMesh = function () {

  			return depthSensing.getMesh( cameraXR );

  		};

  		// Animation Loop

  		let onAnimationFrameCallback = null;

  		function onAnimationFrame( time, frame ) {

  			pose = frame.getViewerPose( customReferenceSpace || referenceSpace );
  			xrFrame = frame;

  			if ( pose !== null ) {

  				const views = pose.views;

  				if ( glBaseLayer !== null ) {

  					renderer.setRenderTargetFramebuffer( newRenderTarget, glBaseLayer.framebuffer );
  					renderer.setRenderTarget( newRenderTarget );

  				}

  				let cameraXRNeedsUpdate = false;

  				// check if it's necessary to rebuild cameraXR's camera list

  				if ( views.length !== cameraXR.cameras.length ) {

  					cameraXR.cameras.length = 0;
  					cameraXRNeedsUpdate = true;

  				}

  				for ( let i = 0; i < views.length; i ++ ) {

  					const view = views[ i ];

  					let viewport = null;

  					if ( glBaseLayer !== null ) {

  						viewport = glBaseLayer.getViewport( view );

  					} else {

  						const glSubImage = glBinding.getViewSubImage( glProjLayer, view );
  						viewport = glSubImage.viewport;

  						// For side-by-side projection, we only produce a single texture for both eyes.
  						if ( i === 0 ) {

  							renderer.setRenderTargetTextures(
  								newRenderTarget,
  								glSubImage.colorTexture,
  								glProjLayer.ignoreDepthValues ? undefined : glSubImage.depthStencilTexture );

  							renderer.setRenderTarget( newRenderTarget );

  						}

  					}

  					let camera = cameras[ i ];

  					if ( camera === undefined ) {

  						camera = new PerspectiveCamera();
  						camera.layers.enable( i );
  						camera.viewport = new Vector4();
  						cameras[ i ] = camera;

  					}

  					camera.matrix.fromArray( view.transform.matrix );
  					camera.matrix.decompose( camera.position, camera.quaternion, camera.scale );
  					camera.projectionMatrix.fromArray( view.projectionMatrix );
  					camera.projectionMatrixInverse.copy( camera.projectionMatrix ).invert();
  					camera.viewport.set( viewport.x, viewport.y, viewport.width, viewport.height );

  					if ( i === 0 ) {

  						cameraXR.matrix.copy( camera.matrix );
  						cameraXR.matrix.decompose( cameraXR.position, cameraXR.quaternion, cameraXR.scale );

  					}

  					if ( cameraXRNeedsUpdate === true ) {

  						cameraXR.cameras.push( camera );

  					}

  				}

  				//

  				const enabledFeatures = session.enabledFeatures;

  				if ( enabledFeatures && enabledFeatures.includes( 'depth-sensing' ) ) {

  					const depthData = glBinding.getDepthInformation( views[ 0 ] );

  					if ( depthData && depthData.isValid && depthData.texture ) {

  						depthSensing.init( renderer, depthData, session.renderState );

  					}

  				}

  			}

  			//

  			for ( let i = 0; i < controllers.length; i ++ ) {

  				const inputSource = controllerInputSources[ i ];
  				const controller = controllers[ i ];

  				if ( inputSource !== null && controller !== undefined ) {

  					controller.update( inputSource, frame, customReferenceSpace || referenceSpace );

  				}

  			}

  			if ( onAnimationFrameCallback ) onAnimationFrameCallback( time, frame );

  			if ( frame.detectedPlanes ) {

  				scope.dispatchEvent( { type: 'planesdetected', data: frame } );

  			}

  			xrFrame = null;

  		}

  		const animation = new WebGLAnimation();

  		animation.setAnimationLoop( onAnimationFrame );

  		this.setAnimationLoop = function ( callback ) {

  			onAnimationFrameCallback = callback;

  		};

  		this.dispose = function () {};

  	}

  }

  const _e1 = /*@__PURE__*/ new Euler();
  const _m1 = /*@__PURE__*/ new Matrix4();

  function WebGLMaterials( renderer, properties ) {

  	function refreshTransformUniform( map, uniform ) {

  		if ( map.matrixAutoUpdate === true ) {

  			map.updateMatrix();

  		}

  		uniform.value.copy( map.matrix );

  	}

  	function refreshFogUniforms( uniforms, fog ) {

  		fog.color.getRGB( uniforms.fogColor.value, getUnlitUniformColorSpace( renderer ) );

  		if ( fog.isFog ) {

  			uniforms.fogNear.value = fog.near;
  			uniforms.fogFar.value = fog.far;

  		} else if ( fog.isFogExp2 ) {

  			uniforms.fogDensity.value = fog.density;

  		}

  	}

  	function refreshMaterialUniforms( uniforms, material, pixelRatio, height, transmissionRenderTarget ) {

  		if ( material.isMeshBasicMaterial ) {

  			refreshUniformsCommon( uniforms, material );

  		} else if ( material.isMeshLambertMaterial ) {

  			refreshUniformsCommon( uniforms, material );

  		} else if ( material.isMeshToonMaterial ) {

  			refreshUniformsCommon( uniforms, material );
  			refreshUniformsToon( uniforms, material );

  		} else if ( material.isMeshPhongMaterial ) {

  			refreshUniformsCommon( uniforms, material );
  			refreshUniformsPhong( uniforms, material );

  		} else if ( material.isMeshStandardMaterial ) {

  			refreshUniformsCommon( uniforms, material );
  			refreshUniformsStandard( uniforms, material );

  			if ( material.isMeshPhysicalMaterial ) {

  				refreshUniformsPhysical( uniforms, material, transmissionRenderTarget );

  			}

  		} else if ( material.isMeshMatcapMaterial ) {

  			refreshUniformsCommon( uniforms, material );
  			refreshUniformsMatcap( uniforms, material );

  		} else if ( material.isMeshDepthMaterial ) {

  			refreshUniformsCommon( uniforms, material );

  		} else if ( material.isMeshDistanceMaterial ) {

  			refreshUniformsCommon( uniforms, material );
  			refreshUniformsDistance( uniforms, material );

  		} else if ( material.isMeshNormalMaterial ) {

  			refreshUniformsCommon( uniforms, material );

  		} else if ( material.isLineBasicMaterial ) {

  			refreshUniformsLine( uniforms, material );

  			if ( material.isLineDashedMaterial ) {

  				refreshUniformsDash( uniforms, material );

  			}

  		} else if ( material.isPointsMaterial ) {

  			refreshUniformsPoints( uniforms, material, pixelRatio, height );

  		} else if ( material.isSpriteMaterial ) {

  			refreshUniformsSprites( uniforms, material );

  		} else if ( material.isShadowMaterial ) {

  			uniforms.color.value.copy( material.color );
  			uniforms.opacity.value = material.opacity;

  		} else if ( material.isShaderMaterial ) {

  			material.uniformsNeedUpdate = false; // #15581

  		}

  	}

  	function refreshUniformsCommon( uniforms, material ) {

  		uniforms.opacity.value = material.opacity;

  		if ( material.color ) {

  			uniforms.diffuse.value.copy( material.color );

  		}

  		if ( material.emissive ) {

  			uniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );

  		}

  		if ( material.map ) {

  			uniforms.map.value = material.map;

  			refreshTransformUniform( material.map, uniforms.mapTransform );

  		}

  		if ( material.alphaMap ) {

  			uniforms.alphaMap.value = material.alphaMap;

  			refreshTransformUniform( material.alphaMap, uniforms.alphaMapTransform );

  		}

  		if ( material.bumpMap ) {

  			uniforms.bumpMap.value = material.bumpMap;

  			refreshTransformUniform( material.bumpMap, uniforms.bumpMapTransform );

  			uniforms.bumpScale.value = material.bumpScale;

  			if ( material.side === BackSide ) {

  				uniforms.bumpScale.value *= - 1;

  			}

  		}

  		if ( material.normalMap ) {

  			uniforms.normalMap.value = material.normalMap;

  			refreshTransformUniform( material.normalMap, uniforms.normalMapTransform );

  			uniforms.normalScale.value.copy( material.normalScale );

  			if ( material.side === BackSide ) {

  				uniforms.normalScale.value.negate();

  			}

  		}

  		if ( material.displacementMap ) {

  			uniforms.displacementMap.value = material.displacementMap;

  			refreshTransformUniform( material.displacementMap, uniforms.displacementMapTransform );

  			uniforms.displacementScale.value = material.displacementScale;
  			uniforms.displacementBias.value = material.displacementBias;

  		}

  		if ( material.emissiveMap ) {

  			uniforms.emissiveMap.value = material.emissiveMap;

  			refreshTransformUniform( material.emissiveMap, uniforms.emissiveMapTransform );

  		}

  		if ( material.specularMap ) {

  			uniforms.specularMap.value = material.specularMap;

  			refreshTransformUniform( material.specularMap, uniforms.specularMapTransform );

  		}

  		if ( material.alphaTest > 0 ) {

  			uniforms.alphaTest.value = material.alphaTest;

  		}

  		const materialProperties = properties.get( material );

  		const envMap = materialProperties.envMap;
  		const envMapRotation = materialProperties.envMapRotation;

  		if ( envMap ) {

  			uniforms.envMap.value = envMap;

  			_e1.copy( envMapRotation );

  			// accommodate left-handed frame
  			_e1.x *= - 1; _e1.y *= - 1; _e1.z *= - 1;

  			if ( envMap.isCubeTexture && envMap.isRenderTargetTexture === false ) {

  				// environment maps which are not cube render targets or PMREMs follow a different convention
  				_e1.y *= - 1;
  				_e1.z *= - 1;

  			}

  			uniforms.envMapRotation.value.setFromMatrix4( _m1.makeRotationFromEuler( _e1 ) );

  			uniforms.flipEnvMap.value = ( envMap.isCubeTexture && envMap.isRenderTargetTexture === false ) ? - 1 : 1;

  			uniforms.reflectivity.value = material.reflectivity;
  			uniforms.ior.value = material.ior;
  			uniforms.refractionRatio.value = material.refractionRatio;

  		}

  		if ( material.lightMap ) {

  			uniforms.lightMap.value = material.lightMap;
  			uniforms.lightMapIntensity.value = material.lightMapIntensity;

  			refreshTransformUniform( material.lightMap, uniforms.lightMapTransform );

  		}

  		if ( material.aoMap ) {

  			uniforms.aoMap.value = material.aoMap;
  			uniforms.aoMapIntensity.value = material.aoMapIntensity;

  			refreshTransformUniform( material.aoMap, uniforms.aoMapTransform );

  		}

  	}

  	function refreshUniformsLine( uniforms, material ) {

  		uniforms.diffuse.value.copy( material.color );
  		uniforms.opacity.value = material.opacity;

  		if ( material.map ) {

  			uniforms.map.value = material.map;

  			refreshTransformUniform( material.map, uniforms.mapTransform );

  		}

  	}

  	function refreshUniformsDash( uniforms, material ) {

  		uniforms.dashSize.value = material.dashSize;
  		uniforms.totalSize.value = material.dashSize + material.gapSize;
  		uniforms.scale.value = material.scale;

  	}

  	function refreshUniformsPoints( uniforms, material, pixelRatio, height ) {

  		uniforms.diffuse.value.copy( material.color );
  		uniforms.opacity.value = material.opacity;
  		uniforms.size.value = material.size * pixelRatio;
  		uniforms.scale.value = height * 0.5;

  		if ( material.map ) {

  			uniforms.map.value = material.map;

  			refreshTransformUniform( material.map, uniforms.uvTransform );

  		}

  		if ( material.alphaMap ) {

  			uniforms.alphaMap.value = material.alphaMap;

  			refreshTransformUniform( material.alphaMap, uniforms.alphaMapTransform );

  		}

  		if ( material.alphaTest > 0 ) {

  			uniforms.alphaTest.value = material.alphaTest;

  		}

  	}

  	function refreshUniformsSprites( uniforms, material ) {

  		uniforms.diffuse.value.copy( material.color );
  		uniforms.opacity.value = material.opacity;
  		uniforms.rotation.value = material.rotation;

  		if ( material.map ) {

  			uniforms.map.value = material.map;

  			refreshTransformUniform( material.map, uniforms.mapTransform );

  		}

  		if ( material.alphaMap ) {

  			uniforms.alphaMap.value = material.alphaMap;

  			refreshTransformUniform( material.alphaMap, uniforms.alphaMapTransform );

  		}

  		if ( material.alphaTest > 0 ) {

  			uniforms.alphaTest.value = material.alphaTest;

  		}

  	}

  	function refreshUniformsPhong( uniforms, material ) {

  		uniforms.specular.value.copy( material.specular );
  		uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )

  	}

  	function refreshUniformsToon( uniforms, material ) {

  		if ( material.gradientMap ) {

  			uniforms.gradientMap.value = material.gradientMap;

  		}

  	}

  	function refreshUniformsStandard( uniforms, material ) {

  		uniforms.metalness.value = material.metalness;

  		if ( material.metalnessMap ) {

  			uniforms.metalnessMap.value = material.metalnessMap;

  			refreshTransformUniform( material.metalnessMap, uniforms.metalnessMapTransform );

  		}

  		uniforms.roughness.value = material.roughness;

  		if ( material.roughnessMap ) {

  			uniforms.roughnessMap.value = material.roughnessMap;

  			refreshTransformUniform( material.roughnessMap, uniforms.roughnessMapTransform );

  		}

  		if ( material.envMap ) {

  			//uniforms.envMap.value = material.envMap; // part of uniforms common

  			uniforms.envMapIntensity.value = material.envMapIntensity;

  		}

  	}

  	function refreshUniformsPhysical( uniforms, material, transmissionRenderTarget ) {

  		uniforms.ior.value = material.ior; // also part of uniforms common

  		if ( material.sheen > 0 ) {

  			uniforms.sheenColor.value.copy( material.sheenColor ).multiplyScalar( material.sheen );

  			uniforms.sheenRoughness.value = material.sheenRoughness;

  			if ( material.sheenColorMap ) {

  				uniforms.sheenColorMap.value = material.sheenColorMap;

  				refreshTransformUniform( material.sheenColorMap, uniforms.sheenColorMapTransform );

  			}

  			if ( material.sheenRoughnessMap ) {

  				uniforms.sheenRoughnessMap.value = material.sheenRoughnessMap;

  				refreshTransformUniform( material.sheenRoughnessMap, uniforms.sheenRoughnessMapTransform );

  			}

  		}

  		if ( material.clearcoat > 0 ) {

  			uniforms.clearcoat.value = material.clearcoat;
  			uniforms.clearcoatRoughness.value = material.clearcoatRoughness;

  			if ( material.clearcoatMap ) {

  				uniforms.clearcoatMap.value = material.clearcoatMap;

  				refreshTransformUniform( material.clearcoatMap, uniforms.clearcoatMapTransform );

  			}

  			if ( material.clearcoatRoughnessMap ) {

  				uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;

  				refreshTransformUniform( material.clearcoatRoughnessMap, uniforms.clearcoatRoughnessMapTransform );

  			}

  			if ( material.clearcoatNormalMap ) {

  				uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;

  				refreshTransformUniform( material.clearcoatNormalMap, uniforms.clearcoatNormalMapTransform );

  				uniforms.clearcoatNormalScale.value.copy( material.clearcoatNormalScale );

  				if ( material.side === BackSide ) {

  					uniforms.clearcoatNormalScale.value.negate();

  				}

  			}

  		}

  		if ( material.dispersion > 0 ) {

  			uniforms.dispersion.value = material.dispersion;

  		}

  		if ( material.iridescence > 0 ) {

  			uniforms.iridescence.value = material.iridescence;
  			uniforms.iridescenceIOR.value = material.iridescenceIOR;
  			uniforms.iridescenceThicknessMinimum.value = material.iridescenceThicknessRange[ 0 ];
  			uniforms.iridescenceThicknessMaximum.value = material.iridescenceThicknessRange[ 1 ];

  			if ( material.iridescenceMap ) {

  				uniforms.iridescenceMap.value = material.iridescenceMap;

  				refreshTransformUniform( material.iridescenceMap, uniforms.iridescenceMapTransform );

  			}

  			if ( material.iridescenceThicknessMap ) {

  				uniforms.iridescenceThicknessMap.value = material.iridescenceThicknessMap;

  				refreshTransformUniform( material.iridescenceThicknessMap, uniforms.iridescenceThicknessMapTransform );

  			}

  		}

  		if ( material.transmission > 0 ) {

  			uniforms.transmission.value = material.transmission;
  			uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;
  			uniforms.transmissionSamplerSize.value.set( transmissionRenderTarget.width, transmissionRenderTarget.height );

  			if ( material.transmissionMap ) {

  				uniforms.transmissionMap.value = material.transmissionMap;

  				refreshTransformUniform( material.transmissionMap, uniforms.transmissionMapTransform );

  			}

  			uniforms.thickness.value = material.thickness;

  			if ( material.thicknessMap ) {

  				uniforms.thicknessMap.value = material.thicknessMap;

  				refreshTransformUniform( material.thicknessMap, uniforms.thicknessMapTransform );

  			}

  			uniforms.attenuationDistance.value = material.attenuationDistance;
  			uniforms.attenuationColor.value.copy( material.attenuationColor );

  		}

  		if ( material.anisotropy > 0 ) {

  			uniforms.anisotropyVector.value.set( material.anisotropy * Math.cos( material.anisotropyRotation ), material.anisotropy * Math.sin( material.anisotropyRotation ) );

  			if ( material.anisotropyMap ) {

  				uniforms.anisotropyMap.value = material.anisotropyMap;

  				refreshTransformUniform( material.anisotropyMap, uniforms.anisotropyMapTransform );

  			}

  		}

  		uniforms.specularIntensity.value = material.specularIntensity;
  		uniforms.specularColor.value.copy( material.specularColor );

  		if ( material.specularColorMap ) {

  			uniforms.specularColorMap.value = material.specularColorMap;

  			refreshTransformUniform( material.specularColorMap, uniforms.specularColorMapTransform );

  		}

  		if ( material.specularIntensityMap ) {

  			uniforms.specularIntensityMap.value = material.specularIntensityMap;

  			refreshTransformUniform( material.specularIntensityMap, uniforms.specularIntensityMapTransform );

  		}

  	}

  	function refreshUniformsMatcap( uniforms, material ) {

  		if ( material.matcap ) {

  			uniforms.matcap.value = material.matcap;

  		}

  	}

  	function refreshUniformsDistance( uniforms, material ) {

  		const light = properties.get( material ).light;

  		uniforms.referencePosition.value.setFromMatrixPosition( light.matrixWorld );
  		uniforms.nearDistance.value = light.shadow.camera.near;
  		uniforms.farDistance.value = light.shadow.camera.far;

  	}

  	return {
  		refreshFogUniforms: refreshFogUniforms,
  		refreshMaterialUniforms: refreshMaterialUniforms
  	};

  }

  function WebGLUniformsGroups( gl, info, capabilities, state ) {

  	let buffers = {};
  	let updateList = {};
  	let allocatedBindingPoints = [];

  	const maxBindingPoints = gl.getParameter( gl.MAX_UNIFORM_BUFFER_BINDINGS ); // binding points are global whereas block indices are per shader program

  	function bind( uniformsGroup, program ) {

  		const webglProgram = program.program;
  		state.uniformBlockBinding( uniformsGroup, webglProgram );

  	}

  	function update( uniformsGroup, program ) {

  		let buffer = buffers[ uniformsGroup.id ];

  		if ( buffer === undefined ) {

  			prepareUniformsGroup( uniformsGroup );

  			buffer = createBuffer( uniformsGroup );
  			buffers[ uniformsGroup.id ] = buffer;

  			uniformsGroup.addEventListener( 'dispose', onUniformsGroupsDispose );

  		}

  		// ensure to update the binding points/block indices mapping for this program

  		const webglProgram = program.program;
  		state.updateUBOMapping( uniformsGroup, webglProgram );

  		// update UBO once per frame

  		const frame = info.render.frame;

  		if ( updateList[ uniformsGroup.id ] !== frame ) {

  			updateBufferData( uniformsGroup );

  			updateList[ uniformsGroup.id ] = frame;

  		}

  	}

  	function createBuffer( uniformsGroup ) {

  		// the setup of an UBO is independent of a particular shader program but global

  		const bindingPointIndex = allocateBindingPointIndex();
  		uniformsGroup.__bindingPointIndex = bindingPointIndex;

  		const buffer = gl.createBuffer();
  		const size = uniformsGroup.__size;
  		const usage = uniformsGroup.usage;

  		gl.bindBuffer( gl.UNIFORM_BUFFER, buffer );
  		gl.bufferData( gl.UNIFORM_BUFFER, size, usage );
  		gl.bindBuffer( gl.UNIFORM_BUFFER, null );
  		gl.bindBufferBase( gl.UNIFORM_BUFFER, bindingPointIndex, buffer );

  		return buffer;

  	}

  	function allocateBindingPointIndex() {

  		for ( let i = 0; i < maxBindingPoints; i ++ ) {

  			if ( allocatedBindingPoints.indexOf( i ) === - 1 ) {

  				allocatedBindingPoints.push( i );
  				return i;

  			}

  		}

  		console.error( 'THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached.' );

  		return 0;

  	}

  	function updateBufferData( uniformsGroup ) {

  		const buffer = buffers[ uniformsGroup.id ];
  		const uniforms = uniformsGroup.uniforms;
  		const cache = uniformsGroup.__cache;

  		gl.bindBuffer( gl.UNIFORM_BUFFER, buffer );

  		for ( let i = 0, il = uniforms.length; i < il; i ++ ) {

  			const uniformArray = Array.isArray( uniforms[ i ] ) ? uniforms[ i ] : [ uniforms[ i ] ];

  			for ( let j = 0, jl = uniformArray.length; j < jl; j ++ ) {

  				const uniform = uniformArray[ j ];

  				if ( hasUniformChanged( uniform, i, j, cache ) === true ) {

  					const offset = uniform.__offset;

  					const values = Array.isArray( uniform.value ) ? uniform.value : [ uniform.value ];

  					let arrayOffset = 0;

  					for ( let k = 0; k < values.length; k ++ ) {

  						const value = values[ k ];

  						const info = getUniformSize( value );

  						// TODO add integer and struct support
  						if ( typeof value === 'number' || typeof value === 'boolean' ) {

  							uniform.__data[ 0 ] = value;
  							gl.bufferSubData( gl.UNIFORM_BUFFER, offset + arrayOffset, uniform.__data );

  						} else if ( value.isMatrix3 ) {

  							// manually converting 3x3 to 3x4

  							uniform.__data[ 0 ] = value.elements[ 0 ];
  							uniform.__data[ 1 ] = value.elements[ 1 ];
  							uniform.__data[ 2 ] = value.elements[ 2 ];
  							uniform.__data[ 3 ] = 0;
  							uniform.__data[ 4 ] = value.elements[ 3 ];
  							uniform.__data[ 5 ] = value.elements[ 4 ];
  							uniform.__data[ 6 ] = value.elements[ 5 ];
  							uniform.__data[ 7 ] = 0;
  							uniform.__data[ 8 ] = value.elements[ 6 ];
  							uniform.__data[ 9 ] = value.elements[ 7 ];
  							uniform.__data[ 10 ] = value.elements[ 8 ];
  							uniform.__data[ 11 ] = 0;

  						} else {

  							value.toArray( uniform.__data, arrayOffset );

  							arrayOffset += info.storage / Float32Array.BYTES_PER_ELEMENT;

  						}

  					}

  					gl.bufferSubData( gl.UNIFORM_BUFFER, offset, uniform.__data );

  				}

  			}

  		}

  		gl.bindBuffer( gl.UNIFORM_BUFFER, null );

  	}

  	function hasUniformChanged( uniform, index, indexArray, cache ) {

  		const value = uniform.value;
  		const indexString = index + '_' + indexArray;

  		if ( cache[ indexString ] === undefined ) {

  			// cache entry does not exist so far

  			if ( typeof value === 'number' || typeof value === 'boolean' ) {

  				cache[ indexString ] = value;

  			} else {

  				cache[ indexString ] = value.clone();

  			}

  			return true;

  		} else {

  			const cachedObject = cache[ indexString ];

  			// compare current value with cached entry

  			if ( typeof value === 'number' || typeof value === 'boolean' ) {

  				if ( cachedObject !== value ) {

  					cache[ indexString ] = value;
  					return true;

  				}

  			} else {

  				if ( cachedObject.equals( value ) === false ) {

  					cachedObject.copy( value );
  					return true;

  				}

  			}

  		}

  		return false;

  	}

  	function prepareUniformsGroup( uniformsGroup ) {

  		// determine total buffer size according to the STD140 layout
  		// Hint: STD140 is the only supported layout in WebGL 2

  		const uniforms = uniformsGroup.uniforms;

  		let offset = 0; // global buffer offset in bytes
  		const chunkSize = 16; // size of a chunk in bytes

  		for ( let i = 0, l = uniforms.length; i < l; i ++ ) {

  			const uniformArray = Array.isArray( uniforms[ i ] ) ? uniforms[ i ] : [ uniforms[ i ] ];

  			for ( let j = 0, jl = uniformArray.length; j < jl; j ++ ) {

  				const uniform = uniformArray[ j ];

  				const values = Array.isArray( uniform.value ) ? uniform.value : [ uniform.value ];

  				for ( let k = 0, kl = values.length; k < kl; k ++ ) {

  					const value = values[ k ];

  					const info = getUniformSize( value );

  					const chunkOffset = offset % chunkSize; // offset in the current chunk
  					const chunkPadding = chunkOffset % info.boundary; // required padding to match boundary
  					const chunkStart = chunkOffset + chunkPadding; // the start position in the current chunk for the data

  					offset += chunkPadding;

  					// Check for chunk overflow
  					if ( chunkStart !== 0 && ( chunkSize - chunkStart ) < info.storage ) {

  						// Add padding and adjust offset
  						offset += ( chunkSize - chunkStart );

  					}

  					// the following two properties will be used for partial buffer updates
  					uniform.__data = new Float32Array( info.storage / Float32Array.BYTES_PER_ELEMENT );
  					uniform.__offset = offset;

  					// Update the global offset
  					offset += info.storage;

  				}

  			}

  		}

  		// ensure correct final padding

  		const chunkOffset = offset % chunkSize;

  		if ( chunkOffset > 0 ) offset += ( chunkSize - chunkOffset );

  		//

  		uniformsGroup.__size = offset;
  		uniformsGroup.__cache = {};

  		return this;

  	}

  	function getUniformSize( value ) {

  		const info = {
  			boundary: 0, // bytes
  			storage: 0 // bytes
  		};

  		// determine sizes according to STD140

  		if ( typeof value === 'number' || typeof value === 'boolean' ) {

  			// float/int/bool

  			info.boundary = 4;
  			info.storage = 4;

  		} else if ( value.isVector2 ) {

  			// vec2

  			info.boundary = 8;
  			info.storage = 8;

  		} else if ( value.isVector3 || value.isColor ) {

  			// vec3

  			info.boundary = 16;
  			info.storage = 12; // evil: vec3 must start on a 16-byte boundary but it only consumes 12 bytes

  		} else if ( value.isVector4 ) {

  			// vec4

  			info.boundary = 16;
  			info.storage = 16;

  		} else if ( value.isMatrix3 ) {

  			// mat3 (in STD140 a 3x3 matrix is represented as 3x4)

  			info.boundary = 48;
  			info.storage = 48;

  		} else if ( value.isMatrix4 ) {

  			// mat4

  			info.boundary = 64;
  			info.storage = 64;

  		} else if ( value.isTexture ) {

  			console.warn( 'THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.' );

  		} else {

  			console.warn( 'THREE.WebGLRenderer: Unsupported uniform value type.', value );

  		}

  		return info;

  	}

  	function onUniformsGroupsDispose( event ) {

  		const uniformsGroup = event.target;

  		uniformsGroup.removeEventListener( 'dispose', onUniformsGroupsDispose );

  		const index = allocatedBindingPoints.indexOf( uniformsGroup.__bindingPointIndex );
  		allocatedBindingPoints.splice( index, 1 );

  		gl.deleteBuffer( buffers[ uniformsGroup.id ] );

  		delete buffers[ uniformsGroup.id ];
  		delete updateList[ uniformsGroup.id ];

  	}

  	function dispose() {

  		for ( const id in buffers ) {

  			gl.deleteBuffer( buffers[ id ] );

  		}

  		allocatedBindingPoints = [];
  		buffers = {};
  		updateList = {};

  	}

  	return {

  		bind: bind,
  		update: update,

  		dispose: dispose

  	};

  }

  class WebGLRenderer {

  	constructor( parameters = {} ) {

  		const {
  			canvas = createCanvasElement(),
  			context = null,
  			depth = true,
  			stencil = false,
  			alpha = false,
  			antialias = false,
  			premultipliedAlpha = true,
  			preserveDrawingBuffer = false,
  			powerPreference = 'default',
  			failIfMajorPerformanceCaveat = false,
  		} = parameters;

  		this.isWebGLRenderer = true;

  		let _alpha;

  		if ( context !== null ) {

  			if ( typeof WebGLRenderingContext !== 'undefined' && context instanceof WebGLRenderingContext ) {

  				throw new Error( 'THREE.WebGLRenderer: WebGL 1 is not supported since r163.' );

  			}

  			_alpha = context.getContextAttributes().alpha;

  		} else {

  			_alpha = alpha;

  		}

  		const uintClearColor = new Uint32Array( 4 );
  		const intClearColor = new Int32Array( 4 );

  		let currentRenderList = null;
  		let currentRenderState = null;

  		// render() can be called from within a callback triggered by another render.
  		// We track this so that the nested render call gets its list and state isolated from the parent render call.

  		const renderListStack = [];
  		const renderStateStack = [];

  		// public properties

  		this.domElement = canvas;

  		// Debug configuration container
  		this.debug = {

  			/**
  			 * Enables error checking and reporting when shader programs are being compiled
  			 * @type {boolean}
  			 */
  			checkShaderErrors: true,
  			/**
  			 * Callback for custom error reporting.
  			 * @type {?Function}
  			 */
  			onShaderError: null
  		};

  		// clearing

  		this.autoClear = true;
  		this.autoClearColor = true;
  		this.autoClearDepth = true;
  		this.autoClearStencil = true;

  		// scene graph

  		this.sortObjects = true;

  		// user-defined clipping

  		this.clippingPlanes = [];
  		this.localClippingEnabled = false;

  		// physically based shading

  		this._outputColorSpace = SRGBColorSpace;

  		// tone mapping

  		this.toneMapping = NoToneMapping;
  		this.toneMappingExposure = 1.0;

  		// internal properties

  		const _this = this;

  		let _isContextLost = false;

  		// internal state cache

  		let _currentActiveCubeFace = 0;
  		let _currentActiveMipmapLevel = 0;
  		let _currentRenderTarget = null;
  		let _currentMaterialId = - 1;

  		let _currentCamera = null;

  		const _currentViewport = new Vector4();
  		const _currentScissor = new Vector4();
  		let _currentScissorTest = null;

  		const _currentClearColor = new Color( 0x000000 );
  		let _currentClearAlpha = 0;

  		//

  		let _width = canvas.width;
  		let _height = canvas.height;

  		let _pixelRatio = 1;
  		let _opaqueSort = null;
  		let _transparentSort = null;

  		const _viewport = new Vector4( 0, 0, _width, _height );
  		const _scissor = new Vector4( 0, 0, _width, _height );
  		let _scissorTest = false;

  		// frustum

  		const _frustum = new Frustum();

  		// clipping

  		let _clippingEnabled = false;
  		let _localClippingEnabled = false;

  		// camera matrices cache

  		const _projScreenMatrix = new Matrix4();

  		const _vector3 = new Vector3();

  		const _vector4 = new Vector4();

  		const _emptyScene = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };

  		let _renderBackground = false;

  		function getTargetPixelRatio() {

  			return _currentRenderTarget === null ? _pixelRatio : 1;

  		}

  		// initialize

  		let _gl = context;

  		function getContext( contextName, contextAttributes ) {

  			return canvas.getContext( contextName, contextAttributes );

  		}

  		try {

  			const contextAttributes = {
  				alpha: true,
  				depth,
  				stencil,
  				antialias,
  				premultipliedAlpha,
  				preserveDrawingBuffer,
  				powerPreference,
  				failIfMajorPerformanceCaveat,
  			};

  			// OffscreenCanvas does not have setAttribute, see #22811
  			if ( 'setAttribute' in canvas ) canvas.setAttribute( 'data-engine', `three.js r${REVISION}` );

  			// event listeners must be registered before WebGL context is created, see #12753
  			canvas.addEventListener( 'webglcontextlost', onContextLost, false );
  			canvas.addEventListener( 'webglcontextrestored', onContextRestore, false );
  			canvas.addEventListener( 'webglcontextcreationerror', onContextCreationError, false );

  			if ( _gl === null ) {

  				const contextName = 'webgl2';

  				_gl = getContext( contextName, contextAttributes );

  				if ( _gl === null ) {

  					if ( getContext( contextName ) ) {

  						throw new Error( 'Error creating WebGL context with your selected attributes.' );

  					} else {

  						throw new Error( 'Error creating WebGL context.' );

  					}

  				}

  			}

  		} catch ( error ) {

  			console.error( 'THREE.WebGLRenderer: ' + error.message );
  			throw error;

  		}

  		let extensions, capabilities, state, info;
  		let properties, textures, cubemaps, cubeuvmaps, attributes, geometries, objects;
  		let programCache, materials, renderLists, renderStates, clipping, shadowMap;

  		let background, morphtargets, bufferRenderer, indexedBufferRenderer;

  		let utils, bindingStates, uniformsGroups;

  		function initGLContext() {

  			extensions = new WebGLExtensions( _gl );
  			extensions.init();

  			utils = new WebGLUtils( _gl, extensions );

  			capabilities = new WebGLCapabilities( _gl, extensions, parameters, utils );

  			state = new WebGLState( _gl );

  			info = new WebGLInfo( _gl );
  			properties = new WebGLProperties();
  			textures = new WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info );
  			cubemaps = new WebGLCubeMaps( _this );
  			cubeuvmaps = new WebGLCubeUVMaps( _this );
  			attributes = new WebGLAttributes( _gl );
  			bindingStates = new WebGLBindingStates( _gl, attributes );
  			geometries = new WebGLGeometries( _gl, attributes, info, bindingStates );
  			objects = new WebGLObjects( _gl, geometries, attributes, info );
  			morphtargets = new WebGLMorphtargets( _gl, capabilities, textures );
  			clipping = new WebGLClipping( properties );
  			programCache = new WebGLPrograms( _this, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping );
  			materials = new WebGLMaterials( _this, properties );
  			renderLists = new WebGLRenderLists();
  			renderStates = new WebGLRenderStates( extensions );
  			background = new WebGLBackground( _this, cubemaps, cubeuvmaps, state, objects, _alpha, premultipliedAlpha );
  			shadowMap = new WebGLShadowMap( _this, objects, capabilities );
  			uniformsGroups = new WebGLUniformsGroups( _gl, info, capabilities, state );

  			bufferRenderer = new WebGLBufferRenderer( _gl, extensions, info );
  			indexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, info );

  			info.programs = programCache.programs;

  			_this.capabilities = capabilities;
  			_this.extensions = extensions;
  			_this.properties = properties;
  			_this.renderLists = renderLists;
  			_this.shadowMap = shadowMap;
  			_this.state = state;
  			_this.info = info;

  		}

  		initGLContext();

  		// xr

  		const xr = new WebXRManager( _this, _gl );

  		this.xr = xr;

  		// API

  		this.getContext = function () {

  			return _gl;

  		};

  		this.getContextAttributes = function () {

  			return _gl.getContextAttributes();

  		};

  		this.forceContextLoss = function () {

  			const extension = extensions.get( 'WEBGL_lose_context' );
  			if ( extension ) extension.loseContext();

  		};

  		this.forceContextRestore = function () {

  			const extension = extensions.get( 'WEBGL_lose_context' );
  			if ( extension ) extension.restoreContext();

  		};

  		this.getPixelRatio = function () {

  			return _pixelRatio;

  		};

  		this.setPixelRatio = function ( value ) {

  			if ( value === undefined ) return;

  			_pixelRatio = value;

  			this.setSize( _width, _height, false );

  		};

  		this.getSize = function ( target ) {

  			return target.set( _width, _height );

  		};

  		this.setSize = function ( width, height, updateStyle = true ) {

  			if ( xr.isPresenting ) {

  				console.warn( 'THREE.WebGLRenderer: Can\'t change size while VR device is presenting.' );
  				return;

  			}

  			_width = width;
  			_height = height;

  			canvas.width = Math.floor( width * _pixelRatio );
  			canvas.height = Math.floor( height * _pixelRatio );

  			if ( updateStyle === true ) {

  				canvas.style.width = width + 'px';
  				canvas.style.height = height + 'px';

  			}

  			this.setViewport( 0, 0, width, height );

  		};

  		this.getDrawingBufferSize = function ( target ) {

  			return target.set( _width * _pixelRatio, _height * _pixelRatio ).floor();

  		};

  		this.setDrawingBufferSize = function ( width, height, pixelRatio ) {

  			_width = width;
  			_height = height;

  			_pixelRatio = pixelRatio;

  			canvas.width = Math.floor( width * pixelRatio );
  			canvas.height = Math.floor( height * pixelRatio );

  			this.setViewport( 0, 0, width, height );

  		};

  		this.getCurrentViewport = function ( target ) {

  			return target.copy( _currentViewport );

  		};

  		this.getViewport = function ( target ) {

  			return target.copy( _viewport );

  		};

  		this.setViewport = function ( x, y, width, height ) {

  			if ( x.isVector4 ) {

  				_viewport.set( x.x, x.y, x.z, x.w );

  			} else {

  				_viewport.set( x, y, width, height );

  			}

  			state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).round() );

  		};

  		this.getScissor = function ( target ) {

  			return target.copy( _scissor );

  		};

  		this.setScissor = function ( x, y, width, height ) {

  			if ( x.isVector4 ) {

  				_scissor.set( x.x, x.y, x.z, x.w );

  			} else {

  				_scissor.set( x, y, width, height );

  			}

  			state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).round() );

  		};

  		this.getScissorTest = function () {

  			return _scissorTest;

  		};

  		this.setScissorTest = function ( boolean ) {

  			state.setScissorTest( _scissorTest = boolean );

  		};

  		this.setOpaqueSort = function ( method ) {

  			_opaqueSort = method;

  		};

  		this.setTransparentSort = function ( method ) {

  			_transparentSort = method;

  		};

  		// Clearing

  		this.getClearColor = function ( target ) {

  			return target.copy( background.getClearColor() );

  		};

  		this.setClearColor = function () {

  			background.setClearColor.apply( background, arguments );

  		};

  		this.getClearAlpha = function () {

  			return background.getClearAlpha();

  		};

  		this.setClearAlpha = function () {

  			background.setClearAlpha.apply( background, arguments );

  		};

  		this.clear = function ( color = true, depth = true, stencil = true ) {

  			let bits = 0;

  			if ( color ) {

  				// check if we're trying to clear an integer target
  				let isIntegerFormat = false;
  				if ( _currentRenderTarget !== null ) {

  					const targetFormat = _currentRenderTarget.texture.format;
  					isIntegerFormat = targetFormat === RGBAIntegerFormat ||
  						targetFormat === RGIntegerFormat ||
  						targetFormat === RedIntegerFormat;

  				}

  				// use the appropriate clear functions to clear the target if it's a signed
  				// or unsigned integer target
  				if ( isIntegerFormat ) {

  					const targetType = _currentRenderTarget.texture.type;
  					const isUnsignedType = targetType === UnsignedByteType ||
  						targetType === UnsignedIntType ||
  						targetType === UnsignedShortType ||
  						targetType === UnsignedInt248Type ||
  						targetType === UnsignedShort4444Type ||
  						targetType === UnsignedShort5551Type;

  					const clearColor = background.getClearColor();
  					const a = background.getClearAlpha();
  					const r = clearColor.r;
  					const g = clearColor.g;
  					const b = clearColor.b;

  					if ( isUnsignedType ) {

  						uintClearColor[ 0 ] = r;
  						uintClearColor[ 1 ] = g;
  						uintClearColor[ 2 ] = b;
  						uintClearColor[ 3 ] = a;
  						_gl.clearBufferuiv( _gl.COLOR, 0, uintClearColor );

  					} else {

  						intClearColor[ 0 ] = r;
  						intClearColor[ 1 ] = g;
  						intClearColor[ 2 ] = b;
  						intClearColor[ 3 ] = a;
  						_gl.clearBufferiv( _gl.COLOR, 0, intClearColor );

  					}

  				} else {

  					bits |= _gl.COLOR_BUFFER_BIT;

  				}

  			}

  			if ( depth ) bits |= _gl.DEPTH_BUFFER_BIT;
  			if ( stencil ) {

  				bits |= _gl.STENCIL_BUFFER_BIT;
  				this.state.buffers.stencil.setMask( 0xffffffff );

  			}

  			_gl.clear( bits );

  		};

  		this.clearColor = function () {

  			this.clear( true, false, false );

  		};

  		this.clearDepth = function () {

  			this.clear( false, true, false );

  		};

  		this.clearStencil = function () {

  			this.clear( false, false, true );

  		};

  		//

  		this.dispose = function () {

  			canvas.removeEventListener( 'webglcontextlost', onContextLost, false );
  			canvas.removeEventListener( 'webglcontextrestored', onContextRestore, false );
  			canvas.removeEventListener( 'webglcontextcreationerror', onContextCreationError, false );

  			renderLists.dispose();
  			renderStates.dispose();
  			properties.dispose();
  			cubemaps.dispose();
  			cubeuvmaps.dispose();
  			objects.dispose();
  			bindingStates.dispose();
  			uniformsGroups.dispose();
  			programCache.dispose();

  			xr.dispose();

  			xr.removeEventListener( 'sessionstart', onXRSessionStart );
  			xr.removeEventListener( 'sessionend', onXRSessionEnd );

  			animation.stop();

  		};

  		// Events

  		function onContextLost( event ) {

  			event.preventDefault();

  			console.log( 'THREE.WebGLRenderer: Context Lost.' );

  			_isContextLost = true;

  		}

  		function onContextRestore( /* event */ ) {

  			console.log( 'THREE.WebGLRenderer: Context Restored.' );

  			_isContextLost = false;

  			const infoAutoReset = info.autoReset;
  			const shadowMapEnabled = shadowMap.enabled;
  			const shadowMapAutoUpdate = shadowMap.autoUpdate;
  			const shadowMapNeedsUpdate = shadowMap.needsUpdate;
  			const shadowMapType = shadowMap.type;

  			initGLContext();

  			info.autoReset = infoAutoReset;
  			shadowMap.enabled = shadowMapEnabled;
  			shadowMap.autoUpdate = shadowMapAutoUpdate;
  			shadowMap.needsUpdate = shadowMapNeedsUpdate;
  			shadowMap.type = shadowMapType;

  		}

  		function onContextCreationError( event ) {

  			console.error( 'THREE.WebGLRenderer: A WebGL context could not be created. Reason: ', event.statusMessage );

  		}

  		function onMaterialDispose( event ) {

  			const material = event.target;

  			material.removeEventListener( 'dispose', onMaterialDispose );

  			deallocateMaterial( material );

  		}

  		// Buffer deallocation

  		function deallocateMaterial( material ) {

  			releaseMaterialProgramReferences( material );

  			properties.remove( material );

  		}


  		function releaseMaterialProgramReferences( material ) {

  			const programs = properties.get( material ).programs;

  			if ( programs !== undefined ) {

  				programs.forEach( function ( program ) {

  					programCache.releaseProgram( program );

  				} );

  				if ( material.isShaderMaterial ) {

  					programCache.releaseShaderCache( material );

  				}

  			}

  		}

  		// Buffer rendering

  		this.renderBufferDirect = function ( camera, scene, geometry, material, object, group ) {

  			if ( scene === null ) scene = _emptyScene; // renderBufferDirect second parameter used to be fog (could be null)

  			const frontFaceCW = ( object.isMesh && object.matrixWorld.determinant() < 0 );

  			const program = setProgram( camera, scene, geometry, material, object );

  			state.setMaterial( material, frontFaceCW );

  			//

  			let index = geometry.index;
  			let rangeFactor = 1;

  			if ( material.wireframe === true ) {

  				index = geometries.getWireframeAttribute( geometry );

  				if ( index === undefined ) return;

  				rangeFactor = 2;

  			}

  			//

  			const drawRange = geometry.drawRange;
  			const position = geometry.attributes.position;

  			let drawStart = drawRange.start * rangeFactor;
  			let drawEnd = ( drawRange.start + drawRange.count ) * rangeFactor;

  			if ( group !== null ) {

  				drawStart = Math.max( drawStart, group.start * rangeFactor );
  				drawEnd = Math.min( drawEnd, ( group.start + group.count ) * rangeFactor );

  			}

  			if ( index !== null ) {

  				drawStart = Math.max( drawStart, 0 );
  				drawEnd = Math.min( drawEnd, index.count );

  			} else if ( position !== undefined && position !== null ) {

  				drawStart = Math.max( drawStart, 0 );
  				drawEnd = Math.min( drawEnd, position.count );

  			}

  			const drawCount = drawEnd - drawStart;

  			if ( drawCount < 0 || drawCount === Infinity ) return;

  			//

  			bindingStates.setup( object, material, program, geometry, index );

  			let attribute;
  			let renderer = bufferRenderer;

  			if ( index !== null ) {

  				attribute = attributes.get( index );

  				renderer = indexedBufferRenderer;
  				renderer.setIndex( attribute );

  			}

  			//

  			if ( object.isMesh ) {

  				if ( material.wireframe === true ) {

  					state.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );
  					renderer.setMode( _gl.LINES );

  				} else {

  					renderer.setMode( _gl.TRIANGLES );

  				}

  			} else if ( object.isLine ) {

  				let lineWidth = material.linewidth;

  				if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material

  				state.setLineWidth( lineWidth * getTargetPixelRatio() );

  				if ( object.isLineSegments ) {

  					renderer.setMode( _gl.LINES );

  				} else if ( object.isLineLoop ) {

  					renderer.setMode( _gl.LINE_LOOP );

  				} else {

  					renderer.setMode( _gl.LINE_STRIP );

  				}

  			} else if ( object.isPoints ) {

  				renderer.setMode( _gl.POINTS );

  			} else if ( object.isSprite ) {

  				renderer.setMode( _gl.TRIANGLES );

  			}

  			if ( object.isBatchedMesh ) {

  				if ( object._multiDrawInstances !== null ) {

  					renderer.renderMultiDrawInstances( object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount, object._multiDrawInstances );

  				} else {

  					if ( ! extensions.get( 'WEBGL_multi_draw' ) ) {

  						const starts = object._multiDrawStarts;
  						const counts = object._multiDrawCounts;
  						const drawCount = object._multiDrawCount;
  						const bytesPerElement = index ? attributes.get( index ).bytesPerElement : 1;
  						const uniforms = properties.get( material ).currentProgram.getUniforms();
  						for ( let i = 0; i < drawCount; i ++ ) {

  							uniforms.setValue( _gl, '_gl_DrawID', i );
  							renderer.render( starts[ i ] / bytesPerElement, counts[ i ] );

  						}

  					} else {

  						renderer.renderMultiDraw( object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount );

  					}

  				}

  			} else if ( object.isInstancedMesh ) {

  				renderer.renderInstances( drawStart, drawCount, object.count );

  			} else if ( geometry.isInstancedBufferGeometry ) {

  				const maxInstanceCount = geometry._maxInstanceCount !== undefined ? geometry._maxInstanceCount : Infinity;
  				const instanceCount = Math.min( geometry.instanceCount, maxInstanceCount );

  				renderer.renderInstances( drawStart, drawCount, instanceCount );

  			} else {

  				renderer.render( drawStart, drawCount );

  			}

  		};

  		// Compile

  		function prepareMaterial( material, scene, object ) {

  			if ( material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false ) {

  				material.side = BackSide;
  				material.needsUpdate = true;
  				getProgram( material, scene, object );

  				material.side = FrontSide;
  				material.needsUpdate = true;
  				getProgram( material, scene, object );

  				material.side = DoubleSide;

  			} else {

  				getProgram( material, scene, object );

  			}

  		}

  		this.compile = function ( scene, camera, targetScene = null ) {

  			if ( targetScene === null ) targetScene = scene;

  			currentRenderState = renderStates.get( targetScene );
  			currentRenderState.init( camera );

  			renderStateStack.push( currentRenderState );

  			// gather lights from both the target scene and the new object that will be added to the scene.

  			targetScene.traverseVisible( function ( object ) {

  				if ( object.isLight && object.layers.test( camera.layers ) ) {

  					currentRenderState.pushLight( object );

  					if ( object.castShadow ) {

  						currentRenderState.pushShadow( object );

  					}

  				}

  			} );

  			if ( scene !== targetScene ) {

  				scene.traverseVisible( function ( object ) {

  					if ( object.isLight && object.layers.test( camera.layers ) ) {

  						currentRenderState.pushLight( object );

  						if ( object.castShadow ) {

  							currentRenderState.pushShadow( object );

  						}

  					}

  				} );

  			}

  			currentRenderState.setupLights();

  			// Only initialize materials in the new scene, not the targetScene.

  			const materials = new Set();

  			scene.traverse( function ( object ) {

  				const material = object.material;

  				if ( material ) {

  					if ( Array.isArray( material ) ) {

  						for ( let i = 0; i < material.length; i ++ ) {

  							const material2 = material[ i ];

  							prepareMaterial( material2, targetScene, object );
  							materials.add( material2 );

  						}

  					} else {

  						prepareMaterial( material, targetScene, object );
  						materials.add( material );

  					}

  				}

  			} );

  			renderStateStack.pop();
  			currentRenderState = null;

  			return materials;

  		};

  		// compileAsync

  		this.compileAsync = function ( scene, camera, targetScene = null ) {

  			const materials = this.compile( scene, camera, targetScene );

  			// Wait for all the materials in the new object to indicate that they're
  			// ready to be used before resolving the promise.

  			return new Promise( ( resolve ) => {

  				function checkMaterialsReady() {

  					materials.forEach( function ( material ) {

  						const materialProperties = properties.get( material );
  						const program = materialProperties.currentProgram;

  						if ( program.isReady() ) {

  							// remove any programs that report they're ready to use from the list
  							materials.delete( material );

  						}

  					} );

  					// once the list of compiling materials is empty, call the callback

  					if ( materials.size === 0 ) {

  						resolve( scene );
  						return;

  					}

  					// if some materials are still not ready, wait a bit and check again

  					setTimeout( checkMaterialsReady, 10 );

  				}

  				if ( extensions.get( 'KHR_parallel_shader_compile' ) !== null ) {

  					// If we can check the compilation status of the materials without
  					// blocking then do so right away.

  					checkMaterialsReady();

  				} else {

  					// Otherwise start by waiting a bit to give the materials we just
  					// initialized a chance to finish.

  					setTimeout( checkMaterialsReady, 10 );

  				}

  			} );

  		};

  		// Animation Loop

  		let onAnimationFrameCallback = null;

  		function onAnimationFrame( time ) {

  			if ( onAnimationFrameCallback ) onAnimationFrameCallback( time );

  		}

  		function onXRSessionStart() {

  			animation.stop();

  		}

  		function onXRSessionEnd() {

  			animation.start();

  		}

  		const animation = new WebGLAnimation();
  		animation.setAnimationLoop( onAnimationFrame );

  		if ( typeof self !== 'undefined' ) animation.setContext( self );

  		this.setAnimationLoop = function ( callback ) {

  			onAnimationFrameCallback = callback;
  			xr.setAnimationLoop( callback );

  			( callback === null ) ? animation.stop() : animation.start();

  		};

  		xr.addEventListener( 'sessionstart', onXRSessionStart );
  		xr.addEventListener( 'sessionend', onXRSessionEnd );

  		// Rendering

  		this.render = function ( scene, camera ) {

  			if ( camera !== undefined && camera.isCamera !== true ) {

  				console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
  				return;

  			}

  			if ( _isContextLost === true ) return;

  			// update scene graph

  			if ( scene.matrixWorldAutoUpdate === true ) scene.updateMatrixWorld();

  			// update camera matrices and frustum

  			if ( camera.parent === null && camera.matrixWorldAutoUpdate === true ) camera.updateMatrixWorld();

  			if ( xr.enabled === true && xr.isPresenting === true ) {

  				if ( xr.cameraAutoUpdate === true ) xr.updateCamera( camera );

  				camera = xr.getCamera(); // use XR camera for rendering

  			}

  			//
  			if ( scene.isScene === true ) scene.onBeforeRender( _this, scene, camera, _currentRenderTarget );

  			currentRenderState = renderStates.get( scene, renderStateStack.length );
  			currentRenderState.init( camera );

  			renderStateStack.push( currentRenderState );

  			_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
  			_frustum.setFromProjectionMatrix( _projScreenMatrix );

  			_localClippingEnabled = this.localClippingEnabled;
  			_clippingEnabled = clipping.init( this.clippingPlanes, _localClippingEnabled );

  			currentRenderList = renderLists.get( scene, renderListStack.length );
  			currentRenderList.init();

  			renderListStack.push( currentRenderList );

  			if ( xr.enabled === true && xr.isPresenting === true ) {

  				const depthSensingMesh = _this.xr.getDepthSensingMesh();

  				if ( depthSensingMesh !== null ) {

  					projectObject( depthSensingMesh, camera, - Infinity, _this.sortObjects );

  				}

  			}

  			projectObject( scene, camera, 0, _this.sortObjects );

  			currentRenderList.finish();

  			if ( _this.sortObjects === true ) {

  				currentRenderList.sort( _opaqueSort, _transparentSort );

  			}

  			_renderBackground = xr.enabled === false || xr.isPresenting === false || xr.hasDepthSensing() === false;
  			if ( _renderBackground ) {

  				background.addToRenderList( currentRenderList, scene );

  			}

  			//

  			this.info.render.frame ++;

  			if ( _clippingEnabled === true ) clipping.beginShadows();

  			const shadowsArray = currentRenderState.state.shadowsArray;

  			shadowMap.render( shadowsArray, scene, camera );

  			if ( _clippingEnabled === true ) clipping.endShadows();

  			//

  			if ( this.info.autoReset === true ) this.info.reset();

  			// render scene

  			const opaqueObjects = currentRenderList.opaque;
  			const transmissiveObjects = currentRenderList.transmissive;

  			currentRenderState.setupLights();

  			if ( camera.isArrayCamera ) {

  				const cameras = camera.cameras;

  				if ( transmissiveObjects.length > 0 ) {

  					for ( let i = 0, l = cameras.length; i < l; i ++ ) {

  						const camera2 = cameras[ i ];

  						renderTransmissionPass( opaqueObjects, transmissiveObjects, scene, camera2 );

  					}

  				}

  				if ( _renderBackground ) background.render( scene );

  				for ( let i = 0, l = cameras.length; i < l; i ++ ) {

  					const camera2 = cameras[ i ];

  					renderScene( currentRenderList, scene, camera2, camera2.viewport );

  				}

  			} else {

  				if ( transmissiveObjects.length > 0 ) renderTransmissionPass( opaqueObjects, transmissiveObjects, scene, camera );

  				if ( _renderBackground ) background.render( scene );

  				renderScene( currentRenderList, scene, camera );

  			}

  			//

  			if ( _currentRenderTarget !== null ) {

  				// resolve multisample renderbuffers to a single-sample texture if necessary

  				textures.updateMultisampleRenderTarget( _currentRenderTarget );

  				// Generate mipmap if we're using any kind of mipmap filtering

  				textures.updateRenderTargetMipmap( _currentRenderTarget );

  			}

  			//

  			if ( scene.isScene === true ) scene.onAfterRender( _this, scene, camera );

  			// _gl.finish();

  			bindingStates.resetDefaultState();
  			_currentMaterialId = - 1;
  			_currentCamera = null;

  			renderStateStack.pop();

  			if ( renderStateStack.length > 0 ) {

  				currentRenderState = renderStateStack[ renderStateStack.length - 1 ];

  				if ( _clippingEnabled === true ) clipping.setGlobalState( _this.clippingPlanes, currentRenderState.state.camera );

  			} else {

  				currentRenderState = null;

  			}

  			renderListStack.pop();

  			if ( renderListStack.length > 0 ) {

  				currentRenderList = renderListStack[ renderListStack.length - 1 ];

  			} else {

  				currentRenderList = null;

  			}

  		};

  		function projectObject( object, camera, groupOrder, sortObjects ) {

  			if ( object.visible === false ) return;

  			const visible = object.layers.test( camera.layers );

  			if ( visible ) {

  				if ( object.isGroup ) {

  					groupOrder = object.renderOrder;

  				} else if ( object.isLOD ) {

  					if ( object.autoUpdate === true ) object.update( camera );

  				} else if ( object.isLight ) {

  					currentRenderState.pushLight( object );

  					if ( object.castShadow ) {

  						currentRenderState.pushShadow( object );

  					}

  				} else if ( object.isSprite ) {

  					if ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) {

  						if ( sortObjects ) {

  							_vector4.setFromMatrixPosition( object.matrixWorld )
  								.applyMatrix4( _projScreenMatrix );

  						}

  						const geometry = objects.update( object );
  						const material = object.material;

  						if ( material.visible ) {

  							currentRenderList.push( object, geometry, material, groupOrder, _vector4.z, null );

  						}

  					}

  				} else if ( object.isMesh || object.isLine || object.isPoints ) {

  					if ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) {

  						const geometry = objects.update( object );
  						const material = object.material;

  						if ( sortObjects ) {

  							if ( object.boundingSphere !== undefined ) {

  								if ( object.boundingSphere === null ) object.computeBoundingSphere();
  								_vector4.copy( object.boundingSphere.center );

  							} else {

  								if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();
  								_vector4.copy( geometry.boundingSphere.center );

  							}

  							_vector4
  								.applyMatrix4( object.matrixWorld )
  								.applyMatrix4( _projScreenMatrix );

  						}

  						if ( Array.isArray( material ) ) {

  							const groups = geometry.groups;

  							for ( let i = 0, l = groups.length; i < l; i ++ ) {

  								const group = groups[ i ];
  								const groupMaterial = material[ group.materialIndex ];

  								if ( groupMaterial && groupMaterial.visible ) {

  									currentRenderList.push( object, geometry, groupMaterial, groupOrder, _vector4.z, group );

  								}

  							}

  						} else if ( material.visible ) {

  							currentRenderList.push( object, geometry, material, groupOrder, _vector4.z, null );

  						}

  					}

  				}

  			}

  			const children = object.children;

  			for ( let i = 0, l = children.length; i < l; i ++ ) {

  				projectObject( children[ i ], camera, groupOrder, sortObjects );

  			}

  		}

  		function renderScene( currentRenderList, scene, camera, viewport ) {

  			const opaqueObjects = currentRenderList.opaque;
  			const transmissiveObjects = currentRenderList.transmissive;
  			const transparentObjects = currentRenderList.transparent;

  			currentRenderState.setupLightsView( camera );

  			if ( _clippingEnabled === true ) clipping.setGlobalState( _this.clippingPlanes, camera );

  			if ( viewport ) state.viewport( _currentViewport.copy( viewport ) );

  			if ( opaqueObjects.length > 0 ) renderObjects( opaqueObjects, scene, camera );
  			if ( transmissiveObjects.length > 0 ) renderObjects( transmissiveObjects, scene, camera );
  			if ( transparentObjects.length > 0 ) renderObjects( transparentObjects, scene, camera );

  			// Ensure depth buffer writing is enabled so it can be cleared on next render

  			state.buffers.depth.setTest( true );
  			state.buffers.depth.setMask( true );
  			state.buffers.color.setMask( true );

  			state.setPolygonOffset( false );

  		}

  		function renderTransmissionPass( opaqueObjects, transmissiveObjects, scene, camera ) {

  			const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;

  			if ( overrideMaterial !== null ) {

  				return;

  			}

  			if ( currentRenderState.state.transmissionRenderTarget[ camera.id ] === undefined ) {

  				currentRenderState.state.transmissionRenderTarget[ camera.id ] = new WebGLRenderTarget( 1, 1, {
  					generateMipmaps: true,
  					type: ( extensions.has( 'EXT_color_buffer_half_float' ) || extensions.has( 'EXT_color_buffer_float' ) ) ? HalfFloatType : UnsignedByteType,
  					minFilter: LinearMipmapLinearFilter,
  					samples: 4,
  					stencilBuffer: stencil,
  					resolveDepthBuffer: false,
  					resolveStencilBuffer: false,
  					colorSpace: ColorManagement.workingColorSpace,
  				} );

  				// debug

  				/*
  				const geometry = new PlaneGeometry();
  				const material = new MeshBasicMaterial( { map: _transmissionRenderTarget.texture } );

  				const mesh = new Mesh( geometry, material );
  				scene.add( mesh );
  				*/

  			}

  			const transmissionRenderTarget = currentRenderState.state.transmissionRenderTarget[ camera.id ];

  			const activeViewport = camera.viewport || _currentViewport;
  			transmissionRenderTarget.setSize( activeViewport.z, activeViewport.w );

  			//

  			const currentRenderTarget = _this.getRenderTarget();
  			_this.setRenderTarget( transmissionRenderTarget );

  			_this.getClearColor( _currentClearColor );
  			_currentClearAlpha = _this.getClearAlpha();
  			if ( _currentClearAlpha < 1 ) _this.setClearColor( 0xffffff, 0.5 );

  			_this.clear();

  			if ( _renderBackground ) background.render( scene );

  			// Turn off the features which can affect the frag color for opaque objects pass.
  			// Otherwise they are applied twice in opaque objects pass and transmission objects pass.
  			const currentToneMapping = _this.toneMapping;
  			_this.toneMapping = NoToneMapping;

  			// Remove viewport from camera to avoid nested render calls resetting viewport to it (e.g Reflector).
  			// Transmission render pass requires viewport to match the transmissionRenderTarget.
  			const currentCameraViewport = camera.viewport;
  			if ( camera.viewport !== undefined ) camera.viewport = undefined;

  			currentRenderState.setupLightsView( camera );

  			if ( _clippingEnabled === true ) clipping.setGlobalState( _this.clippingPlanes, camera );

  			renderObjects( opaqueObjects, scene, camera );

  			textures.updateMultisampleRenderTarget( transmissionRenderTarget );
  			textures.updateRenderTargetMipmap( transmissionRenderTarget );

  			if ( extensions.has( 'WEBGL_multisampled_render_to_texture' ) === false ) { // see #28131

  				let renderTargetNeedsUpdate = false;

  				for ( let i = 0, l = transmissiveObjects.length; i < l; i ++ ) {

  					const renderItem = transmissiveObjects[ i ];

  					const object = renderItem.object;
  					const geometry = renderItem.geometry;
  					const material = renderItem.material;
  					const group = renderItem.group;

  					if ( material.side === DoubleSide && object.layers.test( camera.layers ) ) {

  						const currentSide = material.side;

  						material.side = BackSide;
  						material.needsUpdate = true;

  						renderObject( object, scene, camera, geometry, material, group );

  						material.side = currentSide;
  						material.needsUpdate = true;

  						renderTargetNeedsUpdate = true;

  					}

  				}

  				if ( renderTargetNeedsUpdate === true ) {

  					textures.updateMultisampleRenderTarget( transmissionRenderTarget );
  					textures.updateRenderTargetMipmap( transmissionRenderTarget );

  				}

  			}

  			_this.setRenderTarget( currentRenderTarget );

  			_this.setClearColor( _currentClearColor, _currentClearAlpha );

  			if ( currentCameraViewport !== undefined ) camera.viewport = currentCameraViewport;

  			_this.toneMapping = currentToneMapping;

  		}

  		function renderObjects( renderList, scene, camera ) {

  			const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;

  			for ( let i = 0, l = renderList.length; i < l; i ++ ) {

  				const renderItem = renderList[ i ];

  				const object = renderItem.object;
  				const geometry = renderItem.geometry;
  				const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
  				const group = renderItem.group;

  				if ( object.layers.test( camera.layers ) ) {

  					renderObject( object, scene, camera, geometry, material, group );

  				}

  			}

  		}

  		function renderObject( object, scene, camera, geometry, material, group ) {

  			object.onBeforeRender( _this, scene, camera, geometry, material, group );

  			object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
  			object.normalMatrix.getNormalMatrix( object.modelViewMatrix );

  			if ( material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false ) {

  				material.side = BackSide;
  				material.needsUpdate = true;
  				_this.renderBufferDirect( camera, scene, geometry, material, object, group );

  				material.side = FrontSide;
  				material.needsUpdate = true;
  				_this.renderBufferDirect( camera, scene, geometry, material, object, group );

  				material.side = DoubleSide;

  			} else {

  				_this.renderBufferDirect( camera, scene, geometry, material, object, group );

  			}

  			object.onAfterRender( _this, scene, camera, geometry, material, group );

  		}

  		function getProgram( material, scene, object ) {

  			if ( scene.isScene !== true ) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

  			const materialProperties = properties.get( material );

  			const lights = currentRenderState.state.lights;
  			const shadowsArray = currentRenderState.state.shadowsArray;

  			const lightsStateVersion = lights.state.version;

  			const parameters = programCache.getParameters( material, lights.state, shadowsArray, scene, object );
  			const programCacheKey = programCache.getProgramCacheKey( parameters );

  			let programs = materialProperties.programs;

  			// always update environment and fog - changing these trigger an getProgram call, but it's possible that the program doesn't change

  			materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
  			materialProperties.fog = scene.fog;
  			materialProperties.envMap = ( material.isMeshStandardMaterial ? cubeuvmaps : cubemaps ).get( material.envMap || materialProperties.environment );
  			materialProperties.envMapRotation = ( materialProperties.environment !== null && material.envMap === null ) ? scene.environmentRotation : material.envMapRotation;

  			if ( programs === undefined ) {

  				// new material

  				material.addEventListener( 'dispose', onMaterialDispose );

  				programs = new Map();
  				materialProperties.programs = programs;

  			}

  			let program = programs.get( programCacheKey );

  			if ( program !== undefined ) {

  				// early out if program and light state is identical

  				if ( materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion ) {

  					updateCommonMaterialProperties( material, parameters );

  					return program;

  				}

  			} else {

  				parameters.uniforms = programCache.getUniforms( material );

  				material.onBeforeCompile( parameters, _this );

  				program = programCache.acquireProgram( parameters, programCacheKey );
  				programs.set( programCacheKey, program );

  				materialProperties.uniforms = parameters.uniforms;

  			}

  			const uniforms = materialProperties.uniforms;

  			if ( ( ! material.isShaderMaterial && ! material.isRawShaderMaterial ) || material.clipping === true ) {

  				uniforms.clippingPlanes = clipping.uniform;

  			}

  			updateCommonMaterialProperties( material, parameters );

  			// store the light setup it was created for

  			materialProperties.needsLights = materialNeedsLights( material );
  			materialProperties.lightsStateVersion = lightsStateVersion;

  			if ( materialProperties.needsLights ) {

  				// wire up the material to this renderer's lighting state

  				uniforms.ambientLightColor.value = lights.state.ambient;
  				uniforms.lightProbe.value = lights.state.probe;
  				uniforms.directionalLights.value = lights.state.directional;
  				uniforms.directionalLightShadows.value = lights.state.directionalShadow;
  				uniforms.spotLights.value = lights.state.spot;
  				uniforms.spotLightShadows.value = lights.state.spotShadow;
  				uniforms.rectAreaLights.value = lights.state.rectArea;
  				uniforms.ltc_1.value = lights.state.rectAreaLTC1;
  				uniforms.ltc_2.value = lights.state.rectAreaLTC2;
  				uniforms.pointLights.value = lights.state.point;
  				uniforms.pointLightShadows.value = lights.state.pointShadow;
  				uniforms.hemisphereLights.value = lights.state.hemi;

  				uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
  				uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
  				uniforms.spotShadowMap.value = lights.state.spotShadowMap;
  				uniforms.spotLightMatrix.value = lights.state.spotLightMatrix;
  				uniforms.spotLightMap.value = lights.state.spotLightMap;
  				uniforms.pointShadowMap.value = lights.state.pointShadowMap;
  				uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
  				// TODO (abelnation): add area lights shadow info to uniforms

  			}

  			materialProperties.currentProgram = program;
  			materialProperties.uniformsList = null;

  			return program;

  		}

  		function getUniformList( materialProperties ) {

  			if ( materialProperties.uniformsList === null ) {

  				const progUniforms = materialProperties.currentProgram.getUniforms();
  				materialProperties.uniformsList = WebGLUniforms.seqWithValue( progUniforms.seq, materialProperties.uniforms );

  			}

  			return materialProperties.uniformsList;

  		}

  		function updateCommonMaterialProperties( material, parameters ) {

  			const materialProperties = properties.get( material );

  			materialProperties.outputColorSpace = parameters.outputColorSpace;
  			materialProperties.batching = parameters.batching;
  			materialProperties.batchingColor = parameters.batchingColor;
  			materialProperties.instancing = parameters.instancing;
  			materialProperties.instancingColor = parameters.instancingColor;
  			materialProperties.instancingMorph = parameters.instancingMorph;
  			materialProperties.skinning = parameters.skinning;
  			materialProperties.morphTargets = parameters.morphTargets;
  			materialProperties.morphNormals = parameters.morphNormals;
  			materialProperties.morphColors = parameters.morphColors;
  			materialProperties.morphTargetsCount = parameters.morphTargetsCount;
  			materialProperties.numClippingPlanes = parameters.numClippingPlanes;
  			materialProperties.numIntersection = parameters.numClipIntersection;
  			materialProperties.vertexAlphas = parameters.vertexAlphas;
  			materialProperties.vertexTangents = parameters.vertexTangents;
  			materialProperties.toneMapping = parameters.toneMapping;

  		}

  		function setProgram( camera, scene, geometry, material, object ) {

  			if ( scene.isScene !== true ) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

  			textures.resetTextureUnits();

  			const fog = scene.fog;
  			const environment = material.isMeshStandardMaterial ? scene.environment : null;
  			const colorSpace = ( _currentRenderTarget === null ) ? _this.outputColorSpace : ( _currentRenderTarget.isXRRenderTarget === true ? _currentRenderTarget.texture.colorSpace : LinearSRGBColorSpace );
  			const envMap = ( material.isMeshStandardMaterial ? cubeuvmaps : cubemaps ).get( material.envMap || environment );
  			const vertexAlphas = material.vertexColors === true && !! geometry.attributes.color && geometry.attributes.color.itemSize === 4;
  			const vertexTangents = !! geometry.attributes.tangent && ( !! material.normalMap || material.anisotropy > 0 );
  			const morphTargets = !! geometry.morphAttributes.position;
  			const morphNormals = !! geometry.morphAttributes.normal;
  			const morphColors = !! geometry.morphAttributes.color;

  			let toneMapping = NoToneMapping;

  			if ( material.toneMapped ) {

  				if ( _currentRenderTarget === null || _currentRenderTarget.isXRRenderTarget === true ) {

  					toneMapping = _this.toneMapping;

  				}

  			}

  			const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
  			const morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;

  			const materialProperties = properties.get( material );
  			const lights = currentRenderState.state.lights;

  			if ( _clippingEnabled === true ) {

  				if ( _localClippingEnabled === true || camera !== _currentCamera ) {

  					const useCache =
  						camera === _currentCamera &&
  						material.id === _currentMaterialId;

  					// we might want to call this function with some ClippingGroup
  					// object instead of the material, once it becomes feasible
  					// (#8465, #8379)
  					clipping.setState( material, camera, useCache );

  				}

  			}

  			//

  			let needsProgramChange = false;

  			if ( material.version === materialProperties.__version ) {

  				if ( materialProperties.needsLights && ( materialProperties.lightsStateVersion !== lights.state.version ) ) {

  					needsProgramChange = true;

  				} else if ( materialProperties.outputColorSpace !== colorSpace ) {

  					needsProgramChange = true;

  				} else if ( object.isBatchedMesh && materialProperties.batching === false ) {

  					needsProgramChange = true;

  				} else if ( ! object.isBatchedMesh && materialProperties.batching === true ) {

  					needsProgramChange = true;

  				} else if ( object.isBatchedMesh && materialProperties.batchingColor === true && object.colorTexture === null ) {

  					needsProgramChange = true;

  				} else if ( object.isBatchedMesh && materialProperties.batchingColor === false && object.colorTexture !== null ) {

  					needsProgramChange = true;

  				} else if ( object.isInstancedMesh && materialProperties.instancing === false ) {

  					needsProgramChange = true;

  				} else if ( ! object.isInstancedMesh && materialProperties.instancing === true ) {

  					needsProgramChange = true;

  				} else if ( object.isSkinnedMesh && materialProperties.skinning === false ) {

  					needsProgramChange = true;

  				} else if ( ! object.isSkinnedMesh && materialProperties.skinning === true ) {

  					needsProgramChange = true;

  				} else if ( object.isInstancedMesh && materialProperties.instancingColor === true && object.instanceColor === null ) {

  					needsProgramChange = true;

  				} else if ( object.isInstancedMesh && materialProperties.instancingColor === false && object.instanceColor !== null ) {

  					needsProgramChange = true;

  				} else if ( object.isInstancedMesh && materialProperties.instancingMorph === true && object.morphTexture === null ) {

  					needsProgramChange = true;

  				} else if ( object.isInstancedMesh && materialProperties.instancingMorph === false && object.morphTexture !== null ) {

  					needsProgramChange = true;

  				} else if ( materialProperties.envMap !== envMap ) {

  					needsProgramChange = true;

  				} else if ( material.fog === true && materialProperties.fog !== fog ) {

  					needsProgramChange = true;

  				} else if ( materialProperties.numClippingPlanes !== undefined &&
  					( materialProperties.numClippingPlanes !== clipping.numPlanes ||
  					materialProperties.numIntersection !== clipping.numIntersection ) ) {

  					needsProgramChange = true;

  				} else if ( materialProperties.vertexAlphas !== vertexAlphas ) {

  					needsProgramChange = true;

  				} else if ( materialProperties.vertexTangents !== vertexTangents ) {

  					needsProgramChange = true;

  				} else if ( materialProperties.morphTargets !== morphTargets ) {

  					needsProgramChange = true;

  				} else if ( materialProperties.morphNormals !== morphNormals ) {

  					needsProgramChange = true;

  				} else if ( materialProperties.morphColors !== morphColors ) {

  					needsProgramChange = true;

  				} else if ( materialProperties.toneMapping !== toneMapping ) {

  					needsProgramChange = true;

  				} else if ( materialProperties.morphTargetsCount !== morphTargetsCount ) {

  					needsProgramChange = true;

  				}

  			} else {

  				needsProgramChange = true;
  				materialProperties.__version = material.version;

  			}

  			//

  			let program = materialProperties.currentProgram;

  			if ( needsProgramChange === true ) {

  				program = getProgram( material, scene, object );

  			}

  			let refreshProgram = false;
  			let refreshMaterial = false;
  			let refreshLights = false;

  			const p_uniforms = program.getUniforms(),
  				m_uniforms = materialProperties.uniforms;

  			if ( state.useProgram( program.program ) ) {

  				refreshProgram = true;
  				refreshMaterial = true;
  				refreshLights = true;

  			}

  			if ( material.id !== _currentMaterialId ) {

  				_currentMaterialId = material.id;

  				refreshMaterial = true;

  			}

  			if ( refreshProgram || _currentCamera !== camera ) {

  				// common camera uniforms

  				p_uniforms.setValue( _gl, 'projectionMatrix', camera.projectionMatrix );
  				p_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );

  				const uCamPos = p_uniforms.map.cameraPosition;

  				if ( uCamPos !== undefined ) {

  					uCamPos.setValue( _gl, _vector3.setFromMatrixPosition( camera.matrixWorld ) );

  				}

  				if ( capabilities.logarithmicDepthBuffer ) {

  					p_uniforms.setValue( _gl, 'logDepthBufFC',
  						2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

  				}

  				// consider moving isOrthographic to UniformLib and WebGLMaterials, see https://github.com/mrdoob/three.js/pull/26467#issuecomment-1645185067

  				if ( material.isMeshPhongMaterial ||
  					material.isMeshToonMaterial ||
  					material.isMeshLambertMaterial ||
  					material.isMeshBasicMaterial ||
  					material.isMeshStandardMaterial ||
  					material.isShaderMaterial ) {

  					p_uniforms.setValue( _gl, 'isOrthographic', camera.isOrthographicCamera === true );

  				}

  				if ( _currentCamera !== camera ) {

  					_currentCamera = camera;

  					// lighting uniforms depend on the camera so enforce an update
  					// now, in case this material supports lights - or later, when
  					// the next material that does gets activated:

  					refreshMaterial = true;		// set to true on material change
  					refreshLights = true;		// remains set until update done

  				}

  			}

  			// skinning and morph target uniforms must be set even if material didn't change
  			// auto-setting of texture unit for bone and morph texture must go before other textures
  			// otherwise textures used for skinning and morphing can take over texture units reserved for other material textures

  			if ( object.isSkinnedMesh ) {

  				p_uniforms.setOptional( _gl, object, 'bindMatrix' );
  				p_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );

  				const skeleton = object.skeleton;

  				if ( skeleton ) {

  					if ( skeleton.boneTexture === null ) skeleton.computeBoneTexture();

  					p_uniforms.setValue( _gl, 'boneTexture', skeleton.boneTexture, textures );

  				}

  			}

  			if ( object.isBatchedMesh ) {

  				p_uniforms.setOptional( _gl, object, 'batchingTexture' );
  				p_uniforms.setValue( _gl, 'batchingTexture', object._matricesTexture, textures );

  				p_uniforms.setOptional( _gl, object, 'batchingIdTexture' );
  				p_uniforms.setValue( _gl, 'batchingIdTexture', object._indirectTexture, textures );

  				p_uniforms.setOptional( _gl, object, 'batchingColorTexture' );
  				if ( object._colorsTexture !== null ) {

  					p_uniforms.setValue( _gl, 'batchingColorTexture', object._colorsTexture, textures );

  				}

  			}

  			const morphAttributes = geometry.morphAttributes;

  			if ( morphAttributes.position !== undefined || morphAttributes.normal !== undefined || ( morphAttributes.color !== undefined ) ) {

  				morphtargets.update( object, geometry, program );

  			}

  			if ( refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow ) {

  				materialProperties.receiveShadow = object.receiveShadow;
  				p_uniforms.setValue( _gl, 'receiveShadow', object.receiveShadow );

  			}

  			// https://github.com/mrdoob/three.js/pull/24467#issuecomment-1209031512

  			if ( material.isMeshGouraudMaterial && material.envMap !== null ) {

  				m_uniforms.envMap.value = envMap;

  				m_uniforms.flipEnvMap.value = ( envMap.isCubeTexture && envMap.isRenderTargetTexture === false ) ? - 1 : 1;

  			}

  			if ( material.isMeshStandardMaterial && material.envMap === null && scene.environment !== null ) {

  				m_uniforms.envMapIntensity.value = scene.environmentIntensity;

  			}

  			if ( refreshMaterial ) {

  				p_uniforms.setValue( _gl, 'toneMappingExposure', _this.toneMappingExposure );

  				if ( materialProperties.needsLights ) {

  					// the current material requires lighting info

  					// note: all lighting uniforms are always set correctly
  					// they simply reference the renderer's state for their
  					// values
  					//
  					// use the current material's .needsUpdate flags to set
  					// the GL state when required

  					markUniformsLightsNeedsUpdate( m_uniforms, refreshLights );

  				}

  				// refresh uniforms common to several materials

  				if ( fog && material.fog === true ) {

  					materials.refreshFogUniforms( m_uniforms, fog );

  				}

  				materials.refreshMaterialUniforms( m_uniforms, material, _pixelRatio, _height, currentRenderState.state.transmissionRenderTarget[ camera.id ] );

  				WebGLUniforms.upload( _gl, getUniformList( materialProperties ), m_uniforms, textures );

  			}

  			if ( material.isShaderMaterial && material.uniformsNeedUpdate === true ) {

  				WebGLUniforms.upload( _gl, getUniformList( materialProperties ), m_uniforms, textures );
  				material.uniformsNeedUpdate = false;

  			}

  			if ( material.isSpriteMaterial ) {

  				p_uniforms.setValue( _gl, 'center', object.center );

  			}

  			// common matrices

  			p_uniforms.setValue( _gl, 'modelViewMatrix', object.modelViewMatrix );
  			p_uniforms.setValue( _gl, 'normalMatrix', object.normalMatrix );
  			p_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );

  			// UBOs

  			if ( material.isShaderMaterial || material.isRawShaderMaterial ) {

  				const groups = material.uniformsGroups;

  				for ( let i = 0, l = groups.length; i < l; i ++ ) {

  					const group = groups[ i ];

  					uniformsGroups.update( group, program );
  					uniformsGroups.bind( group, program );

  				}

  			}

  			return program;

  		}

  		// If uniforms are marked as clean, they don't need to be loaded to the GPU.

  		function markUniformsLightsNeedsUpdate( uniforms, value ) {

  			uniforms.ambientLightColor.needsUpdate = value;
  			uniforms.lightProbe.needsUpdate = value;

  			uniforms.directionalLights.needsUpdate = value;
  			uniforms.directionalLightShadows.needsUpdate = value;
  			uniforms.pointLights.needsUpdate = value;
  			uniforms.pointLightShadows.needsUpdate = value;
  			uniforms.spotLights.needsUpdate = value;
  			uniforms.spotLightShadows.needsUpdate = value;
  			uniforms.rectAreaLights.needsUpdate = value;
  			uniforms.hemisphereLights.needsUpdate = value;

  		}

  		function materialNeedsLights( material ) {

  			return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial ||
  				material.isMeshStandardMaterial || material.isShadowMaterial ||
  				( material.isShaderMaterial && material.lights === true );

  		}

  		this.getActiveCubeFace = function () {

  			return _currentActiveCubeFace;

  		};

  		this.getActiveMipmapLevel = function () {

  			return _currentActiveMipmapLevel;

  		};

  		this.getRenderTarget = function () {

  			return _currentRenderTarget;

  		};

  		this.setRenderTargetTextures = function ( renderTarget, colorTexture, depthTexture ) {

  			properties.get( renderTarget.texture ).__webglTexture = colorTexture;
  			properties.get( renderTarget.depthTexture ).__webglTexture = depthTexture;

  			const renderTargetProperties = properties.get( renderTarget );
  			renderTargetProperties.__hasExternalTextures = true;

  			renderTargetProperties.__autoAllocateDepthBuffer = depthTexture === undefined;

  			if ( ! renderTargetProperties.__autoAllocateDepthBuffer ) {

  				// The multisample_render_to_texture extension doesn't work properly if there
  				// are midframe flushes and an external depth buffer. Disable use of the extension.
  				if ( extensions.has( 'WEBGL_multisampled_render_to_texture' ) === true ) {

  					console.warn( 'THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided' );
  					renderTargetProperties.__useRenderToTexture = false;

  				}

  			}

  		};

  		this.setRenderTargetFramebuffer = function ( renderTarget, defaultFramebuffer ) {

  			const renderTargetProperties = properties.get( renderTarget );
  			renderTargetProperties.__webglFramebuffer = defaultFramebuffer;
  			renderTargetProperties.__useDefaultFramebuffer = defaultFramebuffer === undefined;

  		};

  		this.setRenderTarget = function ( renderTarget, activeCubeFace = 0, activeMipmapLevel = 0 ) {

  			_currentRenderTarget = renderTarget;
  			_currentActiveCubeFace = activeCubeFace;
  			_currentActiveMipmapLevel = activeMipmapLevel;

  			let useDefaultFramebuffer = true;
  			let framebuffer = null;
  			let isCube = false;
  			let isRenderTarget3D = false;

  			if ( renderTarget ) {

  				const renderTargetProperties = properties.get( renderTarget );

  				if ( renderTargetProperties.__useDefaultFramebuffer !== undefined ) {

  					// We need to make sure to rebind the framebuffer.
  					state.bindFramebuffer( _gl.FRAMEBUFFER, null );
  					useDefaultFramebuffer = false;

  				} else if ( renderTargetProperties.__webglFramebuffer === undefined ) {

  					textures.setupRenderTarget( renderTarget );

  				} else if ( renderTargetProperties.__hasExternalTextures ) {

  					// Color and depth texture must be rebound in order for the swapchain to update.
  					textures.rebindTextures( renderTarget, properties.get( renderTarget.texture ).__webglTexture, properties.get( renderTarget.depthTexture ).__webglTexture );

  				}

  				const texture = renderTarget.texture;

  				if ( texture.isData3DTexture || texture.isDataArrayTexture || texture.isCompressedArrayTexture ) {

  					isRenderTarget3D = true;

  				}

  				const __webglFramebuffer = properties.get( renderTarget ).__webglFramebuffer;

  				if ( renderTarget.isWebGLCubeRenderTarget ) {

  					if ( Array.isArray( __webglFramebuffer[ activeCubeFace ] ) ) {

  						framebuffer = __webglFramebuffer[ activeCubeFace ][ activeMipmapLevel ];

  					} else {

  						framebuffer = __webglFramebuffer[ activeCubeFace ];

  					}

  					isCube = true;

  				} else if ( ( renderTarget.samples > 0 ) && textures.useMultisampledRTT( renderTarget ) === false ) {

  					framebuffer = properties.get( renderTarget ).__webglMultisampledFramebuffer;

  				} else {

  					if ( Array.isArray( __webglFramebuffer ) ) {

  						framebuffer = __webglFramebuffer[ activeMipmapLevel ];

  					} else {

  						framebuffer = __webglFramebuffer;

  					}

  				}

  				_currentViewport.copy( renderTarget.viewport );
  				_currentScissor.copy( renderTarget.scissor );
  				_currentScissorTest = renderTarget.scissorTest;

  			} else {

  				_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor();
  				_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor();
  				_currentScissorTest = _scissorTest;

  			}

  			const framebufferBound = state.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

  			if ( framebufferBound && useDefaultFramebuffer ) {

  				state.drawBuffers( renderTarget, framebuffer );

  			}

  			state.viewport( _currentViewport );
  			state.scissor( _currentScissor );
  			state.setScissorTest( _currentScissorTest );

  			if ( isCube ) {

  				const textureProperties = properties.get( renderTarget.texture );
  				_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel );

  			} else if ( isRenderTarget3D ) {

  				const textureProperties = properties.get( renderTarget.texture );
  				const layer = activeCubeFace || 0;
  				_gl.framebufferTextureLayer( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureProperties.__webglTexture, activeMipmapLevel || 0, layer );

  			}

  			_currentMaterialId = - 1; // reset current material to ensure correct uniform bindings

  		};

  		this.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer, activeCubeFaceIndex ) {

  			if ( ! ( renderTarget && renderTarget.isWebGLRenderTarget ) ) {

  				console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
  				return;

  			}

  			let framebuffer = properties.get( renderTarget ).__webglFramebuffer;

  			if ( renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined ) {

  				framebuffer = framebuffer[ activeCubeFaceIndex ];

  			}

  			if ( framebuffer ) {

  				state.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

  				try {

  					const texture = renderTarget.texture;
  					const textureFormat = texture.format;
  					const textureType = texture.type;

  					if ( ! capabilities.textureFormatReadable( textureFormat ) ) {

  						console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );
  						return;

  					}

  					if ( ! capabilities.textureTypeReadable( textureType ) ) {

  						console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );
  						return;

  					}

  					// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)

  					if ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {

  						_gl.readPixels( x, y, width, height, utils.convert( textureFormat ), utils.convert( textureType ), buffer );

  					}

  				} finally {

  					// restore framebuffer of current render target if necessary

  					const framebuffer = ( _currentRenderTarget !== null ) ? properties.get( _currentRenderTarget ).__webglFramebuffer : null;
  					state.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

  				}

  			}

  		};

  		this.readRenderTargetPixelsAsync = async function ( renderTarget, x, y, width, height, buffer, activeCubeFaceIndex ) {

  			if ( ! ( renderTarget && renderTarget.isWebGLRenderTarget ) ) {

  				throw new Error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );

  			}

  			let framebuffer = properties.get( renderTarget ).__webglFramebuffer;
  			if ( renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined ) {

  				framebuffer = framebuffer[ activeCubeFaceIndex ];

  			}

  			if ( framebuffer ) {

  				state.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

  				try {

  					const texture = renderTarget.texture;
  					const textureFormat = texture.format;
  					const textureType = texture.type;

  					if ( ! capabilities.textureFormatReadable( textureFormat ) ) {

  						throw new Error( 'THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.' );

  					}

  					if ( ! capabilities.textureTypeReadable( textureType ) ) {

  						throw new Error( 'THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.' );

  					}

  					// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)
  					if ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {

  						const glBuffer = _gl.createBuffer();
  						_gl.bindBuffer( _gl.PIXEL_PACK_BUFFER, glBuffer );
  						_gl.bufferData( _gl.PIXEL_PACK_BUFFER, buffer.byteLength, _gl.STREAM_READ );
  						_gl.readPixels( x, y, width, height, utils.convert( textureFormat ), utils.convert( textureType ), 0 );
  						_gl.flush();

  						// check if the commands have finished every 8 ms
  						const sync = _gl.fenceSync( _gl.SYNC_GPU_COMMANDS_COMPLETE, 0 );
  						await probeAsync( _gl, sync, 4 );

  						try {

  							_gl.bindBuffer( _gl.PIXEL_PACK_BUFFER, glBuffer );
  							_gl.getBufferSubData( _gl.PIXEL_PACK_BUFFER, 0, buffer );

  						} finally {

  							_gl.deleteBuffer( glBuffer );
  							_gl.deleteSync( sync );

  						}

  						return buffer;

  					}

  				} finally {

  					// restore framebuffer of current render target if necessary

  					const framebuffer = ( _currentRenderTarget !== null ) ? properties.get( _currentRenderTarget ).__webglFramebuffer : null;
  					state.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

  				}

  			}

  		};

  		this.copyFramebufferToTexture = function ( texture, position = null, level = 0 ) {

  			// support previous signature with position first
  			if ( texture.isTexture !== true ) {

  				// @deprecated, r165
  				warnOnce( 'WebGLRenderer: copyFramebufferToTexture function signature has changed.' );

  				position = arguments[ 0 ] || null;
  				texture = arguments[ 1 ];

  			}

  			const levelScale = Math.pow( 2, - level );
  			const width = Math.floor( texture.image.width * levelScale );
  			const height = Math.floor( texture.image.height * levelScale );

  			const x = position !== null ? position.x : 0;
  			const y = position !== null ? position.y : 0;

  			textures.setTexture2D( texture, 0 );

  			_gl.copyTexSubImage2D( _gl.TEXTURE_2D, level, 0, 0, x, y, width, height );

  			state.unbindTexture();

  		};

  		this.copyTextureToTexture = function ( srcTexture, dstTexture, srcRegion = null, dstPosition = null, level = 0 ) {

  			// support previous signature with dstPosition first
  			if ( srcTexture.isTexture !== true ) {

  				// @deprecated, r165
  				warnOnce( 'WebGLRenderer: copyTextureToTexture function signature has changed.' );

  				dstPosition = arguments[ 0 ] || null;
  				srcTexture = arguments[ 1 ];
  				dstTexture = arguments[ 2 ];
  				level = arguments[ 3 ] || 0;
  				srcRegion = null;

  			}

  			let width, height, minX, minY;
  			let dstX, dstY;
  			if ( srcRegion !== null ) {

  				width = srcRegion.max.x - srcRegion.min.x;
  				height = srcRegion.max.y - srcRegion.min.y;
  				minX = srcRegion.min.x;
  				minY = srcRegion.min.y;

  			} else {

  				width = srcTexture.image.width;
  				height = srcTexture.image.height;
  				minX = 0;
  				minY = 0;

  			}

  			if ( dstPosition !== null ) {

  				dstX = dstPosition.x;
  				dstY = dstPosition.y;

  			} else {

  				dstX = 0;
  				dstY = 0;

  			}

  			const glFormat = utils.convert( dstTexture.format );
  			const glType = utils.convert( dstTexture.type );

  			textures.setTexture2D( dstTexture, 0 );

  			// As another texture upload may have changed pixelStorei
  			// parameters, make sure they are correct for the dstTexture
  			_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY );
  			_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha );
  			_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment );

  			const currentUnpackRowLen = _gl.getParameter( _gl.UNPACK_ROW_LENGTH );
  			const currentUnpackImageHeight = _gl.getParameter( _gl.UNPACK_IMAGE_HEIGHT );
  			const currentUnpackSkipPixels = _gl.getParameter( _gl.UNPACK_SKIP_PIXELS );
  			const currentUnpackSkipRows = _gl.getParameter( _gl.UNPACK_SKIP_ROWS );
  			const currentUnpackSkipImages = _gl.getParameter( _gl.UNPACK_SKIP_IMAGES );

  			const image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[ level ] : srcTexture.image;

  			_gl.pixelStorei( _gl.UNPACK_ROW_LENGTH, image.width );
  			_gl.pixelStorei( _gl.UNPACK_IMAGE_HEIGHT, image.height );
  			_gl.pixelStorei( _gl.UNPACK_SKIP_PIXELS, minX );
  			_gl.pixelStorei( _gl.UNPACK_SKIP_ROWS, minY );

  			if ( srcTexture.isDataTexture ) {

  				_gl.texSubImage2D( _gl.TEXTURE_2D, level, dstX, dstY, width, height, glFormat, glType, image.data );

  			} else {

  				if ( srcTexture.isCompressedTexture ) {

  					_gl.compressedTexSubImage2D( _gl.TEXTURE_2D, level, dstX, dstY, image.width, image.height, glFormat, image.data );

  				} else {

  					_gl.texSubImage2D( _gl.TEXTURE_2D, level, dstX, dstY, width, height, glFormat, glType, image );

  				}

  			}

  			_gl.pixelStorei( _gl.UNPACK_ROW_LENGTH, currentUnpackRowLen );
  			_gl.pixelStorei( _gl.UNPACK_IMAGE_HEIGHT, currentUnpackImageHeight );
  			_gl.pixelStorei( _gl.UNPACK_SKIP_PIXELS, currentUnpackSkipPixels );
  			_gl.pixelStorei( _gl.UNPACK_SKIP_ROWS, currentUnpackSkipRows );
  			_gl.pixelStorei( _gl.UNPACK_SKIP_IMAGES, currentUnpackSkipImages );

  			// Generate mipmaps only when copying level 0
  			if ( level === 0 && dstTexture.generateMipmaps ) _gl.generateMipmap( _gl.TEXTURE_2D );

  			state.unbindTexture();

  		};

  		this.copyTextureToTexture3D = function ( srcTexture, dstTexture, srcRegion = null, dstPosition = null, level = 0 ) {

  			// support previous signature with source box first
  			if ( srcTexture.isTexture !== true ) {

  				// @deprecated, r165
  				warnOnce( 'WebGLRenderer: copyTextureToTexture3D function signature has changed.' );

  				srcRegion = arguments[ 0 ] || null;
  				dstPosition = arguments[ 1 ] || null;
  				srcTexture = arguments[ 2 ];
  				dstTexture = arguments[ 3 ];
  				level = arguments[ 4 ] || 0;

  			}

  			let width, height, depth, minX, minY, minZ;
  			let dstX, dstY, dstZ;
  			const image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[ level ] : srcTexture.image;
  			if ( srcRegion !== null ) {

  				width = srcRegion.max.x - srcRegion.min.x;
  				height = srcRegion.max.y - srcRegion.min.y;
  				depth = srcRegion.max.z - srcRegion.min.z;
  				minX = srcRegion.min.x;
  				minY = srcRegion.min.y;
  				minZ = srcRegion.min.z;

  			} else {

  				width = image.width;
  				height = image.height;
  				depth = image.depth;
  				minX = 0;
  				minY = 0;
  				minZ = 0;

  			}

  			if ( dstPosition !== null ) {

  				dstX = dstPosition.x;
  				dstY = dstPosition.y;
  				dstZ = dstPosition.z;

  			} else {

  				dstX = 0;
  				dstY = 0;
  				dstZ = 0;

  			}

  			const glFormat = utils.convert( dstTexture.format );
  			const glType = utils.convert( dstTexture.type );
  			let glTarget;

  			if ( dstTexture.isData3DTexture ) {

  				textures.setTexture3D( dstTexture, 0 );
  				glTarget = _gl.TEXTURE_3D;

  			} else if ( dstTexture.isDataArrayTexture || dstTexture.isCompressedArrayTexture ) {

  				textures.setTexture2DArray( dstTexture, 0 );
  				glTarget = _gl.TEXTURE_2D_ARRAY;

  			} else {

  				console.warn( 'THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.' );
  				return;

  			}

  			_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY );
  			_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha );
  			_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment );

  			const currentUnpackRowLen = _gl.getParameter( _gl.UNPACK_ROW_LENGTH );
  			const currentUnpackImageHeight = _gl.getParameter( _gl.UNPACK_IMAGE_HEIGHT );
  			const currentUnpackSkipPixels = _gl.getParameter( _gl.UNPACK_SKIP_PIXELS );
  			const currentUnpackSkipRows = _gl.getParameter( _gl.UNPACK_SKIP_ROWS );
  			const currentUnpackSkipImages = _gl.getParameter( _gl.UNPACK_SKIP_IMAGES );

  			_gl.pixelStorei( _gl.UNPACK_ROW_LENGTH, image.width );
  			_gl.pixelStorei( _gl.UNPACK_IMAGE_HEIGHT, image.height );
  			_gl.pixelStorei( _gl.UNPACK_SKIP_PIXELS, minX );
  			_gl.pixelStorei( _gl.UNPACK_SKIP_ROWS, minY );
  			_gl.pixelStorei( _gl.UNPACK_SKIP_IMAGES, minZ );

  			if ( srcTexture.isDataTexture || srcTexture.isData3DTexture ) {

  				_gl.texSubImage3D( glTarget, level, dstX, dstY, dstZ, width, height, depth, glFormat, glType, image.data );

  			} else {

  				if ( dstTexture.isCompressedArrayTexture ) {

  					_gl.compressedTexSubImage3D( glTarget, level, dstX, dstY, dstZ, width, height, depth, glFormat, image.data );

  				} else {

  					_gl.texSubImage3D( glTarget, level, dstX, dstY, dstZ, width, height, depth, glFormat, glType, image );

  				}

  			}

  			_gl.pixelStorei( _gl.UNPACK_ROW_LENGTH, currentUnpackRowLen );
  			_gl.pixelStorei( _gl.UNPACK_IMAGE_HEIGHT, currentUnpackImageHeight );
  			_gl.pixelStorei( _gl.UNPACK_SKIP_PIXELS, currentUnpackSkipPixels );
  			_gl.pixelStorei( _gl.UNPACK_SKIP_ROWS, currentUnpackSkipRows );
  			_gl.pixelStorei( _gl.UNPACK_SKIP_IMAGES, currentUnpackSkipImages );

  			// Generate mipmaps only when copying level 0
  			if ( level === 0 && dstTexture.generateMipmaps ) _gl.generateMipmap( glTarget );

  			state.unbindTexture();

  		};

  		this.initRenderTarget = function ( target ) {

  			if ( properties.get( target ).__webglFramebuffer === undefined ) {

  				textures.setupRenderTarget( target );

  			}

  		};

  		this.initTexture = function ( texture ) {

  			if ( texture.isCubeTexture ) {

  				textures.setTextureCube( texture, 0 );

  			} else if ( texture.isData3DTexture ) {

  				textures.setTexture3D( texture, 0 );

  			} else if ( texture.isDataArrayTexture || texture.isCompressedArrayTexture ) {

  				textures.setTexture2DArray( texture, 0 );

  			} else {

  				textures.setTexture2D( texture, 0 );

  			}

  			state.unbindTexture();

  		};

  		this.resetState = function () {

  			_currentActiveCubeFace = 0;
  			_currentActiveMipmapLevel = 0;
  			_currentRenderTarget = null;

  			state.reset();
  			bindingStates.reset();

  		};

  		if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

  			__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) );

  		}

  	}

  	get coordinateSystem() {

  		return WebGLCoordinateSystem;

  	}

  	get outputColorSpace() {

  		return this._outputColorSpace;

  	}

  	set outputColorSpace( colorSpace ) {

  		this._outputColorSpace = colorSpace;

  		const gl = this.getContext();
  		gl.drawingBufferColorSpace = colorSpace === DisplayP3ColorSpace ? 'display-p3' : 'srgb';
  		gl.unpackColorSpace = ColorManagement.workingColorSpace === LinearDisplayP3ColorSpace ? 'display-p3' : 'srgb';

  	}

  }

  class Scene extends Object3D {

  	constructor() {

  		super();

  		this.isScene = true;

  		this.type = 'Scene';

  		this.background = null;
  		this.environment = null;
  		this.fog = null;

  		this.backgroundBlurriness = 0;
  		this.backgroundIntensity = 1;
  		this.backgroundRotation = new Euler();

  		this.environmentIntensity = 1;
  		this.environmentRotation = new Euler();

  		this.overrideMaterial = null;

  		if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

  			__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) );

  		}

  	}

  	copy( source, recursive ) {

  		super.copy( source, recursive );

  		if ( source.background !== null ) this.background = source.background.clone();
  		if ( source.environment !== null ) this.environment = source.environment.clone();
  		if ( source.fog !== null ) this.fog = source.fog.clone();

  		this.backgroundBlurriness = source.backgroundBlurriness;
  		this.backgroundIntensity = source.backgroundIntensity;
  		this.backgroundRotation.copy( source.backgroundRotation );

  		this.environmentIntensity = source.environmentIntensity;
  		this.environmentRotation.copy( source.environmentRotation );

  		if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();

  		this.matrixAutoUpdate = source.matrixAutoUpdate;

  		return this;

  	}

  	toJSON( meta ) {

  		const data = super.toJSON( meta );

  		if ( this.fog !== null ) data.object.fog = this.fog.toJSON();

  		if ( this.backgroundBlurriness > 0 ) data.object.backgroundBlurriness = this.backgroundBlurriness;
  		if ( this.backgroundIntensity !== 1 ) data.object.backgroundIntensity = this.backgroundIntensity;
  		data.object.backgroundRotation = this.backgroundRotation.toArray();

  		if ( this.environmentIntensity !== 1 ) data.object.environmentIntensity = this.environmentIntensity;
  		data.object.environmentRotation = this.environmentRotation.toArray();

  		return data;

  	}

  }

  class InterleavedBuffer {

  	constructor( array, stride ) {

  		this.isInterleavedBuffer = true;

  		this.array = array;
  		this.stride = stride;
  		this.count = array !== undefined ? array.length / stride : 0;

  		this.usage = StaticDrawUsage;
  		this._updateRange = { offset: 0, count: - 1 };
  		this.updateRanges = [];

  		this.version = 0;

  		this.uuid = generateUUID();

  	}

  	onUploadCallback() {}

  	set needsUpdate( value ) {

  		if ( value === true ) this.version ++;

  	}

  	get updateRange() {

  		warnOnce( 'THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead.' ); // @deprecated, r159
  		return this._updateRange;

  	}

  	setUsage( value ) {

  		this.usage = value;

  		return this;

  	}

  	addUpdateRange( start, count ) {

  		this.updateRanges.push( { start, count } );

  	}

  	clearUpdateRanges() {

  		this.updateRanges.length = 0;

  	}

  	copy( source ) {

  		this.array = new source.array.constructor( source.array );
  		this.count = source.count;
  		this.stride = source.stride;
  		this.usage = source.usage;

  		return this;

  	}

  	copyAt( index1, attribute, index2 ) {

  		index1 *= this.stride;
  		index2 *= attribute.stride;

  		for ( let i = 0, l = this.stride; i < l; i ++ ) {

  			this.array[ index1 + i ] = attribute.array[ index2 + i ];

  		}

  		return this;

  	}

  	set( value, offset = 0 ) {

  		this.array.set( value, offset );

  		return this;

  	}

  	clone( data ) {

  		if ( data.arrayBuffers === undefined ) {

  			data.arrayBuffers = {};

  		}

  		if ( this.array.buffer._uuid === undefined ) {

  			this.array.buffer._uuid = generateUUID();

  		}

  		if ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {

  			data.arrayBuffers[ this.array.buffer._uuid ] = this.array.slice( 0 ).buffer;

  		}

  		const array = new this.array.constructor( data.arrayBuffers[ this.array.buffer._uuid ] );

  		const ib = new this.constructor( array, this.stride );
  		ib.setUsage( this.usage );

  		return ib;

  	}

  	onUpload( callback ) {

  		this.onUploadCallback = callback;

  		return this;

  	}

  	toJSON( data ) {

  		if ( data.arrayBuffers === undefined ) {

  			data.arrayBuffers = {};

  		}

  		// generate UUID for array buffer if necessary

  		if ( this.array.buffer._uuid === undefined ) {

  			this.array.buffer._uuid = generateUUID();

  		}

  		if ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {

  			data.arrayBuffers[ this.array.buffer._uuid ] = Array.from( new Uint32Array( this.array.buffer ) );

  		}

  		//

  		return {
  			uuid: this.uuid,
  			buffer: this.array.buffer._uuid,
  			type: this.array.constructor.name,
  			stride: this.stride
  		};

  	}

  }

  const _vector$6 = /*@__PURE__*/ new Vector3();

  class InterleavedBufferAttribute {

  	constructor( interleavedBuffer, itemSize, offset, normalized = false ) {

  		this.isInterleavedBufferAttribute = true;

  		this.name = '';

  		this.data = interleavedBuffer;
  		this.itemSize = itemSize;
  		this.offset = offset;

  		this.normalized = normalized;

  	}

  	get count() {

  		return this.data.count;

  	}

  	get array() {

  		return this.data.array;

  	}

  	set needsUpdate( value ) {

  		this.data.needsUpdate = value;

  	}

  	applyMatrix4( m ) {

  		for ( let i = 0, l = this.data.count; i < l; i ++ ) {

  			_vector$6.fromBufferAttribute( this, i );

  			_vector$6.applyMatrix4( m );

  			this.setXYZ( i, _vector$6.x, _vector$6.y, _vector$6.z );

  		}

  		return this;

  	}

  	applyNormalMatrix( m ) {

  		for ( let i = 0, l = this.count; i < l; i ++ ) {

  			_vector$6.fromBufferAttribute( this, i );

  			_vector$6.applyNormalMatrix( m );

  			this.setXYZ( i, _vector$6.x, _vector$6.y, _vector$6.z );

  		}

  		return this;

  	}

  	transformDirection( m ) {

  		for ( let i = 0, l = this.count; i < l; i ++ ) {

  			_vector$6.fromBufferAttribute( this, i );

  			_vector$6.transformDirection( m );

  			this.setXYZ( i, _vector$6.x, _vector$6.y, _vector$6.z );

  		}

  		return this;

  	}

  	getComponent( index, component ) {

  		let value = this.array[ index * this.data.stride + this.offset + component ];

  		if ( this.normalized ) value = denormalize( value, this.array );

  		return value;

  	}

  	setComponent( index, component, value ) {

  		if ( this.normalized ) value = normalize( value, this.array );

  		this.data.array[ index * this.data.stride + this.offset + component ] = value;

  		return this;

  	}

  	setX( index, x ) {

  		if ( this.normalized ) x = normalize( x, this.array );

  		this.data.array[ index * this.data.stride + this.offset ] = x;

  		return this;

  	}

  	setY( index, y ) {

  		if ( this.normalized ) y = normalize( y, this.array );

  		this.data.array[ index * this.data.stride + this.offset + 1 ] = y;

  		return this;

  	}

  	setZ( index, z ) {

  		if ( this.normalized ) z = normalize( z, this.array );

  		this.data.array[ index * this.data.stride + this.offset + 2 ] = z;

  		return this;

  	}

  	setW( index, w ) {

  		if ( this.normalized ) w = normalize( w, this.array );

  		this.data.array[ index * this.data.stride + this.offset + 3 ] = w;

  		return this;

  	}

  	getX( index ) {

  		let x = this.data.array[ index * this.data.stride + this.offset ];

  		if ( this.normalized ) x = denormalize( x, this.array );

  		return x;

  	}

  	getY( index ) {

  		let y = this.data.array[ index * this.data.stride + this.offset + 1 ];

  		if ( this.normalized ) y = denormalize( y, this.array );

  		return y;

  	}

  	getZ( index ) {

  		let z = this.data.array[ index * this.data.stride + this.offset + 2 ];

  		if ( this.normalized ) z = denormalize( z, this.array );

  		return z;

  	}

  	getW( index ) {

  		let w = this.data.array[ index * this.data.stride + this.offset + 3 ];

  		if ( this.normalized ) w = denormalize( w, this.array );

  		return w;

  	}

  	setXY( index, x, y ) {

  		index = index * this.data.stride + this.offset;

  		if ( this.normalized ) {

  			x = normalize( x, this.array );
  			y = normalize( y, this.array );

  		}

  		this.data.array[ index + 0 ] = x;
  		this.data.array[ index + 1 ] = y;

  		return this;

  	}

  	setXYZ( index, x, y, z ) {

  		index = index * this.data.stride + this.offset;

  		if ( this.normalized ) {

  			x = normalize( x, this.array );
  			y = normalize( y, this.array );
  			z = normalize( z, this.array );

  		}

  		this.data.array[ index + 0 ] = x;
  		this.data.array[ index + 1 ] = y;
  		this.data.array[ index + 2 ] = z;

  		return this;

  	}

  	setXYZW( index, x, y, z, w ) {

  		index = index * this.data.stride + this.offset;

  		if ( this.normalized ) {

  			x = normalize( x, this.array );
  			y = normalize( y, this.array );
  			z = normalize( z, this.array );
  			w = normalize( w, this.array );

  		}

  		this.data.array[ index + 0 ] = x;
  		this.data.array[ index + 1 ] = y;
  		this.data.array[ index + 2 ] = z;
  		this.data.array[ index + 3 ] = w;

  		return this;

  	}

  	clone( data ) {

  		if ( data === undefined ) {

  			console.log( 'THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.' );

  			const array = [];

  			for ( let i = 0; i < this.count; i ++ ) {

  				const index = i * this.data.stride + this.offset;

  				for ( let j = 0; j < this.itemSize; j ++ ) {

  					array.push( this.data.array[ index + j ] );

  				}

  			}

  			return new BufferAttribute( new this.array.constructor( array ), this.itemSize, this.normalized );

  		} else {

  			if ( data.interleavedBuffers === undefined ) {

  				data.interleavedBuffers = {};

  			}

  			if ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {

  				data.interleavedBuffers[ this.data.uuid ] = this.data.clone( data );

  			}

  			return new InterleavedBufferAttribute( data.interleavedBuffers[ this.data.uuid ], this.itemSize, this.offset, this.normalized );

  		}

  	}

  	toJSON( data ) {

  		if ( data === undefined ) {

  			console.log( 'THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.' );

  			const array = [];

  			for ( let i = 0; i < this.count; i ++ ) {

  				const index = i * this.data.stride + this.offset;

  				for ( let j = 0; j < this.itemSize; j ++ ) {

  					array.push( this.data.array[ index + j ] );

  				}

  			}

  			// de-interleave data and save it as an ordinary buffer attribute for now

  			return {
  				itemSize: this.itemSize,
  				type: this.array.constructor.name,
  				array: array,
  				normalized: this.normalized
  			};

  		} else {

  			// save as true interleaved attribute

  			if ( data.interleavedBuffers === undefined ) {

  				data.interleavedBuffers = {};

  			}

  			if ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {

  				data.interleavedBuffers[ this.data.uuid ] = this.data.toJSON( data );

  			}

  			return {
  				isInterleavedBufferAttribute: true,
  				itemSize: this.itemSize,
  				data: this.data.uuid,
  				offset: this.offset,
  				normalized: this.normalized
  			};

  		}

  	}

  }

  const _basePosition = /*@__PURE__*/ new Vector3();

  const _skinIndex = /*@__PURE__*/ new Vector4();
  const _skinWeight = /*@__PURE__*/ new Vector4();

  const _vector3 = /*@__PURE__*/ new Vector3();
  const _matrix4 = /*@__PURE__*/ new Matrix4();
  const _vertex = /*@__PURE__*/ new Vector3();

  const _sphere$4 = /*@__PURE__*/ new Sphere();
  const _inverseMatrix$2 = /*@__PURE__*/ new Matrix4();
  const _ray$2 = /*@__PURE__*/ new Ray();

  class SkinnedMesh extends Mesh {

  	constructor( geometry, material ) {

  		super( geometry, material );

  		this.isSkinnedMesh = true;

  		this.type = 'SkinnedMesh';

  		this.bindMode = AttachedBindMode;
  		this.bindMatrix = new Matrix4();
  		this.bindMatrixInverse = new Matrix4();

  		this.boundingBox = null;
  		this.boundingSphere = null;

  	}

  	computeBoundingBox() {

  		const geometry = this.geometry;

  		if ( this.boundingBox === null ) {

  			this.boundingBox = new Box3();

  		}

  		this.boundingBox.makeEmpty();

  		const positionAttribute = geometry.getAttribute( 'position' );

  		for ( let i = 0; i < positionAttribute.count; i ++ ) {

  			this.getVertexPosition( i, _vertex );
  			this.boundingBox.expandByPoint( _vertex );

  		}

  	}

  	computeBoundingSphere() {

  		const geometry = this.geometry;

  		if ( this.boundingSphere === null ) {

  			this.boundingSphere = new Sphere();

  		}

  		this.boundingSphere.makeEmpty();

  		const positionAttribute = geometry.getAttribute( 'position' );

  		for ( let i = 0; i < positionAttribute.count; i ++ ) {

  			this.getVertexPosition( i, _vertex );
  			this.boundingSphere.expandByPoint( _vertex );

  		}

  	}

  	copy( source, recursive ) {

  		super.copy( source, recursive );

  		this.bindMode = source.bindMode;
  		this.bindMatrix.copy( source.bindMatrix );
  		this.bindMatrixInverse.copy( source.bindMatrixInverse );

  		this.skeleton = source.skeleton;

  		if ( source.boundingBox !== null ) this.boundingBox = source.boundingBox.clone();
  		if ( source.boundingSphere !== null ) this.boundingSphere = source.boundingSphere.clone();

  		return this;

  	}

  	raycast( raycaster, intersects ) {

  		const material = this.material;
  		const matrixWorld = this.matrixWorld;

  		if ( material === undefined ) return;

  		// test with bounding sphere in world space

  		if ( this.boundingSphere === null ) this.computeBoundingSphere();

  		_sphere$4.copy( this.boundingSphere );
  		_sphere$4.applyMatrix4( matrixWorld );

  		if ( raycaster.ray.intersectsSphere( _sphere$4 ) === false ) return;

  		// convert ray to local space of skinned mesh

  		_inverseMatrix$2.copy( matrixWorld ).invert();
  		_ray$2.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$2 );

  		// test with bounding box in local space

  		if ( this.boundingBox !== null ) {

  			if ( _ray$2.intersectsBox( this.boundingBox ) === false ) return;

  		}

  		// test for intersections with geometry

  		this._computeIntersections( raycaster, intersects, _ray$2 );

  	}

  	getVertexPosition( index, target ) {

  		super.getVertexPosition( index, target );

  		this.applyBoneTransform( index, target );

  		return target;

  	}

  	bind( skeleton, bindMatrix ) {

  		this.skeleton = skeleton;

  		if ( bindMatrix === undefined ) {

  			this.updateMatrixWorld( true );

  			this.skeleton.calculateInverses();

  			bindMatrix = this.matrixWorld;

  		}

  		this.bindMatrix.copy( bindMatrix );
  		this.bindMatrixInverse.copy( bindMatrix ).invert();

  	}

  	pose() {

  		this.skeleton.pose();

  	}

  	normalizeSkinWeights() {

  		const vector = new Vector4();

  		const skinWeight = this.geometry.attributes.skinWeight;

  		for ( let i = 0, l = skinWeight.count; i < l; i ++ ) {

  			vector.fromBufferAttribute( skinWeight, i );

  			const scale = 1.0 / vector.manhattanLength();

  			if ( scale !== Infinity ) {

  				vector.multiplyScalar( scale );

  			} else {

  				vector.set( 1, 0, 0, 0 ); // do something reasonable

  			}

  			skinWeight.setXYZW( i, vector.x, vector.y, vector.z, vector.w );

  		}

  	}

  	updateMatrixWorld( force ) {

  		super.updateMatrixWorld( force );

  		if ( this.bindMode === AttachedBindMode ) {

  			this.bindMatrixInverse.copy( this.matrixWorld ).invert();

  		} else if ( this.bindMode === DetachedBindMode ) {

  			this.bindMatrixInverse.copy( this.bindMatrix ).invert();

  		} else {

  			console.warn( 'THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode );

  		}

  	}

  	applyBoneTransform( index, vector ) {

  		const skeleton = this.skeleton;
  		const geometry = this.geometry;

  		_skinIndex.fromBufferAttribute( geometry.attributes.skinIndex, index );
  		_skinWeight.fromBufferAttribute( geometry.attributes.skinWeight, index );

  		_basePosition.copy( vector ).applyMatrix4( this.bindMatrix );

  		vector.set( 0, 0, 0 );

  		for ( let i = 0; i < 4; i ++ ) {

  			const weight = _skinWeight.getComponent( i );

  			if ( weight !== 0 ) {

  				const boneIndex = _skinIndex.getComponent( i );

  				_matrix4.multiplyMatrices( skeleton.bones[ boneIndex ].matrixWorld, skeleton.boneInverses[ boneIndex ] );

  				vector.addScaledVector( _vector3.copy( _basePosition ).applyMatrix4( _matrix4 ), weight );

  			}

  		}

  		return vector.applyMatrix4( this.bindMatrixInverse );

  	}

  }

  class Bone extends Object3D {

  	constructor() {

  		super();

  		this.isBone = true;

  		this.type = 'Bone';

  	}

  }

  class DataTexture extends Texture {

  	constructor( data = null, width = 1, height = 1, format, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, colorSpace ) {

  		super( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace );

  		this.isDataTexture = true;

  		this.image = { data: data, width: width, height: height };

  		this.generateMipmaps = false;
  		this.flipY = false;
  		this.unpackAlignment = 1;

  	}

  }

  const _offsetMatrix = /*@__PURE__*/ new Matrix4();
  const _identityMatrix$1 = /*@__PURE__*/ new Matrix4();

  class Skeleton {

  	constructor( bones = [], boneInverses = [] ) {

  		this.uuid = generateUUID();

  		this.bones = bones.slice( 0 );
  		this.boneInverses = boneInverses;
  		this.boneMatrices = null;

  		this.boneTexture = null;

  		this.init();

  	}

  	init() {

  		const bones = this.bones;
  		const boneInverses = this.boneInverses;

  		this.boneMatrices = new Float32Array( bones.length * 16 );

  		// calculate inverse bone matrices if necessary

  		if ( boneInverses.length === 0 ) {

  			this.calculateInverses();

  		} else {

  			// handle special case

  			if ( bones.length !== boneInverses.length ) {

  				console.warn( 'THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.' );

  				this.boneInverses = [];

  				for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

  					this.boneInverses.push( new Matrix4() );

  				}

  			}

  		}

  	}

  	calculateInverses() {

  		this.boneInverses.length = 0;

  		for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

  			const inverse = new Matrix4();

  			if ( this.bones[ i ] ) {

  				inverse.copy( this.bones[ i ].matrixWorld ).invert();

  			}

  			this.boneInverses.push( inverse );

  		}

  	}

  	pose() {

  		// recover the bind-time world matrices

  		for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

  			const bone = this.bones[ i ];

  			if ( bone ) {

  				bone.matrixWorld.copy( this.boneInverses[ i ] ).invert();

  			}

  		}

  		// compute the local matrices, positions, rotations and scales

  		for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

  			const bone = this.bones[ i ];

  			if ( bone ) {

  				if ( bone.parent && bone.parent.isBone ) {

  					bone.matrix.copy( bone.parent.matrixWorld ).invert();
  					bone.matrix.multiply( bone.matrixWorld );

  				} else {

  					bone.matrix.copy( bone.matrixWorld );

  				}

  				bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

  			}

  		}

  	}

  	update() {

  		const bones = this.bones;
  		const boneInverses = this.boneInverses;
  		const boneMatrices = this.boneMatrices;
  		const boneTexture = this.boneTexture;

  		// flatten bone matrices to array

  		for ( let i = 0, il = bones.length; i < il; i ++ ) {

  			// compute the offset between the current and the original transform

  			const matrix = bones[ i ] ? bones[ i ].matrixWorld : _identityMatrix$1;

  			_offsetMatrix.multiplyMatrices( matrix, boneInverses[ i ] );
  			_offsetMatrix.toArray( boneMatrices, i * 16 );

  		}

  		if ( boneTexture !== null ) {

  			boneTexture.needsUpdate = true;

  		}

  	}

  	clone() {

  		return new Skeleton( this.bones, this.boneInverses );

  	}

  	computeBoneTexture() {

  		// layout (1 matrix = 4 pixels)
  		//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
  		//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
  		//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
  		//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
  		//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)

  		let size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix
  		size = Math.ceil( size / 4 ) * 4;
  		size = Math.max( size, 4 );

  		const boneMatrices = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel
  		boneMatrices.set( this.boneMatrices ); // copy current values

  		const boneTexture = new DataTexture( boneMatrices, size, size, RGBAFormat, FloatType );
  		boneTexture.needsUpdate = true;

  		this.boneMatrices = boneMatrices;
  		this.boneTexture = boneTexture;

  		return this;

  	}

  	getBoneByName( name ) {

  		for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

  			const bone = this.bones[ i ];

  			if ( bone.name === name ) {

  				return bone;

  			}

  		}

  		return undefined;

  	}

  	dispose( ) {

  		if ( this.boneTexture !== null ) {

  			this.boneTexture.dispose();

  			this.boneTexture = null;

  		}

  	}

  	fromJSON( json, bones ) {

  		this.uuid = json.uuid;

  		for ( let i = 0, l = json.bones.length; i < l; i ++ ) {

  			const uuid = json.bones[ i ];
  			let bone = bones[ uuid ];

  			if ( bone === undefined ) {

  				console.warn( 'THREE.Skeleton: No bone found with UUID:', uuid );
  				bone = new Bone();

  			}

  			this.bones.push( bone );
  			this.boneInverses.push( new Matrix4().fromArray( json.boneInverses[ i ] ) );

  		}

  		this.init();

  		return this;

  	}

  	toJSON() {

  		const data = {
  			metadata: {
  				version: 4.6,
  				type: 'Skeleton',
  				generator: 'Skeleton.toJSON'
  			},
  			bones: [],
  			boneInverses: []
  		};

  		data.uuid = this.uuid;

  		const bones = this.bones;
  		const boneInverses = this.boneInverses;

  		for ( let i = 0, l = bones.length; i < l; i ++ ) {

  			const bone = bones[ i ];
  			data.bones.push( bone.uuid );

  			const boneInverse = boneInverses[ i ];
  			data.boneInverses.push( boneInverse.toArray() );

  		}

  		return data;

  	}

  }

  class InstancedBufferAttribute extends BufferAttribute {

  	constructor( array, itemSize, normalized, meshPerAttribute = 1 ) {

  		super( array, itemSize, normalized );

  		this.isInstancedBufferAttribute = true;

  		this.meshPerAttribute = meshPerAttribute;

  	}

  	copy( source ) {

  		super.copy( source );

  		this.meshPerAttribute = source.meshPerAttribute;

  		return this;

  	}

  	toJSON() {

  		const data = super.toJSON();

  		data.meshPerAttribute = this.meshPerAttribute;

  		data.isInstancedBufferAttribute = true;

  		return data;

  	}

  }

  const _instanceLocalMatrix = /*@__PURE__*/ new Matrix4();
  const _instanceWorldMatrix = /*@__PURE__*/ new Matrix4();

  const _instanceIntersects = [];

  const _box3 = /*@__PURE__*/ new Box3();
  const _identity = /*@__PURE__*/ new Matrix4();
  const _mesh$1 = /*@__PURE__*/ new Mesh();
  const _sphere$3 = /*@__PURE__*/ new Sphere();

  class InstancedMesh extends Mesh {

  	constructor( geometry, material, count ) {

  		super( geometry, material );

  		this.isInstancedMesh = true;

  		this.instanceMatrix = new InstancedBufferAttribute( new Float32Array( count * 16 ), 16 );
  		this.instanceColor = null;
  		this.morphTexture = null;

  		this.count = count;

  		this.boundingBox = null;
  		this.boundingSphere = null;

  		for ( let i = 0; i < count; i ++ ) {

  			this.setMatrixAt( i, _identity );

  		}

  	}

  	computeBoundingBox() {

  		const geometry = this.geometry;
  		const count = this.count;

  		if ( this.boundingBox === null ) {

  			this.boundingBox = new Box3();

  		}

  		if ( geometry.boundingBox === null ) {

  			geometry.computeBoundingBox();

  		}

  		this.boundingBox.makeEmpty();

  		for ( let i = 0; i < count; i ++ ) {

  			this.getMatrixAt( i, _instanceLocalMatrix );

  			_box3.copy( geometry.boundingBox ).applyMatrix4( _instanceLocalMatrix );

  			this.boundingBox.union( _box3 );

  		}

  	}

  	computeBoundingSphere() {

  		const geometry = this.geometry;
  		const count = this.count;

  		if ( this.boundingSphere === null ) {

  			this.boundingSphere = new Sphere();

  		}

  		if ( geometry.boundingSphere === null ) {

  			geometry.computeBoundingSphere();

  		}

  		this.boundingSphere.makeEmpty();

  		for ( let i = 0; i < count; i ++ ) {

  			this.getMatrixAt( i, _instanceLocalMatrix );

  			_sphere$3.copy( geometry.boundingSphere ).applyMatrix4( _instanceLocalMatrix );

  			this.boundingSphere.union( _sphere$3 );

  		}

  	}

  	copy( source, recursive ) {

  		super.copy( source, recursive );

  		this.instanceMatrix.copy( source.instanceMatrix );

  		if ( source.morphTexture !== null ) this.morphTexture = source.morphTexture.clone();
  		if ( source.instanceColor !== null ) this.instanceColor = source.instanceColor.clone();

  		this.count = source.count;

  		if ( source.boundingBox !== null ) this.boundingBox = source.boundingBox.clone();
  		if ( source.boundingSphere !== null ) this.boundingSphere = source.boundingSphere.clone();

  		return this;

  	}

  	getColorAt( index, color ) {

  		color.fromArray( this.instanceColor.array, index * 3 );

  	}

  	getMatrixAt( index, matrix ) {

  		matrix.fromArray( this.instanceMatrix.array, index * 16 );

  	}

  	getMorphAt( index, object ) {

  		const objectInfluences = object.morphTargetInfluences;

  		const array = this.morphTexture.source.data.data;

  		const len = objectInfluences.length + 1; // All influences + the baseInfluenceSum

  		const dataIndex = index * len + 1; // Skip the baseInfluenceSum at the beginning

  		for ( let i = 0; i < objectInfluences.length; i ++ ) {

  			objectInfluences[ i ] = array[ dataIndex + i ];

  		}

  	}

  	raycast( raycaster, intersects ) {

  		const matrixWorld = this.matrixWorld;
  		const raycastTimes = this.count;

  		_mesh$1.geometry = this.geometry;
  		_mesh$1.material = this.material;

  		if ( _mesh$1.material === undefined ) return;

  		// test with bounding sphere first

  		if ( this.boundingSphere === null ) this.computeBoundingSphere();

  		_sphere$3.copy( this.boundingSphere );
  		_sphere$3.applyMatrix4( matrixWorld );

  		if ( raycaster.ray.intersectsSphere( _sphere$3 ) === false ) return;

  		// now test each instance

  		for ( let instanceId = 0; instanceId < raycastTimes; instanceId ++ ) {

  			// calculate the world matrix for each instance

  			this.getMatrixAt( instanceId, _instanceLocalMatrix );

  			_instanceWorldMatrix.multiplyMatrices( matrixWorld, _instanceLocalMatrix );

  			// the mesh represents this single instance

  			_mesh$1.matrixWorld = _instanceWorldMatrix;

  			_mesh$1.raycast( raycaster, _instanceIntersects );

  			// process the result of raycast

  			for ( let i = 0, l = _instanceIntersects.length; i < l; i ++ ) {

  				const intersect = _instanceIntersects[ i ];
  				intersect.instanceId = instanceId;
  				intersect.object = this;
  				intersects.push( intersect );

  			}

  			_instanceIntersects.length = 0;

  		}

  	}

  	setColorAt( index, color ) {

  		if ( this.instanceColor === null ) {

  			this.instanceColor = new InstancedBufferAttribute( new Float32Array( this.instanceMatrix.count * 3 ).fill( 1 ), 3 );

  		}

  		color.toArray( this.instanceColor.array, index * 3 );

  	}

  	setMatrixAt( index, matrix ) {

  		matrix.toArray( this.instanceMatrix.array, index * 16 );

  	}

  	setMorphAt( index, object ) {

  		const objectInfluences = object.morphTargetInfluences;

  		const len = objectInfluences.length + 1; // morphBaseInfluence + all influences

  		if ( this.morphTexture === null ) {

  			this.morphTexture = new DataTexture( new Float32Array( len * this.count ), len, this.count, RedFormat, FloatType );

  		}

  		const array = this.morphTexture.source.data.data;

  		let morphInfluencesSum = 0;

  		for ( let i = 0; i < objectInfluences.length; i ++ ) {

  			morphInfluencesSum += objectInfluences[ i ];

  		}

  		const morphBaseInfluence = this.geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;

  		const dataIndex = len * index;

  		array[ dataIndex ] = morphBaseInfluence;

  		array.set( objectInfluences, dataIndex + 1 );

  	}

  	updateMorphTargets() {

  	}

  	dispose() {

  		this.dispatchEvent( { type: 'dispose' } );

  		if ( this.morphTexture !== null ) {

  			this.morphTexture.dispose();
  			this.morphTexture = null;

  		}

  		return this;

  	}

  }

  class LineBasicMaterial extends Material {

  	constructor( parameters ) {

  		super();

  		this.isLineBasicMaterial = true;

  		this.type = 'LineBasicMaterial';

  		this.color = new Color( 0xffffff );

  		this.map = null;

  		this.linewidth = 1;
  		this.linecap = 'round';
  		this.linejoin = 'round';

  		this.fog = true;

  		this.setValues( parameters );

  	}


  	copy( source ) {

  		super.copy( source );

  		this.color.copy( source.color );

  		this.map = source.map;

  		this.linewidth = source.linewidth;
  		this.linecap = source.linecap;
  		this.linejoin = source.linejoin;

  		this.fog = source.fog;

  		return this;

  	}

  }

  const _vStart = /*@__PURE__*/ new Vector3();
  const _vEnd = /*@__PURE__*/ new Vector3();

  const _inverseMatrix$1 = /*@__PURE__*/ new Matrix4();
  const _ray$1 = /*@__PURE__*/ new Ray();
  const _sphere$1 = /*@__PURE__*/ new Sphere();

  const _intersectPointOnRay = /*@__PURE__*/ new Vector3();
  const _intersectPointOnSegment = /*@__PURE__*/ new Vector3();

  class Line extends Object3D {

  	constructor( geometry = new BufferGeometry(), material = new LineBasicMaterial() ) {

  		super();

  		this.isLine = true;

  		this.type = 'Line';

  		this.geometry = geometry;
  		this.material = material;

  		this.updateMorphTargets();

  	}

  	copy( source, recursive ) {

  		super.copy( source, recursive );

  		this.material = Array.isArray( source.material ) ? source.material.slice() : source.material;
  		this.geometry = source.geometry;

  		return this;

  	}

  	computeLineDistances() {

  		const geometry = this.geometry;

  		// we assume non-indexed geometry

  		if ( geometry.index === null ) {

  			const positionAttribute = geometry.attributes.position;
  			const lineDistances = [ 0 ];

  			for ( let i = 1, l = positionAttribute.count; i < l; i ++ ) {

  				_vStart.fromBufferAttribute( positionAttribute, i - 1 );
  				_vEnd.fromBufferAttribute( positionAttribute, i );

  				lineDistances[ i ] = lineDistances[ i - 1 ];
  				lineDistances[ i ] += _vStart.distanceTo( _vEnd );

  			}

  			geometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );

  		} else {

  			console.warn( 'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );

  		}

  		return this;

  	}

  	raycast( raycaster, intersects ) {

  		const geometry = this.geometry;
  		const matrixWorld = this.matrixWorld;
  		const threshold = raycaster.params.Line.threshold;
  		const drawRange = geometry.drawRange;

  		// Checking boundingSphere distance to ray

  		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

  		_sphere$1.copy( geometry.boundingSphere );
  		_sphere$1.applyMatrix4( matrixWorld );
  		_sphere$1.radius += threshold;

  		if ( raycaster.ray.intersectsSphere( _sphere$1 ) === false ) return;

  		//

  		_inverseMatrix$1.copy( matrixWorld ).invert();
  		_ray$1.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$1 );

  		const localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
  		const localThresholdSq = localThreshold * localThreshold;

  		const step = this.isLineSegments ? 2 : 1;

  		const index = geometry.index;
  		const attributes = geometry.attributes;
  		const positionAttribute = attributes.position;

  		if ( index !== null ) {

  			const start = Math.max( 0, drawRange.start );
  			const end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

  			for ( let i = start, l = end - 1; i < l; i += step ) {

  				const a = index.getX( i );
  				const b = index.getX( i + 1 );

  				const intersect = checkIntersection( this, raycaster, _ray$1, localThresholdSq, a, b );

  				if ( intersect ) {

  					intersects.push( intersect );

  				}

  			}

  			if ( this.isLineLoop ) {

  				const a = index.getX( end - 1 );
  				const b = index.getX( start );

  				const intersect = checkIntersection( this, raycaster, _ray$1, localThresholdSq, a, b );

  				if ( intersect ) {

  					intersects.push( intersect );

  				}

  			}

  		} else {

  			const start = Math.max( 0, drawRange.start );
  			const end = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );

  			for ( let i = start, l = end - 1; i < l; i += step ) {

  				const intersect = checkIntersection( this, raycaster, _ray$1, localThresholdSq, i, i + 1 );

  				if ( intersect ) {

  					intersects.push( intersect );

  				}

  			}

  			if ( this.isLineLoop ) {

  				const intersect = checkIntersection( this, raycaster, _ray$1, localThresholdSq, end - 1, start );

  				if ( intersect ) {

  					intersects.push( intersect );

  				}

  			}

  		}

  	}

  	updateMorphTargets() {

  		const geometry = this.geometry;

  		const morphAttributes = geometry.morphAttributes;
  		const keys = Object.keys( morphAttributes );

  		if ( keys.length > 0 ) {

  			const morphAttribute = morphAttributes[ keys[ 0 ] ];

  			if ( morphAttribute !== undefined ) {

  				this.morphTargetInfluences = [];
  				this.morphTargetDictionary = {};

  				for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

  					const name = morphAttribute[ m ].name || String( m );

  					this.morphTargetInfluences.push( 0 );
  					this.morphTargetDictionary[ name ] = m;

  				}

  			}

  		}

  	}

  }

  function checkIntersection( object, raycaster, ray, thresholdSq, a, b ) {

  	const positionAttribute = object.geometry.attributes.position;

  	_vStart.fromBufferAttribute( positionAttribute, a );
  	_vEnd.fromBufferAttribute( positionAttribute, b );

  	const distSq = ray.distanceSqToSegment( _vStart, _vEnd, _intersectPointOnRay, _intersectPointOnSegment );

  	if ( distSq > thresholdSq ) return;

  	_intersectPointOnRay.applyMatrix4( object.matrixWorld ); // Move back to world space for distance calculation

  	const distance = raycaster.ray.origin.distanceTo( _intersectPointOnRay );

  	if ( distance < raycaster.near || distance > raycaster.far ) return;

  	return {

  		distance: distance,
  		// What do we want? intersection point on the ray or on the segment??
  		// point: raycaster.ray.at( distance ),
  		point: _intersectPointOnSegment.clone().applyMatrix4( object.matrixWorld ),
  		index: a,
  		face: null,
  		faceIndex: null,
  		object: object

  	};

  }

  const _start = /*@__PURE__*/ new Vector3();
  const _end = /*@__PURE__*/ new Vector3();

  class LineSegments extends Line {

  	constructor( geometry, material ) {

  		super( geometry, material );

  		this.isLineSegments = true;

  		this.type = 'LineSegments';

  	}

  	computeLineDistances() {

  		const geometry = this.geometry;

  		// we assume non-indexed geometry

  		if ( geometry.index === null ) {

  			const positionAttribute = geometry.attributes.position;
  			const lineDistances = [];

  			for ( let i = 0, l = positionAttribute.count; i < l; i += 2 ) {

  				_start.fromBufferAttribute( positionAttribute, i );
  				_end.fromBufferAttribute( positionAttribute, i + 1 );

  				lineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];
  				lineDistances[ i + 1 ] = lineDistances[ i ] + _start.distanceTo( _end );

  			}

  			geometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );

  		} else {

  			console.warn( 'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );

  		}

  		return this;

  	}

  }

  class LineLoop extends Line {

  	constructor( geometry, material ) {

  		super( geometry, material );

  		this.isLineLoop = true;

  		this.type = 'LineLoop';

  	}

  }

  class PointsMaterial extends Material {

  	constructor( parameters ) {

  		super();

  		this.isPointsMaterial = true;

  		this.type = 'PointsMaterial';

  		this.color = new Color( 0xffffff );

  		this.map = null;

  		this.alphaMap = null;

  		this.size = 1;
  		this.sizeAttenuation = true;

  		this.fog = true;

  		this.setValues( parameters );

  	}

  	copy( source ) {

  		super.copy( source );

  		this.color.copy( source.color );

  		this.map = source.map;

  		this.alphaMap = source.alphaMap;

  		this.size = source.size;
  		this.sizeAttenuation = source.sizeAttenuation;

  		this.fog = source.fog;

  		return this;

  	}

  }

  const _inverseMatrix = /*@__PURE__*/ new Matrix4();
  const _ray = /*@__PURE__*/ new Ray();
  const _sphere = /*@__PURE__*/ new Sphere();
  const _position$2 = /*@__PURE__*/ new Vector3();

  class Points extends Object3D {

  	constructor( geometry = new BufferGeometry(), material = new PointsMaterial() ) {

  		super();

  		this.isPoints = true;

  		this.type = 'Points';

  		this.geometry = geometry;
  		this.material = material;

  		this.updateMorphTargets();

  	}

  	copy( source, recursive ) {

  		super.copy( source, recursive );

  		this.material = Array.isArray( source.material ) ? source.material.slice() : source.material;
  		this.geometry = source.geometry;

  		return this;

  	}

  	raycast( raycaster, intersects ) {

  		const geometry = this.geometry;
  		const matrixWorld = this.matrixWorld;
  		const threshold = raycaster.params.Points.threshold;
  		const drawRange = geometry.drawRange;

  		// Checking boundingSphere distance to ray

  		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

  		_sphere.copy( geometry.boundingSphere );
  		_sphere.applyMatrix4( matrixWorld );
  		_sphere.radius += threshold;

  		if ( raycaster.ray.intersectsSphere( _sphere ) === false ) return;

  		//

  		_inverseMatrix.copy( matrixWorld ).invert();
  		_ray.copy( raycaster.ray ).applyMatrix4( _inverseMatrix );

  		const localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
  		const localThresholdSq = localThreshold * localThreshold;

  		const index = geometry.index;
  		const attributes = geometry.attributes;
  		const positionAttribute = attributes.position;

  		if ( index !== null ) {

  			const start = Math.max( 0, drawRange.start );
  			const end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

  			for ( let i = start, il = end; i < il; i ++ ) {

  				const a = index.getX( i );

  				_position$2.fromBufferAttribute( positionAttribute, a );

  				testPoint( _position$2, a, localThresholdSq, matrixWorld, raycaster, intersects, this );

  			}

  		} else {

  			const start = Math.max( 0, drawRange.start );
  			const end = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );

  			for ( let i = start, l = end; i < l; i ++ ) {

  				_position$2.fromBufferAttribute( positionAttribute, i );

  				testPoint( _position$2, i, localThresholdSq, matrixWorld, raycaster, intersects, this );

  			}

  		}

  	}

  	updateMorphTargets() {

  		const geometry = this.geometry;

  		const morphAttributes = geometry.morphAttributes;
  		const keys = Object.keys( morphAttributes );

  		if ( keys.length > 0 ) {

  			const morphAttribute = morphAttributes[ keys[ 0 ] ];

  			if ( morphAttribute !== undefined ) {

  				this.morphTargetInfluences = [];
  				this.morphTargetDictionary = {};

  				for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

  					const name = morphAttribute[ m ].name || String( m );

  					this.morphTargetInfluences.push( 0 );
  					this.morphTargetDictionary[ name ] = m;

  				}

  			}

  		}

  	}

  }

  function testPoint( point, index, localThresholdSq, matrixWorld, raycaster, intersects, object ) {

  	const rayPointDistanceSq = _ray.distanceSqToPoint( point );

  	if ( rayPointDistanceSq < localThresholdSq ) {

  		const intersectPoint = new Vector3();

  		_ray.closestPointToPoint( point, intersectPoint );
  		intersectPoint.applyMatrix4( matrixWorld );

  		const distance = raycaster.ray.origin.distanceTo( intersectPoint );

  		if ( distance < raycaster.near || distance > raycaster.far ) return;

  		intersects.push( {

  			distance: distance,
  			distanceToRay: Math.sqrt( rayPointDistanceSq ),
  			point: intersectPoint,
  			index: index,
  			face: null,
  			object: object

  		} );

  	}

  }

  class CompressedTexture extends Texture {

  	constructor( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, colorSpace ) {

  		super( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace );

  		this.isCompressedTexture = true;

  		this.image = { width: width, height: height };
  		this.mipmaps = mipmaps;

  		// no flipping for cube textures
  		// (also flipping doesn't work for compressed textures )

  		this.flipY = false;

  		// can't generate mipmaps for compressed textures
  		// mips must be embedded in DDS files

  		this.generateMipmaps = false;

  	}

  }

  class CanvasTexture extends Texture {

  	constructor( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

  		super( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

  		this.isCanvasTexture = true;

  		this.needsUpdate = true;

  	}

  }

  /**
   * Extensible curve object.
   *
   * Some common of curve methods:
   * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )
   * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )
   * .getPoints(), .getSpacedPoints()
   * .getLength()
   * .updateArcLengths()
   *
   * This following curves inherit from THREE.Curve:
   *
   * -- 2D curves --
   * THREE.ArcCurve
   * THREE.CubicBezierCurve
   * THREE.EllipseCurve
   * THREE.LineCurve
   * THREE.QuadraticBezierCurve
   * THREE.SplineCurve
   *
   * -- 3D curves --
   * THREE.CatmullRomCurve3
   * THREE.CubicBezierCurve3
   * THREE.LineCurve3
   * THREE.QuadraticBezierCurve3
   *
   * A series of curves can be represented as a THREE.CurvePath.
   *
   **/

  class Curve {

  	constructor() {

  		this.type = 'Curve';

  		this.arcLengthDivisions = 200;

  	}

  	// Virtual base class method to overwrite and implement in subclasses
  	//	- t [0 .. 1]

  	getPoint( /* t, optionalTarget */ ) {

  		console.warn( 'THREE.Curve: .getPoint() not implemented.' );
  		return null;

  	}

  	// Get point at relative position in curve according to arc length
  	// - u [0 .. 1]

  	getPointAt( u, optionalTarget ) {

  		const t = this.getUtoTmapping( u );
  		return this.getPoint( t, optionalTarget );

  	}

  	// Get sequence of points using getPoint( t )

  	getPoints( divisions = 5 ) {

  		const points = [];

  		for ( let d = 0; d <= divisions; d ++ ) {

  			points.push( this.getPoint( d / divisions ) );

  		}

  		return points;

  	}

  	// Get sequence of points using getPointAt( u )

  	getSpacedPoints( divisions = 5 ) {

  		const points = [];

  		for ( let d = 0; d <= divisions; d ++ ) {

  			points.push( this.getPointAt( d / divisions ) );

  		}

  		return points;

  	}

  	// Get total curve arc length

  	getLength() {

  		const lengths = this.getLengths();
  		return lengths[ lengths.length - 1 ];

  	}

  	// Get list of cumulative segment lengths

  	getLengths( divisions = this.arcLengthDivisions ) {

  		if ( this.cacheArcLengths &&
  			( this.cacheArcLengths.length === divisions + 1 ) &&
  			! this.needsUpdate ) {

  			return this.cacheArcLengths;

  		}

  		this.needsUpdate = false;

  		const cache = [];
  		let current, last = this.getPoint( 0 );
  		let sum = 0;

  		cache.push( 0 );

  		for ( let p = 1; p <= divisions; p ++ ) {

  			current = this.getPoint( p / divisions );
  			sum += current.distanceTo( last );
  			cache.push( sum );
  			last = current;

  		}

  		this.cacheArcLengths = cache;

  		return cache; // { sums: cache, sum: sum }; Sum is in the last element.

  	}

  	updateArcLengths() {

  		this.needsUpdate = true;
  		this.getLengths();

  	}

  	// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant

  	getUtoTmapping( u, distance ) {

  		const arcLengths = this.getLengths();

  		let i = 0;
  		const il = arcLengths.length;

  		let targetArcLength; // The targeted u distance value to get

  		if ( distance ) {

  			targetArcLength = distance;

  		} else {

  			targetArcLength = u * arcLengths[ il - 1 ];

  		}

  		// binary search for the index with largest value smaller than target u distance

  		let low = 0, high = il - 1, comparison;

  		while ( low <= high ) {

  			i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

  			comparison = arcLengths[ i ] - targetArcLength;

  			if ( comparison < 0 ) {

  				low = i + 1;

  			} else if ( comparison > 0 ) {

  				high = i - 1;

  			} else {

  				high = i;
  				break;

  				// DONE

  			}

  		}

  		i = high;

  		if ( arcLengths[ i ] === targetArcLength ) {

  			return i / ( il - 1 );

  		}

  		// we could get finer grain at lengths, or use simple interpolation between two points

  		const lengthBefore = arcLengths[ i ];
  		const lengthAfter = arcLengths[ i + 1 ];

  		const segmentLength = lengthAfter - lengthBefore;

  		// determine where we are between the 'before' and 'after' points

  		const segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

  		// add that fractional amount to t

  		const t = ( i + segmentFraction ) / ( il - 1 );

  		return t;

  	}

  	// Returns a unit vector tangent at t
  	// In case any sub curve does not implement its tangent derivation,
  	// 2 points a small delta apart will be used to find its gradient
  	// which seems to give a reasonable approximation

  	getTangent( t, optionalTarget ) {

  		const delta = 0.0001;
  		let t1 = t - delta;
  		let t2 = t + delta;

  		// Capping in case of danger

  		if ( t1 < 0 ) t1 = 0;
  		if ( t2 > 1 ) t2 = 1;

  		const pt1 = this.getPoint( t1 );
  		const pt2 = this.getPoint( t2 );

  		const tangent = optionalTarget || ( ( pt1.isVector2 ) ? new Vector2() : new Vector3() );

  		tangent.copy( pt2 ).sub( pt1 ).normalize();

  		return tangent;

  	}

  	getTangentAt( u, optionalTarget ) {

  		const t = this.getUtoTmapping( u );
  		return this.getTangent( t, optionalTarget );

  	}

  	computeFrenetFrames( segments, closed ) {

  		// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf

  		const normal = new Vector3();

  		const tangents = [];
  		const normals = [];
  		const binormals = [];

  		const vec = new Vector3();
  		const mat = new Matrix4();

  		// compute the tangent vectors for each segment on the curve

  		for ( let i = 0; i <= segments; i ++ ) {

  			const u = i / segments;

  			tangents[ i ] = this.getTangentAt( u, new Vector3() );

  		}

  		// select an initial normal vector perpendicular to the first tangent vector,
  		// and in the direction of the minimum tangent xyz component

  		normals[ 0 ] = new Vector3();
  		binormals[ 0 ] = new Vector3();
  		let min = Number.MAX_VALUE;
  		const tx = Math.abs( tangents[ 0 ].x );
  		const ty = Math.abs( tangents[ 0 ].y );
  		const tz = Math.abs( tangents[ 0 ].z );

  		if ( tx <= min ) {

  			min = tx;
  			normal.set( 1, 0, 0 );

  		}

  		if ( ty <= min ) {

  			min = ty;
  			normal.set( 0, 1, 0 );

  		}

  		if ( tz <= min ) {

  			normal.set( 0, 0, 1 );

  		}

  		vec.crossVectors( tangents[ 0 ], normal ).normalize();

  		normals[ 0 ].crossVectors( tangents[ 0 ], vec );
  		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );


  		// compute the slowly-varying normal and binormal vectors for each segment on the curve

  		for ( let i = 1; i <= segments; i ++ ) {

  			normals[ i ] = normals[ i - 1 ].clone();

  			binormals[ i ] = binormals[ i - 1 ].clone();

  			vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );

  			if ( vec.length() > Number.EPSILON ) {

  				vec.normalize();

  				const theta = Math.acos( clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors

  				normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

  			}

  			binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

  		}

  		// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

  		if ( closed === true ) {

  			let theta = Math.acos( clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );
  			theta /= segments;

  			if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {

  				theta = - theta;

  			}

  			for ( let i = 1; i <= segments; i ++ ) {

  				// twist a little...
  				normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
  				binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

  			}

  		}

  		return {
  			tangents: tangents,
  			normals: normals,
  			binormals: binormals
  		};

  	}

  	clone() {

  		return new this.constructor().copy( this );

  	}

  	copy( source ) {

  		this.arcLengthDivisions = source.arcLengthDivisions;

  		return this;

  	}

  	toJSON() {

  		const data = {
  			metadata: {
  				version: 4.6,
  				type: 'Curve',
  				generator: 'Curve.toJSON'
  			}
  		};

  		data.arcLengthDivisions = this.arcLengthDivisions;
  		data.type = this.type;

  		return data;

  	}

  	fromJSON( json ) {

  		this.arcLengthDivisions = json.arcLengthDivisions;

  		return this;

  	}

  }

  /**
   * Port from https://github.com/mapbox/earcut (v2.2.4)
   */

  const Earcut = {

  	triangulate: function ( data, holeIndices, dim = 2 ) {

  		const hasHoles = holeIndices && holeIndices.length;
  		const outerLen = hasHoles ? holeIndices[ 0 ] * dim : data.length;
  		let outerNode = linkedList( data, 0, outerLen, dim, true );
  		const triangles = [];

  		if ( ! outerNode || outerNode.next === outerNode.prev ) return triangles;

  		let minX, minY, maxX, maxY, x, y, invSize;

  		if ( hasHoles ) outerNode = eliminateHoles( data, holeIndices, outerNode, dim );

  		// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
  		if ( data.length > 80 * dim ) {

  			minX = maxX = data[ 0 ];
  			minY = maxY = data[ 1 ];

  			for ( let i = dim; i < outerLen; i += dim ) {

  				x = data[ i ];
  				y = data[ i + 1 ];
  				if ( x < minX ) minX = x;
  				if ( y < minY ) minY = y;
  				if ( x > maxX ) maxX = x;
  				if ( y > maxY ) maxY = y;

  			}

  			// minX, minY and invSize are later used to transform coords into integers for z-order calculation
  			invSize = Math.max( maxX - minX, maxY - minY );
  			invSize = invSize !== 0 ? 32767 / invSize : 0;

  		}

  		earcutLinked( outerNode, triangles, dim, minX, minY, invSize, 0 );

  		return triangles;

  	}

  };

  // create a circular doubly linked list from polygon points in the specified winding order
  function linkedList( data, start, end, dim, clockwise ) {

  	let i, last;

  	if ( clockwise === ( signedArea( data, start, end, dim ) > 0 ) ) {

  		for ( i = start; i < end; i += dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );

  	} else {

  		for ( i = end - dim; i >= start; i -= dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );

  	}

  	if ( last && equals( last, last.next ) ) {

  		removeNode( last );
  		last = last.next;

  	}

  	return last;

  }

  // eliminate colinear or duplicate points
  function filterPoints( start, end ) {

  	if ( ! start ) return start;
  	if ( ! end ) end = start;

  	let p = start,
  		again;
  	do {

  		again = false;

  		if ( ! p.steiner && ( equals( p, p.next ) || area( p.prev, p, p.next ) === 0 ) ) {

  			removeNode( p );
  			p = end = p.prev;
  			if ( p === p.next ) break;
  			again = true;

  		} else {

  			p = p.next;

  		}

  	} while ( again || p !== end );

  	return end;

  }

  // main ear slicing loop which triangulates a polygon (given as a linked list)
  function earcutLinked( ear, triangles, dim, minX, minY, invSize, pass ) {

  	if ( ! ear ) return;

  	// interlink polygon nodes in z-order
  	if ( ! pass && invSize ) indexCurve( ear, minX, minY, invSize );

  	let stop = ear,
  		prev, next;

  	// iterate through ears, slicing them one by one
  	while ( ear.prev !== ear.next ) {

  		prev = ear.prev;
  		next = ear.next;

  		if ( invSize ? isEarHashed( ear, minX, minY, invSize ) : isEar( ear ) ) {

  			// cut off the triangle
  			triangles.push( prev.i / dim | 0 );
  			triangles.push( ear.i / dim | 0 );
  			triangles.push( next.i / dim | 0 );

  			removeNode( ear );

  			// skipping the next vertex leads to less sliver triangles
  			ear = next.next;
  			stop = next.next;

  			continue;

  		}

  		ear = next;

  		// if we looped through the whole remaining polygon and can't find any more ears
  		if ( ear === stop ) {

  			// try filtering points and slicing again
  			if ( ! pass ) {

  				earcutLinked( filterPoints( ear ), triangles, dim, minX, minY, invSize, 1 );

  				// if this didn't work, try curing all small self-intersections locally

  			} else if ( pass === 1 ) {

  				ear = cureLocalIntersections( filterPoints( ear ), triangles, dim );
  				earcutLinked( ear, triangles, dim, minX, minY, invSize, 2 );

  				// as a last resort, try splitting the remaining polygon into two

  			} else if ( pass === 2 ) {

  				splitEarcut( ear, triangles, dim, minX, minY, invSize );

  			}

  			break;

  		}

  	}

  }

  // check whether a polygon node forms a valid ear with adjacent nodes
  function isEar( ear ) {

  	const a = ear.prev,
  		b = ear,
  		c = ear.next;

  	if ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear

  	// now make sure we don't have other points inside the potential ear
  	const ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;

  	// triangle bbox; min & max are calculated like this for speed
  	const x0 = ax < bx ? ( ax < cx ? ax : cx ) : ( bx < cx ? bx : cx ),
  		y0 = ay < by ? ( ay < cy ? ay : cy ) : ( by < cy ? by : cy ),
  		x1 = ax > bx ? ( ax > cx ? ax : cx ) : ( bx > cx ? bx : cx ),
  		y1 = ay > by ? ( ay > cy ? ay : cy ) : ( by > cy ? by : cy );

  	let p = c.next;
  	while ( p !== a ) {

  		if ( p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 &&
  			pointInTriangle( ax, ay, bx, by, cx, cy, p.x, p.y ) &&
  			area( p.prev, p, p.next ) >= 0 ) return false;
  		p = p.next;

  	}

  	return true;

  }

  function isEarHashed( ear, minX, minY, invSize ) {

  	const a = ear.prev,
  		b = ear,
  		c = ear.next;

  	if ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear

  	const ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;

  	// triangle bbox; min & max are calculated like this for speed
  	const x0 = ax < bx ? ( ax < cx ? ax : cx ) : ( bx < cx ? bx : cx ),
  		y0 = ay < by ? ( ay < cy ? ay : cy ) : ( by < cy ? by : cy ),
  		x1 = ax > bx ? ( ax > cx ? ax : cx ) : ( bx > cx ? bx : cx ),
  		y1 = ay > by ? ( ay > cy ? ay : cy ) : ( by > cy ? by : cy );

  	// z-order range for the current triangle bbox;
  	const minZ = zOrder( x0, y0, minX, minY, invSize ),
  		maxZ = zOrder( x1, y1, minX, minY, invSize );

  	let p = ear.prevZ,
  		n = ear.nextZ;

  	// look for points inside the triangle in both directions
  	while ( p && p.z >= minZ && n && n.z <= maxZ ) {

  		if ( p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&
  			pointInTriangle( ax, ay, bx, by, cx, cy, p.x, p.y ) && area( p.prev, p, p.next ) >= 0 ) return false;
  		p = p.prevZ;

  		if ( n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&
  			pointInTriangle( ax, ay, bx, by, cx, cy, n.x, n.y ) && area( n.prev, n, n.next ) >= 0 ) return false;
  		n = n.nextZ;

  	}

  	// look for remaining points in decreasing z-order
  	while ( p && p.z >= minZ ) {

  		if ( p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&
  			pointInTriangle( ax, ay, bx, by, cx, cy, p.x, p.y ) && area( p.prev, p, p.next ) >= 0 ) return false;
  		p = p.prevZ;

  	}

  	// look for remaining points in increasing z-order
  	while ( n && n.z <= maxZ ) {

  		if ( n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&
  			pointInTriangle( ax, ay, bx, by, cx, cy, n.x, n.y ) && area( n.prev, n, n.next ) >= 0 ) return false;
  		n = n.nextZ;

  	}

  	return true;

  }

  // go through all polygon nodes and cure small local self-intersections
  function cureLocalIntersections( start, triangles, dim ) {

  	let p = start;
  	do {

  		const a = p.prev,
  			b = p.next.next;

  		if ( ! equals( a, b ) && intersects( a, p, p.next, b ) && locallyInside( a, b ) && locallyInside( b, a ) ) {

  			triangles.push( a.i / dim | 0 );
  			triangles.push( p.i / dim | 0 );
  			triangles.push( b.i / dim | 0 );

  			// remove two nodes involved
  			removeNode( p );
  			removeNode( p.next );

  			p = start = b;

  		}

  		p = p.next;

  	} while ( p !== start );

  	return filterPoints( p );

  }

  // try splitting polygon into two and triangulate them independently
  function splitEarcut( start, triangles, dim, minX, minY, invSize ) {

  	// look for a valid diagonal that divides the polygon into two
  	let a = start;
  	do {

  		let b = a.next.next;
  		while ( b !== a.prev ) {

  			if ( a.i !== b.i && isValidDiagonal( a, b ) ) {

  				// split the polygon in two by the diagonal
  				let c = splitPolygon( a, b );

  				// filter colinear points around the cuts
  				a = filterPoints( a, a.next );
  				c = filterPoints( c, c.next );

  				// run earcut on each half
  				earcutLinked( a, triangles, dim, minX, minY, invSize, 0 );
  				earcutLinked( c, triangles, dim, minX, minY, invSize, 0 );
  				return;

  			}

  			b = b.next;

  		}

  		a = a.next;

  	} while ( a !== start );

  }

  // link every hole into the outer loop, producing a single-ring polygon without holes
  function eliminateHoles( data, holeIndices, outerNode, dim ) {

  	const queue = [];
  	let i, len, start, end, list;

  	for ( i = 0, len = holeIndices.length; i < len; i ++ ) {

  		start = holeIndices[ i ] * dim;
  		end = i < len - 1 ? holeIndices[ i + 1 ] * dim : data.length;
  		list = linkedList( data, start, end, dim, false );
  		if ( list === list.next ) list.steiner = true;
  		queue.push( getLeftmost( list ) );

  	}

  	queue.sort( compareX );

  	// process holes from left to right
  	for ( i = 0; i < queue.length; i ++ ) {

  		outerNode = eliminateHole( queue[ i ], outerNode );

  	}

  	return outerNode;

  }

  function compareX( a, b ) {

  	return a.x - b.x;

  }

  // find a bridge between vertices that connects hole with an outer ring and link it
  function eliminateHole( hole, outerNode ) {

  	const bridge = findHoleBridge( hole, outerNode );
  	if ( ! bridge ) {

  		return outerNode;

  	}

  	const bridgeReverse = splitPolygon( bridge, hole );

  	// filter collinear points around the cuts
  	filterPoints( bridgeReverse, bridgeReverse.next );
  	return filterPoints( bridge, bridge.next );

  }

  // David Eberly's algorithm for finding a bridge between hole and outer polygon
  function findHoleBridge( hole, outerNode ) {

  	let p = outerNode,
  		qx = - Infinity,
  		m;

  	const hx = hole.x, hy = hole.y;

  	// find a segment intersected by a ray from the hole's leftmost point to the left;
  	// segment's endpoint with lesser x will be potential connection point
  	do {

  		if ( hy <= p.y && hy >= p.next.y && p.next.y !== p.y ) {

  			const x = p.x + ( hy - p.y ) * ( p.next.x - p.x ) / ( p.next.y - p.y );
  			if ( x <= hx && x > qx ) {

  				qx = x;
  				m = p.x < p.next.x ? p : p.next;
  				if ( x === hx ) return m; // hole touches outer segment; pick leftmost endpoint

  			}

  		}

  		p = p.next;

  	} while ( p !== outerNode );

  	if ( ! m ) return null;

  	// look for points inside the triangle of hole point, segment intersection and endpoint;
  	// if there are no points found, we have a valid connection;
  	// otherwise choose the point of the minimum angle with the ray as connection point

  	const stop = m,
  		mx = m.x,
  		my = m.y;
  	let tanMin = Infinity, tan;

  	p = m;

  	do {

  		if ( hx >= p.x && p.x >= mx && hx !== p.x &&
  				pointInTriangle( hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y ) ) {

  			tan = Math.abs( hy - p.y ) / ( hx - p.x ); // tangential

  			if ( locallyInside( p, hole ) && ( tan < tanMin || ( tan === tanMin && ( p.x > m.x || ( p.x === m.x && sectorContainsSector( m, p ) ) ) ) ) ) {

  				m = p;
  				tanMin = tan;

  			}

  		}

  		p = p.next;

  	} while ( p !== stop );

  	return m;

  }

  // whether sector in vertex m contains sector in vertex p in the same coordinates
  function sectorContainsSector( m, p ) {

  	return area( m.prev, m, p.prev ) < 0 && area( p.next, m, m.next ) < 0;

  }

  // interlink polygon nodes in z-order
  function indexCurve( start, minX, minY, invSize ) {

  	let p = start;
  	do {

  		if ( p.z === 0 ) p.z = zOrder( p.x, p.y, minX, minY, invSize );
  		p.prevZ = p.prev;
  		p.nextZ = p.next;
  		p = p.next;

  	} while ( p !== start );

  	p.prevZ.nextZ = null;
  	p.prevZ = null;

  	sortLinked( p );

  }

  // Simon Tatham's linked list merge sort algorithm
  // http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
  function sortLinked( list ) {

  	let i, p, q, e, tail, numMerges, pSize, qSize,
  		inSize = 1;

  	do {

  		p = list;
  		list = null;
  		tail = null;
  		numMerges = 0;

  		while ( p ) {

  			numMerges ++;
  			q = p;
  			pSize = 0;
  			for ( i = 0; i < inSize; i ++ ) {

  				pSize ++;
  				q = q.nextZ;
  				if ( ! q ) break;

  			}

  			qSize = inSize;

  			while ( pSize > 0 || ( qSize > 0 && q ) ) {

  				if ( pSize !== 0 && ( qSize === 0 || ! q || p.z <= q.z ) ) {

  					e = p;
  					p = p.nextZ;
  					pSize --;

  				} else {

  					e = q;
  					q = q.nextZ;
  					qSize --;

  				}

  				if ( tail ) tail.nextZ = e;
  				else list = e;

  				e.prevZ = tail;
  				tail = e;

  			}

  			p = q;

  		}

  		tail.nextZ = null;
  		inSize *= 2;

  	} while ( numMerges > 1 );

  	return list;

  }

  // z-order of a point given coords and inverse of the longer side of data bbox
  function zOrder( x, y, minX, minY, invSize ) {

  	// coords are transformed into non-negative 15-bit integer range
  	x = ( x - minX ) * invSize | 0;
  	y = ( y - minY ) * invSize | 0;

  	x = ( x | ( x << 8 ) ) & 0x00FF00FF;
  	x = ( x | ( x << 4 ) ) & 0x0F0F0F0F;
  	x = ( x | ( x << 2 ) ) & 0x33333333;
  	x = ( x | ( x << 1 ) ) & 0x55555555;

  	y = ( y | ( y << 8 ) ) & 0x00FF00FF;
  	y = ( y | ( y << 4 ) ) & 0x0F0F0F0F;
  	y = ( y | ( y << 2 ) ) & 0x33333333;
  	y = ( y | ( y << 1 ) ) & 0x55555555;

  	return x | ( y << 1 );

  }

  // find the leftmost node of a polygon ring
  function getLeftmost( start ) {

  	let p = start,
  		leftmost = start;
  	do {

  		if ( p.x < leftmost.x || ( p.x === leftmost.x && p.y < leftmost.y ) ) leftmost = p;
  		p = p.next;

  	} while ( p !== start );

  	return leftmost;

  }

  // check if a point lies within a convex triangle
  function pointInTriangle( ax, ay, bx, by, cx, cy, px, py ) {

  	return ( cx - px ) * ( ay - py ) >= ( ax - px ) * ( cy - py ) &&
             ( ax - px ) * ( by - py ) >= ( bx - px ) * ( ay - py ) &&
             ( bx - px ) * ( cy - py ) >= ( cx - px ) * ( by - py );

  }

  // check if a diagonal between two polygon nodes is valid (lies in polygon interior)
  function isValidDiagonal( a, b ) {

  	return a.next.i !== b.i && a.prev.i !== b.i && ! intersectsPolygon( a, b ) && // dones't intersect other edges
             ( locallyInside( a, b ) && locallyInside( b, a ) && middleInside( a, b ) && // locally visible
              ( area( a.prev, a, b.prev ) || area( a, b.prev, b ) ) || // does not create opposite-facing sectors
              equals( a, b ) && area( a.prev, a, a.next ) > 0 && area( b.prev, b, b.next ) > 0 ); // special zero-length case

  }

  // signed area of a triangle
  function area( p, q, r ) {

  	return ( q.y - p.y ) * ( r.x - q.x ) - ( q.x - p.x ) * ( r.y - q.y );

  }

  // check if two points are equal
  function equals( p1, p2 ) {

  	return p1.x === p2.x && p1.y === p2.y;

  }

  // check if two segments intersect
  function intersects( p1, q1, p2, q2 ) {

  	const o1 = sign( area( p1, q1, p2 ) );
  	const o2 = sign( area( p1, q1, q2 ) );
  	const o3 = sign( area( p2, q2, p1 ) );
  	const o4 = sign( area( p2, q2, q1 ) );

  	if ( o1 !== o2 && o3 !== o4 ) return true; // general case

  	if ( o1 === 0 && onSegment( p1, p2, q1 ) ) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
  	if ( o2 === 0 && onSegment( p1, q2, q1 ) ) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
  	if ( o3 === 0 && onSegment( p2, p1, q2 ) ) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
  	if ( o4 === 0 && onSegment( p2, q1, q2 ) ) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

  	return false;

  }

  // for collinear points p, q, r, check if point q lies on segment pr
  function onSegment( p, q, r ) {

  	return q.x <= Math.max( p.x, r.x ) && q.x >= Math.min( p.x, r.x ) && q.y <= Math.max( p.y, r.y ) && q.y >= Math.min( p.y, r.y );

  }

  function sign( num ) {

  	return num > 0 ? 1 : num < 0 ? - 1 : 0;

  }

  // check if a polygon diagonal intersects any polygon segments
  function intersectsPolygon( a, b ) {

  	let p = a;
  	do {

  		if ( p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
  			intersects( p, p.next, a, b ) ) return true;
  		p = p.next;

  	} while ( p !== a );

  	return false;

  }

  // check if a polygon diagonal is locally inside the polygon
  function locallyInside( a, b ) {

  	return area( a.prev, a, a.next ) < 0 ?
  		area( a, b, a.next ) >= 0 && area( a, a.prev, b ) >= 0 :
  		area( a, b, a.prev ) < 0 || area( a, a.next, b ) < 0;

  }

  // check if the middle point of a polygon diagonal is inside the polygon
  function middleInside( a, b ) {

  	let p = a,
  		inside = false;
  	const px = ( a.x + b.x ) / 2,
  		py = ( a.y + b.y ) / 2;
  	do {

  		if ( ( ( p.y > py ) !== ( p.next.y > py ) ) && p.next.y !== p.y &&
  			( px < ( p.next.x - p.x ) * ( py - p.y ) / ( p.next.y - p.y ) + p.x ) )
  			inside = ! inside;
  		p = p.next;

  	} while ( p !== a );

  	return inside;

  }

  // link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
  // if one belongs to the outer ring and another to a hole, it merges it into a single ring
  function splitPolygon( a, b ) {

  	const a2 = new Node( a.i, a.x, a.y ),
  		b2 = new Node( b.i, b.x, b.y ),
  		an = a.next,
  		bp = b.prev;

  	a.next = b;
  	b.prev = a;

  	a2.next = an;
  	an.prev = a2;

  	b2.next = a2;
  	a2.prev = b2;

  	bp.next = b2;
  	b2.prev = bp;

  	return b2;

  }

  // create a node and optionally link it with previous one (in a circular doubly linked list)
  function insertNode( i, x, y, last ) {

  	const p = new Node( i, x, y );

  	if ( ! last ) {

  		p.prev = p;
  		p.next = p;

  	} else {

  		p.next = last.next;
  		p.prev = last;
  		last.next.prev = p;
  		last.next = p;

  	}

  	return p;

  }

  function removeNode( p ) {

  	p.next.prev = p.prev;
  	p.prev.next = p.next;

  	if ( p.prevZ ) p.prevZ.nextZ = p.nextZ;
  	if ( p.nextZ ) p.nextZ.prevZ = p.prevZ;

  }

  function Node( i, x, y ) {

  	// vertex index in coordinates array
  	this.i = i;

  	// vertex coordinates
  	this.x = x;
  	this.y = y;

  	// previous and next vertex nodes in a polygon ring
  	this.prev = null;
  	this.next = null;

  	// z-order curve value
  	this.z = 0;

  	// previous and next nodes in z-order
  	this.prevZ = null;
  	this.nextZ = null;

  	// indicates whether this is a steiner point
  	this.steiner = false;

  }

  function signedArea( data, start, end, dim ) {

  	let sum = 0;
  	for ( let i = start, j = end - dim; i < end; i += dim ) {

  		sum += ( data[ j ] - data[ i ] ) * ( data[ i + 1 ] + data[ j + 1 ] );
  		j = i;

  	}

  	return sum;

  }

  class ShapeUtils {

  	// calculate area of the contour polygon

  	static area( contour ) {

  		const n = contour.length;
  		let a = 0.0;

  		for ( let p = n - 1, q = 0; q < n; p = q ++ ) {

  			a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

  		}

  		return a * 0.5;

  	}

  	static isClockWise( pts ) {

  		return ShapeUtils.area( pts ) < 0;

  	}

  	static triangulateShape( contour, holes ) {

  		const vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]
  		const holeIndices = []; // array of hole indices
  		const faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]

  		removeDupEndPts( contour );
  		addContour( vertices, contour );

  		//

  		let holeIndex = contour.length;

  		holes.forEach( removeDupEndPts );

  		for ( let i = 0; i < holes.length; i ++ ) {

  			holeIndices.push( holeIndex );
  			holeIndex += holes[ i ].length;
  			addContour( vertices, holes[ i ] );

  		}

  		//

  		const triangles = Earcut.triangulate( vertices, holeIndices );

  		//

  		for ( let i = 0; i < triangles.length; i += 3 ) {

  			faces.push( triangles.slice( i, i + 3 ) );

  		}

  		return faces;

  	}

  }

  function removeDupEndPts( points ) {

  	const l = points.length;

  	if ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {

  		points.pop();

  	}

  }

  function addContour( vertices, contour ) {

  	for ( let i = 0; i < contour.length; i ++ ) {

  		vertices.push( contour[ i ].x );
  		vertices.push( contour[ i ].y );

  	}

  }

  class MeshStandardMaterial extends Material {

  	constructor( parameters ) {

  		super();

  		this.isMeshStandardMaterial = true;

  		this.defines = { 'STANDARD': '' };

  		this.type = 'MeshStandardMaterial';

  		this.color = new Color( 0xffffff ); // diffuse
  		this.roughness = 1.0;
  		this.metalness = 0.0;

  		this.map = null;

  		this.lightMap = null;
  		this.lightMapIntensity = 1.0;

  		this.aoMap = null;
  		this.aoMapIntensity = 1.0;

  		this.emissive = new Color( 0x000000 );
  		this.emissiveIntensity = 1.0;
  		this.emissiveMap = null;

  		this.bumpMap = null;
  		this.bumpScale = 1;

  		this.normalMap = null;
  		this.normalMapType = TangentSpaceNormalMap;
  		this.normalScale = new Vector2( 1, 1 );

  		this.displacementMap = null;
  		this.displacementScale = 1;
  		this.displacementBias = 0;

  		this.roughnessMap = null;

  		this.metalnessMap = null;

  		this.alphaMap = null;

  		this.envMap = null;
  		this.envMapRotation = new Euler();
  		this.envMapIntensity = 1.0;

  		this.wireframe = false;
  		this.wireframeLinewidth = 1;
  		this.wireframeLinecap = 'round';
  		this.wireframeLinejoin = 'round';

  		this.flatShading = false;

  		this.fog = true;

  		this.setValues( parameters );

  	}

  	copy( source ) {

  		super.copy( source );

  		this.defines = { 'STANDARD': '' };

  		this.color.copy( source.color );
  		this.roughness = source.roughness;
  		this.metalness = source.metalness;

  		this.map = source.map;

  		this.lightMap = source.lightMap;
  		this.lightMapIntensity = source.lightMapIntensity;

  		this.aoMap = source.aoMap;
  		this.aoMapIntensity = source.aoMapIntensity;

  		this.emissive.copy( source.emissive );
  		this.emissiveMap = source.emissiveMap;
  		this.emissiveIntensity = source.emissiveIntensity;

  		this.bumpMap = source.bumpMap;
  		this.bumpScale = source.bumpScale;

  		this.normalMap = source.normalMap;
  		this.normalMapType = source.normalMapType;
  		this.normalScale.copy( source.normalScale );

  		this.displacementMap = source.displacementMap;
  		this.displacementScale = source.displacementScale;
  		this.displacementBias = source.displacementBias;

  		this.roughnessMap = source.roughnessMap;

  		this.metalnessMap = source.metalnessMap;

  		this.alphaMap = source.alphaMap;

  		this.envMap = source.envMap;
  		this.envMapRotation.copy( source.envMapRotation );
  		this.envMapIntensity = source.envMapIntensity;

  		this.wireframe = source.wireframe;
  		this.wireframeLinewidth = source.wireframeLinewidth;
  		this.wireframeLinecap = source.wireframeLinecap;
  		this.wireframeLinejoin = source.wireframeLinejoin;

  		this.flatShading = source.flatShading;

  		this.fog = source.fog;

  		return this;

  	}

  }

  class MeshPhysicalMaterial extends MeshStandardMaterial {

  	constructor( parameters ) {

  		super();

  		this.isMeshPhysicalMaterial = true;

  		this.defines = {

  			'STANDARD': '',
  			'PHYSICAL': ''

  		};

  		this.type = 'MeshPhysicalMaterial';

  		this.anisotropyRotation = 0;
  		this.anisotropyMap = null;

  		this.clearcoatMap = null;
  		this.clearcoatRoughness = 0.0;
  		this.clearcoatRoughnessMap = null;
  		this.clearcoatNormalScale = new Vector2( 1, 1 );
  		this.clearcoatNormalMap = null;

  		this.ior = 1.5;

  		Object.defineProperty( this, 'reflectivity', {
  			get: function () {

  				return ( clamp( 2.5 * ( this.ior - 1 ) / ( this.ior + 1 ), 0, 1 ) );

  			},
  			set: function ( reflectivity ) {

  				this.ior = ( 1 + 0.4 * reflectivity ) / ( 1 - 0.4 * reflectivity );

  			}
  		} );

  		this.iridescenceMap = null;
  		this.iridescenceIOR = 1.3;
  		this.iridescenceThicknessRange = [ 100, 400 ];
  		this.iridescenceThicknessMap = null;

  		this.sheenColor = new Color( 0x000000 );
  		this.sheenColorMap = null;
  		this.sheenRoughness = 1.0;
  		this.sheenRoughnessMap = null;

  		this.transmissionMap = null;

  		this.thickness = 0;
  		this.thicknessMap = null;
  		this.attenuationDistance = Infinity;
  		this.attenuationColor = new Color( 1, 1, 1 );

  		this.specularIntensity = 1.0;
  		this.specularIntensityMap = null;
  		this.specularColor = new Color( 1, 1, 1 );
  		this.specularColorMap = null;

  		this._anisotropy = 0;
  		this._clearcoat = 0;
  		this._dispersion = 0;
  		this._iridescence = 0;
  		this._sheen = 0.0;
  		this._transmission = 0;

  		this.setValues( parameters );

  	}

  	get anisotropy() {

  		return this._anisotropy;

  	}

  	set anisotropy( value ) {

  		if ( this._anisotropy > 0 !== value > 0 ) {

  			this.version ++;

  		}

  		this._anisotropy = value;

  	}

  	get clearcoat() {

  		return this._clearcoat;

  	}

  	set clearcoat( value ) {

  		if ( this._clearcoat > 0 !== value > 0 ) {

  			this.version ++;

  		}

  		this._clearcoat = value;

  	}

  	get iridescence() {

  		return this._iridescence;

  	}

  	set iridescence( value ) {

  		if ( this._iridescence > 0 !== value > 0 ) {

  			this.version ++;

  		}

  		this._iridescence = value;

  	}

  	get dispersion() {

  		return this._dispersion;

  	}

  	set dispersion( value ) {

  		if ( this._dispersion > 0 !== value > 0 ) {

  			this.version ++;

  		}

  		this._dispersion = value;

  	}

  	get sheen() {

  		return this._sheen;

  	}

  	set sheen( value ) {

  		if ( this._sheen > 0 !== value > 0 ) {

  			this.version ++;

  		}

  		this._sheen = value;

  	}

  	get transmission() {

  		return this._transmission;

  	}

  	set transmission( value ) {

  		if ( this._transmission > 0 !== value > 0 ) {

  			this.version ++;

  		}

  		this._transmission = value;

  	}

  	copy( source ) {

  		super.copy( source );

  		this.defines = {

  			'STANDARD': '',
  			'PHYSICAL': ''

  		};

  		this.anisotropy = source.anisotropy;
  		this.anisotropyRotation = source.anisotropyRotation;
  		this.anisotropyMap = source.anisotropyMap;

  		this.clearcoat = source.clearcoat;
  		this.clearcoatMap = source.clearcoatMap;
  		this.clearcoatRoughness = source.clearcoatRoughness;
  		this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
  		this.clearcoatNormalMap = source.clearcoatNormalMap;
  		this.clearcoatNormalScale.copy( source.clearcoatNormalScale );

  		this.dispersion = source.dispersion;
  		this.ior = source.ior;

  		this.iridescence = source.iridescence;
  		this.iridescenceMap = source.iridescenceMap;
  		this.iridescenceIOR = source.iridescenceIOR;
  		this.iridescenceThicknessRange = [ ...source.iridescenceThicknessRange ];
  		this.iridescenceThicknessMap = source.iridescenceThicknessMap;

  		this.sheen = source.sheen;
  		this.sheenColor.copy( source.sheenColor );
  		this.sheenColorMap = source.sheenColorMap;
  		this.sheenRoughness = source.sheenRoughness;
  		this.sheenRoughnessMap = source.sheenRoughnessMap;

  		this.transmission = source.transmission;
  		this.transmissionMap = source.transmissionMap;

  		this.thickness = source.thickness;
  		this.thicknessMap = source.thicknessMap;
  		this.attenuationDistance = source.attenuationDistance;
  		this.attenuationColor.copy( source.attenuationColor );

  		this.specularIntensity = source.specularIntensity;
  		this.specularIntensityMap = source.specularIntensityMap;
  		this.specularColor.copy( source.specularColor );
  		this.specularColorMap = source.specularColorMap;

  		return this;

  	}

  }

  class MeshPhongMaterial extends Material {

  	constructor( parameters ) {

  		super();

  		this.isMeshPhongMaterial = true;

  		this.type = 'MeshPhongMaterial';

  		this.color = new Color( 0xffffff ); // diffuse
  		this.specular = new Color( 0x111111 );
  		this.shininess = 30;

  		this.map = null;

  		this.lightMap = null;
  		this.lightMapIntensity = 1.0;

  		this.aoMap = null;
  		this.aoMapIntensity = 1.0;

  		this.emissive = new Color( 0x000000 );
  		this.emissiveIntensity = 1.0;
  		this.emissiveMap = null;

  		this.bumpMap = null;
  		this.bumpScale = 1;

  		this.normalMap = null;
  		this.normalMapType = TangentSpaceNormalMap;
  		this.normalScale = new Vector2( 1, 1 );

  		this.displacementMap = null;
  		this.displacementScale = 1;
  		this.displacementBias = 0;

  		this.specularMap = null;

  		this.alphaMap = null;

  		this.envMap = null;
  		this.envMapRotation = new Euler();
  		this.combine = MultiplyOperation;
  		this.reflectivity = 1;
  		this.refractionRatio = 0.98;

  		this.wireframe = false;
  		this.wireframeLinewidth = 1;
  		this.wireframeLinecap = 'round';
  		this.wireframeLinejoin = 'round';

  		this.flatShading = false;

  		this.fog = true;

  		this.setValues( parameters );

  	}

  	copy( source ) {

  		super.copy( source );

  		this.color.copy( source.color );
  		this.specular.copy( source.specular );
  		this.shininess = source.shininess;

  		this.map = source.map;

  		this.lightMap = source.lightMap;
  		this.lightMapIntensity = source.lightMapIntensity;

  		this.aoMap = source.aoMap;
  		this.aoMapIntensity = source.aoMapIntensity;

  		this.emissive.copy( source.emissive );
  		this.emissiveMap = source.emissiveMap;
  		this.emissiveIntensity = source.emissiveIntensity;

  		this.bumpMap = source.bumpMap;
  		this.bumpScale = source.bumpScale;

  		this.normalMap = source.normalMap;
  		this.normalMapType = source.normalMapType;
  		this.normalScale.copy( source.normalScale );

  		this.displacementMap = source.displacementMap;
  		this.displacementScale = source.displacementScale;
  		this.displacementBias = source.displacementBias;

  		this.specularMap = source.specularMap;

  		this.alphaMap = source.alphaMap;

  		this.envMap = source.envMap;
  		this.envMapRotation.copy( source.envMapRotation );
  		this.combine = source.combine;
  		this.reflectivity = source.reflectivity;
  		this.refractionRatio = source.refractionRatio;

  		this.wireframe = source.wireframe;
  		this.wireframeLinewidth = source.wireframeLinewidth;
  		this.wireframeLinecap = source.wireframeLinecap;
  		this.wireframeLinejoin = source.wireframeLinejoin;

  		this.flatShading = source.flatShading;

  		this.fog = source.fog;

  		return this;

  	}

  }

  class MeshLambertMaterial extends Material {

  	constructor( parameters ) {

  		super();

  		this.isMeshLambertMaterial = true;

  		this.type = 'MeshLambertMaterial';

  		this.color = new Color( 0xffffff ); // diffuse

  		this.map = null;

  		this.lightMap = null;
  		this.lightMapIntensity = 1.0;

  		this.aoMap = null;
  		this.aoMapIntensity = 1.0;

  		this.emissive = new Color( 0x000000 );
  		this.emissiveIntensity = 1.0;
  		this.emissiveMap = null;

  		this.bumpMap = null;
  		this.bumpScale = 1;

  		this.normalMap = null;
  		this.normalMapType = TangentSpaceNormalMap;
  		this.normalScale = new Vector2( 1, 1 );

  		this.displacementMap = null;
  		this.displacementScale = 1;
  		this.displacementBias = 0;

  		this.specularMap = null;

  		this.alphaMap = null;

  		this.envMap = null;
  		this.envMapRotation = new Euler();
  		this.combine = MultiplyOperation;
  		this.reflectivity = 1;
  		this.refractionRatio = 0.98;

  		this.wireframe = false;
  		this.wireframeLinewidth = 1;
  		this.wireframeLinecap = 'round';
  		this.wireframeLinejoin = 'round';

  		this.flatShading = false;

  		this.fog = true;

  		this.setValues( parameters );

  	}

  	copy( source ) {

  		super.copy( source );

  		this.color.copy( source.color );

  		this.map = source.map;

  		this.lightMap = source.lightMap;
  		this.lightMapIntensity = source.lightMapIntensity;

  		this.aoMap = source.aoMap;
  		this.aoMapIntensity = source.aoMapIntensity;

  		this.emissive.copy( source.emissive );
  		this.emissiveMap = source.emissiveMap;
  		this.emissiveIntensity = source.emissiveIntensity;

  		this.bumpMap = source.bumpMap;
  		this.bumpScale = source.bumpScale;

  		this.normalMap = source.normalMap;
  		this.normalMapType = source.normalMapType;
  		this.normalScale.copy( source.normalScale );

  		this.displacementMap = source.displacementMap;
  		this.displacementScale = source.displacementScale;
  		this.displacementBias = source.displacementBias;

  		this.specularMap = source.specularMap;

  		this.alphaMap = source.alphaMap;

  		this.envMap = source.envMap;
  		this.envMapRotation.copy( source.envMapRotation );
  		this.combine = source.combine;
  		this.reflectivity = source.reflectivity;
  		this.refractionRatio = source.refractionRatio;

  		this.wireframe = source.wireframe;
  		this.wireframeLinewidth = source.wireframeLinewidth;
  		this.wireframeLinecap = source.wireframeLinecap;
  		this.wireframeLinejoin = source.wireframeLinejoin;

  		this.flatShading = source.flatShading;

  		this.fog = source.fog;

  		return this;

  	}

  }

  // converts an array to a specific type
  function convertArray( array, type, forceClone ) {

  	if ( ! array || // let 'undefined' and 'null' pass
  		! forceClone && array.constructor === type ) return array;

  	if ( typeof type.BYTES_PER_ELEMENT === 'number' ) {

  		return new type( array ); // create typed array

  	}

  	return Array.prototype.slice.call( array ); // create Array

  }

  function isTypedArray( object ) {

  	return ArrayBuffer.isView( object ) &&
  		! ( object instanceof DataView );

  }

  // returns an array by which times and values can be sorted
  function getKeyframeOrder( times ) {

  	function compareTime( i, j ) {

  		return times[ i ] - times[ j ];

  	}

  	const n = times.length;
  	const result = new Array( n );
  	for ( let i = 0; i !== n; ++ i ) result[ i ] = i;

  	result.sort( compareTime );

  	return result;

  }

  // uses the array previously returned by 'getKeyframeOrder' to sort data
  function sortedArray( values, stride, order ) {

  	const nValues = values.length;
  	const result = new values.constructor( nValues );

  	for ( let i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {

  		const srcOffset = order[ i ] * stride;

  		for ( let j = 0; j !== stride; ++ j ) {

  			result[ dstOffset ++ ] = values[ srcOffset + j ];

  		}

  	}

  	return result;

  }

  // function for parsing AOS keyframe formats
  function flattenJSON( jsonKeys, times, values, valuePropertyName ) {

  	let i = 1, key = jsonKeys[ 0 ];

  	while ( key !== undefined && key[ valuePropertyName ] === undefined ) {

  		key = jsonKeys[ i ++ ];

  	}

  	if ( key === undefined ) return; // no data

  	let value = key[ valuePropertyName ];
  	if ( value === undefined ) return; // no data

  	if ( Array.isArray( value ) ) {

  		do {

  			value = key[ valuePropertyName ];

  			if ( value !== undefined ) {

  				times.push( key.time );
  				values.push.apply( values, value ); // push all elements

  			}

  			key = jsonKeys[ i ++ ];

  		} while ( key !== undefined );

  	} else if ( value.toArray !== undefined ) {

  		// ...assume THREE.Math-ish

  		do {

  			value = key[ valuePropertyName ];

  			if ( value !== undefined ) {

  				times.push( key.time );
  				value.toArray( values, values.length );

  			}

  			key = jsonKeys[ i ++ ];

  		} while ( key !== undefined );

  	} else {

  		// otherwise push as-is

  		do {

  			value = key[ valuePropertyName ];

  			if ( value !== undefined ) {

  				times.push( key.time );
  				values.push( value );

  			}

  			key = jsonKeys[ i ++ ];

  		} while ( key !== undefined );

  	}

  }

  /**
   * Abstract base class of interpolants over parametric samples.
   *
   * The parameter domain is one dimensional, typically the time or a path
   * along a curve defined by the data.
   *
   * The sample values can have any dimensionality and derived classes may
   * apply special interpretations to the data.
   *
   * This class provides the interval seek in a Template Method, deferring
   * the actual interpolation to derived classes.
   *
   * Time complexity is O(1) for linear access crossing at most two points
   * and O(log N) for random access, where N is the number of positions.
   *
   * References:
   *
   * 		http://www.oodesign.com/template-method-pattern.html
   *
   */

  class Interpolant {

  	constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

  		this.parameterPositions = parameterPositions;
  		this._cachedIndex = 0;

  		this.resultBuffer = resultBuffer !== undefined ?
  			resultBuffer : new sampleValues.constructor( sampleSize );
  		this.sampleValues = sampleValues;
  		this.valueSize = sampleSize;

  		this.settings = null;
  		this.DefaultSettings_ = {};

  	}

  	evaluate( t ) {

  		const pp = this.parameterPositions;
  		let i1 = this._cachedIndex,
  			t1 = pp[ i1 ],
  			t0 = pp[ i1 - 1 ];

  		validate_interval: {

  			seek: {

  				let right;

  				linear_scan: {

  					//- See http://jsperf.com/comparison-to-undefined/3
  					//- slower code:
  					//-
  					//- 				if ( t >= t1 || t1 === undefined ) {
  					forward_scan: if ( ! ( t < t1 ) ) {

  						for ( let giveUpAt = i1 + 2; ; ) {

  							if ( t1 === undefined ) {

  								if ( t < t0 ) break forward_scan;

  								// after end

  								i1 = pp.length;
  								this._cachedIndex = i1;
  								return this.copySampleValue_( i1 - 1 );

  							}

  							if ( i1 === giveUpAt ) break; // this loop

  							t0 = t1;
  							t1 = pp[ ++ i1 ];

  							if ( t < t1 ) {

  								// we have arrived at the sought interval
  								break seek;

  							}

  						}

  						// prepare binary search on the right side of the index
  						right = pp.length;
  						break linear_scan;

  					}

  					//- slower code:
  					//-					if ( t < t0 || t0 === undefined ) {
  					if ( ! ( t >= t0 ) ) {

  						// looping?

  						const t1global = pp[ 1 ];

  						if ( t < t1global ) {

  							i1 = 2; // + 1, using the scan for the details
  							t0 = t1global;

  						}

  						// linear reverse scan

  						for ( let giveUpAt = i1 - 2; ; ) {

  							if ( t0 === undefined ) {

  								// before start

  								this._cachedIndex = 0;
  								return this.copySampleValue_( 0 );

  							}

  							if ( i1 === giveUpAt ) break; // this loop

  							t1 = t0;
  							t0 = pp[ -- i1 - 1 ];

  							if ( t >= t0 ) {

  								// we have arrived at the sought interval
  								break seek;

  							}

  						}

  						// prepare binary search on the left side of the index
  						right = i1;
  						i1 = 0;
  						break linear_scan;

  					}

  					// the interval is valid

  					break validate_interval;

  				} // linear scan

  				// binary search

  				while ( i1 < right ) {

  					const mid = ( i1 + right ) >>> 1;

  					if ( t < pp[ mid ] ) {

  						right = mid;

  					} else {

  						i1 = mid + 1;

  					}

  				}

  				t1 = pp[ i1 ];
  				t0 = pp[ i1 - 1 ];

  				// check boundary cases, again

  				if ( t0 === undefined ) {

  					this._cachedIndex = 0;
  					return this.copySampleValue_( 0 );

  				}

  				if ( t1 === undefined ) {

  					i1 = pp.length;
  					this._cachedIndex = i1;
  					return this.copySampleValue_( i1 - 1 );

  				}

  			} // seek

  			this._cachedIndex = i1;

  			this.intervalChanged_( i1, t0, t1 );

  		} // validate_interval

  		return this.interpolate_( i1, t0, t, t1 );

  	}

  	getSettings_() {

  		return this.settings || this.DefaultSettings_;

  	}

  	copySampleValue_( index ) {

  		// copies a sample value to the result buffer

  		const result = this.resultBuffer,
  			values = this.sampleValues,
  			stride = this.valueSize,
  			offset = index * stride;

  		for ( let i = 0; i !== stride; ++ i ) {

  			result[ i ] = values[ offset + i ];

  		}

  		return result;

  	}

  	// Template methods for derived classes:

  	interpolate_( /* i1, t0, t, t1 */ ) {

  		throw new Error( 'call to abstract method' );
  		// implementations shall return this.resultBuffer

  	}

  	intervalChanged_( /* i1, t0, t1 */ ) {

  		// empty

  	}

  }

  /**
   * Fast and simple cubic spline interpolant.
   *
   * It was derived from a Hermitian construction setting the first derivative
   * at each sample position to the linear slope between neighboring positions
   * over their parameter interval.
   */

  class CubicInterpolant extends Interpolant {

  	constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

  		super( parameterPositions, sampleValues, sampleSize, resultBuffer );

  		this._weightPrev = - 0;
  		this._offsetPrev = - 0;
  		this._weightNext = - 0;
  		this._offsetNext = - 0;

  		this.DefaultSettings_ = {

  			endingStart: ZeroCurvatureEnding,
  			endingEnd: ZeroCurvatureEnding

  		};

  	}

  	intervalChanged_( i1, t0, t1 ) {

  		const pp = this.parameterPositions;
  		let iPrev = i1 - 2,
  			iNext = i1 + 1,

  			tPrev = pp[ iPrev ],
  			tNext = pp[ iNext ];

  		if ( tPrev === undefined ) {

  			switch ( this.getSettings_().endingStart ) {

  				case ZeroSlopeEnding:

  					// f'(t0) = 0
  					iPrev = i1;
  					tPrev = 2 * t0 - t1;

  					break;

  				case WrapAroundEnding:

  					// use the other end of the curve
  					iPrev = pp.length - 2;
  					tPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];

  					break;

  				default: // ZeroCurvatureEnding

  					// f''(t0) = 0 a.k.a. Natural Spline
  					iPrev = i1;
  					tPrev = t1;

  			}

  		}

  		if ( tNext === undefined ) {

  			switch ( this.getSettings_().endingEnd ) {

  				case ZeroSlopeEnding:

  					// f'(tN) = 0
  					iNext = i1;
  					tNext = 2 * t1 - t0;

  					break;

  				case WrapAroundEnding:

  					// use the other end of the curve
  					iNext = 1;
  					tNext = t1 + pp[ 1 ] - pp[ 0 ];

  					break;

  				default: // ZeroCurvatureEnding

  					// f''(tN) = 0, a.k.a. Natural Spline
  					iNext = i1 - 1;
  					tNext = t0;

  			}

  		}

  		const halfDt = ( t1 - t0 ) * 0.5,
  			stride = this.valueSize;

  		this._weightPrev = halfDt / ( t0 - tPrev );
  		this._weightNext = halfDt / ( tNext - t1 );
  		this._offsetPrev = iPrev * stride;
  		this._offsetNext = iNext * stride;

  	}

  	interpolate_( i1, t0, t, t1 ) {

  		const result = this.resultBuffer,
  			values = this.sampleValues,
  			stride = this.valueSize,

  			o1 = i1 * stride,		o0 = o1 - stride,
  			oP = this._offsetPrev, 	oN = this._offsetNext,
  			wP = this._weightPrev,	wN = this._weightNext,

  			p = ( t - t0 ) / ( t1 - t0 ),
  			pp = p * p,
  			ppp = pp * p;

  		// evaluate polynomials

  		const sP = - wP * ppp + 2 * wP * pp - wP * p;
  		const s0 = ( 1 + wP ) * ppp + ( - 1.5 - 2 * wP ) * pp + ( - 0.5 + wP ) * p + 1;
  		const s1 = ( - 1 - wN ) * ppp + ( 1.5 + wN ) * pp + 0.5 * p;
  		const sN = wN * ppp - wN * pp;

  		// combine data linearly

  		for ( let i = 0; i !== stride; ++ i ) {

  			result[ i ] =
  					sP * values[ oP + i ] +
  					s0 * values[ o0 + i ] +
  					s1 * values[ o1 + i ] +
  					sN * values[ oN + i ];

  		}

  		return result;

  	}

  }

  class LinearInterpolant extends Interpolant {

  	constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

  		super( parameterPositions, sampleValues, sampleSize, resultBuffer );

  	}

  	interpolate_( i1, t0, t, t1 ) {

  		const result = this.resultBuffer,
  			values = this.sampleValues,
  			stride = this.valueSize,

  			offset1 = i1 * stride,
  			offset0 = offset1 - stride,

  			weight1 = ( t - t0 ) / ( t1 - t0 ),
  			weight0 = 1 - weight1;

  		for ( let i = 0; i !== stride; ++ i ) {

  			result[ i ] =
  					values[ offset0 + i ] * weight0 +
  					values[ offset1 + i ] * weight1;

  		}

  		return result;

  	}

  }

  /**
   *
   * Interpolant that evaluates to the sample value at the position preceding
   * the parameter.
   */

  class DiscreteInterpolant extends Interpolant {

  	constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

  		super( parameterPositions, sampleValues, sampleSize, resultBuffer );

  	}

  	interpolate_( i1 /*, t0, t, t1 */ ) {

  		return this.copySampleValue_( i1 - 1 );

  	}

  }

  class KeyframeTrack {

  	constructor( name, times, values, interpolation ) {

  		if ( name === undefined ) throw new Error( 'THREE.KeyframeTrack: track name is undefined' );
  		if ( times === undefined || times.length === 0 ) throw new Error( 'THREE.KeyframeTrack: no keyframes in track named ' + name );

  		this.name = name;

  		this.times = convertArray( times, this.TimeBufferType );
  		this.values = convertArray( values, this.ValueBufferType );

  		this.setInterpolation( interpolation || this.DefaultInterpolation );

  	}

  	// Serialization (in static context, because of constructor invocation
  	// and automatic invocation of .toJSON):

  	static toJSON( track ) {

  		const trackType = track.constructor;

  		let json;

  		// derived classes can define a static toJSON method
  		if ( trackType.toJSON !== this.toJSON ) {

  			json = trackType.toJSON( track );

  		} else {

  			// by default, we assume the data can be serialized as-is
  			json = {

  				'name': track.name,
  				'times': convertArray( track.times, Array ),
  				'values': convertArray( track.values, Array )

  			};

  			const interpolation = track.getInterpolation();

  			if ( interpolation !== track.DefaultInterpolation ) {

  				json.interpolation = interpolation;

  			}

  		}

  		json.type = track.ValueTypeName; // mandatory

  		return json;

  	}

  	InterpolantFactoryMethodDiscrete( result ) {

  		return new DiscreteInterpolant( this.times, this.values, this.getValueSize(), result );

  	}

  	InterpolantFactoryMethodLinear( result ) {

  		return new LinearInterpolant( this.times, this.values, this.getValueSize(), result );

  	}

  	InterpolantFactoryMethodSmooth( result ) {

  		return new CubicInterpolant( this.times, this.values, this.getValueSize(), result );

  	}

  	setInterpolation( interpolation ) {

  		let factoryMethod;

  		switch ( interpolation ) {

  			case InterpolateDiscrete:

  				factoryMethod = this.InterpolantFactoryMethodDiscrete;

  				break;

  			case InterpolateLinear:

  				factoryMethod = this.InterpolantFactoryMethodLinear;

  				break;

  			case InterpolateSmooth:

  				factoryMethod = this.InterpolantFactoryMethodSmooth;

  				break;

  		}

  		if ( factoryMethod === undefined ) {

  			const message = 'unsupported interpolation for ' +
  				this.ValueTypeName + ' keyframe track named ' + this.name;

  			if ( this.createInterpolant === undefined ) {

  				// fall back to default, unless the default itself is messed up
  				if ( interpolation !== this.DefaultInterpolation ) {

  					this.setInterpolation( this.DefaultInterpolation );

  				} else {

  					throw new Error( message ); // fatal, in this case

  				}

  			}

  			console.warn( 'THREE.KeyframeTrack:', message );
  			return this;

  		}

  		this.createInterpolant = factoryMethod;

  		return this;

  	}

  	getInterpolation() {

  		switch ( this.createInterpolant ) {

  			case this.InterpolantFactoryMethodDiscrete:

  				return InterpolateDiscrete;

  			case this.InterpolantFactoryMethodLinear:

  				return InterpolateLinear;

  			case this.InterpolantFactoryMethodSmooth:

  				return InterpolateSmooth;

  		}

  	}

  	getValueSize() {

  		return this.values.length / this.times.length;

  	}

  	// move all keyframes either forwards or backwards in time
  	shift( timeOffset ) {

  		if ( timeOffset !== 0.0 ) {

  			const times = this.times;

  			for ( let i = 0, n = times.length; i !== n; ++ i ) {

  				times[ i ] += timeOffset;

  			}

  		}

  		return this;

  	}

  	// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
  	scale( timeScale ) {

  		if ( timeScale !== 1.0 ) {

  			const times = this.times;

  			for ( let i = 0, n = times.length; i !== n; ++ i ) {

  				times[ i ] *= timeScale;

  			}

  		}

  		return this;

  	}

  	// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
  	// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
  	trim( startTime, endTime ) {

  		const times = this.times,
  			nKeys = times.length;

  		let from = 0,
  			to = nKeys - 1;

  		while ( from !== nKeys && times[ from ] < startTime ) {

  			++ from;

  		}

  		while ( to !== - 1 && times[ to ] > endTime ) {

  			-- to;

  		}

  		++ to; // inclusive -> exclusive bound

  		if ( from !== 0 || to !== nKeys ) {

  			// empty tracks are forbidden, so keep at least one keyframe
  			if ( from >= to ) {

  				to = Math.max( to, 1 );
  				from = to - 1;

  			}

  			const stride = this.getValueSize();
  			this.times = times.slice( from, to );
  			this.values = this.values.slice( from * stride, to * stride );

  		}

  		return this;

  	}

  	// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
  	validate() {

  		let valid = true;

  		const valueSize = this.getValueSize();
  		if ( valueSize - Math.floor( valueSize ) !== 0 ) {

  			console.error( 'THREE.KeyframeTrack: Invalid value size in track.', this );
  			valid = false;

  		}

  		const times = this.times,
  			values = this.values,

  			nKeys = times.length;

  		if ( nKeys === 0 ) {

  			console.error( 'THREE.KeyframeTrack: Track is empty.', this );
  			valid = false;

  		}

  		let prevTime = null;

  		for ( let i = 0; i !== nKeys; i ++ ) {

  			const currTime = times[ i ];

  			if ( typeof currTime === 'number' && isNaN( currTime ) ) {

  				console.error( 'THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime );
  				valid = false;
  				break;

  			}

  			if ( prevTime !== null && prevTime > currTime ) {

  				console.error( 'THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime );
  				valid = false;
  				break;

  			}

  			prevTime = currTime;

  		}

  		if ( values !== undefined ) {

  			if ( isTypedArray( values ) ) {

  				for ( let i = 0, n = values.length; i !== n; ++ i ) {

  					const value = values[ i ];

  					if ( isNaN( value ) ) {

  						console.error( 'THREE.KeyframeTrack: Value is not a valid number.', this, i, value );
  						valid = false;
  						break;

  					}

  				}

  			}

  		}

  		return valid;

  	}

  	// removes equivalent sequential keys as common in morph target sequences
  	// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
  	optimize() {

  		// times or values may be shared with other tracks, so overwriting is unsafe
  		const times = this.times.slice(),
  			values = this.values.slice(),
  			stride = this.getValueSize(),

  			smoothInterpolation = this.getInterpolation() === InterpolateSmooth,

  			lastIndex = times.length - 1;

  		let writeIndex = 1;

  		for ( let i = 1; i < lastIndex; ++ i ) {

  			let keep = false;

  			const time = times[ i ];
  			const timeNext = times[ i + 1 ];

  			// remove adjacent keyframes scheduled at the same time

  			if ( time !== timeNext && ( i !== 1 || time !== times[ 0 ] ) ) {

  				if ( ! smoothInterpolation ) {

  					// remove unnecessary keyframes same as their neighbors

  					const offset = i * stride,
  						offsetP = offset - stride,
  						offsetN = offset + stride;

  					for ( let j = 0; j !== stride; ++ j ) {

  						const value = values[ offset + j ];

  						if ( value !== values[ offsetP + j ] ||
  							value !== values[ offsetN + j ] ) {

  							keep = true;
  							break;

  						}

  					}

  				} else {

  					keep = true;

  				}

  			}

  			// in-place compaction

  			if ( keep ) {

  				if ( i !== writeIndex ) {

  					times[ writeIndex ] = times[ i ];

  					const readOffset = i * stride,
  						writeOffset = writeIndex * stride;

  					for ( let j = 0; j !== stride; ++ j ) {

  						values[ writeOffset + j ] = values[ readOffset + j ];

  					}

  				}

  				++ writeIndex;

  			}

  		}

  		// flush last keyframe (compaction looks ahead)

  		if ( lastIndex > 0 ) {

  			times[ writeIndex ] = times[ lastIndex ];

  			for ( let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j ) {

  				values[ writeOffset + j ] = values[ readOffset + j ];

  			}

  			++ writeIndex;

  		}

  		if ( writeIndex !== times.length ) {

  			this.times = times.slice( 0, writeIndex );
  			this.values = values.slice( 0, writeIndex * stride );

  		} else {

  			this.times = times;
  			this.values = values;

  		}

  		return this;

  	}

  	clone() {

  		const times = this.times.slice();
  		const values = this.values.slice();

  		const TypedKeyframeTrack = this.constructor;
  		const track = new TypedKeyframeTrack( this.name, times, values );

  		// Interpolant argument to constructor is not saved, so copy the factory method directly.
  		track.createInterpolant = this.createInterpolant;

  		return track;

  	}

  }

  KeyframeTrack.prototype.TimeBufferType = Float32Array;
  KeyframeTrack.prototype.ValueBufferType = Float32Array;
  KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;

  /**
   * A Track of Boolean keyframe values.
   */
  class BooleanKeyframeTrack extends KeyframeTrack {

  	// No interpolation parameter because only InterpolateDiscrete is valid.
  	constructor( name, times, values ) {

  		super( name, times, values );

  	}

  }

  BooleanKeyframeTrack.prototype.ValueTypeName = 'bool';
  BooleanKeyframeTrack.prototype.ValueBufferType = Array;
  BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
  BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
  BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

  /**
   * A Track of keyframe values that represent color.
   */
  class ColorKeyframeTrack extends KeyframeTrack {}

  ColorKeyframeTrack.prototype.ValueTypeName = 'color';

  /**
   * A Track of numeric keyframe values.
   */
  class NumberKeyframeTrack extends KeyframeTrack {}

  NumberKeyframeTrack.prototype.ValueTypeName = 'number';

  /**
   * Spherical linear unit quaternion interpolant.
   */

  class QuaternionLinearInterpolant extends Interpolant {

  	constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

  		super( parameterPositions, sampleValues, sampleSize, resultBuffer );

  	}

  	interpolate_( i1, t0, t, t1 ) {

  		const result = this.resultBuffer,
  			values = this.sampleValues,
  			stride = this.valueSize,

  			alpha = ( t - t0 ) / ( t1 - t0 );

  		let offset = i1 * stride;

  		for ( let end = offset + stride; offset !== end; offset += 4 ) {

  			Quaternion.slerpFlat( result, 0, values, offset - stride, values, offset, alpha );

  		}

  		return result;

  	}

  }

  /**
   * A Track of quaternion keyframe values.
   */
  class QuaternionKeyframeTrack extends KeyframeTrack {

  	InterpolantFactoryMethodLinear( result ) {

  		return new QuaternionLinearInterpolant( this.times, this.values, this.getValueSize(), result );

  	}

  }

  QuaternionKeyframeTrack.prototype.ValueTypeName = 'quaternion';
  // ValueBufferType is inherited
  // DefaultInterpolation is inherited;
  QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

  /**
   * A Track that interpolates Strings
   */
  class StringKeyframeTrack extends KeyframeTrack {

  	// No interpolation parameter because only InterpolateDiscrete is valid.
  	constructor( name, times, values ) {

  		super( name, times, values );

  	}

  }

  StringKeyframeTrack.prototype.ValueTypeName = 'string';
  StringKeyframeTrack.prototype.ValueBufferType = Array;
  StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
  StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
  StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

  /**
   * A Track of vectored keyframe values.
   */
  class VectorKeyframeTrack extends KeyframeTrack {}

  VectorKeyframeTrack.prototype.ValueTypeName = 'vector';

  class AnimationClip {

  	constructor( name = '', duration = - 1, tracks = [], blendMode = NormalAnimationBlendMode ) {

  		this.name = name;
  		this.tracks = tracks;
  		this.duration = duration;
  		this.blendMode = blendMode;

  		this.uuid = generateUUID();

  		// this means it should figure out its duration by scanning the tracks
  		if ( this.duration < 0 ) {

  			this.resetDuration();

  		}

  	}


  	static parse( json ) {

  		const tracks = [],
  			jsonTracks = json.tracks,
  			frameTime = 1.0 / ( json.fps || 1.0 );

  		for ( let i = 0, n = jsonTracks.length; i !== n; ++ i ) {

  			tracks.push( parseKeyframeTrack( jsonTracks[ i ] ).scale( frameTime ) );

  		}

  		const clip = new this( json.name, json.duration, tracks, json.blendMode );
  		clip.uuid = json.uuid;

  		return clip;

  	}

  	static toJSON( clip ) {

  		const tracks = [],
  			clipTracks = clip.tracks;

  		const json = {

  			'name': clip.name,
  			'duration': clip.duration,
  			'tracks': tracks,
  			'uuid': clip.uuid,
  			'blendMode': clip.blendMode

  		};

  		for ( let i = 0, n = clipTracks.length; i !== n; ++ i ) {

  			tracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );

  		}

  		return json;

  	}

  	static CreateFromMorphTargetSequence( name, morphTargetSequence, fps, noLoop ) {

  		const numMorphTargets = morphTargetSequence.length;
  		const tracks = [];

  		for ( let i = 0; i < numMorphTargets; i ++ ) {

  			let times = [];
  			let values = [];

  			times.push(
  				( i + numMorphTargets - 1 ) % numMorphTargets,
  				i,
  				( i + 1 ) % numMorphTargets );

  			values.push( 0, 1, 0 );

  			const order = getKeyframeOrder( times );
  			times = sortedArray( times, 1, order );
  			values = sortedArray( values, 1, order );

  			// if there is a key at the first frame, duplicate it as the
  			// last frame as well for perfect loop.
  			if ( ! noLoop && times[ 0 ] === 0 ) {

  				times.push( numMorphTargets );
  				values.push( values[ 0 ] );

  			}

  			tracks.push(
  				new NumberKeyframeTrack(
  					'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',
  					times, values
  				).scale( 1.0 / fps ) );

  		}

  		return new this( name, - 1, tracks );

  	}

  	static findByName( objectOrClipArray, name ) {

  		let clipArray = objectOrClipArray;

  		if ( ! Array.isArray( objectOrClipArray ) ) {

  			const o = objectOrClipArray;
  			clipArray = o.geometry && o.geometry.animations || o.animations;

  		}

  		for ( let i = 0; i < clipArray.length; i ++ ) {

  			if ( clipArray[ i ].name === name ) {

  				return clipArray[ i ];

  			}

  		}

  		return null;

  	}

  	static CreateClipsFromMorphTargetSequences( morphTargets, fps, noLoop ) {

  		const animationToMorphTargets = {};

  		// tested with https://regex101.com/ on trick sequences
  		// such flamingo_flyA_003, flamingo_run1_003, crdeath0059
  		const pattern = /^([\w-]*?)([\d]+)$/;

  		// sort morph target names into animation groups based
  		// patterns like Walk_001, Walk_002, Run_001, Run_002
  		for ( let i = 0, il = morphTargets.length; i < il; i ++ ) {

  			const morphTarget = morphTargets[ i ];
  			const parts = morphTarget.name.match( pattern );

  			if ( parts && parts.length > 1 ) {

  				const name = parts[ 1 ];

  				let animationMorphTargets = animationToMorphTargets[ name ];

  				if ( ! animationMorphTargets ) {

  					animationToMorphTargets[ name ] = animationMorphTargets = [];

  				}

  				animationMorphTargets.push( morphTarget );

  			}

  		}

  		const clips = [];

  		for ( const name in animationToMorphTargets ) {

  			clips.push( this.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );

  		}

  		return clips;

  	}

  	// parse the animation.hierarchy format
  	static parseAnimation( animation, bones ) {

  		if ( ! animation ) {

  			console.error( 'THREE.AnimationClip: No animation in JSONLoader data.' );
  			return null;

  		}

  		const addNonemptyTrack = function ( trackType, trackName, animationKeys, propertyName, destTracks ) {

  			// only return track if there are actually keys.
  			if ( animationKeys.length !== 0 ) {

  				const times = [];
  				const values = [];

  				flattenJSON( animationKeys, times, values, propertyName );

  				// empty keys are filtered out, so check again
  				if ( times.length !== 0 ) {

  					destTracks.push( new trackType( trackName, times, values ) );

  				}

  			}

  		};

  		const tracks = [];

  		const clipName = animation.name || 'default';
  		const fps = animation.fps || 30;
  		const blendMode = animation.blendMode;

  		// automatic length determination in AnimationClip.
  		let duration = animation.length || - 1;

  		const hierarchyTracks = animation.hierarchy || [];

  		for ( let h = 0; h < hierarchyTracks.length; h ++ ) {

  			const animationKeys = hierarchyTracks[ h ].keys;

  			// skip empty tracks
  			if ( ! animationKeys || animationKeys.length === 0 ) continue;

  			// process morph targets
  			if ( animationKeys[ 0 ].morphTargets ) {

  				// figure out all morph targets used in this track
  				const morphTargetNames = {};

  				let k;

  				for ( k = 0; k < animationKeys.length; k ++ ) {

  					if ( animationKeys[ k ].morphTargets ) {

  						for ( let m = 0; m < animationKeys[ k ].morphTargets.length; m ++ ) {

  							morphTargetNames[ animationKeys[ k ].morphTargets[ m ] ] = - 1;

  						}

  					}

  				}

  				// create a track for each morph target with all zero
  				// morphTargetInfluences except for the keys in which
  				// the morphTarget is named.
  				for ( const morphTargetName in morphTargetNames ) {

  					const times = [];
  					const values = [];

  					for ( let m = 0; m !== animationKeys[ k ].morphTargets.length; ++ m ) {

  						const animationKey = animationKeys[ k ];

  						times.push( animationKey.time );
  						values.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );

  					}

  					tracks.push( new NumberKeyframeTrack( '.morphTargetInfluence[' + morphTargetName + ']', times, values ) );

  				}

  				duration = morphTargetNames.length * fps;

  			} else {

  				// ...assume skeletal animation

  				const boneName = '.bones[' + bones[ h ].name + ']';

  				addNonemptyTrack(
  					VectorKeyframeTrack, boneName + '.position',
  					animationKeys, 'pos', tracks );

  				addNonemptyTrack(
  					QuaternionKeyframeTrack, boneName + '.quaternion',
  					animationKeys, 'rot', tracks );

  				addNonemptyTrack(
  					VectorKeyframeTrack, boneName + '.scale',
  					animationKeys, 'scl', tracks );

  			}

  		}

  		if ( tracks.length === 0 ) {

  			return null;

  		}

  		const clip = new this( clipName, duration, tracks, blendMode );

  		return clip;

  	}

  	resetDuration() {

  		const tracks = this.tracks;
  		let duration = 0;

  		for ( let i = 0, n = tracks.length; i !== n; ++ i ) {

  			const track = this.tracks[ i ];

  			duration = Math.max( duration, track.times[ track.times.length - 1 ] );

  		}

  		this.duration = duration;

  		return this;

  	}

  	trim() {

  		for ( let i = 0; i < this.tracks.length; i ++ ) {

  			this.tracks[ i ].trim( 0, this.duration );

  		}

  		return this;

  	}

  	validate() {

  		let valid = true;

  		for ( let i = 0; i < this.tracks.length; i ++ ) {

  			valid = valid && this.tracks[ i ].validate();

  		}

  		return valid;

  	}

  	optimize() {

  		for ( let i = 0; i < this.tracks.length; i ++ ) {

  			this.tracks[ i ].optimize();

  		}

  		return this;

  	}

  	clone() {

  		const tracks = [];

  		for ( let i = 0; i < this.tracks.length; i ++ ) {

  			tracks.push( this.tracks[ i ].clone() );

  		}

  		return new this.constructor( this.name, this.duration, tracks, this.blendMode );

  	}

  	toJSON() {

  		return this.constructor.toJSON( this );

  	}

  }

  function getTrackTypeForValueTypeName( typeName ) {

  	switch ( typeName.toLowerCase() ) {

  		case 'scalar':
  		case 'double':
  		case 'float':
  		case 'number':
  		case 'integer':

  			return NumberKeyframeTrack;

  		case 'vector':
  		case 'vector2':
  		case 'vector3':
  		case 'vector4':

  			return VectorKeyframeTrack;

  		case 'color':

  			return ColorKeyframeTrack;

  		case 'quaternion':

  			return QuaternionKeyframeTrack;

  		case 'bool':
  		case 'boolean':

  			return BooleanKeyframeTrack;

  		case 'string':

  			return StringKeyframeTrack;

  	}

  	throw new Error( 'THREE.KeyframeTrack: Unsupported typeName: ' + typeName );

  }

  function parseKeyframeTrack( json ) {

  	if ( json.type === undefined ) {

  		throw new Error( 'THREE.KeyframeTrack: track type undefined, can not parse' );

  	}

  	const trackType = getTrackTypeForValueTypeName( json.type );

  	if ( json.times === undefined ) {

  		const times = [], values = [];

  		flattenJSON( json.keys, times, values, 'value' );

  		json.times = times;
  		json.values = values;

  	}

  	// derived classes can define a static parse method
  	if ( trackType.parse !== undefined ) {

  		return trackType.parse( json );

  	} else {

  		// by default, we assume a constructor compatible with the base
  		return new trackType( json.name, json.times, json.values, json.interpolation );

  	}

  }

  const Cache = {

  	enabled: false,

  	files: {},

  	add: function ( key, file ) {

  		if ( this.enabled === false ) return;

  		// console.log( 'THREE.Cache', 'Adding key:', key );

  		this.files[ key ] = file;

  	},

  	get: function ( key ) {

  		if ( this.enabled === false ) return;

  		// console.log( 'THREE.Cache', 'Checking key:', key );

  		return this.files[ key ];

  	},

  	remove: function ( key ) {

  		delete this.files[ key ];

  	},

  	clear: function () {

  		this.files = {};

  	}

  };

  class LoadingManager {

  	constructor( onLoad, onProgress, onError ) {

  		const scope = this;

  		let isLoading = false;
  		let itemsLoaded = 0;
  		let itemsTotal = 0;
  		let urlModifier = undefined;
  		const handlers = [];

  		// Refer to #5689 for the reason why we don't set .onStart
  		// in the constructor

  		this.onStart = undefined;
  		this.onLoad = onLoad;
  		this.onProgress = onProgress;
  		this.onError = onError;

  		this.itemStart = function ( url ) {

  			itemsTotal ++;

  			if ( isLoading === false ) {

  				if ( scope.onStart !== undefined ) {

  					scope.onStart( url, itemsLoaded, itemsTotal );

  				}

  			}

  			isLoading = true;

  		};

  		this.itemEnd = function ( url ) {

  			itemsLoaded ++;

  			if ( scope.onProgress !== undefined ) {

  				scope.onProgress( url, itemsLoaded, itemsTotal );

  			}

  			if ( itemsLoaded === itemsTotal ) {

  				isLoading = false;

  				if ( scope.onLoad !== undefined ) {

  					scope.onLoad();

  				}

  			}

  		};

  		this.itemError = function ( url ) {

  			if ( scope.onError !== undefined ) {

  				scope.onError( url );

  			}

  		};

  		this.resolveURL = function ( url ) {

  			if ( urlModifier ) {

  				return urlModifier( url );

  			}

  			return url;

  		};

  		this.setURLModifier = function ( transform ) {

  			urlModifier = transform;

  			return this;

  		};

  		this.addHandler = function ( regex, loader ) {

  			handlers.push( regex, loader );

  			return this;

  		};

  		this.removeHandler = function ( regex ) {

  			const index = handlers.indexOf( regex );

  			if ( index !== - 1 ) {

  				handlers.splice( index, 2 );

  			}

  			return this;

  		};

  		this.getHandler = function ( file ) {

  			for ( let i = 0, l = handlers.length; i < l; i += 2 ) {

  				const regex = handlers[ i ];
  				const loader = handlers[ i + 1 ];

  				if ( regex.global ) regex.lastIndex = 0; // see #17920

  				if ( regex.test( file ) ) {

  					return loader;

  				}

  			}

  			return null;

  		};

  	}

  }

  const DefaultLoadingManager = /*@__PURE__*/ new LoadingManager();

  class Loader {

  	constructor( manager ) {

  		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

  		this.crossOrigin = 'anonymous';
  		this.withCredentials = false;
  		this.path = '';
  		this.resourcePath = '';
  		this.requestHeader = {};

  	}

  	load( /* url, onLoad, onProgress, onError */ ) {}

  	loadAsync( url, onProgress ) {

  		const scope = this;

  		return new Promise( function ( resolve, reject ) {

  			scope.load( url, resolve, onProgress, reject );

  		} );

  	}

  	parse( /* data */ ) {}

  	setCrossOrigin( crossOrigin ) {

  		this.crossOrigin = crossOrigin;
  		return this;

  	}

  	setWithCredentials( value ) {

  		this.withCredentials = value;
  		return this;

  	}

  	setPath( path ) {

  		this.path = path;
  		return this;

  	}

  	setResourcePath( resourcePath ) {

  		this.resourcePath = resourcePath;
  		return this;

  	}

  	setRequestHeader( requestHeader ) {

  		this.requestHeader = requestHeader;
  		return this;

  	}

  }

  Loader.DEFAULT_MATERIAL_NAME = '__DEFAULT';

  const loading = {};

  class HttpError extends Error {

  	constructor( message, response ) {

  		super( message );
  		this.response = response;

  	}

  }

  class FileLoader extends Loader {

  	constructor( manager ) {

  		super( manager );

  	}

  	load( url, onLoad, onProgress, onError ) {

  		if ( url === undefined ) url = '';

  		if ( this.path !== undefined ) url = this.path + url;

  		url = this.manager.resolveURL( url );

  		const cached = Cache.get( url );

  		if ( cached !== undefined ) {

  			this.manager.itemStart( url );

  			setTimeout( () => {

  				if ( onLoad ) onLoad( cached );

  				this.manager.itemEnd( url );

  			}, 0 );

  			return cached;

  		}

  		// Check if request is duplicate

  		if ( loading[ url ] !== undefined ) {

  			loading[ url ].push( {

  				onLoad: onLoad,
  				onProgress: onProgress,
  				onError: onError

  			} );

  			return;

  		}

  		// Initialise array for duplicate requests
  		loading[ url ] = [];

  		loading[ url ].push( {
  			onLoad: onLoad,
  			onProgress: onProgress,
  			onError: onError,
  		} );

  		// create request
  		const req = new Request( url, {
  			headers: new Headers( this.requestHeader ),
  			credentials: this.withCredentials ? 'include' : 'same-origin',
  			// An abort controller could be added within a future PR
  		} );

  		// record states ( avoid data race )
  		const mimeType = this.mimeType;
  		const responseType = this.responseType;

  		// start the fetch
  		fetch( req )
  			.then( response => {

  				if ( response.status === 200 || response.status === 0 ) {

  					// Some browsers return HTTP Status 0 when using non-http protocol
  					// e.g. 'file://' or 'data://'. Handle as success.

  					if ( response.status === 0 ) {

  						console.warn( 'THREE.FileLoader: HTTP Status 0 received.' );

  					}

  					// Workaround: Checking if response.body === undefined for Alipay browser #23548

  					if ( typeof ReadableStream === 'undefined' || response.body === undefined || response.body.getReader === undefined ) {

  						return response;

  					}

  					const callbacks = loading[ url ];
  					const reader = response.body.getReader();

  					// Nginx needs X-File-Size check
  					// https://serverfault.com/questions/482875/why-does-nginx-remove-content-length-header-for-chunked-content
  					const contentLength = response.headers.get( 'X-File-Size' ) || response.headers.get( 'Content-Length' );
  					const total = contentLength ? parseInt( contentLength ) : 0;
  					const lengthComputable = total !== 0;
  					let loaded = 0;

  					// periodically read data into the new stream tracking while download progress
  					const stream = new ReadableStream( {
  						start( controller ) {

  							readData();

  							function readData() {

  								reader.read().then( ( { done, value } ) => {

  									if ( done ) {

  										controller.close();

  									} else {

  										loaded += value.byteLength;

  										const event = new ProgressEvent( 'progress', { lengthComputable, loaded, total } );
  										for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

  											const callback = callbacks[ i ];
  											if ( callback.onProgress ) callback.onProgress( event );

  										}

  										controller.enqueue( value );
  										readData();

  									}

  								}, ( e ) => {

  									controller.error( e );

  								} );

  							}

  						}

  					} );

  					return new Response( stream );

  				} else {

  					throw new HttpError( `fetch for "${response.url}" responded with ${response.status}: ${response.statusText}`, response );

  				}

  			} )
  			.then( response => {

  				switch ( responseType ) {

  					case 'arraybuffer':

  						return response.arrayBuffer();

  					case 'blob':

  						return response.blob();

  					case 'document':

  						return response.text()
  							.then( text => {

  								const parser = new DOMParser();
  								return parser.parseFromString( text, mimeType );

  							} );

  					case 'json':

  						return response.json();

  					default:

  						if ( mimeType === undefined ) {

  							return response.text();

  						} else {

  							// sniff encoding
  							const re = /charset="?([^;"\s]*)"?/i;
  							const exec = re.exec( mimeType );
  							const label = exec && exec[ 1 ] ? exec[ 1 ].toLowerCase() : undefined;
  							const decoder = new TextDecoder( label );
  							return response.arrayBuffer().then( ab => decoder.decode( ab ) );

  						}

  				}

  			} )
  			.then( data => {

  				// Add to cache only on HTTP success, so that we do not cache
  				// error response bodies as proper responses to requests.
  				Cache.add( url, data );

  				const callbacks = loading[ url ];
  				delete loading[ url ];

  				for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

  					const callback = callbacks[ i ];
  					if ( callback.onLoad ) callback.onLoad( data );

  				}

  			} )
  			.catch( err => {

  				// Abort errors and other errors are handled the same

  				const callbacks = loading[ url ];

  				if ( callbacks === undefined ) {

  					// When onLoad was called and url was deleted in `loading`
  					this.manager.itemError( url );
  					throw err;

  				}

  				delete loading[ url ];

  				for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

  					const callback = callbacks[ i ];
  					if ( callback.onError ) callback.onError( err );

  				}

  				this.manager.itemError( url );

  			} )
  			.finally( () => {

  				this.manager.itemEnd( url );

  			} );

  		this.manager.itemStart( url );

  	}

  	setResponseType( value ) {

  		this.responseType = value;
  		return this;

  	}

  	setMimeType( value ) {

  		this.mimeType = value;
  		return this;

  	}

  }

  class ImageLoader extends Loader {

  	constructor( manager ) {

  		super( manager );

  	}

  	load( url, onLoad, onProgress, onError ) {

  		if ( this.path !== undefined ) url = this.path + url;

  		url = this.manager.resolveURL( url );

  		const scope = this;

  		const cached = Cache.get( url );

  		if ( cached !== undefined ) {

  			scope.manager.itemStart( url );

  			setTimeout( function () {

  				if ( onLoad ) onLoad( cached );

  				scope.manager.itemEnd( url );

  			}, 0 );

  			return cached;

  		}

  		const image = createElementNS( 'img' );

  		function onImageLoad() {

  			removeEventListeners();

  			Cache.add( url, this );

  			if ( onLoad ) onLoad( this );

  			scope.manager.itemEnd( url );

  		}

  		function onImageError( event ) {

  			removeEventListeners();

  			if ( onError ) onError( event );

  			scope.manager.itemError( url );
  			scope.manager.itemEnd( url );

  		}

  		function removeEventListeners() {

  			image.removeEventListener( 'load', onImageLoad, false );
  			image.removeEventListener( 'error', onImageError, false );

  		}

  		image.addEventListener( 'load', onImageLoad, false );
  		image.addEventListener( 'error', onImageError, false );

  		if ( url.slice( 0, 5 ) !== 'data:' ) {

  			if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;

  		}

  		scope.manager.itemStart( url );

  		image.src = url;

  		return image;

  	}

  }

  class TextureLoader extends Loader {

  	constructor( manager ) {

  		super( manager );

  	}

  	load( url, onLoad, onProgress, onError ) {

  		const texture = new Texture();

  		const loader = new ImageLoader( this.manager );
  		loader.setCrossOrigin( this.crossOrigin );
  		loader.setPath( this.path );

  		loader.load( url, function ( image ) {

  			texture.image = image;
  			texture.needsUpdate = true;

  			if ( onLoad !== undefined ) {

  				onLoad( texture );

  			}

  		}, onProgress, onError );

  		return texture;

  	}

  }

  class Light extends Object3D {

  	constructor( color, intensity = 1 ) {

  		super();

  		this.isLight = true;

  		this.type = 'Light';

  		this.color = new Color( color );
  		this.intensity = intensity;

  	}

  	dispose() {

  		// Empty here in base class; some subclasses override.

  	}

  	copy( source, recursive ) {

  		super.copy( source, recursive );

  		this.color.copy( source.color );
  		this.intensity = source.intensity;

  		return this;

  	}

  	toJSON( meta ) {

  		const data = super.toJSON( meta );

  		data.object.color = this.color.getHex();
  		data.object.intensity = this.intensity;

  		if ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();

  		if ( this.distance !== undefined ) data.object.distance = this.distance;
  		if ( this.angle !== undefined ) data.object.angle = this.angle;
  		if ( this.decay !== undefined ) data.object.decay = this.decay;
  		if ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;

  		if ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();
  		if ( this.target !== undefined ) data.object.target = this.target.uuid;

  		return data;

  	}

  }

  const _projScreenMatrix$1 = /*@__PURE__*/ new Matrix4();
  const _lightPositionWorld$1 = /*@__PURE__*/ new Vector3();
  const _lookTarget$1 = /*@__PURE__*/ new Vector3();

  class LightShadow {

  	constructor( camera ) {

  		this.camera = camera;

  		this.intensity = 1;

  		this.bias = 0;
  		this.normalBias = 0;
  		this.radius = 1;
  		this.blurSamples = 8;

  		this.mapSize = new Vector2( 512, 512 );

  		this.map = null;
  		this.mapPass = null;
  		this.matrix = new Matrix4();

  		this.autoUpdate = true;
  		this.needsUpdate = false;

  		this._frustum = new Frustum();
  		this._frameExtents = new Vector2( 1, 1 );

  		this._viewportCount = 1;

  		this._viewports = [

  			new Vector4( 0, 0, 1, 1 )

  		];

  	}

  	getViewportCount() {

  		return this._viewportCount;

  	}

  	getFrustum() {

  		return this._frustum;

  	}

  	updateMatrices( light ) {

  		const shadowCamera = this.camera;
  		const shadowMatrix = this.matrix;

  		_lightPositionWorld$1.setFromMatrixPosition( light.matrixWorld );
  		shadowCamera.position.copy( _lightPositionWorld$1 );

  		_lookTarget$1.setFromMatrixPosition( light.target.matrixWorld );
  		shadowCamera.lookAt( _lookTarget$1 );
  		shadowCamera.updateMatrixWorld();

  		_projScreenMatrix$1.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
  		this._frustum.setFromProjectionMatrix( _projScreenMatrix$1 );

  		shadowMatrix.set(
  			0.5, 0.0, 0.0, 0.5,
  			0.0, 0.5, 0.0, 0.5,
  			0.0, 0.0, 0.5, 0.5,
  			0.0, 0.0, 0.0, 1.0
  		);

  		shadowMatrix.multiply( _projScreenMatrix$1 );

  	}

  	getViewport( viewportIndex ) {

  		return this._viewports[ viewportIndex ];

  	}

  	getFrameExtents() {

  		return this._frameExtents;

  	}

  	dispose() {

  		if ( this.map ) {

  			this.map.dispose();

  		}

  		if ( this.mapPass ) {

  			this.mapPass.dispose();

  		}

  	}

  	copy( source ) {

  		this.camera = source.camera.clone();

  		this.intensity = source.intensity;

  		this.bias = source.bias;
  		this.radius = source.radius;

  		this.mapSize.copy( source.mapSize );

  		return this;

  	}

  	clone() {

  		return new this.constructor().copy( this );

  	}

  	toJSON() {

  		const object = {};

  		if ( this.intensity !== 1 ) object.intensity = this.intensity;
  		if ( this.bias !== 0 ) object.bias = this.bias;
  		if ( this.normalBias !== 0 ) object.normalBias = this.normalBias;
  		if ( this.radius !== 1 ) object.radius = this.radius;
  		if ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();

  		object.camera = this.camera.toJSON( false ).object;
  		delete object.camera.matrix;

  		return object;

  	}

  }

  class SpotLightShadow extends LightShadow {

  	constructor() {

  		super( new PerspectiveCamera( 50, 1, 0.5, 500 ) );

  		this.isSpotLightShadow = true;

  		this.focus = 1;

  	}

  	updateMatrices( light ) {

  		const camera = this.camera;

  		const fov = RAD2DEG$1 * 2 * light.angle * this.focus;
  		const aspect = this.mapSize.width / this.mapSize.height;
  		const far = light.distance || camera.far;

  		if ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {

  			camera.fov = fov;
  			camera.aspect = aspect;
  			camera.far = far;
  			camera.updateProjectionMatrix();

  		}

  		super.updateMatrices( light );

  	}

  	copy( source ) {

  		super.copy( source );

  		this.focus = source.focus;

  		return this;

  	}

  }

  class SpotLight extends Light {

  	constructor( color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 2 ) {

  		super( color, intensity );

  		this.isSpotLight = true;

  		this.type = 'SpotLight';

  		this.position.copy( Object3D.DEFAULT_UP );
  		this.updateMatrix();

  		this.target = new Object3D();

  		this.distance = distance;
  		this.angle = angle;
  		this.penumbra = penumbra;
  		this.decay = decay;

  		this.map = null;

  		this.shadow = new SpotLightShadow();

  	}

  	get power() {

  		// compute the light's luminous power (in lumens) from its intensity (in candela)
  		// by convention for a spotlight, luminous power (lm) =  * luminous intensity (cd)
  		return this.intensity * Math.PI;

  	}

  	set power( power ) {

  		// set the light's intensity (in candela) from the desired luminous power (in lumens)
  		this.intensity = power / Math.PI;

  	}

  	dispose() {

  		this.shadow.dispose();

  	}

  	copy( source, recursive ) {

  		super.copy( source, recursive );

  		this.distance = source.distance;
  		this.angle = source.angle;
  		this.penumbra = source.penumbra;
  		this.decay = source.decay;

  		this.target = source.target.clone();

  		this.shadow = source.shadow.clone();

  		return this;

  	}

  }

  const _projScreenMatrix = /*@__PURE__*/ new Matrix4();
  const _lightPositionWorld = /*@__PURE__*/ new Vector3();
  const _lookTarget = /*@__PURE__*/ new Vector3();

  class PointLightShadow extends LightShadow {

  	constructor() {

  		super( new PerspectiveCamera( 90, 1, 0.5, 500 ) );

  		this.isPointLightShadow = true;

  		this._frameExtents = new Vector2( 4, 2 );

  		this._viewportCount = 6;

  		this._viewports = [
  			// These viewports map a cube-map onto a 2D texture with the
  			// following orientation:
  			//
  			//  xzXZ
  			//   y Y
  			//
  			// X - Positive x direction
  			// x - Negative x direction
  			// Y - Positive y direction
  			// y - Negative y direction
  			// Z - Positive z direction
  			// z - Negative z direction

  			// positive X
  			new Vector4( 2, 1, 1, 1 ),
  			// negative X
  			new Vector4( 0, 1, 1, 1 ),
  			// positive Z
  			new Vector4( 3, 1, 1, 1 ),
  			// negative Z
  			new Vector4( 1, 1, 1, 1 ),
  			// positive Y
  			new Vector4( 3, 0, 1, 1 ),
  			// negative Y
  			new Vector4( 1, 0, 1, 1 )
  		];

  		this._cubeDirections = [
  			new Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ),
  			new Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 )
  		];

  		this._cubeUps = [
  			new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),
  			new Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),	new Vector3( 0, 0, - 1 )
  		];

  	}

  	updateMatrices( light, viewportIndex = 0 ) {

  		const camera = this.camera;
  		const shadowMatrix = this.matrix;

  		const far = light.distance || camera.far;

  		if ( far !== camera.far ) {

  			camera.far = far;
  			camera.updateProjectionMatrix();

  		}

  		_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
  		camera.position.copy( _lightPositionWorld );

  		_lookTarget.copy( camera.position );
  		_lookTarget.add( this._cubeDirections[ viewportIndex ] );
  		camera.up.copy( this._cubeUps[ viewportIndex ] );
  		camera.lookAt( _lookTarget );
  		camera.updateMatrixWorld();

  		shadowMatrix.makeTranslation( - _lightPositionWorld.x, - _lightPositionWorld.y, - _lightPositionWorld.z );

  		_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
  		this._frustum.setFromProjectionMatrix( _projScreenMatrix );

  	}

  }

  class PointLight extends Light {

  	constructor( color, intensity, distance = 0, decay = 2 ) {

  		super( color, intensity );

  		this.isPointLight = true;

  		this.type = 'PointLight';

  		this.distance = distance;
  		this.decay = decay;

  		this.shadow = new PointLightShadow();

  	}

  	get power() {

  		// compute the light's luminous power (in lumens) from its intensity (in candela)
  		// for an isotropic light source, luminous power (lm) = 4  luminous intensity (cd)
  		return this.intensity * 4 * Math.PI;

  	}

  	set power( power ) {

  		// set the light's intensity (in candela) from the desired luminous power (in lumens)
  		this.intensity = power / ( 4 * Math.PI );

  	}

  	dispose() {

  		this.shadow.dispose();

  	}

  	copy( source, recursive ) {

  		super.copy( source, recursive );

  		this.distance = source.distance;
  		this.decay = source.decay;

  		this.shadow = source.shadow.clone();

  		return this;

  	}

  }

  class DirectionalLightShadow extends LightShadow {

  	constructor() {

  		super( new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );

  		this.isDirectionalLightShadow = true;

  	}

  }

  class DirectionalLight extends Light {

  	constructor( color, intensity ) {

  		super( color, intensity );

  		this.isDirectionalLight = true;

  		this.type = 'DirectionalLight';

  		this.position.copy( Object3D.DEFAULT_UP );
  		this.updateMatrix();

  		this.target = new Object3D();

  		this.shadow = new DirectionalLightShadow();

  	}

  	dispose() {

  		this.shadow.dispose();

  	}

  	copy( source ) {

  		super.copy( source );

  		this.target = source.target.clone();
  		this.shadow = source.shadow.clone();

  		return this;

  	}

  }

  class AmbientLight extends Light {

  	constructor( color, intensity ) {

  		super( color, intensity );

  		this.isAmbientLight = true;

  		this.type = 'AmbientLight';

  	}

  }

  class LoaderUtils {

  	static decodeText( array ) { // @deprecated, r165

  		console.warn( 'THREE.LoaderUtils: decodeText() has been deprecated with r165 and will be removed with r175. Use TextDecoder instead.' );

  		if ( typeof TextDecoder !== 'undefined' ) {

  			return new TextDecoder().decode( array );

  		}

  		// Avoid the String.fromCharCode.apply(null, array) shortcut, which
  		// throws a "maximum call stack size exceeded" error for large arrays.

  		let s = '';

  		for ( let i = 0, il = array.length; i < il; i ++ ) {

  			// Implicitly assumes little-endian.
  			s += String.fromCharCode( array[ i ] );

  		}

  		try {

  			// merges multi-byte utf-8 characters.

  			return decodeURIComponent( escape( s ) );

  		} catch ( e ) { // see #16358

  			return s;

  		}

  	}

  	static extractUrlBase( url ) {

  		const index = url.lastIndexOf( '/' );

  		if ( index === - 1 ) return './';

  		return url.slice( 0, index + 1 );

  	}

  	static resolveURL( url, path ) {

  		// Invalid URL
  		if ( typeof url !== 'string' || url === '' ) return '';

  		// Host Relative URL
  		if ( /^https?:\/\//i.test( path ) && /^\//.test( url ) ) {

  			path = path.replace( /(^https?:\/\/[^\/]+).*/i, '$1' );

  		}

  		// Absolute URL http://,https://,//
  		if ( /^(https?:)?\/\//i.test( url ) ) return url;

  		// Data URI
  		if ( /^data:.*,.*$/i.test( url ) ) return url;

  		// Blob URL
  		if ( /^blob:.*$/i.test( url ) ) return url;

  		// Relative URL
  		return path + url;

  	}

  }

  class ImageBitmapLoader extends Loader {

  	constructor( manager ) {

  		super( manager );

  		this.isImageBitmapLoader = true;

  		if ( typeof createImageBitmap === 'undefined' ) {

  			console.warn( 'THREE.ImageBitmapLoader: createImageBitmap() not supported.' );

  		}

  		if ( typeof fetch === 'undefined' ) {

  			console.warn( 'THREE.ImageBitmapLoader: fetch() not supported.' );

  		}

  		this.options = { premultiplyAlpha: 'none' };

  	}

  	setOptions( options ) {

  		this.options = options;

  		return this;

  	}

  	load( url, onLoad, onProgress, onError ) {

  		if ( url === undefined ) url = '';

  		if ( this.path !== undefined ) url = this.path + url;

  		url = this.manager.resolveURL( url );

  		const scope = this;

  		const cached = Cache.get( url );

  		if ( cached !== undefined ) {

  			scope.manager.itemStart( url );

  			// If cached is a promise, wait for it to resolve
  			if ( cached.then ) {

  				cached.then( imageBitmap => {

  					if ( onLoad ) onLoad( imageBitmap );

  					scope.manager.itemEnd( url );

  				} ).catch( e => {

  					if ( onError ) onError( e );

  				} );
  				return;

  			}

  			// If cached is not a promise (i.e., it's already an imageBitmap)
  			setTimeout( function () {

  				if ( onLoad ) onLoad( cached );

  				scope.manager.itemEnd( url );

  			}, 0 );

  			return cached;

  		}

  		const fetchOptions = {};
  		fetchOptions.credentials = ( this.crossOrigin === 'anonymous' ) ? 'same-origin' : 'include';
  		fetchOptions.headers = this.requestHeader;

  		const promise = fetch( url, fetchOptions ).then( function ( res ) {

  			return res.blob();

  		} ).then( function ( blob ) {

  			return createImageBitmap( blob, Object.assign( scope.options, { colorSpaceConversion: 'none' } ) );

  		} ).then( function ( imageBitmap ) {

  			Cache.add( url, imageBitmap );

  			if ( onLoad ) onLoad( imageBitmap );

  			scope.manager.itemEnd( url );

  			return imageBitmap;

  		} ).catch( function ( e ) {

  			if ( onError ) onError( e );

  			Cache.remove( url );

  			scope.manager.itemError( url );
  			scope.manager.itemEnd( url );

  		} );

  		Cache.add( url, promise );
  		scope.manager.itemStart( url );

  	}

  }

  // Characters [].:/ are reserved for track binding syntax.
  const _RESERVED_CHARS_RE = '\\[\\]\\.:\\/';
  const _reservedRe = new RegExp( '[' + _RESERVED_CHARS_RE + ']', 'g' );

  // Attempts to allow node names from any language. ES5's `\w` regexp matches
  // only latin characters, and the unicode \p{L} is not yet supported. So
  // instead, we exclude reserved characters and match everything else.
  const _wordChar = '[^' + _RESERVED_CHARS_RE + ']';
  const _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace( '\\.', '' ) + ']';

  // Parent directories, delimited by '/' or ':'. Currently unused, but must
  // be matched to parse the rest of the track name.
  const _directoryRe = /*@__PURE__*/ /((?:WC+[\/:])*)/.source.replace( 'WC', _wordChar );

  // Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.
  const _nodeRe = /*@__PURE__*/ /(WCOD+)?/.source.replace( 'WCOD', _wordCharOrDot );

  // Object on target node, and accessor. May not contain reserved
  // characters. Accessor may contain any character except closing bracket.
  const _objectRe = /*@__PURE__*/ /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace( 'WC', _wordChar );

  // Property and accessor. May not contain reserved characters. Accessor may
  // contain any non-bracket characters.
  const _propertyRe = /*@__PURE__*/ /\.(WC+)(?:\[(.+)\])?/.source.replace( 'WC', _wordChar );

  const _trackRe = new RegExp( ''
  	+ '^'
  	+ _directoryRe
  	+ _nodeRe
  	+ _objectRe
  	+ _propertyRe
  	+ '$'
  );

  const _supportedObjectNames = [ 'material', 'materials', 'bones', 'map' ];

  class Composite {

  	constructor( targetGroup, path, optionalParsedPath ) {

  		const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName( path );

  		this._targetGroup = targetGroup;
  		this._bindings = targetGroup.subscribe_( path, parsedPath );

  	}

  	getValue( array, offset ) {

  		this.bind(); // bind all binding

  		const firstValidIndex = this._targetGroup.nCachedObjects_,
  			binding = this._bindings[ firstValidIndex ];

  		// and only call .getValue on the first
  		if ( binding !== undefined ) binding.getValue( array, offset );

  	}

  	setValue( array, offset ) {

  		const bindings = this._bindings;

  		for ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

  			bindings[ i ].setValue( array, offset );

  		}

  	}

  	bind() {

  		const bindings = this._bindings;

  		for ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

  			bindings[ i ].bind();

  		}

  	}

  	unbind() {

  		const bindings = this._bindings;

  		for ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

  			bindings[ i ].unbind();

  		}

  	}

  }

  // Note: This class uses a State pattern on a per-method basis:
  // 'bind' sets 'this.getValue' / 'setValue' and shadows the
  // prototype version of these methods with one that represents
  // the bound state. When the property is not found, the methods
  // become no-ops.
  class PropertyBinding {

  	constructor( rootNode, path, parsedPath ) {

  		this.path = path;
  		this.parsedPath = parsedPath || PropertyBinding.parseTrackName( path );

  		this.node = PropertyBinding.findNode( rootNode, this.parsedPath.nodeName );

  		this.rootNode = rootNode;

  		// initial state of these methods that calls 'bind'
  		this.getValue = this._getValue_unbound;
  		this.setValue = this._setValue_unbound;

  	}


  	static create( root, path, parsedPath ) {

  		if ( ! ( root && root.isAnimationObjectGroup ) ) {

  			return new PropertyBinding( root, path, parsedPath );

  		} else {

  			return new PropertyBinding.Composite( root, path, parsedPath );

  		}

  	}

  	/**
  	 * Replaces spaces with underscores and removes unsupported characters from
  	 * node names, to ensure compatibility with parseTrackName().
  	 *
  	 * @param {string} name Node name to be sanitized.
  	 * @return {string}
  	 */
  	static sanitizeNodeName( name ) {

  		return name.replace( /\s/g, '_' ).replace( _reservedRe, '' );

  	}

  	static parseTrackName( trackName ) {

  		const matches = _trackRe.exec( trackName );

  		if ( matches === null ) {

  			throw new Error( 'PropertyBinding: Cannot parse trackName: ' + trackName );

  		}

  		const results = {
  			// directoryName: matches[ 1 ], // (tschw) currently unused
  			nodeName: matches[ 2 ],
  			objectName: matches[ 3 ],
  			objectIndex: matches[ 4 ],
  			propertyName: matches[ 5 ], // required
  			propertyIndex: matches[ 6 ]
  		};

  		const lastDot = results.nodeName && results.nodeName.lastIndexOf( '.' );

  		if ( lastDot !== undefined && lastDot !== - 1 ) {

  			const objectName = results.nodeName.substring( lastDot + 1 );

  			// Object names must be checked against an allowlist. Otherwise, there
  			// is no way to parse 'foo.bar.baz': 'baz' must be a property, but
  			// 'bar' could be the objectName, or part of a nodeName (which can
  			// include '.' characters).
  			if ( _supportedObjectNames.indexOf( objectName ) !== - 1 ) {

  				results.nodeName = results.nodeName.substring( 0, lastDot );
  				results.objectName = objectName;

  			}

  		}

  		if ( results.propertyName === null || results.propertyName.length === 0 ) {

  			throw new Error( 'PropertyBinding: can not parse propertyName from trackName: ' + trackName );

  		}

  		return results;

  	}

  	static findNode( root, nodeName ) {

  		if ( nodeName === undefined || nodeName === '' || nodeName === '.' || nodeName === - 1 || nodeName === root.name || nodeName === root.uuid ) {

  			return root;

  		}

  		// search into skeleton bones.
  		if ( root.skeleton ) {

  			const bone = root.skeleton.getBoneByName( nodeName );

  			if ( bone !== undefined ) {

  				return bone;

  			}

  		}

  		// search into node subtree.
  		if ( root.children ) {

  			const searchNodeSubtree = function ( children ) {

  				for ( let i = 0; i < children.length; i ++ ) {

  					const childNode = children[ i ];

  					if ( childNode.name === nodeName || childNode.uuid === nodeName ) {

  						return childNode;

  					}

  					const result = searchNodeSubtree( childNode.children );

  					if ( result ) return result;

  				}

  				return null;

  			};

  			const subTreeNode = searchNodeSubtree( root.children );

  			if ( subTreeNode ) {

  				return subTreeNode;

  			}

  		}

  		return null;

  	}

  	// these are used to "bind" a nonexistent property
  	_getValue_unavailable() {}
  	_setValue_unavailable() {}

  	// Getters

  	_getValue_direct( buffer, offset ) {

  		buffer[ offset ] = this.targetObject[ this.propertyName ];

  	}

  	_getValue_array( buffer, offset ) {

  		const source = this.resolvedProperty;

  		for ( let i = 0, n = source.length; i !== n; ++ i ) {

  			buffer[ offset ++ ] = source[ i ];

  		}

  	}

  	_getValue_arrayElement( buffer, offset ) {

  		buffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];

  	}

  	_getValue_toArray( buffer, offset ) {

  		this.resolvedProperty.toArray( buffer, offset );

  	}

  	// Direct

  	_setValue_direct( buffer, offset ) {

  		this.targetObject[ this.propertyName ] = buffer[ offset ];

  	}

  	_setValue_direct_setNeedsUpdate( buffer, offset ) {

  		this.targetObject[ this.propertyName ] = buffer[ offset ];
  		this.targetObject.needsUpdate = true;

  	}

  	_setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {

  		this.targetObject[ this.propertyName ] = buffer[ offset ];
  		this.targetObject.matrixWorldNeedsUpdate = true;

  	}

  	// EntireArray

  	_setValue_array( buffer, offset ) {

  		const dest = this.resolvedProperty;

  		for ( let i = 0, n = dest.length; i !== n; ++ i ) {

  			dest[ i ] = buffer[ offset ++ ];

  		}

  	}

  	_setValue_array_setNeedsUpdate( buffer, offset ) {

  		const dest = this.resolvedProperty;

  		for ( let i = 0, n = dest.length; i !== n; ++ i ) {

  			dest[ i ] = buffer[ offset ++ ];

  		}

  		this.targetObject.needsUpdate = true;

  	}

  	_setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {

  		const dest = this.resolvedProperty;

  		for ( let i = 0, n = dest.length; i !== n; ++ i ) {

  			dest[ i ] = buffer[ offset ++ ];

  		}

  		this.targetObject.matrixWorldNeedsUpdate = true;

  	}

  	// ArrayElement

  	_setValue_arrayElement( buffer, offset ) {

  		this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];

  	}

  	_setValue_arrayElement_setNeedsUpdate( buffer, offset ) {

  		this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
  		this.targetObject.needsUpdate = true;

  	}

  	_setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {

  		this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
  		this.targetObject.matrixWorldNeedsUpdate = true;

  	}

  	// HasToFromArray

  	_setValue_fromArray( buffer, offset ) {

  		this.resolvedProperty.fromArray( buffer, offset );

  	}

  	_setValue_fromArray_setNeedsUpdate( buffer, offset ) {

  		this.resolvedProperty.fromArray( buffer, offset );
  		this.targetObject.needsUpdate = true;

  	}

  	_setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {

  		this.resolvedProperty.fromArray( buffer, offset );
  		this.targetObject.matrixWorldNeedsUpdate = true;

  	}

  	_getValue_unbound( targetArray, offset ) {

  		this.bind();
  		this.getValue( targetArray, offset );

  	}

  	_setValue_unbound( sourceArray, offset ) {

  		this.bind();
  		this.setValue( sourceArray, offset );

  	}

  	// create getter / setter pair for a property in the scene graph
  	bind() {

  		let targetObject = this.node;
  		const parsedPath = this.parsedPath;

  		const objectName = parsedPath.objectName;
  		const propertyName = parsedPath.propertyName;
  		let propertyIndex = parsedPath.propertyIndex;

  		if ( ! targetObject ) {

  			targetObject = PropertyBinding.findNode( this.rootNode, parsedPath.nodeName );

  			this.node = targetObject;

  		}

  		// set fail state so we can just 'return' on error
  		this.getValue = this._getValue_unavailable;
  		this.setValue = this._setValue_unavailable;

  		// ensure there is a value node
  		if ( ! targetObject ) {

  			console.warn( 'THREE.PropertyBinding: No target node found for track: ' + this.path + '.' );
  			return;

  		}

  		if ( objectName ) {

  			let objectIndex = parsedPath.objectIndex;

  			// special cases were we need to reach deeper into the hierarchy to get the face materials....
  			switch ( objectName ) {

  				case 'materials':

  					if ( ! targetObject.material ) {

  						console.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );
  						return;

  					}

  					if ( ! targetObject.material.materials ) {

  						console.error( 'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this );
  						return;

  					}

  					targetObject = targetObject.material.materials;

  					break;

  				case 'bones':

  					if ( ! targetObject.skeleton ) {

  						console.error( 'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this );
  						return;

  					}

  					// potential future optimization: skip this if propertyIndex is already an integer
  					// and convert the integer string to a true integer.

  					targetObject = targetObject.skeleton.bones;

  					// support resolving morphTarget names into indices.
  					for ( let i = 0; i < targetObject.length; i ++ ) {

  						if ( targetObject[ i ].name === objectIndex ) {

  							objectIndex = i;
  							break;

  						}

  					}

  					break;

  				case 'map':

  					if ( 'map' in targetObject ) {

  						targetObject = targetObject.map;
  						break;

  					}

  					if ( ! targetObject.material ) {

  						console.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );
  						return;

  					}

  					if ( ! targetObject.material.map ) {

  						console.error( 'THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.', this );
  						return;

  					}

  					targetObject = targetObject.material.map;
  					break;

  				default:

  					if ( targetObject[ objectName ] === undefined ) {

  						console.error( 'THREE.PropertyBinding: Can not bind to objectName of node undefined.', this );
  						return;

  					}

  					targetObject = targetObject[ objectName ];

  			}


  			if ( objectIndex !== undefined ) {

  				if ( targetObject[ objectIndex ] === undefined ) {

  					console.error( 'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject );
  					return;

  				}

  				targetObject = targetObject[ objectIndex ];

  			}

  		}

  		// resolve property
  		const nodeProperty = targetObject[ propertyName ];

  		if ( nodeProperty === undefined ) {

  			const nodeName = parsedPath.nodeName;

  			console.error( 'THREE.PropertyBinding: Trying to update property for track: ' + nodeName +
  				'.' + propertyName + ' but it wasn\'t found.', targetObject );
  			return;

  		}

  		// determine versioning scheme
  		let versioning = this.Versioning.None;

  		this.targetObject = targetObject;

  		if ( targetObject.needsUpdate !== undefined ) { // material

  			versioning = this.Versioning.NeedsUpdate;

  		} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform

  			versioning = this.Versioning.MatrixWorldNeedsUpdate;

  		}

  		// determine how the property gets bound
  		let bindingType = this.BindingType.Direct;

  		if ( propertyIndex !== undefined ) {

  			// access a sub element of the property array (only primitives are supported right now)

  			if ( propertyName === 'morphTargetInfluences' ) {

  				// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

  				// support resolving morphTarget names into indices.
  				if ( ! targetObject.geometry ) {

  					console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this );
  					return;

  				}

  				if ( ! targetObject.geometry.morphAttributes ) {

  					console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this );
  					return;

  				}

  				if ( targetObject.morphTargetDictionary[ propertyIndex ] !== undefined ) {

  					propertyIndex = targetObject.morphTargetDictionary[ propertyIndex ];

  				}

  			}

  			bindingType = this.BindingType.ArrayElement;

  			this.resolvedProperty = nodeProperty;
  			this.propertyIndex = propertyIndex;

  		} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {

  			// must use copy for Object3D.Euler/Quaternion

  			bindingType = this.BindingType.HasFromToArray;

  			this.resolvedProperty = nodeProperty;

  		} else if ( Array.isArray( nodeProperty ) ) {

  			bindingType = this.BindingType.EntireArray;

  			this.resolvedProperty = nodeProperty;

  		} else {

  			this.propertyName = propertyName;

  		}

  		// select getter / setter
  		this.getValue = this.GetterByBindingType[ bindingType ];
  		this.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];

  	}

  	unbind() {

  		this.node = null;

  		// back to the prototype version of getValue / setValue
  		// note: avoiding to mutate the shape of 'this' via 'delete'
  		this.getValue = this._getValue_unbound;
  		this.setValue = this._setValue_unbound;

  	}

  }

  PropertyBinding.Composite = Composite;

  PropertyBinding.prototype.BindingType = {
  	Direct: 0,
  	EntireArray: 1,
  	ArrayElement: 2,
  	HasFromToArray: 3
  };

  PropertyBinding.prototype.Versioning = {
  	None: 0,
  	NeedsUpdate: 1,
  	MatrixWorldNeedsUpdate: 2
  };

  PropertyBinding.prototype.GetterByBindingType = [

  	PropertyBinding.prototype._getValue_direct,
  	PropertyBinding.prototype._getValue_array,
  	PropertyBinding.prototype._getValue_arrayElement,
  	PropertyBinding.prototype._getValue_toArray,

  ];

  PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [

  	[
  		// Direct
  		PropertyBinding.prototype._setValue_direct,
  		PropertyBinding.prototype._setValue_direct_setNeedsUpdate,
  		PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate,

  	], [

  		// EntireArray

  		PropertyBinding.prototype._setValue_array,
  		PropertyBinding.prototype._setValue_array_setNeedsUpdate,
  		PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate,

  	], [

  		// ArrayElement
  		PropertyBinding.prototype._setValue_arrayElement,
  		PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,
  		PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,

  	], [

  		// HasToFromArray
  		PropertyBinding.prototype._setValue_fromArray,
  		PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,
  		PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,

  	]

  ];

  class Uniform {

  	constructor( value ) {

  		this.value = value;

  	}

  	clone() {

  		return new Uniform( this.value.clone === undefined ? this.value : this.value.clone() );

  	}

  }

  class GLBufferAttribute {

  	constructor( buffer, type, itemSize, elementSize, count ) {

  		this.isGLBufferAttribute = true;

  		this.name = '';

  		this.buffer = buffer;
  		this.type = type;
  		this.itemSize = itemSize;
  		this.elementSize = elementSize;
  		this.count = count;

  		this.version = 0;

  	}

  	set needsUpdate( value ) {

  		if ( value === true ) this.version ++;

  	}

  	setBuffer( buffer ) {

  		this.buffer = buffer;

  		return this;

  	}

  	setType( type, elementSize ) {

  		this.type = type;
  		this.elementSize = elementSize;

  		return this;

  	}

  	setItemSize( itemSize ) {

  		this.itemSize = itemSize;

  		return this;

  	}

  	setCount( count ) {

  		this.count = count;

  		return this;

  	}

  }

  class AxesHelper extends LineSegments {

  	constructor( size = 1 ) {

  		const vertices = [
  			0, 0, 0,	size, 0, 0,
  			0, 0, 0,	0, size, 0,
  			0, 0, 0,	0, 0, size
  		];

  		const colors = [
  			1, 0, 0,	1, 0.6, 0,
  			0, 1, 0,	0.6, 1, 0,
  			0, 0, 1,	0, 0.6, 1
  		];

  		const geometry = new BufferGeometry();
  		geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  		geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

  		const material = new LineBasicMaterial( { vertexColors: true, toneMapped: false } );

  		super( geometry, material );

  		this.type = 'AxesHelper';

  	}

  	setColors( xAxisColor, yAxisColor, zAxisColor ) {

  		const color = new Color();
  		const array = this.geometry.attributes.color.array;

  		color.set( xAxisColor );
  		color.toArray( array, 0 );
  		color.toArray( array, 3 );

  		color.set( yAxisColor );
  		color.toArray( array, 6 );
  		color.toArray( array, 9 );

  		color.set( zAxisColor );
  		color.toArray( array, 12 );
  		color.toArray( array, 15 );

  		this.geometry.attributes.color.needsUpdate = true;

  		return this;

  	}

  	dispose() {

  		this.geometry.dispose();
  		this.material.dispose();

  	}

  }

  if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

  	__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'register', { detail: {
  		revision: REVISION,
  	} } ) );

  }

  if ( typeof window !== 'undefined' ) {

  	if ( window.__THREE__ ) {

  		console.warn( 'WARNING: Multiple instances of Three.js being imported.' );

  	} else {

  		window.__THREE__ = REVISION;

  	}

  }

  /**
   * Description: reads BVH files and outputs a single Skeleton and an AnimationClip
   *
   * Currently only supports bvh files containing a single root.
   *
   */

  class BVHLoader extends Loader {

  	constructor( manager ) {

  		super( manager );

  		this.animateBonePositions = true;
  		this.animateBoneRotations = true;

  	}

  	load( url, onLoad, onProgress, onError ) {

  		const scope = this;

  		const loader = new FileLoader( scope.manager );
  		loader.setPath( scope.path );
  		loader.setRequestHeader( scope.requestHeader );
  		loader.setWithCredentials( scope.withCredentials );
  		loader.load( url, function ( text ) {

  			try {

  				onLoad( scope.parse( text ) );

  			} catch ( e ) {

  				if ( onError ) {

  					onError( e );

  				} else {

  					console.error( e );

  				}

  				scope.manager.itemError( url );

  			}

  		}, onProgress, onError );

  	}

  	parse( text ) {

  		/*
  			reads a string array (lines) from a BVH file
  			and outputs a skeleton structure including motion data

  			returns thee root node:
  			{ name: '', channels: [], children: [] }
  		*/
  		function readBvh( lines ) {

  			// read model structure

  			if ( nextLine( lines ) !== 'HIERARCHY' ) {

  				console.error( 'THREE.BVHLoader: HIERARCHY expected.' );

  			}

  			const list = []; // collects flat array of all bones
  			const root = readNode( lines, nextLine( lines ), list );

  			// read motion data

  			if ( nextLine( lines ) !== 'MOTION' ) {

  				console.error( 'THREE.BVHLoader: MOTION expected.' );

  			}

  			// number of frames

  			let tokens = nextLine( lines ).split( /[\s]+/ );
  			const numFrames = parseInt( tokens[ 1 ] );

  			if ( isNaN( numFrames ) ) {

  				console.error( 'THREE.BVHLoader: Failed to read number of frames.' );

  			}

  			// frame time

  			tokens = nextLine( lines ).split( /[\s]+/ );
  			const frameTime = parseFloat( tokens[ 2 ] );

  			if ( isNaN( frameTime ) ) {

  				console.error( 'THREE.BVHLoader: Failed to read frame time.' );

  			}

  			// read frame data line by line

  			for ( let i = 0; i < numFrames; i ++ ) {

  				tokens = nextLine( lines ).split( /[\s]+/ );
  				readFrameData( tokens, i * frameTime, root );

  			}

  			return list;

  		}

  		/*
  			Recursively reads data from a single frame into the bone hierarchy.
  			The passed bone hierarchy has to be structured in the same order as the BVH file.
  			keyframe data is stored in bone.frames.

  			- data: splitted string array (frame values), values are shift()ed so
  			this should be empty after parsing the whole hierarchy.
  			- frameTime: playback time for this keyframe.
  			- bone: the bone to read frame data from.
  		*/
  		function readFrameData( data, frameTime, bone ) {

  			// end sites have no motion data

  			if ( bone.type === 'ENDSITE' ) return;

  			// add keyframe

  			const keyframe = {
  				time: frameTime,
  				position: new Vector3(),
  				rotation: new Quaternion()
  			};

  			bone.frames.push( keyframe );

  			const quat = new Quaternion();

  			const vx = new Vector3( 1, 0, 0 );
  			const vy = new Vector3( 0, 1, 0 );
  			const vz = new Vector3( 0, 0, 1 );

  			// parse values for each channel in node

  			for ( let i = 0; i < bone.channels.length; i ++ ) {

  				switch ( bone.channels[ i ] ) {

  					case 'Xposition':
  						keyframe.position.x = parseFloat( data.shift().trim() );
  						break;
  					case 'Yposition':
  						keyframe.position.y = parseFloat( data.shift().trim() );
  						break;
  					case 'Zposition':
  						keyframe.position.z = parseFloat( data.shift().trim() );
  						break;
  					case 'Xrotation':
  						quat.setFromAxisAngle( vx, parseFloat( data.shift().trim() ) * Math.PI / 180 );
  						keyframe.rotation.multiply( quat );
  						break;
  					case 'Yrotation':
  						quat.setFromAxisAngle( vy, parseFloat( data.shift().trim() ) * Math.PI / 180 );
  						keyframe.rotation.multiply( quat );
  						break;
  					case 'Zrotation':
  						quat.setFromAxisAngle( vz, parseFloat( data.shift().trim() ) * Math.PI / 180 );
  						keyframe.rotation.multiply( quat );
  						break;
  					default:
  						console.warn( 'THREE.BVHLoader: Invalid channel type.' );

  				}

  			}

  			// parse child nodes

  			for ( let i = 0; i < bone.children.length; i ++ ) {

  				readFrameData( data, frameTime, bone.children[ i ] );

  			}

  		}

  		/*
  		 Recursively parses the HIERACHY section of the BVH file

  		 - lines: all lines of the file. lines are consumed as we go along.
  		 - firstline: line containing the node type and name e.g. 'JOINT hip'
  		 - list: collects a flat list of nodes

  		 returns: a BVH node including children
  		*/
  		function readNode( lines, firstline, list ) {

  			const node = { name: '', type: '', frames: [] };
  			list.push( node );

  			// parse node type and name

  			let tokens = firstline.split( /[\s]+/ );

  			if ( tokens[ 0 ].toUpperCase() === 'END' && tokens[ 1 ].toUpperCase() === 'SITE' ) {

  				node.type = 'ENDSITE';
  				node.name = 'ENDSITE'; // bvh end sites have no name

  			} else {

  				node.name = tokens[ 1 ];
  				node.type = tokens[ 0 ].toUpperCase();

  			}

  			if ( nextLine( lines ) !== '{' ) {

  				console.error( 'THREE.BVHLoader: Expected opening { after type & name' );

  			}

  			// parse OFFSET

  			tokens = nextLine( lines ).split( /[\s]+/ );

  			if ( tokens[ 0 ] !== 'OFFSET' ) {

  				console.error( 'THREE.BVHLoader: Expected OFFSET but got: ' + tokens[ 0 ] );

  			}

  			if ( tokens.length !== 4 ) {

  				console.error( 'THREE.BVHLoader: Invalid number of values for OFFSET.' );

  			}

  			const offset = new Vector3(
  				parseFloat( tokens[ 1 ] ),
  				parseFloat( tokens[ 2 ] ),
  				parseFloat( tokens[ 3 ] )
  			);

  			if ( isNaN( offset.x ) || isNaN( offset.y ) || isNaN( offset.z ) ) {

  				console.error( 'THREE.BVHLoader: Invalid values of OFFSET.' );

  			}

  			node.offset = offset;

  			// parse CHANNELS definitions

  			if ( node.type !== 'ENDSITE' ) {

  				tokens = nextLine( lines ).split( /[\s]+/ );

  				if ( tokens[ 0 ] !== 'CHANNELS' ) {

  					console.error( 'THREE.BVHLoader: Expected CHANNELS definition.' );

  				}

  				const numChannels = parseInt( tokens[ 1 ] );
  				node.channels = tokens.splice( 2, numChannels );
  				node.children = [];

  			}

  			// read children

  			while ( true ) {

  				const line = nextLine( lines );

  				if ( line === '}' ) {

  					return node;

  				} else {

  					node.children.push( readNode( lines, line, list ) );

  				}

  			}

  		}

  		/*
  			recursively converts the internal bvh node structure to a Bone hierarchy

  			source: the bvh root node
  			list: pass an empty array, collects a flat list of all converted THREE.Bones

  			returns the root Bone
  		*/
  		function toTHREEBone( source, list ) {

  			const bone = new Bone();
  			list.push( bone );

  			bone.position.add( source.offset );
  			bone.name = source.name;

  			if ( source.type !== 'ENDSITE' ) {

  				for ( let i = 0; i < source.children.length; i ++ ) {

  					bone.add( toTHREEBone( source.children[ i ], list ) );

  				}

  			}

  			return bone;

  		}

  		/*
  			builds a AnimationClip from the keyframe data saved in each bone.

  			bone: bvh root node

  			returns: a AnimationClip containing position and quaternion tracks
  		*/
  		function toTHREEAnimation( bones ) {

  			const tracks = [];

  			// create a position and quaternion animation track for each node

  			for ( let i = 0; i < bones.length; i ++ ) {

  				const bone = bones[ i ];

  				if ( bone.type === 'ENDSITE' )
  					continue;

  				// track data

  				const times = [];
  				const positions = [];
  				const rotations = [];

  				for ( let j = 0; j < bone.frames.length; j ++ ) {

  					const frame = bone.frames[ j ];

  					times.push( frame.time );

  					// the animation system animates the position property,
  					// so we have to add the joint offset to all values

  					positions.push( frame.position.x + bone.offset.x );
  					positions.push( frame.position.y + bone.offset.y );
  					positions.push( frame.position.z + bone.offset.z );

  					rotations.push( frame.rotation.x );
  					rotations.push( frame.rotation.y );
  					rotations.push( frame.rotation.z );
  					rotations.push( frame.rotation.w );

  				}

  				if ( scope.animateBonePositions ) {

  					tracks.push( new VectorKeyframeTrack( bone.name + '.position', times, positions ) );

  				}

  				if ( scope.animateBoneRotations ) {

  					tracks.push( new QuaternionKeyframeTrack( bone.name + '.quaternion', times, rotations ) );

  				}

  			}

  			return new AnimationClip( 'animation', - 1, tracks );

  		}

  		/*
  			returns the next non-empty line in lines
  		*/
  		function nextLine( lines ) {

  			let line;
  			// skip empty lines
  			while ( ( line = lines.shift().trim() ).length === 0 ) { }

  			return line;

  		}

  		const scope = this;

  		const lines = text.split( /[\r\n]+/g );

  		const bones = readBvh( lines );

  		const threeBones = [];
  		toTHREEBone( bones[ 0 ], threeBones );

  		const threeClip = toTHREEAnimation( bones );

  		return {
  			skeleton: new Skeleton( threeBones ),
  			clip: threeClip
  		};

  	}

  }

  let _renderer;
  let fullscreenQuadGeometry;
  let fullscreenQuadMaterial;
  let fullscreenQuad;

  function decompress( texture, maxTextureSize = Infinity, renderer = null ) {

  	if ( ! fullscreenQuadGeometry ) fullscreenQuadGeometry = new PlaneGeometry( 2, 2, 1, 1 );
  	if ( ! fullscreenQuadMaterial ) fullscreenQuadMaterial = new ShaderMaterial( {
  		uniforms: { blitTexture: new Uniform( texture ) },
  		vertexShader: `
			varying vec2 vUv;
			void main(){
				vUv = uv;
				gl_Position = vec4(position.xy * 1.0,0.,.999999);
			}`,
  		fragmentShader: `
			uniform sampler2D blitTexture; 
			varying vec2 vUv;

			void main(){ 
				gl_FragColor = vec4(vUv.xy, 0, 1);
				
				#ifdef IS_SRGB
				gl_FragColor = sRGBTransferOETF( texture2D( blitTexture, vUv) );
				#else
				gl_FragColor = texture2D( blitTexture, vUv);
				#endif
			}`
  	} );

  	fullscreenQuadMaterial.uniforms.blitTexture.value = texture;
  	fullscreenQuadMaterial.defines.IS_SRGB = texture.colorSpace == SRGBColorSpace;
  	fullscreenQuadMaterial.needsUpdate = true;

  	if ( ! fullscreenQuad ) {

  		fullscreenQuad = new Mesh( fullscreenQuadGeometry, fullscreenQuadMaterial );
  		fullscreenQuad.frustumCulled = false;

  	}

  	const _camera = new PerspectiveCamera();
  	const _scene = new Scene();
  	_scene.add( fullscreenQuad );

  	if ( renderer === null ) {

  		renderer = _renderer = new WebGLRenderer( { antialias: false } );

  	}

  	const width = Math.min( texture.image.width, maxTextureSize );
  	const height = Math.min( texture.image.height, maxTextureSize );

  	renderer.setSize( width, height );
  	renderer.clear();
  	renderer.render( _scene, _camera );

  	const canvas = document.createElement( 'canvas' );
  	const context = canvas.getContext( '2d' );

  	canvas.width = width;
  	canvas.height = height;

  	context.drawImage( renderer.domElement, 0, 0, width, height );

  	const readableTexture = new CanvasTexture( canvas );

  	readableTexture.minFilter = texture.minFilter;
  	readableTexture.magFilter = texture.magFilter;
  	readableTexture.wrapS = texture.wrapS;
  	readableTexture.wrapT = texture.wrapT;
  	readableTexture.name = texture.name;

  	if ( _renderer ) {

  		_renderer.forceContextLoss();
  		_renderer.dispose();
  		_renderer = null;

  	}

  	return readableTexture;

  }

  /**
   * The KHR_mesh_quantization extension allows these extra attribute component types
   *
   * @see https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_mesh_quantization/README.md#extending-mesh-attributes
   */
  const KHR_mesh_quantization_ExtraAttrTypes = {
  	POSITION: [
  		'byte',
  		'byte normalized',
  		'unsigned byte',
  		'unsigned byte normalized',
  		'short',
  		'short normalized',
  		'unsigned short',
  		'unsigned short normalized',
  	],
  	NORMAL: [
  		'byte normalized',
  		'short normalized',
  	],
  	TANGENT: [
  		'byte normalized',
  		'short normalized',
  	],
  	TEXCOORD: [
  		'byte',
  		'byte normalized',
  		'unsigned byte',
  		'short',
  		'short normalized',
  		'unsigned short',
  	],
  };


  class GLTFExporter {

  	constructor() {

  		this.pluginCallbacks = [];

  		this.register( function ( writer ) {

  			return new GLTFLightExtension( writer );

  		} );

  		this.register( function ( writer ) {

  			return new GLTFMaterialsUnlitExtension$1( writer );

  		} );

  		this.register( function ( writer ) {

  			return new GLTFMaterialsTransmissionExtension$1( writer );

  		} );

  		this.register( function ( writer ) {

  			return new GLTFMaterialsVolumeExtension$1( writer );

  		} );

  		this.register( function ( writer ) {

  			return new GLTFMaterialsIorExtension$1( writer );

  		} );

  		this.register( function ( writer ) {

  			return new GLTFMaterialsSpecularExtension$1( writer );

  		} );

  		this.register( function ( writer ) {

  			return new GLTFMaterialsClearcoatExtension$1( writer );

  		} );

  		this.register( function ( writer ) {

  			return new GLTFMaterialsDispersionExtension$1( writer );

  		} );

  		this.register( function ( writer ) {

  			return new GLTFMaterialsIridescenceExtension$1( writer );

  		} );

  		this.register( function ( writer ) {

  			return new GLTFMaterialsSheenExtension$1( writer );

  		} );

  		this.register( function ( writer ) {

  			return new GLTFMaterialsAnisotropyExtension$1( writer );

  		} );

  		this.register( function ( writer ) {

  			return new GLTFMaterialsEmissiveStrengthExtension$1( writer );

  		} );

  		this.register( function ( writer ) {

  			return new GLTFMaterialsBumpExtension$1( writer );

  		} );

  		this.register( function ( writer ) {

  			return new GLTFMeshGpuInstancing$1( writer );

  		} );

  	}

  	register( callback ) {

  		if ( this.pluginCallbacks.indexOf( callback ) === - 1 ) {

  			this.pluginCallbacks.push( callback );

  		}

  		return this;

  	}

  	unregister( callback ) {

  		if ( this.pluginCallbacks.indexOf( callback ) !== - 1 ) {

  			this.pluginCallbacks.splice( this.pluginCallbacks.indexOf( callback ), 1 );

  		}

  		return this;

  	}

  	/**
  	 * Parse scenes and generate GLTF output
  	 * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes
  	 * @param  {Function} onDone  Callback on completed
  	 * @param  {Function} onError  Callback on errors
  	 * @param  {Object} options options
  	 */
  	parse( input, onDone, onError, options ) {

  		const writer = new GLTFWriter();
  		const plugins = [];

  		for ( let i = 0, il = this.pluginCallbacks.length; i < il; i ++ ) {

  			plugins.push( this.pluginCallbacks[ i ]( writer ) );

  		}

  		writer.setPlugins( plugins );
  		writer.write( input, onDone, options ).catch( onError );

  	}

  	parseAsync( input, options ) {

  		const scope = this;

  		return new Promise( function ( resolve, reject ) {

  			scope.parse( input, resolve, reject, options );

  		} );

  	}

  }

  //------------------------------------------------------------------------------
  // Constants
  //------------------------------------------------------------------------------

  const WEBGL_CONSTANTS$1 = {
  	POINTS: 0x0000,
  	LINES: 0x0001,
  	LINE_LOOP: 0x0002,
  	LINE_STRIP: 0x0003,
  	TRIANGLES: 0x0004,
  	TRIANGLE_STRIP: 0x0005,
  	TRIANGLE_FAN: 0x0006,

  	BYTE: 0x1400,
  	UNSIGNED_BYTE: 0x1401,
  	SHORT: 0x1402,
  	UNSIGNED_SHORT: 0x1403,
  	INT: 0x1404,
  	UNSIGNED_INT: 0x1405,
  	FLOAT: 0x1406,

  	ARRAY_BUFFER: 0x8892,
  	ELEMENT_ARRAY_BUFFER: 0x8893,

  	NEAREST: 0x2600,
  	LINEAR: 0x2601,
  	NEAREST_MIPMAP_NEAREST: 0x2700,
  	LINEAR_MIPMAP_NEAREST: 0x2701,
  	NEAREST_MIPMAP_LINEAR: 0x2702,
  	LINEAR_MIPMAP_LINEAR: 0x2703,

  	CLAMP_TO_EDGE: 33071,
  	MIRRORED_REPEAT: 33648,
  	REPEAT: 10497
  };

  const KHR_MESH_QUANTIZATION = 'KHR_mesh_quantization';

  const THREE_TO_WEBGL = {};

  THREE_TO_WEBGL[ NearestFilter ] = WEBGL_CONSTANTS$1.NEAREST;
  THREE_TO_WEBGL[ NearestMipmapNearestFilter ] = WEBGL_CONSTANTS$1.NEAREST_MIPMAP_NEAREST;
  THREE_TO_WEBGL[ NearestMipmapLinearFilter ] = WEBGL_CONSTANTS$1.NEAREST_MIPMAP_LINEAR;
  THREE_TO_WEBGL[ LinearFilter ] = WEBGL_CONSTANTS$1.LINEAR;
  THREE_TO_WEBGL[ LinearMipmapNearestFilter ] = WEBGL_CONSTANTS$1.LINEAR_MIPMAP_NEAREST;
  THREE_TO_WEBGL[ LinearMipmapLinearFilter ] = WEBGL_CONSTANTS$1.LINEAR_MIPMAP_LINEAR;

  THREE_TO_WEBGL[ ClampToEdgeWrapping ] = WEBGL_CONSTANTS$1.CLAMP_TO_EDGE;
  THREE_TO_WEBGL[ RepeatWrapping ] = WEBGL_CONSTANTS$1.REPEAT;
  THREE_TO_WEBGL[ MirroredRepeatWrapping ] = WEBGL_CONSTANTS$1.MIRRORED_REPEAT;

  const PATH_PROPERTIES$1 = {
  	scale: 'scale',
  	position: 'translation',
  	quaternion: 'rotation',
  	morphTargetInfluences: 'weights'
  };

  const DEFAULT_SPECULAR_COLOR = new Color();

  // GLB constants
  // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification

  const GLB_HEADER_BYTES = 12;
  const GLB_HEADER_MAGIC = 0x46546C67;
  const GLB_VERSION = 2;

  const GLB_CHUNK_PREFIX_BYTES = 8;
  const GLB_CHUNK_TYPE_JSON = 0x4E4F534A;
  const GLB_CHUNK_TYPE_BIN = 0x004E4942;

  //------------------------------------------------------------------------------
  // Utility functions
  //------------------------------------------------------------------------------

  /**
   * Compare two arrays
   * @param  {Array} array1 Array 1 to compare
   * @param  {Array} array2 Array 2 to compare
   * @return {Boolean}        Returns true if both arrays are equal
   */
  function equalArray( array1, array2 ) {

  	return ( array1.length === array2.length ) && array1.every( function ( element, index ) {

  		return element === array2[ index ];

  	} );

  }

  /**
   * Converts a string to an ArrayBuffer.
   * @param  {string} text
   * @return {ArrayBuffer}
   */
  function stringToArrayBuffer( text ) {

  	return new TextEncoder().encode( text ).buffer;

  }

  /**
   * Is identity matrix
   *
   * @param {Matrix4} matrix
   * @returns {Boolean} Returns true, if parameter is identity matrix
   */
  function isIdentityMatrix( matrix ) {

  	return equalArray( matrix.elements, [ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ] );

  }

  /**
   * Get the min and max vectors from the given attribute
   * @param  {BufferAttribute} attribute Attribute to find the min/max in range from start to start + count
   * @param  {Integer} start
   * @param  {Integer} count
   * @return {Object} Object containing the `min` and `max` values (As an array of attribute.itemSize components)
   */
  function getMinMax( attribute, start, count ) {

  	const output = {

  		min: new Array( attribute.itemSize ).fill( Number.POSITIVE_INFINITY ),
  		max: new Array( attribute.itemSize ).fill( Number.NEGATIVE_INFINITY )

  	};

  	for ( let i = start; i < start + count; i ++ ) {

  		for ( let a = 0; a < attribute.itemSize; a ++ ) {

  			let value;

  			if ( attribute.itemSize > 4 ) {

  				 // no support for interleaved data for itemSize > 4

  				value = attribute.array[ i * attribute.itemSize + a ];

  			} else {

  				if ( a === 0 ) value = attribute.getX( i );
  				else if ( a === 1 ) value = attribute.getY( i );
  				else if ( a === 2 ) value = attribute.getZ( i );
  				else if ( a === 3 ) value = attribute.getW( i );

  				if ( attribute.normalized === true ) {

  					value = MathUtils.normalize( value, attribute.array );

  				}

  			}

  			output.min[ a ] = Math.min( output.min[ a ], value );
  			output.max[ a ] = Math.max( output.max[ a ], value );

  		}

  	}

  	return output;

  }

  /**
   * Get the required size + padding for a buffer, rounded to the next 4-byte boundary.
   * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#data-alignment
   *
   * @param {Integer} bufferSize The size the original buffer.
   * @returns {Integer} new buffer size with required padding.
   *
   */
  function getPaddedBufferSize( bufferSize ) {

  	return Math.ceil( bufferSize / 4 ) * 4;

  }

  /**
   * Returns a buffer aligned to 4-byte boundary.
   *
   * @param {ArrayBuffer} arrayBuffer Buffer to pad
   * @param {Integer} paddingByte (Optional)
   * @returns {ArrayBuffer} The same buffer if it's already aligned to 4-byte boundary or a new buffer
   */
  function getPaddedArrayBuffer( arrayBuffer, paddingByte = 0 ) {

  	const paddedLength = getPaddedBufferSize( arrayBuffer.byteLength );

  	if ( paddedLength !== arrayBuffer.byteLength ) {

  		const array = new Uint8Array( paddedLength );
  		array.set( new Uint8Array( arrayBuffer ) );

  		if ( paddingByte !== 0 ) {

  			for ( let i = arrayBuffer.byteLength; i < paddedLength; i ++ ) {

  				array[ i ] = paddingByte;

  			}

  		}

  		return array.buffer;

  	}

  	return arrayBuffer;

  }

  function getCanvas() {

  	if ( typeof document === 'undefined' && typeof OffscreenCanvas !== 'undefined' ) {

  		return new OffscreenCanvas( 1, 1 );

  	}

  	return document.createElement( 'canvas' );

  }

  function getToBlobPromise( canvas, mimeType ) {

  	if ( canvas.toBlob !== undefined ) {

  		return new Promise( ( resolve ) => canvas.toBlob( resolve, mimeType ) );

  	}

  	let quality;

  	// Blink's implementation of convertToBlob seems to default to a quality level of 100%
  	// Use the Blink default quality levels of toBlob instead so that file sizes are comparable.
  	if ( mimeType === 'image/jpeg' ) {

  		quality = 0.92;

  	} else if ( mimeType === 'image/webp' ) {

  		quality = 0.8;

  	}

  	return canvas.convertToBlob( {

  		type: mimeType,
  		quality: quality

  	} );

  }

  /**
   * Writer
   */
  class GLTFWriter {

  	constructor() {

  		this.plugins = [];

  		this.options = {};
  		this.pending = [];
  		this.buffers = [];

  		this.byteOffset = 0;
  		this.buffers = [];
  		this.nodeMap = new Map();
  		this.skins = [];

  		this.extensionsUsed = {};
  		this.extensionsRequired = {};

  		this.uids = new Map();
  		this.uid = 0;

  		this.json = {
  			asset: {
  				version: '2.0',
  				generator: 'THREE.GLTFExporter r' + REVISION
  			}
  		};

  		this.cache = {
  			meshes: new Map(),
  			attributes: new Map(),
  			attributesNormalized: new Map(),
  			materials: new Map(),
  			textures: new Map(),
  			images: new Map()
  		};

  	}

  	setPlugins( plugins ) {

  		this.plugins = plugins;

  	}

  	/**
  	 * Parse scenes and generate GLTF output
  	 * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes
  	 * @param  {Function} onDone  Callback on completed
  	 * @param  {Object} options options
  	 */
  	async write( input, onDone, options = {} ) {

  		this.options = Object.assign( {
  			// default options
  			binary: false,
  			trs: false,
  			onlyVisible: true,
  			maxTextureSize: Infinity,
  			animations: [],
  			includeCustomExtensions: false
  		}, options );

  		if ( this.options.animations.length > 0 ) {

  			// Only TRS properties, and not matrices, may be targeted by animation.
  			this.options.trs = true;

  		}

  		this.processInput( input );

  		await Promise.all( this.pending );

  		const writer = this;
  		const buffers = writer.buffers;
  		const json = writer.json;
  		options = writer.options;

  		const extensionsUsed = writer.extensionsUsed;
  		const extensionsRequired = writer.extensionsRequired;

  		// Merge buffers.
  		const blob = new Blob( buffers, { type: 'application/octet-stream' } );

  		// Declare extensions.
  		const extensionsUsedList = Object.keys( extensionsUsed );
  		const extensionsRequiredList = Object.keys( extensionsRequired );

  		if ( extensionsUsedList.length > 0 ) json.extensionsUsed = extensionsUsedList;
  		if ( extensionsRequiredList.length > 0 ) json.extensionsRequired = extensionsRequiredList;

  		// Update bytelength of the single buffer.
  		if ( json.buffers && json.buffers.length > 0 ) json.buffers[ 0 ].byteLength = blob.size;

  		if ( options.binary === true ) {

  			// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification

  			const reader = new FileReader();
  			reader.readAsArrayBuffer( blob );
  			reader.onloadend = function () {

  				// Binary chunk.
  				const binaryChunk = getPaddedArrayBuffer( reader.result );
  				const binaryChunkPrefix = new DataView( new ArrayBuffer( GLB_CHUNK_PREFIX_BYTES ) );
  				binaryChunkPrefix.setUint32( 0, binaryChunk.byteLength, true );
  				binaryChunkPrefix.setUint32( 4, GLB_CHUNK_TYPE_BIN, true );

  				// JSON chunk.
  				const jsonChunk = getPaddedArrayBuffer( stringToArrayBuffer( JSON.stringify( json ) ), 0x20 );
  				const jsonChunkPrefix = new DataView( new ArrayBuffer( GLB_CHUNK_PREFIX_BYTES ) );
  				jsonChunkPrefix.setUint32( 0, jsonChunk.byteLength, true );
  				jsonChunkPrefix.setUint32( 4, GLB_CHUNK_TYPE_JSON, true );

  				// GLB header.
  				const header = new ArrayBuffer( GLB_HEADER_BYTES );
  				const headerView = new DataView( header );
  				headerView.setUint32( 0, GLB_HEADER_MAGIC, true );
  				headerView.setUint32( 4, GLB_VERSION, true );
  				const totalByteLength = GLB_HEADER_BYTES
  					+ jsonChunkPrefix.byteLength + jsonChunk.byteLength
  					+ binaryChunkPrefix.byteLength + binaryChunk.byteLength;
  				headerView.setUint32( 8, totalByteLength, true );

  				const glbBlob = new Blob( [
  					header,
  					jsonChunkPrefix,
  					jsonChunk,
  					binaryChunkPrefix,
  					binaryChunk
  				], { type: 'application/octet-stream' } );

  				const glbReader = new FileReader();
  				glbReader.readAsArrayBuffer( glbBlob );
  				glbReader.onloadend = function () {

  					onDone( glbReader.result );

  				};

  			};

  		} else {

  			if ( json.buffers && json.buffers.length > 0 ) {

  				const reader = new FileReader();
  				reader.readAsDataURL( blob );
  				reader.onloadend = function () {

  					const base64data = reader.result;
  					json.buffers[ 0 ].uri = base64data;
  					onDone( json );

  				};

  			} else {

  				onDone( json );

  			}

  		}


  	}

  	/**
  	 * Serializes a userData.
  	 *
  	 * @param {THREE.Object3D|THREE.Material} object
  	 * @param {Object} objectDef
  	 */
  	serializeUserData( object, objectDef ) {

  		if ( Object.keys( object.userData ).length === 0 ) return;

  		const options = this.options;
  		const extensionsUsed = this.extensionsUsed;

  		try {

  			const json = JSON.parse( JSON.stringify( object.userData ) );

  			if ( options.includeCustomExtensions && json.gltfExtensions ) {

  				if ( objectDef.extensions === undefined ) objectDef.extensions = {};

  				for ( const extensionName in json.gltfExtensions ) {

  					objectDef.extensions[ extensionName ] = json.gltfExtensions[ extensionName ];
  					extensionsUsed[ extensionName ] = true;

  				}

  				delete json.gltfExtensions;

  			}

  			if ( Object.keys( json ).length > 0 ) objectDef.extras = json;

  		} catch ( error ) {

  			console.warn( 'THREE.GLTFExporter: userData of \'' + object.name + '\' ' +
  				'won\'t be serialized because of JSON.stringify error - ' + error.message );

  		}

  	}

  	/**
  	 * Returns ids for buffer attributes.
  	 * @param  {Object} object
  	 * @return {Integer}
  	 */
  	getUID( attribute, isRelativeCopy = false ) {

  		if ( this.uids.has( attribute ) === false ) {

  			const uids = new Map();

  			uids.set( true, this.uid ++ );
  			uids.set( false, this.uid ++ );

  			this.uids.set( attribute, uids );

  		}

  		const uids = this.uids.get( attribute );

  		return uids.get( isRelativeCopy );

  	}

  	/**
  	 * Checks if normal attribute values are normalized.
  	 *
  	 * @param {BufferAttribute} normal
  	 * @returns {Boolean}
  	 */
  	isNormalizedNormalAttribute( normal ) {

  		const cache = this.cache;

  		if ( cache.attributesNormalized.has( normal ) ) return false;

  		const v = new Vector3();

  		for ( let i = 0, il = normal.count; i < il; i ++ ) {

  			// 0.0005 is from glTF-validator
  			if ( Math.abs( v.fromBufferAttribute( normal, i ).length() - 1.0 ) > 0.0005 ) return false;

  		}

  		return true;

  	}

  	/**
  	 * Creates normalized normal buffer attribute.
  	 *
  	 * @param {BufferAttribute} normal
  	 * @returns {BufferAttribute}
  	 *
  	 */
  	createNormalizedNormalAttribute( normal ) {

  		const cache = this.cache;

  		if ( cache.attributesNormalized.has( normal ) )	return cache.attributesNormalized.get( normal );

  		const attribute = normal.clone();
  		const v = new Vector3();

  		for ( let i = 0, il = attribute.count; i < il; i ++ ) {

  			v.fromBufferAttribute( attribute, i );

  			if ( v.x === 0 && v.y === 0 && v.z === 0 ) {

  				// if values can't be normalized set (1, 0, 0)
  				v.setX( 1.0 );

  			} else {

  				v.normalize();

  			}

  			attribute.setXYZ( i, v.x, v.y, v.z );

  		}

  		cache.attributesNormalized.set( normal, attribute );

  		return attribute;

  	}

  	/**
  	 * Applies a texture transform, if present, to the map definition. Requires
  	 * the KHR_texture_transform extension.
  	 *
  	 * @param {Object} mapDef
  	 * @param {THREE.Texture} texture
  	 */
  	applyTextureTransform( mapDef, texture ) {

  		let didTransform = false;
  		const transformDef = {};

  		if ( texture.offset.x !== 0 || texture.offset.y !== 0 ) {

  			transformDef.offset = texture.offset.toArray();
  			didTransform = true;

  		}

  		if ( texture.rotation !== 0 ) {

  			transformDef.rotation = texture.rotation;
  			didTransform = true;

  		}

  		if ( texture.repeat.x !== 1 || texture.repeat.y !== 1 ) {

  			transformDef.scale = texture.repeat.toArray();
  			didTransform = true;

  		}

  		if ( didTransform ) {

  			mapDef.extensions = mapDef.extensions || {};
  			mapDef.extensions[ 'KHR_texture_transform' ] = transformDef;
  			this.extensionsUsed[ 'KHR_texture_transform' ] = true;

  		}

  	}

  	buildMetalRoughTexture( metalnessMap, roughnessMap ) {

  		if ( metalnessMap === roughnessMap ) return metalnessMap;

  		function getEncodingConversion( map ) {

  			if ( map.colorSpace === SRGBColorSpace ) {

  				return function SRGBToLinear( c ) {

  					return ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );

  				};

  			}

  			return function LinearToLinear( c ) {

  				return c;

  			};

  		}

  		console.warn( 'THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures.' );

  		if ( metalnessMap instanceof CompressedTexture ) {

  			metalnessMap = decompress( metalnessMap );

  		}

  		if ( roughnessMap instanceof CompressedTexture ) {

  			roughnessMap = decompress( roughnessMap );

  		}

  		const metalness = metalnessMap ? metalnessMap.image : null;
  		const roughness = roughnessMap ? roughnessMap.image : null;

  		const width = Math.max( metalness ? metalness.width : 0, roughness ? roughness.width : 0 );
  		const height = Math.max( metalness ? metalness.height : 0, roughness ? roughness.height : 0 );

  		const canvas = getCanvas();
  		canvas.width = width;
  		canvas.height = height;

  		const context = canvas.getContext( '2d', {
  			willReadFrequently: true,
  		} );
  		context.fillStyle = '#00ffff';
  		context.fillRect( 0, 0, width, height );

  		const composite = context.getImageData( 0, 0, width, height );

  		if ( metalness ) {

  			context.drawImage( metalness, 0, 0, width, height );

  			const convert = getEncodingConversion( metalnessMap );
  			const data = context.getImageData( 0, 0, width, height ).data;

  			for ( let i = 2; i < data.length; i += 4 ) {

  				composite.data[ i ] = convert( data[ i ] / 256 ) * 256;

  			}

  		}

  		if ( roughness ) {

  			context.drawImage( roughness, 0, 0, width, height );

  			const convert = getEncodingConversion( roughnessMap );
  			const data = context.getImageData( 0, 0, width, height ).data;

  			for ( let i = 1; i < data.length; i += 4 ) {

  				composite.data[ i ] = convert( data[ i ] / 256 ) * 256;

  			}

  		}

  		context.putImageData( composite, 0, 0 );

  		//

  		const reference = metalnessMap || roughnessMap;

  		const texture = reference.clone();

  		texture.source = new Source( canvas );
  		texture.colorSpace = NoColorSpace;
  		texture.channel = ( metalnessMap || roughnessMap ).channel;

  		if ( metalnessMap && roughnessMap && metalnessMap.channel !== roughnessMap.channel ) {

  			console.warn( 'THREE.GLTFExporter: UV channels for metalnessMap and roughnessMap textures must match.' );

  		}

  		return texture;

  	}

  	/**
  	 * Process a buffer to append to the default one.
  	 * @param  {ArrayBuffer} buffer
  	 * @return {Integer}
  	 */
  	processBuffer( buffer ) {

  		const json = this.json;
  		const buffers = this.buffers;

  		if ( ! json.buffers ) json.buffers = [ { byteLength: 0 } ];

  		// All buffers are merged before export.
  		buffers.push( buffer );

  		return 0;

  	}

  	/**
  	 * Process and generate a BufferView
  	 * @param  {BufferAttribute} attribute
  	 * @param  {number} componentType
  	 * @param  {number} start
  	 * @param  {number} count
  	 * @param  {number} target (Optional) Target usage of the BufferView
  	 * @return {Object}
  	 */
  	processBufferView( attribute, componentType, start, count, target ) {

  		const json = this.json;

  		if ( ! json.bufferViews ) json.bufferViews = [];

  		// Create a new dataview and dump the attribute's array into it

  		let componentSize;

  		switch ( componentType ) {

  			case WEBGL_CONSTANTS$1.BYTE:
  			case WEBGL_CONSTANTS$1.UNSIGNED_BYTE:

  				componentSize = 1;

  				break;

  			case WEBGL_CONSTANTS$1.SHORT:
  			case WEBGL_CONSTANTS$1.UNSIGNED_SHORT:

  				componentSize = 2;

  				break;

  			default:

  				componentSize = 4;

  		}

  		let byteStride = attribute.itemSize * componentSize;

  		if ( target === WEBGL_CONSTANTS$1.ARRAY_BUFFER ) {

  			// Each element of a vertex attribute MUST be aligned to 4-byte boundaries
  			// inside a bufferView
  			byteStride = Math.ceil( byteStride / 4 ) * 4;

  		}

  		const byteLength = getPaddedBufferSize( count * byteStride );
  		const dataView = new DataView( new ArrayBuffer( byteLength ) );
  		let offset = 0;

  		for ( let i = start; i < start + count; i ++ ) {

  			for ( let a = 0; a < attribute.itemSize; a ++ ) {

  				let value;

  				if ( attribute.itemSize > 4 ) {

  					 // no support for interleaved data for itemSize > 4

  					value = attribute.array[ i * attribute.itemSize + a ];

  				} else {

  					if ( a === 0 ) value = attribute.getX( i );
  					else if ( a === 1 ) value = attribute.getY( i );
  					else if ( a === 2 ) value = attribute.getZ( i );
  					else if ( a === 3 ) value = attribute.getW( i );

  					if ( attribute.normalized === true ) {

  						value = MathUtils.normalize( value, attribute.array );

  					}

  				}

  				if ( componentType === WEBGL_CONSTANTS$1.FLOAT ) {

  					dataView.setFloat32( offset, value, true );

  				} else if ( componentType === WEBGL_CONSTANTS$1.INT ) {

  					dataView.setInt32( offset, value, true );

  				} else if ( componentType === WEBGL_CONSTANTS$1.UNSIGNED_INT ) {

  					dataView.setUint32( offset, value, true );

  				} else if ( componentType === WEBGL_CONSTANTS$1.SHORT ) {

  					dataView.setInt16( offset, value, true );

  				} else if ( componentType === WEBGL_CONSTANTS$1.UNSIGNED_SHORT ) {

  					dataView.setUint16( offset, value, true );

  				} else if ( componentType === WEBGL_CONSTANTS$1.BYTE ) {

  					dataView.setInt8( offset, value );

  				} else if ( componentType === WEBGL_CONSTANTS$1.UNSIGNED_BYTE ) {

  					dataView.setUint8( offset, value );

  				}

  				offset += componentSize;

  			}

  			if ( ( offset % byteStride ) !== 0 ) {

  				offset += byteStride - ( offset % byteStride );

  			}

  		}

  		const bufferViewDef = {

  			buffer: this.processBuffer( dataView.buffer ),
  			byteOffset: this.byteOffset,
  			byteLength: byteLength

  		};

  		if ( target !== undefined ) bufferViewDef.target = target;

  		if ( target === WEBGL_CONSTANTS$1.ARRAY_BUFFER ) {

  			// Only define byteStride for vertex attributes.
  			bufferViewDef.byteStride = byteStride;

  		}

  		this.byteOffset += byteLength;

  		json.bufferViews.push( bufferViewDef );

  		// @TODO Merge bufferViews where possible.
  		const output = {

  			id: json.bufferViews.length - 1,
  			byteLength: 0

  		};

  		return output;

  	}

  	/**
  	 * Process and generate a BufferView from an image Blob.
  	 * @param {Blob} blob
  	 * @return {Promise<Integer>}
  	 */
  	processBufferViewImage( blob ) {

  		const writer = this;
  		const json = writer.json;

  		if ( ! json.bufferViews ) json.bufferViews = [];

  		return new Promise( function ( resolve ) {

  			const reader = new FileReader();
  			reader.readAsArrayBuffer( blob );
  			reader.onloadend = function () {

  				const buffer = getPaddedArrayBuffer( reader.result );

  				const bufferViewDef = {
  					buffer: writer.processBuffer( buffer ),
  					byteOffset: writer.byteOffset,
  					byteLength: buffer.byteLength
  				};

  				writer.byteOffset += buffer.byteLength;
  				resolve( json.bufferViews.push( bufferViewDef ) - 1 );

  			};

  		} );

  	}

  	/**
  	 * Process attribute to generate an accessor
  	 * @param  {BufferAttribute} attribute Attribute to process
  	 * @param  {THREE.BufferGeometry} geometry (Optional) Geometry used for truncated draw range
  	 * @param  {Integer} start (Optional)
  	 * @param  {Integer} count (Optional)
  	 * @return {Integer|null} Index of the processed accessor on the "accessors" array
  	 */
  	processAccessor( attribute, geometry, start, count ) {

  		const json = this.json;

  		const types = {

  			1: 'SCALAR',
  			2: 'VEC2',
  			3: 'VEC3',
  			4: 'VEC4',
  			9: 'MAT3',
  			16: 'MAT4'

  		};

  		let componentType;

  		// Detect the component type of the attribute array
  		if ( attribute.array.constructor === Float32Array ) {

  			componentType = WEBGL_CONSTANTS$1.FLOAT;

  		} else if ( attribute.array.constructor === Int32Array ) {

  			componentType = WEBGL_CONSTANTS$1.INT;

  		} else if ( attribute.array.constructor === Uint32Array ) {

  			componentType = WEBGL_CONSTANTS$1.UNSIGNED_INT;

  		} else if ( attribute.array.constructor === Int16Array ) {

  			componentType = WEBGL_CONSTANTS$1.SHORT;

  		} else if ( attribute.array.constructor === Uint16Array ) {

  			componentType = WEBGL_CONSTANTS$1.UNSIGNED_SHORT;

  		} else if ( attribute.array.constructor === Int8Array ) {

  			componentType = WEBGL_CONSTANTS$1.BYTE;

  		} else if ( attribute.array.constructor === Uint8Array ) {

  			componentType = WEBGL_CONSTANTS$1.UNSIGNED_BYTE;

  		} else {

  			throw new Error( 'THREE.GLTFExporter: Unsupported bufferAttribute component type: ' + attribute.array.constructor.name );

  		}

  		if ( start === undefined ) start = 0;
  		if ( count === undefined || count === Infinity ) count = attribute.count;

  		// Skip creating an accessor if the attribute doesn't have data to export
  		if ( count === 0 ) return null;

  		const minMax = getMinMax( attribute, start, count );
  		let bufferViewTarget;

  		// If geometry isn't provided, don't infer the target usage of the bufferView. For
  		// animation samplers, target must not be set.
  		if ( geometry !== undefined ) {

  			bufferViewTarget = attribute === geometry.index ? WEBGL_CONSTANTS$1.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS$1.ARRAY_BUFFER;

  		}

  		const bufferView = this.processBufferView( attribute, componentType, start, count, bufferViewTarget );

  		const accessorDef = {

  			bufferView: bufferView.id,
  			byteOffset: bufferView.byteOffset,
  			componentType: componentType,
  			count: count,
  			max: minMax.max,
  			min: minMax.min,
  			type: types[ attribute.itemSize ]

  		};

  		if ( attribute.normalized === true ) accessorDef.normalized = true;
  		if ( ! json.accessors ) json.accessors = [];

  		return json.accessors.push( accessorDef ) - 1;

  	}

  	/**
  	 * Process image
  	 * @param  {Image} image to process
  	 * @param  {Integer} format of the image (RGBAFormat)
  	 * @param  {Boolean} flipY before writing out the image
  	 * @param  {String} mimeType export format
  	 * @return {Integer}     Index of the processed texture in the "images" array
  	 */
  	processImage( image, format, flipY, mimeType = 'image/png' ) {

  		if ( image !== null ) {

  			const writer = this;
  			const cache = writer.cache;
  			const json = writer.json;
  			const options = writer.options;
  			const pending = writer.pending;

  			if ( ! cache.images.has( image ) ) cache.images.set( image, {} );

  			const cachedImages = cache.images.get( image );

  			const key = mimeType + ':flipY/' + flipY.toString();

  			if ( cachedImages[ key ] !== undefined ) return cachedImages[ key ];

  			if ( ! json.images ) json.images = [];

  			const imageDef = { mimeType: mimeType };

  			const canvas = getCanvas();

  			canvas.width = Math.min( image.width, options.maxTextureSize );
  			canvas.height = Math.min( image.height, options.maxTextureSize );

  			const ctx = canvas.getContext( '2d', {
  				willReadFrequently: true,
  			} );

  			if ( flipY === true ) {

  				ctx.translate( 0, canvas.height );
  				ctx.scale( 1, - 1 );

  			}

  			if ( image.data !== undefined ) { // THREE.DataTexture

  				if ( format !== RGBAFormat ) {

  					console.error( 'GLTFExporter: Only RGBAFormat is supported.', format );

  				}

  				if ( image.width > options.maxTextureSize || image.height > options.maxTextureSize ) {

  					console.warn( 'GLTFExporter: Image size is bigger than maxTextureSize', image );

  				}

  				const data = new Uint8ClampedArray( image.height * image.width * 4 );

  				for ( let i = 0; i < data.length; i += 4 ) {

  					data[ i + 0 ] = image.data[ i + 0 ];
  					data[ i + 1 ] = image.data[ i + 1 ];
  					data[ i + 2 ] = image.data[ i + 2 ];
  					data[ i + 3 ] = image.data[ i + 3 ];

  				}

  				ctx.putImageData( new ImageData( data, image.width, image.height ), 0, 0 );

  			} else {

  				if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
  					( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
  					( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ||
  					( typeof OffscreenCanvas !== 'undefined' && image instanceof OffscreenCanvas ) ) {

  					ctx.drawImage( image, 0, 0, canvas.width, canvas.height );

  				} else {

  					throw new Error( 'THREE.GLTFExporter: Invalid image type. Use HTMLImageElement, HTMLCanvasElement, ImageBitmap or OffscreenCanvas.' );

  				}

  			}

  			if ( options.binary === true ) {

  				pending.push(

  					getToBlobPromise( canvas, mimeType )
  						.then( blob => writer.processBufferViewImage( blob ) )
  						.then( bufferViewIndex => {

  							imageDef.bufferView = bufferViewIndex;

  						} )

  				);

  			} else {

  				if ( canvas.toDataURL !== undefined ) {

  					imageDef.uri = canvas.toDataURL( mimeType );

  				} else {

  					pending.push(

  						getToBlobPromise( canvas, mimeType )
  							.then( blob => new FileReader().readAsDataURL( blob ) )
  							.then( dataURL => {

  								imageDef.uri = dataURL;

  							} )

  					);

  				}

  			}

  			const index = json.images.push( imageDef ) - 1;
  			cachedImages[ key ] = index;
  			return index;

  		} else {

  			throw new Error( 'THREE.GLTFExporter: No valid image data found. Unable to process texture.' );

  		}

  	}

  	/**
  	 * Process sampler
  	 * @param  {Texture} map Texture to process
  	 * @return {Integer}     Index of the processed texture in the "samplers" array
  	 */
  	processSampler( map ) {

  		const json = this.json;

  		if ( ! json.samplers ) json.samplers = [];

  		const samplerDef = {
  			magFilter: THREE_TO_WEBGL[ map.magFilter ],
  			minFilter: THREE_TO_WEBGL[ map.minFilter ],
  			wrapS: THREE_TO_WEBGL[ map.wrapS ],
  			wrapT: THREE_TO_WEBGL[ map.wrapT ]
  		};

  		return json.samplers.push( samplerDef ) - 1;

  	}

  	/**
  	 * Process texture
  	 * @param  {Texture} map Map to process
  	 * @return {Integer} Index of the processed texture in the "textures" array
  	 */
  	processTexture( map ) {

  		const writer = this;
  		const options = writer.options;
  		const cache = this.cache;
  		const json = this.json;

  		if ( cache.textures.has( map ) ) return cache.textures.get( map );

  		if ( ! json.textures ) json.textures = [];

  		// make non-readable textures (e.g. CompressedTexture) readable by blitting them into a new texture
  		if ( map instanceof CompressedTexture ) {

  			map = decompress( map, options.maxTextureSize );

  		}

  		let mimeType = map.userData.mimeType;

  		if ( mimeType === 'image/webp' ) mimeType = 'image/png';

  		const textureDef = {
  			sampler: this.processSampler( map ),
  			source: this.processImage( map.image, map.format, map.flipY, mimeType )
  		};

  		if ( map.name ) textureDef.name = map.name;

  		this._invokeAll( function ( ext ) {

  			ext.writeTexture && ext.writeTexture( map, textureDef );

  		} );

  		const index = json.textures.push( textureDef ) - 1;
  		cache.textures.set( map, index );
  		return index;

  	}

  	/**
  	 * Process material
  	 * @param  {THREE.Material} material Material to process
  	 * @return {Integer|null} Index of the processed material in the "materials" array
  	 */
  	processMaterial( material ) {

  		const cache = this.cache;
  		const json = this.json;

  		if ( cache.materials.has( material ) ) return cache.materials.get( material );

  		if ( material.isShaderMaterial ) {

  			console.warn( 'GLTFExporter: THREE.ShaderMaterial not supported.' );
  			return null;

  		}

  		if ( ! json.materials ) json.materials = [];

  		// @QUESTION Should we avoid including any attribute that has the default value?
  		const materialDef = {	pbrMetallicRoughness: {} };

  		if ( material.isMeshStandardMaterial !== true && material.isMeshBasicMaterial !== true ) {

  			console.warn( 'GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.' );

  		}

  		// pbrMetallicRoughness.baseColorFactor
  		const color = material.color.toArray().concat( [ material.opacity ] );

  		if ( ! equalArray( color, [ 1, 1, 1, 1 ] ) ) {

  			materialDef.pbrMetallicRoughness.baseColorFactor = color;

  		}

  		if ( material.isMeshStandardMaterial ) {

  			materialDef.pbrMetallicRoughness.metallicFactor = material.metalness;
  			materialDef.pbrMetallicRoughness.roughnessFactor = material.roughness;

  		} else {

  			materialDef.pbrMetallicRoughness.metallicFactor = 0.5;
  			materialDef.pbrMetallicRoughness.roughnessFactor = 0.5;

  		}

  		// pbrMetallicRoughness.metallicRoughnessTexture
  		if ( material.metalnessMap || material.roughnessMap ) {

  			const metalRoughTexture = this.buildMetalRoughTexture( material.metalnessMap, material.roughnessMap );

  			const metalRoughMapDef = {
  				index: this.processTexture( metalRoughTexture ),
  				channel: metalRoughTexture.channel
  			};
  			this.applyTextureTransform( metalRoughMapDef, metalRoughTexture );
  			materialDef.pbrMetallicRoughness.metallicRoughnessTexture = metalRoughMapDef;

  		}

  		// pbrMetallicRoughness.baseColorTexture
  		if ( material.map ) {

  			const baseColorMapDef = {
  				index: this.processTexture( material.map ),
  				texCoord: material.map.channel
  			};
  			this.applyTextureTransform( baseColorMapDef, material.map );
  			materialDef.pbrMetallicRoughness.baseColorTexture = baseColorMapDef;

  		}

  		if ( material.emissive ) {

  			const emissive = material.emissive;
  			const maxEmissiveComponent = Math.max( emissive.r, emissive.g, emissive.b );

  			if ( maxEmissiveComponent > 0 ) {

  				materialDef.emissiveFactor = material.emissive.toArray();

  			}

  			// emissiveTexture
  			if ( material.emissiveMap ) {

  				const emissiveMapDef = {
  					index: this.processTexture( material.emissiveMap ),
  					texCoord: material.emissiveMap.channel
  				};
  				this.applyTextureTransform( emissiveMapDef, material.emissiveMap );
  				materialDef.emissiveTexture = emissiveMapDef;

  			}

  		}

  		// normalTexture
  		if ( material.normalMap ) {

  			const normalMapDef = {
  				index: this.processTexture( material.normalMap ),
  				texCoord: material.normalMap.channel
  			};

  			if ( material.normalScale && material.normalScale.x !== 1 ) {

  				// glTF normal scale is univariate. Ignore `y`, which may be flipped.
  				// Context: https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995
  				normalMapDef.scale = material.normalScale.x;

  			}

  			this.applyTextureTransform( normalMapDef, material.normalMap );
  			materialDef.normalTexture = normalMapDef;

  		}

  		// occlusionTexture
  		if ( material.aoMap ) {

  			const occlusionMapDef = {
  				index: this.processTexture( material.aoMap ),
  				texCoord: material.aoMap.channel
  			};

  			if ( material.aoMapIntensity !== 1.0 ) {

  				occlusionMapDef.strength = material.aoMapIntensity;

  			}

  			this.applyTextureTransform( occlusionMapDef, material.aoMap );
  			materialDef.occlusionTexture = occlusionMapDef;

  		}

  		// alphaMode
  		if ( material.transparent ) {

  			materialDef.alphaMode = 'BLEND';

  		} else {

  			if ( material.alphaTest > 0.0 ) {

  				materialDef.alphaMode = 'MASK';
  				materialDef.alphaCutoff = material.alphaTest;

  			}

  		}

  		// doubleSided
  		if ( material.side === DoubleSide ) materialDef.doubleSided = true;
  		if ( material.name !== '' ) materialDef.name = material.name;

  		this.serializeUserData( material, materialDef );

  		this._invokeAll( function ( ext ) {

  			ext.writeMaterial && ext.writeMaterial( material, materialDef );

  		} );

  		const index = json.materials.push( materialDef ) - 1;
  		cache.materials.set( material, index );
  		return index;

  	}

  	/**
  	 * Process mesh
  	 * @param  {THREE.Mesh} mesh Mesh to process
  	 * @return {Integer|null} Index of the processed mesh in the "meshes" array
  	 */
  	processMesh( mesh ) {

  		const cache = this.cache;
  		const json = this.json;

  		const meshCacheKeyParts = [ mesh.geometry.uuid ];

  		if ( Array.isArray( mesh.material ) ) {

  			for ( let i = 0, l = mesh.material.length; i < l; i ++ ) {

  				meshCacheKeyParts.push( mesh.material[ i ].uuid	);

  			}

  		} else {

  			meshCacheKeyParts.push( mesh.material.uuid );

  		}

  		const meshCacheKey = meshCacheKeyParts.join( ':' );

  		if ( cache.meshes.has( meshCacheKey ) ) return cache.meshes.get( meshCacheKey );

  		const geometry = mesh.geometry;

  		let mode;

  		// Use the correct mode
  		if ( mesh.isLineSegments ) {

  			mode = WEBGL_CONSTANTS$1.LINES;

  		} else if ( mesh.isLineLoop ) {

  			mode = WEBGL_CONSTANTS$1.LINE_LOOP;

  		} else if ( mesh.isLine ) {

  			mode = WEBGL_CONSTANTS$1.LINE_STRIP;

  		} else if ( mesh.isPoints ) {

  			mode = WEBGL_CONSTANTS$1.POINTS;

  		} else {

  			mode = mesh.material.wireframe ? WEBGL_CONSTANTS$1.LINES : WEBGL_CONSTANTS$1.TRIANGLES;

  		}

  		const meshDef = {};
  		const attributes = {};
  		const primitives = [];
  		const targets = [];

  		// Conversion between attributes names in threejs and gltf spec
  		const nameConversion = {
  			uv: 'TEXCOORD_0',
  			uv1: 'TEXCOORD_1',
  			uv2: 'TEXCOORD_2',
  			uv3: 'TEXCOORD_3',
  			color: 'COLOR_0',
  			skinWeight: 'WEIGHTS_0',
  			skinIndex: 'JOINTS_0'
  		};

  		const originalNormal = geometry.getAttribute( 'normal' );

  		if ( originalNormal !== undefined && ! this.isNormalizedNormalAttribute( originalNormal ) ) {

  			console.warn( 'THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.' );

  			geometry.setAttribute( 'normal', this.createNormalizedNormalAttribute( originalNormal ) );

  		}

  		// @QUESTION Detect if .vertexColors = true?
  		// For every attribute create an accessor
  		let modifiedAttribute = null;

  		for ( let attributeName in geometry.attributes ) {

  			// Ignore morph target attributes, which are exported later.
  			if ( attributeName.slice( 0, 5 ) === 'morph' ) continue;

  			const attribute = geometry.attributes[ attributeName ];
  			attributeName = nameConversion[ attributeName ] || attributeName.toUpperCase();

  			// Prefix all geometry attributes except the ones specifically
  			// listed in the spec; non-spec attributes are considered custom.
  			const validVertexAttributes =
  					/^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/;

  			if ( ! validVertexAttributes.test( attributeName ) ) attributeName = '_' + attributeName;

  			if ( cache.attributes.has( this.getUID( attribute ) ) ) {

  				attributes[ attributeName ] = cache.attributes.get( this.getUID( attribute ) );
  				continue;

  			}

  			// JOINTS_0 must be UNSIGNED_BYTE or UNSIGNED_SHORT.
  			modifiedAttribute = null;
  			const array = attribute.array;

  			if ( attributeName === 'JOINTS_0' &&
  				! ( array instanceof Uint16Array ) &&
  				! ( array instanceof Uint8Array ) ) {

  				console.warn( 'GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.' );
  				modifiedAttribute = new BufferAttribute( new Uint16Array( array ), attribute.itemSize, attribute.normalized );

  			}

  			const accessor = this.processAccessor( modifiedAttribute || attribute, geometry );

  			if ( accessor !== null ) {

  				if ( ! attributeName.startsWith( '_' ) ) {

  					this.detectMeshQuantization( attributeName, attribute );

  				}

  				attributes[ attributeName ] = accessor;
  				cache.attributes.set( this.getUID( attribute ), accessor );

  			}

  		}

  		if ( originalNormal !== undefined ) geometry.setAttribute( 'normal', originalNormal );

  		// Skip if no exportable attributes found
  		if ( Object.keys( attributes ).length === 0 ) return null;

  		// Morph targets
  		if ( mesh.morphTargetInfluences !== undefined && mesh.morphTargetInfluences.length > 0 ) {

  			const weights = [];
  			const targetNames = [];
  			const reverseDictionary = {};

  			if ( mesh.morphTargetDictionary !== undefined ) {

  				for ( const key in mesh.morphTargetDictionary ) {

  					reverseDictionary[ mesh.morphTargetDictionary[ key ] ] = key;

  				}

  			}

  			for ( let i = 0; i < mesh.morphTargetInfluences.length; ++ i ) {

  				const target = {};
  				let warned = false;

  				for ( const attributeName in geometry.morphAttributes ) {

  					// glTF 2.0 morph supports only POSITION/NORMAL/TANGENT.
  					// Three.js doesn't support TANGENT yet.

  					if ( attributeName !== 'position' && attributeName !== 'normal' ) {

  						if ( ! warned ) {

  							console.warn( 'GLTFExporter: Only POSITION and NORMAL morph are supported.' );
  							warned = true;

  						}

  						continue;

  					}

  					const attribute = geometry.morphAttributes[ attributeName ][ i ];
  					const gltfAttributeName = attributeName.toUpperCase();

  					// Three.js morph attribute has absolute values while the one of glTF has relative values.
  					//
  					// glTF 2.0 Specification:
  					// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#morph-targets

  					const baseAttribute = geometry.attributes[ attributeName ];

  					if ( cache.attributes.has( this.getUID( attribute, true ) ) ) {

  						target[ gltfAttributeName ] = cache.attributes.get( this.getUID( attribute, true ) );
  						continue;

  					}

  					// Clones attribute not to override
  					const relativeAttribute = attribute.clone();

  					if ( ! geometry.morphTargetsRelative ) {

  						for ( let j = 0, jl = attribute.count; j < jl; j ++ ) {

  							for ( let a = 0; a < attribute.itemSize; a ++ ) {

  								if ( a === 0 ) relativeAttribute.setX( j, attribute.getX( j ) - baseAttribute.getX( j ) );
  								if ( a === 1 ) relativeAttribute.setY( j, attribute.getY( j ) - baseAttribute.getY( j ) );
  								if ( a === 2 ) relativeAttribute.setZ( j, attribute.getZ( j ) - baseAttribute.getZ( j ) );
  								if ( a === 3 ) relativeAttribute.setW( j, attribute.getW( j ) - baseAttribute.getW( j ) );

  							}

  						}

  					}

  					target[ gltfAttributeName ] = this.processAccessor( relativeAttribute, geometry );
  					cache.attributes.set( this.getUID( baseAttribute, true ), target[ gltfAttributeName ] );

  				}

  				targets.push( target );

  				weights.push( mesh.morphTargetInfluences[ i ] );

  				if ( mesh.morphTargetDictionary !== undefined ) targetNames.push( reverseDictionary[ i ] );

  			}

  			meshDef.weights = weights;

  			if ( targetNames.length > 0 ) {

  				meshDef.extras = {};
  				meshDef.extras.targetNames = targetNames;

  			}

  		}

  		const isMultiMaterial = Array.isArray( mesh.material );

  		if ( isMultiMaterial && geometry.groups.length === 0 ) return null;

  		let didForceIndices = false;

  		if ( isMultiMaterial && geometry.index === null ) {

  			const indices = [];

  			for ( let i = 0, il = geometry.attributes.position.count; i < il; i ++ ) {

  				indices[ i ] = i;

  			}

  			geometry.setIndex( indices );

  			didForceIndices = true;

  		}

  		const materials = isMultiMaterial ? mesh.material : [ mesh.material ];
  		const groups = isMultiMaterial ? geometry.groups : [ { materialIndex: 0, start: undefined, count: undefined } ];

  		for ( let i = 0, il = groups.length; i < il; i ++ ) {

  			const primitive = {
  				mode: mode,
  				attributes: attributes,
  			};

  			this.serializeUserData( geometry, primitive );

  			if ( targets.length > 0 ) primitive.targets = targets;

  			if ( geometry.index !== null ) {

  				let cacheKey = this.getUID( geometry.index );

  				if ( groups[ i ].start !== undefined || groups[ i ].count !== undefined ) {

  					cacheKey += ':' + groups[ i ].start + ':' + groups[ i ].count;

  				}

  				if ( cache.attributes.has( cacheKey ) ) {

  					primitive.indices = cache.attributes.get( cacheKey );

  				} else {

  					primitive.indices = this.processAccessor( geometry.index, geometry, groups[ i ].start, groups[ i ].count );
  					cache.attributes.set( cacheKey, primitive.indices );

  				}

  				if ( primitive.indices === null ) delete primitive.indices;

  			}

  			const material = this.processMaterial( materials[ groups[ i ].materialIndex ] );

  			if ( material !== null ) primitive.material = material;

  			primitives.push( primitive );

  		}

  		if ( didForceIndices === true ) {

  			geometry.setIndex( null );

  		}

  		meshDef.primitives = primitives;

  		if ( ! json.meshes ) json.meshes = [];

  		this._invokeAll( function ( ext ) {

  			ext.writeMesh && ext.writeMesh( mesh, meshDef );

  		} );

  		const index = json.meshes.push( meshDef ) - 1;
  		cache.meshes.set( meshCacheKey, index );
  		return index;

  	}

  	/**
  	 * If a vertex attribute with a
  	 * [non-standard data type](https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#meshes-overview)
  	 * is used, it is checked whether it is a valid data type according to the
  	 * [KHR_mesh_quantization](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_mesh_quantization/README.md)
  	 * extension.
  	 * In this case the extension is automatically added to the list of used extensions.
  	 *
  	 * @param {string} attributeName
  	 * @param {THREE.BufferAttribute} attribute
  	 */
  	detectMeshQuantization( attributeName, attribute ) {

  		if ( this.extensionsUsed[ KHR_MESH_QUANTIZATION ] ) return;

  		let attrType = undefined;

  		switch ( attribute.array.constructor ) {

  			case Int8Array:

  				attrType = 'byte';

  				break;

  			case Uint8Array:

  				attrType = 'unsigned byte';

  				break;

  			case Int16Array:

  				attrType = 'short';

  				break;

  			case Uint16Array:

  				attrType = 'unsigned short';

  				break;

  			default:

  				return;

  		}

  		if ( attribute.normalized ) attrType += ' normalized';

  		const attrNamePrefix = attributeName.split( '_', 1 )[ 0 ];

  		if ( KHR_mesh_quantization_ExtraAttrTypes[ attrNamePrefix ] && KHR_mesh_quantization_ExtraAttrTypes[ attrNamePrefix ].includes( attrType ) ) {

  			this.extensionsUsed[ KHR_MESH_QUANTIZATION ] = true;
  			this.extensionsRequired[ KHR_MESH_QUANTIZATION ] = true;

  		}

  	}

  	/**
  	 * Process camera
  	 * @param  {THREE.Camera} camera Camera to process
  	 * @return {Integer}      Index of the processed mesh in the "camera" array
  	 */
  	processCamera( camera ) {

  		const json = this.json;

  		if ( ! json.cameras ) json.cameras = [];

  		const isOrtho = camera.isOrthographicCamera;

  		const cameraDef = {
  			type: isOrtho ? 'orthographic' : 'perspective'
  		};

  		if ( isOrtho ) {

  			cameraDef.orthographic = {
  				xmag: camera.right * 2,
  				ymag: camera.top * 2,
  				zfar: camera.far <= 0 ? 0.001 : camera.far,
  				znear: camera.near < 0 ? 0 : camera.near
  			};

  		} else {

  			cameraDef.perspective = {
  				aspectRatio: camera.aspect,
  				yfov: MathUtils.degToRad( camera.fov ),
  				zfar: camera.far <= 0 ? 0.001 : camera.far,
  				znear: camera.near < 0 ? 0 : camera.near
  			};

  		}

  		// Question: Is saving "type" as name intentional?
  		if ( camera.name !== '' ) cameraDef.name = camera.type;

  		return json.cameras.push( cameraDef ) - 1;

  	}

  	/**
  	 * Creates glTF animation entry from AnimationClip object.
  	 *
  	 * Status:
  	 * - Only properties listed in PATH_PROPERTIES may be animated.
  	 *
  	 * @param {THREE.AnimationClip} clip
  	 * @param {THREE.Object3D} root
  	 * @return {number|null}
  	 */
  	processAnimation( clip, root ) {

  		const json = this.json;
  		const nodeMap = this.nodeMap;

  		if ( ! json.animations ) json.animations = [];

  		clip = GLTFExporter.Utils.mergeMorphTargetTracks( clip.clone(), root );

  		const tracks = clip.tracks;
  		const channels = [];
  		const samplers = [];

  		for ( let i = 0; i < tracks.length; ++ i ) {

  			const track = tracks[ i ];
  			const trackBinding = PropertyBinding.parseTrackName( track.name );
  			let trackNode = PropertyBinding.findNode( root, trackBinding.nodeName );
  			const trackProperty = PATH_PROPERTIES$1[ trackBinding.propertyName ];

  			if ( trackBinding.objectName === 'bones' ) {

  				if ( trackNode.isSkinnedMesh === true ) {

  					trackNode = trackNode.skeleton.getBoneByName( trackBinding.objectIndex );

  				} else {

  					trackNode = undefined;

  				}

  			}

  			if ( ! trackNode || ! trackProperty ) {

  				console.warn( 'THREE.GLTFExporter: Could not export animation track "%s".', track.name );
  				continue;

  			}

  			const inputItemSize = 1;
  			let outputItemSize = track.values.length / track.times.length;

  			if ( trackProperty === PATH_PROPERTIES$1.morphTargetInfluences ) {

  				outputItemSize /= trackNode.morphTargetInfluences.length;

  			}

  			let interpolation;

  			// @TODO export CubicInterpolant(InterpolateSmooth) as CUBICSPLINE

  			// Detecting glTF cubic spline interpolant by checking factory method's special property
  			// GLTFCubicSplineInterpolant is a custom interpolant and track doesn't return
  			// valid value from .getInterpolation().
  			if ( track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === true ) {

  				interpolation = 'CUBICSPLINE';

  				// itemSize of CUBICSPLINE keyframe is 9
  				// (VEC3 * 3: inTangent, splineVertex, and outTangent)
  				// but needs to be stored as VEC3 so dividing by 3 here.
  				outputItemSize /= 3;

  			} else if ( track.getInterpolation() === InterpolateDiscrete ) {

  				interpolation = 'STEP';

  			} else {

  				interpolation = 'LINEAR';

  			}

  			samplers.push( {
  				input: this.processAccessor( new BufferAttribute( track.times, inputItemSize ) ),
  				output: this.processAccessor( new BufferAttribute( track.values, outputItemSize ) ),
  				interpolation: interpolation
  			} );

  			channels.push( {
  				sampler: samplers.length - 1,
  				target: {
  					node: nodeMap.get( trackNode ),
  					path: trackProperty
  				}
  			} );

  		}

  		json.animations.push( {
  			name: clip.name || 'clip_' + json.animations.length,
  			samplers: samplers,
  			channels: channels
  		} );

  		return json.animations.length - 1;

  	}

  	/**
  	 * @param {THREE.Object3D} object
  	 * @return {number|null}
  	 */
  	 processSkin( object ) {

  		const json = this.json;
  		const nodeMap = this.nodeMap;

  		const node = json.nodes[ nodeMap.get( object ) ];

  		const skeleton = object.skeleton;

  		if ( skeleton === undefined ) return null;

  		const rootJoint = object.skeleton.bones[ 0 ];

  		if ( rootJoint === undefined ) return null;

  		const joints = [];
  		const inverseBindMatrices = new Float32Array( skeleton.bones.length * 16 );
  		const temporaryBoneInverse = new Matrix4();

  		for ( let i = 0; i < skeleton.bones.length; ++ i ) {

  			joints.push( nodeMap.get( skeleton.bones[ i ] ) );
  			temporaryBoneInverse.copy( skeleton.boneInverses[ i ] );
  			temporaryBoneInverse.multiply( object.bindMatrix ).toArray( inverseBindMatrices, i * 16 );

  		}

  		if ( json.skins === undefined ) json.skins = [];

  		json.skins.push( {
  			inverseBindMatrices: this.processAccessor( new BufferAttribute( inverseBindMatrices, 16 ) ),
  			joints: joints,
  			skeleton: nodeMap.get( rootJoint )
  		} );

  		const skinIndex = node.skin = json.skins.length - 1;

  		return skinIndex;

  	}

  	/**
  	 * Process Object3D node
  	 * @param  {THREE.Object3D} node Object3D to processNode
  	 * @return {Integer} Index of the node in the nodes list
  	 */
  	processNode( object ) {

  		const json = this.json;
  		const options = this.options;
  		const nodeMap = this.nodeMap;

  		if ( ! json.nodes ) json.nodes = [];

  		const nodeDef = {};

  		if ( options.trs ) {

  			const rotation = object.quaternion.toArray();
  			const position = object.position.toArray();
  			const scale = object.scale.toArray();

  			if ( ! equalArray( rotation, [ 0, 0, 0, 1 ] ) ) {

  				nodeDef.rotation = rotation;

  			}

  			if ( ! equalArray( position, [ 0, 0, 0 ] ) ) {

  				nodeDef.translation = position;

  			}

  			if ( ! equalArray( scale, [ 1, 1, 1 ] ) ) {

  				nodeDef.scale = scale;

  			}

  		} else {

  			if ( object.matrixAutoUpdate ) {

  				object.updateMatrix();

  			}

  			if ( isIdentityMatrix( object.matrix ) === false ) {

  				nodeDef.matrix = object.matrix.elements;

  			}

  		}

  		// We don't export empty strings name because it represents no-name in Three.js.
  		if ( object.name !== '' ) nodeDef.name = String( object.name );

  		this.serializeUserData( object, nodeDef );

  		if ( object.isMesh || object.isLine || object.isPoints ) {

  			const meshIndex = this.processMesh( object );

  			if ( meshIndex !== null ) nodeDef.mesh = meshIndex;

  		} else if ( object.isCamera ) {

  			nodeDef.camera = this.processCamera( object );

  		}

  		if ( object.isSkinnedMesh ) this.skins.push( object );

  		if ( object.children.length > 0 ) {

  			const children = [];

  			for ( let i = 0, l = object.children.length; i < l; i ++ ) {

  				const child = object.children[ i ];

  				if ( child.visible || options.onlyVisible === false ) {

  					const nodeIndex = this.processNode( child );

  					if ( nodeIndex !== null ) children.push( nodeIndex );

  				}

  			}

  			if ( children.length > 0 ) nodeDef.children = children;

  		}

  		this._invokeAll( function ( ext ) {

  			ext.writeNode && ext.writeNode( object, nodeDef );

  		} );

  		const nodeIndex = json.nodes.push( nodeDef ) - 1;
  		nodeMap.set( object, nodeIndex );
  		return nodeIndex;

  	}

  	/**
  	 * Process Scene
  	 * @param  {Scene} node Scene to process
  	 */
  	processScene( scene ) {

  		const json = this.json;
  		const options = this.options;

  		if ( ! json.scenes ) {

  			json.scenes = [];
  			json.scene = 0;

  		}

  		const sceneDef = {};

  		if ( scene.name !== '' ) sceneDef.name = scene.name;

  		json.scenes.push( sceneDef );

  		const nodes = [];

  		for ( let i = 0, l = scene.children.length; i < l; i ++ ) {

  			const child = scene.children[ i ];

  			if ( child.visible || options.onlyVisible === false ) {

  				const nodeIndex = this.processNode( child );

  				if ( nodeIndex !== null ) nodes.push( nodeIndex );

  			}

  		}

  		if ( nodes.length > 0 ) sceneDef.nodes = nodes;

  		this.serializeUserData( scene, sceneDef );

  	}

  	/**
  	 * Creates a Scene to hold a list of objects and parse it
  	 * @param  {Array} objects List of objects to process
  	 */
  	processObjects( objects ) {

  		const scene = new Scene();
  		scene.name = 'AuxScene';

  		for ( let i = 0; i < objects.length; i ++ ) {

  			// We push directly to children instead of calling `add` to prevent
  			// modify the .parent and break its original scene and hierarchy
  			scene.children.push( objects[ i ] );

  		}

  		this.processScene( scene );

  	}

  	/**
  	 * @param {THREE.Object3D|Array<THREE.Object3D>} input
  	 */
  	processInput( input ) {

  		const options = this.options;

  		input = input instanceof Array ? input : [ input ];

  		this._invokeAll( function ( ext ) {

  			ext.beforeParse && ext.beforeParse( input );

  		} );

  		const objectsWithoutScene = [];

  		for ( let i = 0; i < input.length; i ++ ) {

  			if ( input[ i ] instanceof Scene ) {

  				this.processScene( input[ i ] );

  			} else {

  				objectsWithoutScene.push( input[ i ] );

  			}

  		}

  		if ( objectsWithoutScene.length > 0 ) this.processObjects( objectsWithoutScene );

  		for ( let i = 0; i < this.skins.length; ++ i ) {

  			this.processSkin( this.skins[ i ] );

  		}

  		for ( let i = 0; i < options.animations.length; ++ i ) {

  			this.processAnimation( options.animations[ i ], input[ 0 ] );

  		}

  		this._invokeAll( function ( ext ) {

  			ext.afterParse && ext.afterParse( input );

  		} );

  	}

  	_invokeAll( func ) {

  		for ( let i = 0, il = this.plugins.length; i < il; i ++ ) {

  			func( this.plugins[ i ] );

  		}

  	}

  }

  /**
   * Punctual Lights Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual
   */
  class GLTFLightExtension {

  	constructor( writer ) {

  		this.writer = writer;
  		this.name = 'KHR_lights_punctual';

  	}

  	writeNode( light, nodeDef ) {

  		if ( ! light.isLight ) return;

  		if ( ! light.isDirectionalLight && ! light.isPointLight && ! light.isSpotLight ) {

  			console.warn( 'THREE.GLTFExporter: Only directional, point, and spot lights are supported.', light );
  			return;

  		}

  		const writer = this.writer;
  		const json = writer.json;
  		const extensionsUsed = writer.extensionsUsed;

  		const lightDef = {};

  		if ( light.name ) lightDef.name = light.name;

  		lightDef.color = light.color.toArray();

  		lightDef.intensity = light.intensity;

  		if ( light.isDirectionalLight ) {

  			lightDef.type = 'directional';

  		} else if ( light.isPointLight ) {

  			lightDef.type = 'point';

  			if ( light.distance > 0 ) lightDef.range = light.distance;

  		} else if ( light.isSpotLight ) {

  			lightDef.type = 'spot';

  			if ( light.distance > 0 ) lightDef.range = light.distance;

  			lightDef.spot = {};
  			lightDef.spot.innerConeAngle = ( 1.0 - light.penumbra ) * light.angle;
  			lightDef.spot.outerConeAngle = light.angle;

  		}

  		if ( light.decay !== undefined && light.decay !== 2 ) {

  			console.warn( 'THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, '
  				+ 'and expects light.decay=2.' );

  		}

  		if ( light.target
  				&& ( light.target.parent !== light
  				|| light.target.position.x !== 0
  				|| light.target.position.y !== 0
  				|| light.target.position.z !== - 1 ) ) {

  			console.warn( 'THREE.GLTFExporter: Light direction may be lost. For best results, '
  				+ 'make light.target a child of the light with position 0,0,-1.' );

  		}

  		if ( ! extensionsUsed[ this.name ] ) {

  			json.extensions = json.extensions || {};
  			json.extensions[ this.name ] = { lights: [] };
  			extensionsUsed[ this.name ] = true;

  		}

  		const lights = json.extensions[ this.name ].lights;
  		lights.push( lightDef );

  		nodeDef.extensions = nodeDef.extensions || {};
  		nodeDef.extensions[ this.name ] = { light: lights.length - 1 };

  	}

  }

  /**
   * Unlit Materials Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit
   */
  let GLTFMaterialsUnlitExtension$1 = class GLTFMaterialsUnlitExtension {

  	constructor( writer ) {

  		this.writer = writer;
  		this.name = 'KHR_materials_unlit';

  	}

  	writeMaterial( material, materialDef ) {

  		if ( ! material.isMeshBasicMaterial ) return;

  		const writer = this.writer;
  		const extensionsUsed = writer.extensionsUsed;

  		materialDef.extensions = materialDef.extensions || {};
  		materialDef.extensions[ this.name ] = {};

  		extensionsUsed[ this.name ] = true;

  		materialDef.pbrMetallicRoughness.metallicFactor = 0.0;
  		materialDef.pbrMetallicRoughness.roughnessFactor = 0.9;

  	}

  };

  /**
   * Clearcoat Materials Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat
   */
  let GLTFMaterialsClearcoatExtension$1 = class GLTFMaterialsClearcoatExtension {

  	constructor( writer ) {

  		this.writer = writer;
  		this.name = 'KHR_materials_clearcoat';

  	}

  	writeMaterial( material, materialDef ) {

  		if ( ! material.isMeshPhysicalMaterial || material.clearcoat === 0 ) return;

  		const writer = this.writer;
  		const extensionsUsed = writer.extensionsUsed;

  		const extensionDef = {};

  		extensionDef.clearcoatFactor = material.clearcoat;

  		if ( material.clearcoatMap ) {

  			const clearcoatMapDef = {
  				index: writer.processTexture( material.clearcoatMap ),
  				texCoord: material.clearcoatMap.channel
  			};
  			writer.applyTextureTransform( clearcoatMapDef, material.clearcoatMap );
  			extensionDef.clearcoatTexture = clearcoatMapDef;

  		}

  		extensionDef.clearcoatRoughnessFactor = material.clearcoatRoughness;

  		if ( material.clearcoatRoughnessMap ) {

  			const clearcoatRoughnessMapDef = {
  				index: writer.processTexture( material.clearcoatRoughnessMap ),
  				texCoord: material.clearcoatRoughnessMap.channel
  			};
  			writer.applyTextureTransform( clearcoatRoughnessMapDef, material.clearcoatRoughnessMap );
  			extensionDef.clearcoatRoughnessTexture = clearcoatRoughnessMapDef;

  		}

  		if ( material.clearcoatNormalMap ) {

  			const clearcoatNormalMapDef = {
  				index: writer.processTexture( material.clearcoatNormalMap ),
  				texCoord: material.clearcoatNormalMap.channel
  			};

  			if ( material.clearcoatNormalScale.x !== 1 ) clearcoatNormalMapDef.scale = material.clearcoatNormalScale.x;

  			writer.applyTextureTransform( clearcoatNormalMapDef, material.clearcoatNormalMap );
  			extensionDef.clearcoatNormalTexture = clearcoatNormalMapDef;

  		}

  		materialDef.extensions = materialDef.extensions || {};
  		materialDef.extensions[ this.name ] = extensionDef;

  		extensionsUsed[ this.name ] = true;


  	}

  };

  /**
   * Materials dispersion Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_dispersion
   */
  let GLTFMaterialsDispersionExtension$1 = class GLTFMaterialsDispersionExtension {

  	constructor( writer ) {

  		this.writer = writer;
  		this.name = 'KHR_materials_dispersion';

  	}

  	writeMaterial( material, materialDef ) {

  		if ( ! material.isMeshPhysicalMaterial || material.dispersion === 0 ) return;

  		const writer = this.writer;
  		const extensionsUsed = writer.extensionsUsed;

  		const extensionDef = {};

  		extensionDef.dispersion = material.dispersion;

  		materialDef.extensions = materialDef.extensions || {};
  		materialDef.extensions[ this.name ] = extensionDef;

  		extensionsUsed[ this.name ] = true;

  	}

  };

  /**
   * Iridescence Materials Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_iridescence
   */
  let GLTFMaterialsIridescenceExtension$1 = class GLTFMaterialsIridescenceExtension {

  	constructor( writer ) {

  		this.writer = writer;
  		this.name = 'KHR_materials_iridescence';

  	}

  	writeMaterial( material, materialDef ) {

  		if ( ! material.isMeshPhysicalMaterial || material.iridescence === 0 ) return;

  		const writer = this.writer;
  		const extensionsUsed = writer.extensionsUsed;

  		const extensionDef = {};

  		extensionDef.iridescenceFactor = material.iridescence;

  		if ( material.iridescenceMap ) {

  			const iridescenceMapDef = {
  				index: writer.processTexture( material.iridescenceMap ),
  				texCoord: material.iridescenceMap.channel
  			};
  			writer.applyTextureTransform( iridescenceMapDef, material.iridescenceMap );
  			extensionDef.iridescenceTexture = iridescenceMapDef;

  		}

  		extensionDef.iridescenceIor = material.iridescenceIOR;
  		extensionDef.iridescenceThicknessMinimum = material.iridescenceThicknessRange[ 0 ];
  		extensionDef.iridescenceThicknessMaximum = material.iridescenceThicknessRange[ 1 ];

  		if ( material.iridescenceThicknessMap ) {

  			const iridescenceThicknessMapDef = {
  				index: writer.processTexture( material.iridescenceThicknessMap ),
  				texCoord: material.iridescenceThicknessMap.channel
  			};
  			writer.applyTextureTransform( iridescenceThicknessMapDef, material.iridescenceThicknessMap );
  			extensionDef.iridescenceThicknessTexture = iridescenceThicknessMapDef;

  		}

  		materialDef.extensions = materialDef.extensions || {};
  		materialDef.extensions[ this.name ] = extensionDef;

  		extensionsUsed[ this.name ] = true;

  	}

  };

  /**
   * Transmission Materials Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission
   */
  let GLTFMaterialsTransmissionExtension$1 = class GLTFMaterialsTransmissionExtension {

  	constructor( writer ) {

  		this.writer = writer;
  		this.name = 'KHR_materials_transmission';

  	}

  	writeMaterial( material, materialDef ) {

  		if ( ! material.isMeshPhysicalMaterial || material.transmission === 0 ) return;

  		const writer = this.writer;
  		const extensionsUsed = writer.extensionsUsed;

  		const extensionDef = {};

  		extensionDef.transmissionFactor = material.transmission;

  		if ( material.transmissionMap ) {

  			const transmissionMapDef = {
  				index: writer.processTexture( material.transmissionMap ),
  				texCoord: material.transmissionMap.channel
  			};
  			writer.applyTextureTransform( transmissionMapDef, material.transmissionMap );
  			extensionDef.transmissionTexture = transmissionMapDef;

  		}

  		materialDef.extensions = materialDef.extensions || {};
  		materialDef.extensions[ this.name ] = extensionDef;

  		extensionsUsed[ this.name ] = true;

  	}

  };

  /**
   * Materials Volume Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume
   */
  let GLTFMaterialsVolumeExtension$1 = class GLTFMaterialsVolumeExtension {

  	constructor( writer ) {

  		this.writer = writer;
  		this.name = 'KHR_materials_volume';

  	}

  	writeMaterial( material, materialDef ) {

  		if ( ! material.isMeshPhysicalMaterial || material.transmission === 0 ) return;

  		const writer = this.writer;
  		const extensionsUsed = writer.extensionsUsed;

  		const extensionDef = {};

  		extensionDef.thicknessFactor = material.thickness;

  		if ( material.thicknessMap ) {

  			const thicknessMapDef = {
  				index: writer.processTexture( material.thicknessMap ),
  				texCoord: material.thicknessMap.channel
  			};
  			writer.applyTextureTransform( thicknessMapDef, material.thicknessMap );
  			extensionDef.thicknessTexture = thicknessMapDef;

  		}

  		extensionDef.attenuationDistance = material.attenuationDistance;
  		extensionDef.attenuationColor = material.attenuationColor.toArray();

  		materialDef.extensions = materialDef.extensions || {};
  		materialDef.extensions[ this.name ] = extensionDef;

  		extensionsUsed[ this.name ] = true;

  	}

  };

  /**
   * Materials ior Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_ior
   */
  let GLTFMaterialsIorExtension$1 = class GLTFMaterialsIorExtension {

  	constructor( writer ) {

  		this.writer = writer;
  		this.name = 'KHR_materials_ior';

  	}

  	writeMaterial( material, materialDef ) {

  		if ( ! material.isMeshPhysicalMaterial || material.ior === 1.5 ) return;

  		const writer = this.writer;
  		const extensionsUsed = writer.extensionsUsed;

  		const extensionDef = {};

  		extensionDef.ior = material.ior;

  		materialDef.extensions = materialDef.extensions || {};
  		materialDef.extensions[ this.name ] = extensionDef;

  		extensionsUsed[ this.name ] = true;

  	}

  };

  /**
   * Materials specular Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_specular
   */
  let GLTFMaterialsSpecularExtension$1 = class GLTFMaterialsSpecularExtension {

  	constructor( writer ) {

  		this.writer = writer;
  		this.name = 'KHR_materials_specular';

  	}

  	writeMaterial( material, materialDef ) {

  		if ( ! material.isMeshPhysicalMaterial || ( material.specularIntensity === 1.0 &&
  		       material.specularColor.equals( DEFAULT_SPECULAR_COLOR ) &&
  		     ! material.specularIntensityMap && ! material.specularColorMap ) ) return;

  		const writer = this.writer;
  		const extensionsUsed = writer.extensionsUsed;

  		const extensionDef = {};

  		if ( material.specularIntensityMap ) {

  			const specularIntensityMapDef = {
  				index: writer.processTexture( material.specularIntensityMap ),
  				texCoord: material.specularIntensityMap.channel
  			};
  			writer.applyTextureTransform( specularIntensityMapDef, material.specularIntensityMap );
  			extensionDef.specularTexture = specularIntensityMapDef;

  		}

  		if ( material.specularColorMap ) {

  			const specularColorMapDef = {
  				index: writer.processTexture( material.specularColorMap ),
  				texCoord: material.specularColorMap.channel
  			};
  			writer.applyTextureTransform( specularColorMapDef, material.specularColorMap );
  			extensionDef.specularColorTexture = specularColorMapDef;

  		}

  		extensionDef.specularFactor = material.specularIntensity;
  		extensionDef.specularColorFactor = material.specularColor.toArray();

  		materialDef.extensions = materialDef.extensions || {};
  		materialDef.extensions[ this.name ] = extensionDef;

  		extensionsUsed[ this.name ] = true;

  	}

  };

  /**
   * Sheen Materials Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen
   */
  let GLTFMaterialsSheenExtension$1 = class GLTFMaterialsSheenExtension {

  	constructor( writer ) {

  		this.writer = writer;
  		this.name = 'KHR_materials_sheen';

  	}

  	writeMaterial( material, materialDef ) {

  		if ( ! material.isMeshPhysicalMaterial || material.sheen == 0.0 ) return;

  		const writer = this.writer;
  		const extensionsUsed = writer.extensionsUsed;

  		const extensionDef = {};

  		if ( material.sheenRoughnessMap ) {

  			const sheenRoughnessMapDef = {
  				index: writer.processTexture( material.sheenRoughnessMap ),
  				texCoord: material.sheenRoughnessMap.channel
  			};
  			writer.applyTextureTransform( sheenRoughnessMapDef, material.sheenRoughnessMap );
  			extensionDef.sheenRoughnessTexture = sheenRoughnessMapDef;

  		}

  		if ( material.sheenColorMap ) {

  			const sheenColorMapDef = {
  				index: writer.processTexture( material.sheenColorMap ),
  				texCoord: material.sheenColorMap.channel
  			};
  			writer.applyTextureTransform( sheenColorMapDef, material.sheenColorMap );
  			extensionDef.sheenColorTexture = sheenColorMapDef;

  		}

  		extensionDef.sheenRoughnessFactor = material.sheenRoughness;
  		extensionDef.sheenColorFactor = material.sheenColor.toArray();

  		materialDef.extensions = materialDef.extensions || {};
  		materialDef.extensions[ this.name ] = extensionDef;

  		extensionsUsed[ this.name ] = true;

  	}

  };

  /**
   * Anisotropy Materials Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_anisotropy
   */
  let GLTFMaterialsAnisotropyExtension$1 = class GLTFMaterialsAnisotropyExtension {

  	constructor( writer ) {

  		this.writer = writer;
  		this.name = 'KHR_materials_anisotropy';

  	}

  	writeMaterial( material, materialDef ) {

  		if ( ! material.isMeshPhysicalMaterial || material.anisotropy == 0.0 ) return;

  		const writer = this.writer;
  		const extensionsUsed = writer.extensionsUsed;

  		const extensionDef = {};

  		if ( material.anisotropyMap ) {

  			const anisotropyMapDef = { index: writer.processTexture( material.anisotropyMap ) };
  			writer.applyTextureTransform( anisotropyMapDef, material.anisotropyMap );
  			extensionDef.anisotropyTexture = anisotropyMapDef;

  		}

  		extensionDef.anisotropyStrength = material.anisotropy;
  		extensionDef.anisotropyRotation = material.anisotropyRotation;

  		materialDef.extensions = materialDef.extensions || {};
  		materialDef.extensions[ this.name ] = extensionDef;

  		extensionsUsed[ this.name ] = true;

  	}

  };

  /**
   * Materials Emissive Strength Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/blob/5768b3ce0ef32bc39cdf1bef10b948586635ead3/extensions/2.0/Khronos/KHR_materials_emissive_strength/README.md
   */
  let GLTFMaterialsEmissiveStrengthExtension$1 = class GLTFMaterialsEmissiveStrengthExtension {

  	constructor( writer ) {

  		this.writer = writer;
  		this.name = 'KHR_materials_emissive_strength';

  	}

  	writeMaterial( material, materialDef ) {

  		if ( ! material.isMeshStandardMaterial || material.emissiveIntensity === 1.0 ) return;

  		const writer = this.writer;
  		const extensionsUsed = writer.extensionsUsed;

  		const extensionDef = {};

  		extensionDef.emissiveStrength = material.emissiveIntensity;

  		materialDef.extensions = materialDef.extensions || {};
  		materialDef.extensions[ this.name ] = extensionDef;

  		extensionsUsed[ this.name ] = true;

  	}

  };


  /**
   * Materials bump Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/EXT_materials_bump
   */
  let GLTFMaterialsBumpExtension$1 = class GLTFMaterialsBumpExtension {

  	constructor( writer ) {

  		this.writer = writer;
  		this.name = 'EXT_materials_bump';

  	}

  	writeMaterial( material, materialDef ) {

  		if ( ! material.isMeshStandardMaterial || (
  		       material.bumpScale === 1 &&
  		     ! material.bumpMap ) ) return;

  		const writer = this.writer;
  		const extensionsUsed = writer.extensionsUsed;

  		const extensionDef = {};

  		if ( material.bumpMap ) {

  			const bumpMapDef = {
  				index: writer.processTexture( material.bumpMap ),
  				texCoord: material.bumpMap.channel
  			};
  			writer.applyTextureTransform( bumpMapDef, material.bumpMap );
  			extensionDef.bumpTexture = bumpMapDef;

  		}

  		extensionDef.bumpFactor = material.bumpScale;

  		materialDef.extensions = materialDef.extensions || {};
  		materialDef.extensions[ this.name ] = extensionDef;

  		extensionsUsed[ this.name ] = true;

  	}

  };

  /**
   * GPU Instancing Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_mesh_gpu_instancing
   */
  let GLTFMeshGpuInstancing$1 = class GLTFMeshGpuInstancing {

  	constructor( writer ) {

  		this.writer = writer;
  		this.name = 'EXT_mesh_gpu_instancing';

  	}

  	writeNode( object, nodeDef ) {

  		if ( ! object.isInstancedMesh ) return;

  		const writer = this.writer;

  		const mesh = object;

  		const translationAttr = new Float32Array( mesh.count * 3 );
  		const rotationAttr = new Float32Array( mesh.count * 4 );
  		const scaleAttr = new Float32Array( mesh.count * 3 );

  		const matrix = new Matrix4();
  		const position = new Vector3();
  		const quaternion = new Quaternion();
  		const scale = new Vector3();

  		for ( let i = 0; i < mesh.count; i ++ ) {

  			mesh.getMatrixAt( i, matrix );
  			matrix.decompose( position, quaternion, scale );

  			position.toArray( translationAttr, i * 3 );
  			quaternion.toArray( rotationAttr, i * 4 );
  			scale.toArray( scaleAttr, i * 3 );

  		}

  		const attributes = {
  			TRANSLATION: writer.processAccessor( new BufferAttribute( translationAttr, 3 ) ),
  			ROTATION: writer.processAccessor( new BufferAttribute( rotationAttr, 4 ) ),
  			SCALE: writer.processAccessor( new BufferAttribute( scaleAttr, 3 ) ),
  		};

  		if ( mesh.instanceColor )
  			attributes._COLOR_0 = writer.processAccessor( mesh.instanceColor );

  		nodeDef.extensions = nodeDef.extensions || {};
  		nodeDef.extensions[ this.name ] = { attributes };

  		writer.extensionsUsed[ this.name ] = true;
  		writer.extensionsRequired[ this.name ] = true;

  	}

  };

  /**
   * Static utility functions
   */
  GLTFExporter.Utils = {

  	insertKeyframe: function ( track, time ) {

  		const tolerance = 0.001; // 1ms
  		const valueSize = track.getValueSize();

  		const times = new track.TimeBufferType( track.times.length + 1 );
  		const values = new track.ValueBufferType( track.values.length + valueSize );
  		const interpolant = track.createInterpolant( new track.ValueBufferType( valueSize ) );

  		let index;

  		if ( track.times.length === 0 ) {

  			times[ 0 ] = time;

  			for ( let i = 0; i < valueSize; i ++ ) {

  				values[ i ] = 0;

  			}

  			index = 0;

  		} else if ( time < track.times[ 0 ] ) {

  			if ( Math.abs( track.times[ 0 ] - time ) < tolerance ) return 0;

  			times[ 0 ] = time;
  			times.set( track.times, 1 );

  			values.set( interpolant.evaluate( time ), 0 );
  			values.set( track.values, valueSize );

  			index = 0;

  		} else if ( time > track.times[ track.times.length - 1 ] ) {

  			if ( Math.abs( track.times[ track.times.length - 1 ] - time ) < tolerance ) {

  				return track.times.length - 1;

  			}

  			times[ times.length - 1 ] = time;
  			times.set( track.times, 0 );

  			values.set( track.values, 0 );
  			values.set( interpolant.evaluate( time ), track.values.length );

  			index = times.length - 1;

  		} else {

  			for ( let i = 0; i < track.times.length; i ++ ) {

  				if ( Math.abs( track.times[ i ] - time ) < tolerance ) return i;

  				if ( track.times[ i ] < time && track.times[ i + 1 ] > time ) {

  					times.set( track.times.slice( 0, i + 1 ), 0 );
  					times[ i + 1 ] = time;
  					times.set( track.times.slice( i + 1 ), i + 2 );

  					values.set( track.values.slice( 0, ( i + 1 ) * valueSize ), 0 );
  					values.set( interpolant.evaluate( time ), ( i + 1 ) * valueSize );
  					values.set( track.values.slice( ( i + 1 ) * valueSize ), ( i + 2 ) * valueSize );

  					index = i + 1;

  					break;

  				}

  			}

  		}

  		track.times = times;
  		track.values = values;

  		return index;

  	},

  	mergeMorphTargetTracks: function ( clip, root ) {

  		const tracks = [];
  		const mergedTracks = {};
  		const sourceTracks = clip.tracks;

  		for ( let i = 0; i < sourceTracks.length; ++ i ) {

  			let sourceTrack = sourceTracks[ i ];
  			const sourceTrackBinding = PropertyBinding.parseTrackName( sourceTrack.name );
  			const sourceTrackNode = PropertyBinding.findNode( root, sourceTrackBinding.nodeName );

  			if ( sourceTrackBinding.propertyName !== 'morphTargetInfluences' || sourceTrackBinding.propertyIndex === undefined ) {

  				// Tracks that don't affect morph targets, or that affect all morph targets together, can be left as-is.
  				tracks.push( sourceTrack );
  				continue;

  			}

  			if ( sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodDiscrete
  				&& sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodLinear ) {

  				if ( sourceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {

  					// This should never happen, because glTF morph target animations
  					// affect all targets already.
  					throw new Error( 'THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.' );

  				}

  				console.warn( 'THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead.' );

  				sourceTrack = sourceTrack.clone();
  				sourceTrack.setInterpolation( InterpolateLinear );

  			}

  			const targetCount = sourceTrackNode.morphTargetInfluences.length;
  			const targetIndex = sourceTrackNode.morphTargetDictionary[ sourceTrackBinding.propertyIndex ];

  			if ( targetIndex === undefined ) {

  				throw new Error( 'THREE.GLTFExporter: Morph target name not found: ' + sourceTrackBinding.propertyIndex );

  			}

  			let mergedTrack;

  			// If this is the first time we've seen this object, create a new
  			// track to store merged keyframe data for each morph target.
  			if ( mergedTracks[ sourceTrackNode.uuid ] === undefined ) {

  				mergedTrack = sourceTrack.clone();

  				const values = new mergedTrack.ValueBufferType( targetCount * mergedTrack.times.length );

  				for ( let j = 0; j < mergedTrack.times.length; j ++ ) {

  					values[ j * targetCount + targetIndex ] = mergedTrack.values[ j ];

  				}

  				// We need to take into consideration the intended target node
  				// of our original un-merged morphTarget animation.
  				mergedTrack.name = ( sourceTrackBinding.nodeName || '' ) + '.morphTargetInfluences';
  				mergedTrack.values = values;

  				mergedTracks[ sourceTrackNode.uuid ] = mergedTrack;
  				tracks.push( mergedTrack );

  				continue;

  			}

  			const sourceInterpolant = sourceTrack.createInterpolant( new sourceTrack.ValueBufferType( 1 ) );

  			mergedTrack = mergedTracks[ sourceTrackNode.uuid ];

  			// For every existing keyframe of the merged track, write a (possibly
  			// interpolated) value from the source track.
  			for ( let j = 0; j < mergedTrack.times.length; j ++ ) {

  				mergedTrack.values[ j * targetCount + targetIndex ] = sourceInterpolant.evaluate( mergedTrack.times[ j ] );

  			}

  			// For every existing keyframe of the source track, write a (possibly
  			// new) keyframe to the merged track. Values from the previous loop may
  			// be written again, but keyframes are de-duplicated.
  			for ( let j = 0; j < sourceTrack.times.length; j ++ ) {

  				const keyframeIndex = this.insertKeyframe( mergedTrack, sourceTrack.times[ j ] );
  				mergedTrack.values[ keyframeIndex * targetCount + targetIndex ] = sourceTrack.values[ j ];

  			}

  		}

  		clip.tracks = tracks;

  		return clip;

  	}

  };

  function getRootBone(skeleton) {
    var boneSet = new Set(skeleton.bones);
    var _iterator = _createForOfIteratorHelper(skeleton.bones),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var bone = _step.value;
        if (bone.parent == null || !boneSet.has(bone.parent)) {
          return bone;
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    throw new Error("Invalid skeleton. Could not find the root bone of the given skeleton.");
  }

  /**
   * Pick an item from the given array by probability evaluation functions.
   */
  function pickByProbability(array, evaluators) {
    if (array.length < 1) {
      return null;
    }
    var results = array.map(function () {
      return 0.0;
    });

    // execute each evaluators
    var _iterator = _createForOfIteratorHelper(evaluators),
      _step;
    try {
      var _loop = function _loop() {
        var evaluator = _step.value;
        var func = evaluator.func,
          weight = evaluator.weight;
        var min = Infinity;
        var max = -Infinity;
        var evaluatorResults = array.map(function (value) {
          var evaluatorResult = func(value);
          min = Math.min(min, evaluatorResult);
          max = Math.max(max, evaluatorResult);
          return evaluatorResult;
        });
        var range = max - min;
        if (range > 0.0) {
          evaluatorResults.map(function (v, i) {
            results[i] += weight * (v - min) / range;
          });
        }
      };
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        _loop();
      }

      // find an index of an element which has the highest result
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    var highestResult = -Infinity;
    var highestIndex = 0;
    var _iterator2 = _createForOfIteratorHelper(results.entries()),
      _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var _step2$value = _slicedToArray(_step2.value, 2),
          i = _step2$value[0],
          result = _step2$value[1];
        if (result > highestResult) {
          highestResult = result;
          highestIndex = i;
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
    return array[highestIndex];
  }

  var _v3A$2 = new Vector3();

  /**
   * Traverse descendants of given object.
   * Once the given function returns `true`, it stops the traversal operation and returns the object.
   *
   * It will perform breadth first search.
   */
  function objectBFS(root, fn) {
    var queue = [root];
    while (queue.length > 0) {
      var obj = queue.shift();
      if (fn(obj)) {
        return obj;
      }
      queue.push.apply(queue, _toConsumableArray(obj.children));
    }
    return null;
  }

  /**
   * Traverse descendants of given object.
   * It will return an array of object that the given evaluation function returns `true`.
   *
   * It will perform breadth first search.
   */
  function objectTraverseFilter(root, fn) {
    var result = [];
    root.traverse(function (obj) {
      if (fn(obj)) {
        result.push(obj);
      }
    });
    return result;
  }

  /**
   * Traverse ancestors of given object.
   * Once the given function returns `true`, it stops the traversal operation and returns the object.
   */
  function objectSearchAncestors(root, fn) {
    var obj = root;
    while (obj != null) {
      if (fn(obj)) {
        return obj;
      }
      obj = obj.parent;
    }
    return null;
  }
  function evaluatorEqual(obj, another) {
    return obj === another ? 1 : 0;
  }
  function evaluatorName(obj, substring) {
    var nameLowerCase = obj.name.toLowerCase();
    return nameLowerCase.includes(substring) ? 1 : 0;
  }

  /**
   * Determine spine, chest, and upperChest.
   *
   * Give it a hips bone and a bone with three children which is supposed to be a chest bone.
   */
  function determineSpineBones(hips, chestCand) {
    // create an array from the hips to the chest
    var spineBones = [];
    objectSearchAncestors(chestCand, function (obj) {
      spineBones.unshift(obj);
      return obj === hips;
    });

    // map spine bones to VRM humanoid definition
    if (spineBones.length < 3) {
      throw new Error("Not enough spine bones.");
    } else if (spineBones.length === 3) {
      // hips - spine - chest
      return [spineBones[1], spineBones[2], null];
    } else if (spineBones.length === 4) {
      // hips - spine - chest - upperChest
      return [spineBones[1], spineBones[2], spineBones[3]];
    } else {
      // too much spine bones
      console.warn("The skeleton has more spine bones than VRM requires. You might get an unexpected result.");
      return [spineBones[Math.floor((spineBones.length - 1) / 3.0)], spineBones[Math.floor((spineBones.length - 1) / 3.0 * 2.0)], spineBones[spineBones.length - 1]];
    }
  }

  /**
   * Determine upperLeg, lowerLeg, foot, and toes.
   *
   * Give it a bone which is a child of hips and supposed to be a root of leg.
   */
  function determineLegBones(legRoot) {
    var _toes$bone;
    var bones = [];
    {
      var currentBone = legRoot;
      var currentDepth = 0;
      while (currentBone != null) {
        var _firstChild$position$;
        var firstChild = currentBone.children[0];
        bones.push({
          bone: currentBone,
          depth: currentDepth,
          len: (_firstChild$position$ = firstChild === null || firstChild === void 0 ? void 0 : firstChild.position.length()) !== null && _firstChild$position$ !== void 0 ? _firstChild$position$ : 0.0
        });
        currentBone = firstChild;
        currentDepth++;
      }
    }
    if (bones.length < 3) {
      throw new Error("Not enough leg bones.");
    }
    var _bones$concat$sort$sl = bones.concat().sort(function (a, b) {
        return b.len - a.len;
      }) // sort by bone length, longer comes first
      .slice(0, 2) // pick three longest bones
      .sort(function (a, b) {
        return a.depth - b.depth;
      }),
      _bones$concat$sort$sl2 = _slicedToArray(_bones$concat$sort$sl, 2),
      upperLeg = _bones$concat$sort$sl2[0],
      lowerLeg = _bones$concat$sort$sl2[1]; // sort by depth

    var foot = bones[lowerLeg.depth + 1];
    if (foot == null) {
      throw new Error("Could not find the foot bone.");
    }
    var toes = bones[foot.depth + 1];
    return [upperLeg.bone, lowerLeg.bone, foot.bone, (_toes$bone = toes === null || toes === void 0 ? void 0 : toes.bone) !== null && _toes$bone !== void 0 ? _toes$bone : null];
  }

  /**
   * Determine shoulder, upperArm, lowerArm, and hand.
   *
   * Give it a bone which is a child of chest and supposed to be a root of arm.
   */
  function determineArmBones(armRoot) {
    var _shoulder$bone;
    var bones = [];
    {
      var currentBone = armRoot;
      var currentDepth = 0;
      while (currentBone != null) {
        var _firstChild$position$2;
        var firstChild = currentBone.children[0];
        bones.push({
          bone: currentBone,
          depth: currentDepth,
          len: (_firstChild$position$2 = firstChild === null || firstChild === void 0 ? void 0 : firstChild.position.length()) !== null && _firstChild$position$2 !== void 0 ? _firstChild$position$2 : 0.0
        });
        currentBone = firstChild;
        currentDepth++;
      }
    }
    if (bones.length < 3) {
      throw new Error("Not enough arm bones.");
    }
    var _bones$concat$sort$sl3 = bones.concat().sort(function (a, b) {
        return b.len - a.len;
      }) // sort by bone length, longer comes first
      .slice(0, 2) // pick three longest bones
      .sort(function (a, b) {
        return a.depth - b.depth;
      }),
      _bones$concat$sort$sl4 = _slicedToArray(_bones$concat$sort$sl3, 2),
      upperArm = _bones$concat$sort$sl4[0],
      lowerArm = _bones$concat$sort$sl4[1]; // sort by depth

    var hand = bones[lowerArm.depth + 1];
    if (hand == null) {
      throw new Error("Could not find the foot bone.");
    }
    var shoulder = upperArm.depth !== 0 ? bones[upperArm.depth - 1] : null;
    return [(_shoulder$bone = shoulder === null || shoulder === void 0 ? void 0 : shoulder.bone) !== null && _shoulder$bone !== void 0 ? _shoulder$bone : null, upperArm.bone, lowerArm.bone, hand.bone];
  }

  /**
   * Determine finger bones.
   *
   * The given result map must have hand bones.
   */
  function determineFingerBones(result) {
    var leftRights = ["left", "right"];
    var handBoneMap = {
      left: result.get("leftHand"),
      right: result.get("rightHand")
    };
    var fingerNames = ["thumb", "index", "middle", "ring", "little"];
    var fingerBoneNamesMap = {
      left: {
        thumb: ["leftThumbMetacarpal", "leftThumbProximal", "leftThumbDistal"],
        index: ["leftIndexProximal", "leftIndexIntermediate", "leftIndexDistal"],
        middle: ["leftMiddleProximal", "leftMiddleIntermediate", "leftMiddleDistal"],
        ring: ["leftRingProximal", "leftRingIntermediate", "leftRingDistal"],
        little: ["leftLittleProximal", "leftLittleIntermediate", "leftLittleDistal"]
      },
      right: {
        thumb: ["rightThumbMetacarpal", "rightThumbProximal", "rightThumbDistal"],
        index: ["rightIndexProximal", "rightIndexIntermediate", "rightIndexDistal"],
        middle: ["rightMiddleProximal", "rightMiddleIntermediate", "rightMiddleDistal"],
        ring: ["rightRingProximal", "rightRingIntermediate", "rightRingDistal"],
        little: ["rightLittleProximal", "rightLittleIntermediate", "rightLittleDistal"]
      }
    };
    for (var _i = 0, _leftRights = leftRights; _i < _leftRights.length; _i++) {
      var leftRight = _leftRights[_i];
      var handBone = handBoneMap[leftRight];
      var fingerRoots = handBone.children.concat();
      var _iterator2 = _createForOfIteratorHelper(fingerNames),
        _step2;
      try {
        var _loop = function _loop() {
          var fingerName = _step2.value;
          var fingerBoneNames = fingerBoneNamesMap[leftRight][fingerName];

          // find nearest bone of the finger
          var fingerRoot = pickByProbability(fingerRoots, [{
            func: function func(obj) {
              return evaluatorName(obj, fingerName);
            },
            weight: 10.0
          }, {
            func: function func(obj) {
              return obj.getWorldPosition(_v3A$2).z;
            },
            weight: 1.0
          }]);
          if (fingerRoot != null) {
            fingerRoots.splice(fingerRoots.indexOf(fingerRoot), 1);
            result.set(fingerBoneNames[0], fingerRoot);
            var child1 = fingerRoot.children[0];
            if (child1 != null) {
              result.set(fingerBoneNames[1], child1);
              var child2 = child1.children[0];
              if (child2 != null) {
                result.set(fingerBoneNames[2], child2);
              }
            }
          }
        };
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          _loop();
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }
  }

  /**
   * Determine neck, head, leftEye, and rightEye.
   *
   * Give it a bone which is a child of chest and supposed to be a root of head.
   */
  function determineHeadBones(headRoot) {
    var head = headRoot;

    // neck might have two or more bones
    while (head.children.length === 1) {
      head = head.children[0];
    }
    var neck = headRoot === head ? null : headRoot;
    var leftEye = null;
    var rightEye = null;
    if (head.children.length === 0) {
      leftEye = pickByProbability(head.children, [{
        func: function func(obj) {
          return evaluatorName(obj, "lefteye");
        },
        weight: 10.0
      }, {
        func: function func(obj) {
          return evaluatorName(obj, "l_faceeye");
        },
        weight: 10.0
      }, {
        func: function func(obj) {
          return evaluatorName(obj, "eye");
        },
        weight: 1.0
      }, {
        func: function func(obj) {
          return obj.getWorldPosition(_v3A$2).x;
        },
        weight: 1.0
      }]);
      rightEye = pickByProbability(head.children, [{
        func: function func(obj) {
          return evaluatorEqual(obj, leftEye);
        },
        weight: -100.0
      }, {
        func: function func(obj) {
          return evaluatorName(obj, "righteye");
        },
        weight: 10.0
      }, {
        func: function func(obj) {
          return evaluatorName(obj, "r_faceeye");
        },
        weight: 10.0
      }, {
        func: function func(obj) {
          return evaluatorName(obj, "eye");
        },
        weight: 1.0
      }, {
        func: function func(obj) {
          return -obj.getWorldPosition(_v3A$2).x;
        },
        weight: 1.0
      }]);
    }
    return [neck, head, leftEye, rightEye];
  }

  /**
   * Map given hierarchy to VRM humanoid.
   */
  function mapSkeletonToVRM(root) {
    var result = new Map();

    // find hips - the first descendant of the root which has three children
    var hips = objectBFS(root, function (obj) {
      return obj.children.length >= 3;
    });
    if (hips == null) {
      throw new Error("Cannot find hips.");
    }
    result.set("hips", hips);

    // find chest candidate - descendants of the hips which has three or more children
    var chestCands = objectTraverseFilter(hips, function (obj) {
      return obj !== hips && obj.children.length >= 3;
    });
    var chestCand = pickByProbability(chestCands, [{
      func: function func(obj) {
        return evaluatorName(obj, "upperchest");
      },
      weight: 1.0
    }, {
      func: function func(obj) {
        return evaluatorName(obj, "chest");
      },
      weight: 1.0
    }]);
    if (chestCand == null) {
      throw new Error("Cannot find chest.");
    }
    var _determineSpineBones = determineSpineBones(hips, chestCand),
      _determineSpineBones2 = _slicedToArray(_determineSpineBones, 3),
      spine = _determineSpineBones2[0],
      chest = _determineSpineBones2[1],
      upperChest = _determineSpineBones2[2];
    result.set("spine", spine);
    result.set("chest", chest);
    if (upperChest != null) {
      result.set("upperChest", upperChest);
    }

    // find leg roots - two children of hips extends to below
    var leftLegRoot = pickByProbability(hips.children, [{
      func: function func(obj) {
        return evaluatorName(obj, "leftupperleg");
      },
      weight: 10.0
    }, {
      func: function func(obj) {
        return evaluatorName(obj, "l_upperleg");
      },
      weight: 10.0
    }, {
      func: function func(obj) {
        return evaluatorName(obj, "leg");
      },
      weight: 1.0
    }, {
      func: function func(obj) {
        return obj.getWorldPosition(_v3A$2).x;
      },
      weight: 1.0
    }]);
    var rightLegRoot = pickByProbability(hips.children, [{
      func: function func(obj) {
        return evaluatorEqual(obj, leftLegRoot);
      },
      weight: -100.0
    }, {
      func: function func(obj) {
        return evaluatorName(obj, "rightupperleg");
      },
      weight: 10.0
    }, {
      func: function func(obj) {
        return evaluatorName(obj, "r_upperleg");
      },
      weight: 10.0
    }, {
      func: function func(obj) {
        return evaluatorName(obj, "leg");
      },
      weight: 1.0
    }, {
      func: function func(obj) {
        return -obj.getWorldPosition(_v3A$2).x;
      },
      weight: 1.0
    }]);

    // determine leg bones
    var _determineLegBones = determineLegBones(leftLegRoot),
      _determineLegBones2 = _slicedToArray(_determineLegBones, 4),
      leftUpperLeg = _determineLegBones2[0],
      leftLowerLeg = _determineLegBones2[1],
      leftFoot = _determineLegBones2[2],
      leftToes = _determineLegBones2[3];
    result.set("leftUpperLeg", leftUpperLeg);
    result.set("leftLowerLeg", leftLowerLeg);
    result.set("leftFoot", leftFoot);
    if (leftToes != null) {
      result.set("leftToes", leftToes);
    }
    var _determineLegBones3 = determineLegBones(rightLegRoot),
      _determineLegBones4 = _slicedToArray(_determineLegBones3, 4),
      rightUpperLeg = _determineLegBones4[0],
      rightLowerLeg = _determineLegBones4[1],
      rightFoot = _determineLegBones4[2],
      rightToes = _determineLegBones4[3];
    result.set("rightUpperLeg", rightUpperLeg);
    result.set("rightLowerLeg", rightLowerLeg);
    result.set("rightFoot", rightFoot);
    if (rightToes != null) {
      result.set("rightToes", rightToes);
    }

    // assuming z+ is the front, determine left arm and right arm
    var leftArmRoot = pickByProbability(chestCand.children, [{
      func: function func(obj) {
        return evaluatorName(obj, "leftshoulder");
      },
      weight: 10.0
    }, {
      func: function func(obj) {
        return evaluatorName(obj, "l_shoulder");
      },
      weight: 10.0
    }, {
      func: function func(obj) {
        return evaluatorName(obj, "leftupperarm");
      },
      weight: 10.0
    }, {
      func: function func(obj) {
        return evaluatorName(obj, "l_upperarm");
      },
      weight: 10.0
    }, {
      func: function func(obj) {
        return evaluatorName(obj, "shoulder");
      },
      weight: 1.0
    }, {
      func: function func(obj) {
        return evaluatorName(obj, "arm");
      },
      weight: 1.0
    }, {
      func: function func(obj) {
        return obj.getWorldPosition(_v3A$2).x;
      },
      weight: 1.0
    }]);
    var rightArmRoot = pickByProbability(chestCand.children, [{
      func: function func(obj) {
        return evaluatorEqual(obj, leftArmRoot);
      },
      weight: -100.0
    }, {
      func: function func(obj) {
        return evaluatorName(obj, "rightshoulder");
      },
      weight: 10.0
    }, {
      func: function func(obj) {
        return evaluatorName(obj, "r_shoulder");
      },
      weight: 10.0
    }, {
      func: function func(obj) {
        return evaluatorName(obj, "rightupperarm");
      },
      weight: 10.0
    }, {
      func: function func(obj) {
        return evaluatorName(obj, "r_upperarm");
      },
      weight: 10.0
    }, {
      func: function func(obj) {
        return evaluatorName(obj, "shoulder");
      },
      weight: 1.0
    }, {
      func: function func(obj) {
        return evaluatorName(obj, "arm");
      },
      weight: 1.0
    }, {
      func: function func(obj) {
        return -obj.getWorldPosition(_v3A$2).x;
      },
      weight: 1.0
    }]);
    var headRoot = pickByProbability(chestCand.children, [{
      func: function func(obj) {
        return evaluatorEqual(obj, leftArmRoot);
      },
      weight: -100.0
    }, {
      func: function func(obj) {
        return evaluatorEqual(obj, rightArmRoot);
      },
      weight: -100.0
    }, {
      func: function func(obj) {
        return evaluatorName(obj, "neck");
      },
      weight: 1.0
    }, {
      func: function func(obj) {
        return evaluatorName(obj, "head");
      },
      weight: 1.0
    }, {
      func: function func(obj) {
        return Math.abs(obj.getWorldPosition(_v3A$2).x);
      },
      weight: -1.0
    }]);

    // determine hand bones
    var _determineArmBones = determineArmBones(leftArmRoot),
      _determineArmBones2 = _slicedToArray(_determineArmBones, 4),
      leftShoulder = _determineArmBones2[0],
      leftUpperArm = _determineArmBones2[1],
      leftLowerArm = _determineArmBones2[2],
      leftHand = _determineArmBones2[3];
    if (leftShoulder != null) {
      result.set("leftShoulder", leftShoulder);
    }
    result.set("leftUpperArm", leftUpperArm);
    result.set("leftLowerArm", leftLowerArm);
    result.set("leftHand", leftHand);
    var _determineArmBones3 = determineArmBones(rightArmRoot),
      _determineArmBones4 = _slicedToArray(_determineArmBones3, 4),
      rightShoulder = _determineArmBones4[0],
      rightUpperArm = _determineArmBones4[1],
      rightLowerArm = _determineArmBones4[2],
      rightHand = _determineArmBones4[3];
    if (rightShoulder != null) {
      result.set("rightShoulder", rightShoulder);
    }
    result.set("rightUpperArm", rightUpperArm);
    result.set("rightLowerArm", rightLowerArm);
    result.set("rightHand", rightHand);

    // determine finger bones
    determineFingerBones(result);

    // determine head
    var _determineHeadBones = determineHeadBones(headRoot),
      _determineHeadBones2 = _slicedToArray(_determineHeadBones, 4),
      neck = _determineHeadBones2[0],
      head = _determineHeadBones2[1],
      leftEye = _determineHeadBones2[2],
      rightEye = _determineHeadBones2[3];
    if (neck != null) {
      result.set("neck", neck);
    }
    result.set("head", head);
    if (leftEye != null) {
      result.set("leftEye", leftEye);
    }
    if (rightEye != null) {
      result.set("rightEye", rightEye);
    }
    return result;
  }

  var EXTENSION_NAME = "VRMC_vrm_animation";
  var VRMAnimationExporterPlugin = /*#__PURE__*/function () {
    function VRMAnimationExporterPlugin(writer) {
      _classCallCheck(this, VRMAnimationExporterPlugin);
      _defineProperty(this, "name", EXTENSION_NAME);
      this.writer = writer;
    }
    return _createClass(VRMAnimationExporterPlugin, [{
      key: "afterParse",
      value: function afterParse(input) {
        var _root$userData, _gltfDef$extensionsUs, _gltfDef$extensions;
        if (!Array.isArray(input)) {
          return;
        }
        var root = input[0];
        var vrmBoneMap = (_root$userData = root.userData) === null || _root$userData === void 0 ? void 0 : _root$userData.vrmBoneMap;
        if (vrmBoneMap == null) {
          return;
        }
        var humanBones = {};
        var _iterator = _createForOfIteratorHelper(vrmBoneMap),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var _step$value = _slicedToArray(_step.value, 2),
              boneName = _step$value[0],
              bone = _step$value[1];
            var node = this.writer.nodeMap.get(bone);
            if (node != null) {
              humanBones[boneName] = {
                node: node
              };
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        var humanoid = {
          humanBones: humanBones
        };
        var extension = {
          specVersion: "1.0",
          //// @ts-expect-error: will fix the three-vrm side later
          humanoid: humanoid
        };
        var gltfDef = this.writer.json;
        (_gltfDef$extensionsUs = gltfDef.extensionsUsed) !== null && _gltfDef$extensionsUs !== void 0 ? _gltfDef$extensionsUs : gltfDef.extensionsUsed = [];
        gltfDef.extensionsUsed.push(EXTENSION_NAME);
        (_gltfDef$extensions = gltfDef.extensions) !== null && _gltfDef$extensions !== void 0 ? _gltfDef$extensions : gltfDef.extensions = {};
        gltfDef.extensions[EXTENSION_NAME] = extension;
      }
    }]);
  }();

  var _v3A$1 = new Vector3();
  function createSkeletonBoundingBox(skeleton) {
    var boundingBox = new Box3();
    var _iterator = _createForOfIteratorHelper(skeleton.bones),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var bone = _step.value;
        boundingBox.expandByPoint(bone.getWorldPosition(_v3A$1));
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    return boundingBox;
  }
  function convertBVHToVRMAnimation(_x, _x2) {
    return _convertBVHToVRMAnimation.apply(this, arguments);
  }
  function _convertBVHToVRMAnimation() {
    _convertBVHToVRMAnimation = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(bvh, options) {
      var _options$scale;
      var scale, skeleton, clip, rootBone, vrmBoneMap, hipsBone, hipsBoneName, hipsPositionTrack, spineBone, spineBoneName, spinePositionTrack, filteredTracks, _iterator2, _step2, origTrack, track, newTrack, _newTrack, offset, i, boundingBox, exporter, gltf;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            scale = (_options$scale = options === null || options === void 0 ? void 0 : options.scale) !== null && _options$scale !== void 0 ? _options$scale : 0.01;
            skeleton = bvh.skeleton.clone();
            clip = bvh.clip.clone(); // find root bone of the skeleton
            rootBone = getRootBone(skeleton); // scale the entire tree by 0.01
            rootBone.traverse(function (bone) {
              bone.position.multiplyScalar(scale);
            });
            rootBone.updateWorldMatrix(false, true);

            // create a map from vrm bone names to bones
            vrmBoneMap = mapSkeletonToVRM(rootBone);
            rootBone.userData.vrmBoneMap = vrmBoneMap;
            hipsBone = vrmBoneMap.get("hips");
            hipsBoneName = hipsBone.name;
            hipsPositionTrack = null;
            spineBone = vrmBoneMap.get("spine");
            spineBoneName = spineBone.name;
            spinePositionTrack = null; // rename tracks + remove translation tracks other than hips + pickup spine track
            filteredTracks = [];
            _iterator2 = _createForOfIteratorHelper(bvh.clip.tracks);
            try {
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                origTrack = _step2.value;
                track = origTrack.clone();
                track.name = track.name.replace(/\.bones\[(.*)\]/, "$1");
                if (track.name.endsWith(".quaternion")) {
                  filteredTracks.push(track);
                }
                if (track.name === "".concat(hipsBoneName, ".position")) {
                  newTrack = track.clone();
                  newTrack.values = track.values.map(function (v) {
                    return v * scale;
                  });
                  hipsPositionTrack = newTrack;
                  filteredTracks.push(newTrack);
                }
                if (track.name === "".concat(spineBoneName, ".position")) {
                  _newTrack = track.clone();
                  _newTrack.values = track.values.map(function (v) {
                    return v * scale;
                  });
                  spinePositionTrack = _newTrack;
                }
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }
            clip.tracks = filteredTracks;

            // Remove offsets contained in hips position track
            if (hipsPositionTrack != null) {
              offset = hipsBone.position.toArray();
              for (i = 0; i < hipsPositionTrack.values.length; i++) {
                hipsPositionTrack.values[i] -= offset[i % 3];
              }
            }

            // some BVHs does not ground correctly
            boundingBox = createSkeletonBoundingBox(skeleton);
            if (boundingBox.min.y < 0) {
              rootBone.position.y -= boundingBox.min.y;
            }

            // export as a gltf
            exporter = new GLTFExporter();
            exporter.register(function (writer) {
              return new VRMAnimationExporterPlugin(writer);
            });
            _context.next = 25;
            return exporter.parseAsync(rootBone, {
              animations: [clip],
              binary: true
            });
          case 25:
            gltf = _context.sent;
            return _context.abrupt("return", gltf);
          case 27:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return _convertBVHToVRMAnimation.apply(this, arguments);
  }

  function animationBvh2vrmaBlob(_x, _x2, _x3) {
    return _animationBvh2vrmaBlob.apply(this, arguments);
  }
  function _animationBvh2vrmaBlob() {
    _animationBvh2vrmaBlob = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(bvhObject, vrm, onProgress) {
      var buffer, blob;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return convertBVHToVRMAnimation(bvhObject);
          case 2:
            buffer = _context.sent;
            blob = new Blob([buffer], {
              type: "model/gltf-binary"
            });
            return _context.abrupt("return", blob);
          case 5:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return _animationBvh2vrmaBlob.apply(this, arguments);
  }

  // ( 62 )[
  // 'bones[Hips]',
  // 'bones[Hips]',
  // 'bones[LHipJoint]',
  // 'bones[LHipJoint]',
  // 'bones[LeftUpLeg]',
  // 'bones[LeftUpLeg]',
  // 'bones[LeftLeg]',
  // 'bones[LeftLeg]',
  // 'bones[LeftFoot]',
  // 'bones[LeftFoot]',
  // 'bones[LeftToeBase]',
  // 'bones[LeftToeBase]',
  // 'bones[RHipJoint]',
  // 'bones[RHipJoint]',
  // 'bones[RightUpLeg]',
  // 'bones[RightUpLeg]',
  // 'bones[RightLeg]',
  // 'bones[RightLeg]',
  // 'bones[RightFoot]',
  // 'bones[RightFoot]',
  // 'bones[RightToeBase]',
  // 'bones[RightToeBase]',
  // 'bones[LowerBack]',
  // 'bones[LowerBack]',
  // 'bones[Spine]',
  // 'bones[Spine]',
  // 'bones[Spine1]',
  // 'bones[Spine1]',
  // 'bones[Neck]',
  // 'bones[Neck]',
  // 'bones[Neck1]',
  // 'bones[Neck1]',
  // 'bones[Head]',
  // 'bones[Head]',
  // 'bones[LeftShoulder]',
  // 'bones[LeftShoulder]',
  // 'bones[LeftArm]',
  // 'bones[LeftArm]',
  // 'bones[LeftForeArm]',
  // 'bones[LeftForeArm]',
  // 'bones[LeftHand]',
  // 'bones[LeftHand]',
  // 'bones[LeftFingerBase]',
  // 'bones[LeftFingerBase]',
  // 'bones[LFingers]',
  // 'bones[LFingers]',
  // 'bones[LThumb]',
  // 'bones[LThumb]',
  // 'bones[RightShoulder]',
  // 'bones[RightShoulder]',
  // 'bones[RightArm]',
  // 'bones[RightArm]',
  // 'bones[RightForeArm]',
  // 'bones[RightForeArm]',
  // 'bones[RightHand]',
  // 'bones[RightHand]',
  // 'bones[RightFingerBase]',
  // 'bones[RightFingerBase]',
  // 'bones[RFingers]',
  // 'bones[RFingers]',
  // 'bones[RThumb]',
  // 'bones[RThumb]' ];

  /*!
   * @pixiv/three-vrm-animation v3.1.1
   * The implementation of VRM Animation
   *
   * Copyright (c) 2019-2024 pixiv Inc.
   * @pixiv/three-vrm-animation is distributed under MIT License
   * https://github.com/pixiv/three-vrm/blob/release/LICENSE
   */
  var __async$1 = (__this, __arguments, generator) => {
    return new Promise((resolve, reject) => {
      var fulfilled = (value) => {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      };
      var rejected = (value) => {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      };
      var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
      step((generator = generator.apply(__this, __arguments)).next());
    });
  };
  var VRMExpressionPresetName$1 = {
    Aa: "aa",
    Ih: "ih",
    Ou: "ou",
    Ee: "ee",
    Oh: "oh",
    Blink: "blink",
    Happy: "happy",
    Angry: "angry",
    Sad: "sad",
    Relaxed: "relaxed",
    LookUp: "lookUp",
    Surprised: "surprised",
    LookDown: "lookDown",
    LookLeft: "lookLeft",
    LookRight: "lookRight",
    BlinkLeft: "blinkLeft",
    BlinkRight: "blinkRight",
    Neutral: "neutral"
  };
  new Color();
  new Vector2();
  new Vector3();
  new Vector3();
  var VRMHumanBoneParentMap$1 = {
    hips: null,
    spine: "hips",
    chest: "spine",
    upperChest: "chest",
    neck: "upperChest",
    head: "neck",
    leftEye: "head",
    rightEye: "head",
    jaw: "head",
    leftUpperLeg: "hips",
    leftLowerLeg: "leftUpperLeg",
    leftFoot: "leftLowerLeg",
    leftToes: "leftFoot",
    rightUpperLeg: "hips",
    rightLowerLeg: "rightUpperLeg",
    rightFoot: "rightLowerLeg",
    rightToes: "rightFoot",
    leftShoulder: "upperChest",
    leftUpperArm: "leftShoulder",
    leftLowerArm: "leftUpperArm",
    leftHand: "leftLowerArm",
    rightShoulder: "upperChest",
    rightUpperArm: "rightShoulder",
    rightLowerArm: "rightUpperArm",
    rightHand: "rightLowerArm",
    leftThumbMetacarpal: "leftHand",
    leftThumbProximal: "leftThumbMetacarpal",
    leftThumbDistal: "leftThumbProximal",
    leftIndexProximal: "leftHand",
    leftIndexIntermediate: "leftIndexProximal",
    leftIndexDistal: "leftIndexIntermediate",
    leftMiddleProximal: "leftHand",
    leftMiddleIntermediate: "leftMiddleProximal",
    leftMiddleDistal: "leftMiddleIntermediate",
    leftRingProximal: "leftHand",
    leftRingIntermediate: "leftRingProximal",
    leftRingDistal: "leftRingIntermediate",
    leftLittleProximal: "leftHand",
    leftLittleIntermediate: "leftLittleProximal",
    leftLittleDistal: "leftLittleIntermediate",
    rightThumbMetacarpal: "rightHand",
    rightThumbProximal: "rightThumbMetacarpal",
    rightThumbDistal: "rightThumbProximal",
    rightIndexProximal: "rightHand",
    rightIndexIntermediate: "rightIndexProximal",
    rightIndexDistal: "rightIndexIntermediate",
    rightMiddleProximal: "rightHand",
    rightMiddleIntermediate: "rightMiddleProximal",
    rightMiddleDistal: "rightMiddleIntermediate",
    rightRingProximal: "rightHand",
    rightRingIntermediate: "rightRingProximal",
    rightRingDistal: "rightRingIntermediate",
    rightLittleProximal: "rightHand",
    rightLittleIntermediate: "rightLittleProximal",
    rightLittleDistal: "rightLittleIntermediate"
  };
  function quatInvertCompat$1(target) {
    if (target.invert) {
      target.invert();
    } else {
      target.inverse();
    }
    return target;
  }
  new Vector3();
  new Vector3();
  new Vector3();
  new Vector3();
  new Vector3();
  new Vector3(0, 1, 0);
  var _position$1 = new Vector3();
  var _scale$1 = new Vector3();
  function getWorldQuaternionLite$1(object, out) {
    object.matrixWorld.decompose(_position$1, out, _scale$1);
    return out;
  }
  function calcAzimuthAltitude$1(vector) {
    return [Math.atan2(-vector.z, vector.x), Math.atan2(vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z))];
  }
  function sanitizeAngle$1(angle) {
    const roundTurn = Math.round(angle / 2 / Math.PI);
    return angle - 2 * Math.PI * roundTurn;
  }
  var VEC3_POSITIVE_Z$1 = new Vector3(0, 0, 1);
  var _v3A5$1 = new Vector3();
  var _v3B3$1 = new Vector3();
  var _v3C$1 = new Vector3();
  var _quatA5$1 = new Quaternion();
  var _quatB2$1 = new Quaternion();
  var _quatC$1 = new Quaternion();
  var _quatD$1 = new Quaternion();
  var _eulerA$1 = new Euler();
  var _VRMLookAt$1 = class _VRMLookAt2 {
    /**
     * Create a new {@link VRMLookAt}.
     *
     * @param humanoid A {@link VRMHumanoid}
     * @param applier A {@link VRMLookAtApplier}
     */
    constructor(humanoid, applier) {
      this.offsetFromHeadBone = new Vector3();
      this.autoUpdate = true;
      this.faceFront = new Vector3(0, 0, 1);
      this.humanoid = humanoid;
      this.applier = applier;
      this._yaw = 0;
      this._pitch = 0;
      this._needsUpdate = true;
      this._restHeadWorldQuaternion = this.getLookAtWorldQuaternion(new Quaternion());
    }
    /**
     * Its current angle around Y axis, in degree.
     */
    get yaw() {
      return this._yaw;
    }
    /**
     * Its current angle around Y axis, in degree.
     */
    set yaw(value) {
      this._yaw = value;
      this._needsUpdate = true;
    }
    /**
     * Its current angle around X axis, in degree.
     */
    get pitch() {
      return this._pitch;
    }
    /**
     * Its current angle around X axis, in degree.
     */
    set pitch(value) {
      this._pitch = value;
      this._needsUpdate = true;
    }
    /**
     * @deprecated Use {@link getEuler} instead.
     */
    get euler() {
      console.warn("VRMLookAt: euler is deprecated. use getEuler() instead.");
      return this.getEuler(new Euler());
    }
    /**
     * Get its yaw-pitch angles as an `Euler`.
     * Does NOT consider {@link faceFront}; it returns `Euler(0, 0, 0; "YXZ")` by default regardless of the faceFront value.
     *
     * @param target The target euler
     */
    getEuler(target) {
      return target.set(MathUtils.DEG2RAD * this._pitch, MathUtils.DEG2RAD * this._yaw, 0, "YXZ");
    }
    /**
     * Copy the given {@link VRMLookAt} into this one.
     * {@link humanoid} must be same as the source one.
     * {@link applier} will reference the same instance as the source one.
     * @param source The {@link VRMLookAt} you want to copy
     * @returns this
     */
    copy(source) {
      if (this.humanoid !== source.humanoid) {
        throw new Error("VRMLookAt: humanoid must be same in order to copy");
      }
      this.offsetFromHeadBone.copy(source.offsetFromHeadBone);
      this.applier = source.applier;
      this.autoUpdate = source.autoUpdate;
      this.target = source.target;
      this.faceFront.copy(source.faceFront);
      return this;
    }
    /**
     * Returns a clone of this {@link VRMLookAt}.
     * Note that {@link humanoid} and {@link applier} will reference the same instance as this one.
     * @returns Copied {@link VRMLookAt}
     */
    clone() {
      return new _VRMLookAt2(this.humanoid, this.applier).copy(this);
    }
    /**
     * Reset the lookAt direction (yaw and pitch) to the initial direction.
     */
    reset() {
      this._yaw = 0;
      this._pitch = 0;
      this._needsUpdate = true;
    }
    /**
     * Get its lookAt position in world coordinate.
     *
     * @param target A target `THREE.Vector3`
     */
    getLookAtWorldPosition(target) {
      const head = this.humanoid.getRawBoneNode("head");
      return target.copy(this.offsetFromHeadBone).applyMatrix4(head.matrixWorld);
    }
    /**
     * Get its lookAt rotation in world coordinate.
     * Does NOT consider {@link faceFront}.
     *
     * @param target A target `THREE.Quaternion`
     */
    getLookAtWorldQuaternion(target) {
      const head = this.humanoid.getRawBoneNode("head");
      return getWorldQuaternionLite$1(head, target);
    }
    /**
     * Get a quaternion that rotates the +Z unit vector of the humanoid Head to the {@link faceFront} direction.
     *
     * @param target A target `THREE.Quaternion`
     */
    getFaceFrontQuaternion(target) {
      if (this.faceFront.distanceToSquared(VEC3_POSITIVE_Z$1) < 0.01) {
        return target.copy(this._restHeadWorldQuaternion).invert();
      }
      const [faceFrontAzimuth, faceFrontAltitude] = calcAzimuthAltitude$1(this.faceFront);
      _eulerA$1.set(0, 0.5 * Math.PI + faceFrontAzimuth, faceFrontAltitude, "YZX");
      return target.setFromEuler(_eulerA$1).premultiply(_quatD$1.copy(this._restHeadWorldQuaternion).invert());
    }
    /**
     * Get its LookAt direction in world coordinate.
     *
     * @param target A target `THREE.Vector3`
     */
    getLookAtWorldDirection(target) {
      this.getLookAtWorldQuaternion(_quatB2$1);
      this.getFaceFrontQuaternion(_quatC$1);
      return target.copy(VEC3_POSITIVE_Z$1).applyQuaternion(_quatB2$1).applyQuaternion(_quatC$1).applyEuler(this.getEuler(_eulerA$1));
    }
    /**
     * Set its lookAt target position.
     *
     * Note that its result will be instantly overwritten if {@link VRMLookAtHead.autoUpdate} is enabled.
     *
     * If you want to track an object continuously, you might want to use {@link target} instead.
     *
     * @param position A target position, in world space
     */
    lookAt(position) {
      const headRotDiffInv = _quatA5$1.copy(this._restHeadWorldQuaternion).multiply(quatInvertCompat$1(this.getLookAtWorldQuaternion(_quatB2$1)));
      const headPos = this.getLookAtWorldPosition(_v3B3$1);
      const lookAtDir = _v3C$1.copy(position).sub(headPos).applyQuaternion(headRotDiffInv).normalize();
      const [azimuthFrom, altitudeFrom] = calcAzimuthAltitude$1(this.faceFront);
      const [azimuthTo, altitudeTo] = calcAzimuthAltitude$1(lookAtDir);
      const yaw = sanitizeAngle$1(azimuthTo - azimuthFrom);
      const pitch = sanitizeAngle$1(altitudeFrom - altitudeTo);
      this._yaw = MathUtils.RAD2DEG * yaw;
      this._pitch = MathUtils.RAD2DEG * pitch;
      this._needsUpdate = true;
    }
    /**
     * Update the VRMLookAtHead.
     * If {@link autoUpdate} is enabled, this will make it look at the {@link target}.
     *
     * @param delta deltaTime, it isn't used though. You can use the parameter if you want to use this in your own extended {@link VRMLookAt}.
     */
    update(delta) {
      if (this.target != null && this.autoUpdate) {
        this.lookAt(this.target.getWorldPosition(_v3A5$1));
      }
      if (this._needsUpdate) {
        this._needsUpdate = false;
        this.applier.applyYawPitch(this._yaw, this._pitch);
      }
    }
  };
  _VRMLookAt$1.EULER_ORDER = "YXZ";
  var VRMLookAt$1 = _VRMLookAt$1;
  new Vector3(0, 0, 1);
  var RAD2DEG = 180 / Math.PI;
  var _eulerA3 = /* @__PURE__ */ new Euler();
  var VRMLookAtQuaternionProxy = class extends Object3D {
    constructor(lookAt) {
      super();
      this.vrmLookAt = lookAt;
      this.type = "VRMLookAtQuaternionProxy";
      const prevRotationOnChangeCallback = this.rotation._onChangeCallback;
      this.rotation._onChange(() => {
        prevRotationOnChangeCallback();
        this._applyToLookAt();
      });
      const prevQuaternionOnChangeCallback = this.quaternion._onChangeCallback;
      this.quaternion._onChange(() => {
        prevQuaternionOnChangeCallback();
        this._applyToLookAt();
      });
    }
    _applyToLookAt() {
      _eulerA3.setFromQuaternion(this.quaternion, VRMLookAt$1.EULER_ORDER);
      this.vrmLookAt.yaw = RAD2DEG * _eulerA3.y;
      this.vrmLookAt.pitch = RAD2DEG * _eulerA3.x;
    }
  };

  // src/createVRMAnimationClip.ts
  function createVRMAnimationHumanoidTracks(vrmAnimation, humanoid, metaVersion) {
    var _a, _b;
    const translation = /* @__PURE__ */ new Map();
    const rotation = /* @__PURE__ */ new Map();
    for (const [name, origTrack] of vrmAnimation.humanoidTracks.rotation.entries()) {
      const nodeName = (_a = humanoid.getNormalizedBoneNode(name)) == null ? void 0 : _a.name;
      if (nodeName != null) {
        const track = new QuaternionKeyframeTrack(
          `${nodeName}.quaternion`,
          origTrack.times,
          origTrack.values.map((v, i) => metaVersion === "0" && i % 2 === 0 ? -v : v)
        );
        rotation.set(name, track);
      }
    }
    for (const [name, origTrack] of vrmAnimation.humanoidTracks.translation.entries()) {
      const nodeName = (_b = humanoid.getNormalizedBoneNode(name)) == null ? void 0 : _b.name;
      if (nodeName != null) {
        const animationY = vrmAnimation.restHipsPosition.y;
        const humanoidY = humanoid.normalizedRestPose.hips.position[1];
        const scale = humanoidY / animationY;
        const track = origTrack.clone();
        track.values = track.values.map((v, i) => (metaVersion === "0" && i % 3 !== 1 ? -v : v) * scale);
        track.name = `${nodeName}.position`;
        translation.set(name, track);
      }
    }
    return { translation, rotation };
  }
  function createVRMAnimationExpressionTracks(vrmAnimation, expressionManager) {
    const preset = /* @__PURE__ */ new Map();
    const custom = /* @__PURE__ */ new Map();
    for (const [name, origTrack] of vrmAnimation.expressionTracks.preset.entries()) {
      const trackName = expressionManager.getExpressionTrackName(name);
      if (trackName != null) {
        const track = origTrack.clone();
        track.name = trackName;
        preset.set(name, track);
      }
    }
    for (const [name, origTrack] of vrmAnimation.expressionTracks.custom.entries()) {
      const trackName = expressionManager.getExpressionTrackName(name);
      if (trackName != null) {
        const track = origTrack.clone();
        track.name = trackName;
        custom.set(name, track);
      }
    }
    return { preset, custom };
  }
  function createVRMAnimationLookAtTrack(vrmAnimation, trackName) {
    if (vrmAnimation.lookAtTrack == null) {
      return null;
    }
    const track = vrmAnimation.lookAtTrack.clone();
    track.name = trackName;
    return track;
  }
  function createVRMAnimationClip(vrmAnimation, vrm) {
    const tracks = [];
    const humanoidTracks = createVRMAnimationHumanoidTracks(vrmAnimation, vrm.humanoid, vrm.meta.metaVersion);
    tracks.push(...humanoidTracks.translation.values());
    tracks.push(...humanoidTracks.rotation.values());
    if (vrm.expressionManager != null) {
      const expressionTracks = createVRMAnimationExpressionTracks(vrmAnimation, vrm.expressionManager);
      tracks.push(...expressionTracks.preset.values());
      tracks.push(...expressionTracks.custom.values());
    }
    if (vrm.lookAt != null) {
      let proxy = vrm.scene.children.find((obj) => obj instanceof VRMLookAtQuaternionProxy);
      if (proxy == null) {
        console.warn(
          "createVRMAnimationClip: VRMLookAtQuaternionProxy is not found. Creating a new one automatically. To suppress this warning, create a VRMLookAtQuaternionProxy manually"
        );
        proxy = new VRMLookAtQuaternionProxy(vrm.lookAt);
        proxy.name = "VRMLookAtQuaternionProxy";
        vrm.scene.add(proxy);
      } else if (proxy.name == null) {
        console.warn(
          "createVRMAnimationClip: VRMLookAtQuaternionProxy is found but its name is not set. Setting the name automatically. To suppress this warning, set the name manually"
        );
        proxy.name = "VRMLookAtQuaternionProxy";
      }
      const track = createVRMAnimationLookAtTrack(vrmAnimation, `${proxy.name}.quaternion`);
      if (track != null) {
        tracks.push(track);
      }
    }
    return new AnimationClip("Clip", vrmAnimation.duration, tracks);
  }
  var VRMAnimation = class {
    constructor() {
      this.duration = 0;
      this.restHipsPosition = new Vector3();
      this.humanoidTracks = {
        translation: /* @__PURE__ */ new Map(),
        rotation: /* @__PURE__ */ new Map()
      };
      this.expressionTracks = {
        preset: /* @__PURE__ */ new Map(),
        custom: /* @__PURE__ */ new Map()
      };
      this.lookAtTrack = null;
    }
  };

  // src/utils/arrayChunk.ts
  function arrayChunk(array, every) {
    const N = array.length;
    const ret = [];
    let current = [];
    let remaining = 0;
    for (let i = 0; i < N; i++) {
      const el = array[i];
      if (remaining <= 0) {
        remaining = every;
        current = [];
        ret.push(current);
      }
      current.push(el);
      remaining--;
    }
    return ret;
  }

  // src/VRMAnimationLoaderPlugin.ts
  var MAT4_IDENTITY = /* @__PURE__ */ new Matrix4();
  var _v3A6$1 = /* @__PURE__ */ new Vector3();
  var _quatA7$1 = /* @__PURE__ */ new Quaternion();
  var _quatB4$1 = /* @__PURE__ */ new Quaternion();
  var _quatC2$1 = /* @__PURE__ */ new Quaternion();
  var POSSIBLE_SPEC_VERSIONS2$1 = /* @__PURE__ */ new Set(["1.0", "1.0-draft"]);
  var vrmExpressionPresetNameSet = /* @__PURE__ */ new Set(Object.values(VRMExpressionPresetName$1));
  var VRMAnimationLoaderPlugin = class {
    constructor(parser) {
      this.parser = parser;
    }
    get name() {
      return "VRMC_vrm_animation";
    }
    afterRoot(gltf) {
      return __async$1(this, null, function* () {
        var _a, _b, _c;
        const defGltf = gltf.parser.json;
        const defExtensionsUsed = defGltf.extensionsUsed;
        if (defExtensionsUsed == null || defExtensionsUsed.indexOf(this.name) == -1) {
          return;
        }
        const defExtension = (_a = defGltf.extensions) == null ? void 0 : _a[this.name];
        if (defExtension == null) {
          return;
        }
        const specVersion = defExtension.specVersion;
        if (!POSSIBLE_SPEC_VERSIONS2$1.has(specVersion)) {
          console.warn(`VRMAnimationLoaderPlugin: Unknown VRMC_vrm_animation spec version: ${specVersion}`);
          return;
        }
        if (specVersion === "1.0-draft") {
          console.warn(
            "VRMAnimationLoaderPlugin: Using a draft spec version: 1.0-draft. Some behaviors may be different. Consider updating the animation file."
          );
        }
        const nodeMap = this._createNodeMap(defExtension);
        const worldMatrixMap = yield this._createBoneWorldMatrixMap(gltf, defExtension);
        const hipsNode = (_c = (_b = defExtension.humanoid) == null ? void 0 : _b.humanBones["hips"]) == null ? void 0 : _c.node;
        const hips = hipsNode != null ? yield gltf.parser.getDependency("node", hipsNode) : null;
        const restHipsPosition = new Vector3();
        hips == null ? void 0 : hips.getWorldPosition(restHipsPosition);
        if (restHipsPosition.lengthSq() < 1e-6) {
          console.warn(
            "VRMAnimationLoaderPlugin: The loaded VRM Animation violates the VRM T-pose (The rest hips position is approximately zero.)"
          );
        }
        const clips = gltf.animations;
        const animations = clips.map((clip, iAnimation) => {
          const defAnimation = defGltf.animations[iAnimation];
          const animation = this._parseAnimation(clip, defAnimation, nodeMap, worldMatrixMap);
          animation.restHipsPosition = restHipsPosition;
          return animation;
        });
        gltf.userData.vrmAnimations = animations;
      });
    }
    _createNodeMap(defExtension) {
      var _a, _b, _c, _d, _e;
      const humanoidIndexToName = /* @__PURE__ */ new Map();
      const expressionsIndexToName = /* @__PURE__ */ new Map();
      const humanBones = (_a = defExtension.humanoid) == null ? void 0 : _a.humanBones;
      if (humanBones) {
        Object.entries(humanBones).forEach(([name, bone]) => {
          const node = bone == null ? void 0 : bone.node;
          if (node != null) {
            humanoidIndexToName.set(node, name);
          }
        });
      }
      const preset = (_b = defExtension.expressions) == null ? void 0 : _b.preset;
      if (preset) {
        Object.entries(preset).forEach(([name, expression]) => {
          const node = expression == null ? void 0 : expression.node;
          if (node != null) {
            expressionsIndexToName.set(node, name);
          }
        });
      }
      const custom = (_c = defExtension.expressions) == null ? void 0 : _c.custom;
      if (custom) {
        Object.entries(custom).forEach(([name, expression]) => {
          const { node } = expression;
          expressionsIndexToName.set(node, name);
        });
      }
      const lookAtIndex = (_e = (_d = defExtension.lookAt) == null ? void 0 : _d.node) != null ? _e : null;
      return { humanoidIndexToName, expressionsIndexToName, lookAtIndex };
    }
    _createBoneWorldMatrixMap(gltf, defExtension) {
      return __async$1(this, null, function* () {
        var _a, _b;
        gltf.scene.updateWorldMatrix(false, true);
        const threeNodes = yield gltf.parser.getDependencies("node");
        const worldMatrixMap = /* @__PURE__ */ new Map();
        if (defExtension.humanoid == null) {
          return worldMatrixMap;
        }
        for (const [boneName, humanBone] of Object.entries(defExtension.humanoid.humanBones)) {
          const node = humanBone == null ? void 0 : humanBone.node;
          if (node != null) {
            const threeNode = threeNodes[node];
            worldMatrixMap.set(boneName, threeNode.matrixWorld);
            if (boneName === "hips") {
              worldMatrixMap.set("hipsParent", (_b = (_a = threeNode.parent) == null ? void 0 : _a.matrixWorld) != null ? _b : MAT4_IDENTITY);
            }
          }
        }
        return worldMatrixMap;
      });
    }
    _parseAnimation(animationClip, defAnimation, nodeMap, worldMatrixMap) {
      const tracks = animationClip.tracks;
      const defChannels = defAnimation.channels;
      const result = new VRMAnimation();
      result.duration = animationClip.duration;
      defChannels.forEach((channel, iChannel) => {
        const { node, path } = channel.target;
        const origTrack = tracks[iChannel];
        if (node == null) {
          return;
        }
        const boneName = nodeMap.humanoidIndexToName.get(node);
        if (boneName != null) {
          let parentBoneName = VRMHumanBoneParentMap$1[boneName];
          while (parentBoneName != null && worldMatrixMap.get(parentBoneName) == null) {
            parentBoneName = VRMHumanBoneParentMap$1[parentBoneName];
          }
          parentBoneName != null ? parentBoneName : parentBoneName = "hipsParent";
          if (path === "translation") {
            if (boneName !== "hips") {
              console.warn(
                `The loading animation contains a translation track for ${boneName}, which is not permitted in the VRMC_vrm_animation spec. ignoring the track`
              );
            } else {
              const hipsParentWorldMatrix = worldMatrixMap.get("hipsParent");
              const trackValues = arrayChunk(origTrack.values, 3).flatMap(
                (v) => _v3A6$1.fromArray(v).applyMatrix4(hipsParentWorldMatrix).toArray()
              );
              const track = origTrack.clone();
              track.values = new Float32Array(trackValues);
              result.humanoidTracks.translation.set(boneName, track);
            }
          } else if (path === "rotation") {
            const worldMatrix = worldMatrixMap.get(boneName);
            const parentWorldMatrix = worldMatrixMap.get(parentBoneName);
            worldMatrix.decompose(_v3A6$1, _quatA7$1, _v3A6$1);
            _quatA7$1.invert();
            parentWorldMatrix.decompose(_v3A6$1, _quatB4$1, _v3A6$1);
            const trackValues = arrayChunk(origTrack.values, 4).flatMap(
              (q) => _quatC2$1.fromArray(q).premultiply(_quatB4$1).multiply(_quatA7$1).toArray()
            );
            const track = origTrack.clone();
            track.values = new Float32Array(trackValues);
            result.humanoidTracks.rotation.set(boneName, track);
          } else {
            throw new Error(`Invalid path "${path}"`);
          }
          return;
        }
        const expressionName = nodeMap.expressionsIndexToName.get(node);
        if (expressionName != null) {
          if (path === "translation") {
            const times = origTrack.times;
            const values = new Float32Array(origTrack.values.length / 3);
            for (let i = 0; i < values.length; i++) {
              values[i] = origTrack.values[3 * i];
            }
            const newTrack = new NumberKeyframeTrack(`${expressionName}.weight`, times, values);
            if (vrmExpressionPresetNameSet.has(expressionName)) {
              result.expressionTracks.preset.set(expressionName, newTrack);
            } else {
              result.expressionTracks.custom.set(expressionName, newTrack);
            }
          } else {
            throw new Error(`Invalid path "${path}"`);
          }
          return;
        }
        if (node === nodeMap.lookAtIndex) {
          if (path === "rotation") {
            result.lookAtTrack = origTrack;
          } else {
            throw new Error(`Invalid path "${path}"`);
          }
        }
      });
      return result;
    }
  };
  /*!
   * @pixiv/three-vrm-core v3.1.1
   * The implementation of core features of VRM, for @pixiv/three-vrm
   *
   * Copyright (c) 2019-2024 pixiv Inc.
   * @pixiv/three-vrm-core is distributed under MIT License
   * https://github.com/pixiv/three-vrm/blob/release/LICENSE
   */

  /**
   * @param {BufferGeometry} geometry
   * @param {number} drawMode
   * @return {BufferGeometry}
   */
  function toTrianglesDrawMode( geometry, drawMode ) {

  	if ( drawMode === TrianglesDrawMode ) {

  		console.warn( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.' );
  		return geometry;

  	}

  	if ( drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode ) {

  		let index = geometry.getIndex();

  		// generate index if not present

  		if ( index === null ) {

  			const indices = [];

  			const position = geometry.getAttribute( 'position' );

  			if ( position !== undefined ) {

  				for ( let i = 0; i < position.count; i ++ ) {

  					indices.push( i );

  				}

  				geometry.setIndex( indices );
  				index = geometry.getIndex();

  			} else {

  				console.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' );
  				return geometry;

  			}

  		}

  		//

  		const numberOfTriangles = index.count - 2;
  		const newIndices = [];

  		if ( drawMode === TriangleFanDrawMode ) {

  			// gl.TRIANGLE_FAN

  			for ( let i = 1; i <= numberOfTriangles; i ++ ) {

  				newIndices.push( index.getX( 0 ) );
  				newIndices.push( index.getX( i ) );
  				newIndices.push( index.getX( i + 1 ) );

  			}

  		} else {

  			// gl.TRIANGLE_STRIP

  			for ( let i = 0; i < numberOfTriangles; i ++ ) {

  				if ( i % 2 === 0 ) {

  					newIndices.push( index.getX( i ) );
  					newIndices.push( index.getX( i + 1 ) );
  					newIndices.push( index.getX( i + 2 ) );

  				} else {

  					newIndices.push( index.getX( i + 2 ) );
  					newIndices.push( index.getX( i + 1 ) );
  					newIndices.push( index.getX( i ) );

  				}

  			}

  		}

  		if ( ( newIndices.length / 3 ) !== numberOfTriangles ) {

  			console.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.' );

  		}

  		// build final geometry

  		const newGeometry = geometry.clone();
  		newGeometry.setIndex( newIndices );
  		newGeometry.clearGroups();

  		return newGeometry;

  	} else {

  		console.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode );
  		return geometry;

  	}

  }

  class GLTFLoader extends Loader {

  	constructor( manager ) {

  		super( manager );

  		this.dracoLoader = null;
  		this.ktx2Loader = null;
  		this.meshoptDecoder = null;

  		this.pluginCallbacks = [];

  		this.register( function ( parser ) {

  			return new GLTFMaterialsClearcoatExtension( parser );

  		} );

  		this.register( function ( parser ) {

  			return new GLTFMaterialsDispersionExtension( parser );

  		} );

  		this.register( function ( parser ) {

  			return new GLTFTextureBasisUExtension( parser );

  		} );

  		this.register( function ( parser ) {

  			return new GLTFTextureWebPExtension( parser );

  		} );

  		this.register( function ( parser ) {

  			return new GLTFTextureAVIFExtension( parser );

  		} );

  		this.register( function ( parser ) {

  			return new GLTFMaterialsSheenExtension( parser );

  		} );

  		this.register( function ( parser ) {

  			return new GLTFMaterialsTransmissionExtension( parser );

  		} );

  		this.register( function ( parser ) {

  			return new GLTFMaterialsVolumeExtension( parser );

  		} );

  		this.register( function ( parser ) {

  			return new GLTFMaterialsIorExtension( parser );

  		} );

  		this.register( function ( parser ) {

  			return new GLTFMaterialsEmissiveStrengthExtension( parser );

  		} );

  		this.register( function ( parser ) {

  			return new GLTFMaterialsSpecularExtension( parser );

  		} );

  		this.register( function ( parser ) {

  			return new GLTFMaterialsIridescenceExtension( parser );

  		} );

  		this.register( function ( parser ) {

  			return new GLTFMaterialsAnisotropyExtension( parser );

  		} );

  		this.register( function ( parser ) {

  			return new GLTFMaterialsBumpExtension( parser );

  		} );

  		this.register( function ( parser ) {

  			return new GLTFLightsExtension( parser );

  		} );

  		this.register( function ( parser ) {

  			return new GLTFMeshoptCompression( parser );

  		} );

  		this.register( function ( parser ) {

  			return new GLTFMeshGpuInstancing( parser );

  		} );

  	}

  	load( url, onLoad, onProgress, onError ) {

  		const scope = this;

  		let resourcePath;

  		if ( this.resourcePath !== '' ) {

  			resourcePath = this.resourcePath;

  		} else if ( this.path !== '' ) {

  			// If a base path is set, resources will be relative paths from that plus the relative path of the gltf file
  			// Example  path = 'https://my-cnd-server.com/', url = 'assets/models/model.gltf'
  			// resourcePath = 'https://my-cnd-server.com/assets/models/'
  			// referenced resource 'model.bin' will be loaded from 'https://my-cnd-server.com/assets/models/model.bin'
  			// referenced resource '../textures/texture.png' will be loaded from 'https://my-cnd-server.com/assets/textures/texture.png'
  			const relativeUrl = LoaderUtils.extractUrlBase( url );
  			resourcePath = LoaderUtils.resolveURL( relativeUrl, this.path );

  		} else {

  			resourcePath = LoaderUtils.extractUrlBase( url );

  		}

  		// Tells the LoadingManager to track an extra item, which resolves after
  		// the model is fully loaded. This means the count of items loaded will
  		// be incorrect, but ensures manager.onLoad() does not fire early.
  		this.manager.itemStart( url );

  		const _onError = function ( e ) {

  			if ( onError ) {

  				onError( e );

  			} else {

  				console.error( e );

  			}

  			scope.manager.itemError( url );
  			scope.manager.itemEnd( url );

  		};

  		const loader = new FileLoader( this.manager );

  		loader.setPath( this.path );
  		loader.setResponseType( 'arraybuffer' );
  		loader.setRequestHeader( this.requestHeader );
  		loader.setWithCredentials( this.withCredentials );

  		loader.load( url, function ( data ) {

  			try {

  				scope.parse( data, resourcePath, function ( gltf ) {

  					onLoad( gltf );

  					scope.manager.itemEnd( url );

  				}, _onError );

  			} catch ( e ) {

  				_onError( e );

  			}

  		}, onProgress, _onError );

  	}

  	setDRACOLoader( dracoLoader ) {

  		this.dracoLoader = dracoLoader;
  		return this;

  	}

  	setDDSLoader() {

  		throw new Error(

  			'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'

  		);

  	}

  	setKTX2Loader( ktx2Loader ) {

  		this.ktx2Loader = ktx2Loader;
  		return this;

  	}

  	setMeshoptDecoder( meshoptDecoder ) {

  		this.meshoptDecoder = meshoptDecoder;
  		return this;

  	}

  	register( callback ) {

  		if ( this.pluginCallbacks.indexOf( callback ) === - 1 ) {

  			this.pluginCallbacks.push( callback );

  		}

  		return this;

  	}

  	unregister( callback ) {

  		if ( this.pluginCallbacks.indexOf( callback ) !== - 1 ) {

  			this.pluginCallbacks.splice( this.pluginCallbacks.indexOf( callback ), 1 );

  		}

  		return this;

  	}

  	parse( data, path, onLoad, onError ) {

  		let json;
  		const extensions = {};
  		const plugins = {};
  		const textDecoder = new TextDecoder();

  		if ( typeof data === 'string' ) {

  			json = JSON.parse( data );

  		} else if ( data instanceof ArrayBuffer ) {

  			const magic = textDecoder.decode( new Uint8Array( data, 0, 4 ) );

  			if ( magic === BINARY_EXTENSION_HEADER_MAGIC ) {

  				try {

  					extensions[ EXTENSIONS.KHR_BINARY_GLTF ] = new GLTFBinaryExtension( data );

  				} catch ( error ) {

  					if ( onError ) onError( error );
  					return;

  				}

  				json = JSON.parse( extensions[ EXTENSIONS.KHR_BINARY_GLTF ].content );

  			} else {

  				json = JSON.parse( textDecoder.decode( data ) );

  			}

  		} else {

  			json = data;

  		}

  		if ( json.asset === undefined || json.asset.version[ 0 ] < 2 ) {

  			if ( onError ) onError( new Error( 'THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.' ) );
  			return;

  		}

  		const parser = new GLTFParser( json, {

  			path: path || this.resourcePath || '',
  			crossOrigin: this.crossOrigin,
  			requestHeader: this.requestHeader,
  			manager: this.manager,
  			ktx2Loader: this.ktx2Loader,
  			meshoptDecoder: this.meshoptDecoder

  		} );

  		parser.fileLoader.setRequestHeader( this.requestHeader );

  		for ( let i = 0; i < this.pluginCallbacks.length; i ++ ) {

  			const plugin = this.pluginCallbacks[ i ]( parser );

  			if ( ! plugin.name ) console.error( 'THREE.GLTFLoader: Invalid plugin found: missing name' );

  			plugins[ plugin.name ] = plugin;

  			// Workaround to avoid determining as unknown extension
  			// in addUnknownExtensionsToUserData().
  			// Remove this workaround if we move all the existing
  			// extension handlers to plugin system
  			extensions[ plugin.name ] = true;

  		}

  		if ( json.extensionsUsed ) {

  			for ( let i = 0; i < json.extensionsUsed.length; ++ i ) {

  				const extensionName = json.extensionsUsed[ i ];
  				const extensionsRequired = json.extensionsRequired || [];

  				switch ( extensionName ) {

  					case EXTENSIONS.KHR_MATERIALS_UNLIT:
  						extensions[ extensionName ] = new GLTFMaterialsUnlitExtension();
  						break;

  					case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
  						extensions[ extensionName ] = new GLTFDracoMeshCompressionExtension( json, this.dracoLoader );
  						break;

  					case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
  						extensions[ extensionName ] = new GLTFTextureTransformExtension();
  						break;

  					case EXTENSIONS.KHR_MESH_QUANTIZATION:
  						extensions[ extensionName ] = new GLTFMeshQuantizationExtension();
  						break;

  					default:

  						if ( extensionsRequired.indexOf( extensionName ) >= 0 && plugins[ extensionName ] === undefined ) {

  							console.warn( 'THREE.GLTFLoader: Unknown extension "' + extensionName + '".' );

  						}

  				}

  			}

  		}

  		parser.setExtensions( extensions );
  		parser.setPlugins( plugins );
  		parser.parse( onLoad, onError );

  	}

  	parseAsync( data, path ) {

  		const scope = this;

  		return new Promise( function ( resolve, reject ) {

  			scope.parse( data, path, resolve, reject );

  		} );

  	}

  }

  /* GLTFREGISTRY */

  function GLTFRegistry() {

  	let objects = {};

  	return	{

  		get: function ( key ) {

  			return objects[ key ];

  		},

  		add: function ( key, object ) {

  			objects[ key ] = object;

  		},

  		remove: function ( key ) {

  			delete objects[ key ];

  		},

  		removeAll: function () {

  			objects = {};

  		}

  	};

  }

  /*********************************/
  /********** EXTENSIONS ***********/
  /*********************************/

  const EXTENSIONS = {
  	KHR_BINARY_GLTF: 'KHR_binary_glTF',
  	KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',
  	KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',
  	KHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',
  	KHR_MATERIALS_DISPERSION: 'KHR_materials_dispersion',
  	KHR_MATERIALS_IOR: 'KHR_materials_ior',
  	KHR_MATERIALS_SHEEN: 'KHR_materials_sheen',
  	KHR_MATERIALS_SPECULAR: 'KHR_materials_specular',
  	KHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',
  	KHR_MATERIALS_IRIDESCENCE: 'KHR_materials_iridescence',
  	KHR_MATERIALS_ANISOTROPY: 'KHR_materials_anisotropy',
  	KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',
  	KHR_MATERIALS_VOLUME: 'KHR_materials_volume',
  	KHR_TEXTURE_BASISU: 'KHR_texture_basisu',
  	KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',
  	KHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',
  	KHR_MATERIALS_EMISSIVE_STRENGTH: 'KHR_materials_emissive_strength',
  	EXT_MATERIALS_BUMP: 'EXT_materials_bump',
  	EXT_TEXTURE_WEBP: 'EXT_texture_webp',
  	EXT_TEXTURE_AVIF: 'EXT_texture_avif',
  	EXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression',
  	EXT_MESH_GPU_INSTANCING: 'EXT_mesh_gpu_instancing'
  };

  /**
   * Punctual Lights Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual
   */
  class GLTFLightsExtension {

  	constructor( parser ) {

  		this.parser = parser;
  		this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;

  		// Object3D instance caches
  		this.cache = { refs: {}, uses: {} };

  	}

  	_markDefs() {

  		const parser = this.parser;
  		const nodeDefs = this.parser.json.nodes || [];

  		for ( let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {

  			const nodeDef = nodeDefs[ nodeIndex ];

  			if ( nodeDef.extensions
  					&& nodeDef.extensions[ this.name ]
  					&& nodeDef.extensions[ this.name ].light !== undefined ) {

  				parser._addNodeRef( this.cache, nodeDef.extensions[ this.name ].light );

  			}

  		}

  	}

  	_loadLight( lightIndex ) {

  		const parser = this.parser;
  		const cacheKey = 'light:' + lightIndex;
  		let dependency = parser.cache.get( cacheKey );

  		if ( dependency ) return dependency;

  		const json = parser.json;
  		const extensions = ( json.extensions && json.extensions[ this.name ] ) || {};
  		const lightDefs = extensions.lights || [];
  		const lightDef = lightDefs[ lightIndex ];
  		let lightNode;

  		const color = new Color( 0xffffff );

  		if ( lightDef.color !== undefined ) color.setRGB( lightDef.color[ 0 ], lightDef.color[ 1 ], lightDef.color[ 2 ], LinearSRGBColorSpace );

  		const range = lightDef.range !== undefined ? lightDef.range : 0;

  		switch ( lightDef.type ) {

  			case 'directional':
  				lightNode = new DirectionalLight( color );
  				lightNode.target.position.set( 0, 0, - 1 );
  				lightNode.add( lightNode.target );
  				break;

  			case 'point':
  				lightNode = new PointLight( color );
  				lightNode.distance = range;
  				break;

  			case 'spot':
  				lightNode = new SpotLight( color );
  				lightNode.distance = range;
  				// Handle spotlight properties.
  				lightDef.spot = lightDef.spot || {};
  				lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;
  				lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;
  				lightNode.angle = lightDef.spot.outerConeAngle;
  				lightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;
  				lightNode.target.position.set( 0, 0, - 1 );
  				lightNode.add( lightNode.target );
  				break;

  			default:
  				throw new Error( 'THREE.GLTFLoader: Unexpected light type: ' + lightDef.type );

  		}

  		// Some lights (e.g. spot) default to a position other than the origin. Reset the position
  		// here, because node-level parsing will only override position if explicitly specified.
  		lightNode.position.set( 0, 0, 0 );

  		lightNode.decay = 2;

  		assignExtrasToUserData( lightNode, lightDef );

  		if ( lightDef.intensity !== undefined ) lightNode.intensity = lightDef.intensity;

  		lightNode.name = parser.createUniqueName( lightDef.name || ( 'light_' + lightIndex ) );

  		dependency = Promise.resolve( lightNode );

  		parser.cache.add( cacheKey, dependency );

  		return dependency;

  	}

  	getDependency( type, index ) {

  		if ( type !== 'light' ) return;

  		return this._loadLight( index );

  	}

  	createNodeAttachment( nodeIndex ) {

  		const self = this;
  		const parser = this.parser;
  		const json = parser.json;
  		const nodeDef = json.nodes[ nodeIndex ];
  		const lightDef = ( nodeDef.extensions && nodeDef.extensions[ this.name ] ) || {};
  		const lightIndex = lightDef.light;

  		if ( lightIndex === undefined ) return null;

  		return this._loadLight( lightIndex ).then( function ( light ) {

  			return parser._getNodeRef( self.cache, lightIndex, light );

  		} );

  	}

  }

  /**
   * Unlit Materials Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit
   */
  class GLTFMaterialsUnlitExtension {

  	constructor() {

  		this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;

  	}

  	getMaterialType() {

  		return MeshBasicMaterial;

  	}

  	extendParams( materialParams, materialDef, parser ) {

  		const pending = [];

  		materialParams.color = new Color( 1.0, 1.0, 1.0 );
  		materialParams.opacity = 1.0;

  		const metallicRoughness = materialDef.pbrMetallicRoughness;

  		if ( metallicRoughness ) {

  			if ( Array.isArray( metallicRoughness.baseColorFactor ) ) {

  				const array = metallicRoughness.baseColorFactor;

  				materialParams.color.setRGB( array[ 0 ], array[ 1 ], array[ 2 ], LinearSRGBColorSpace );
  				materialParams.opacity = array[ 3 ];

  			}

  			if ( metallicRoughness.baseColorTexture !== undefined ) {

  				pending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture, SRGBColorSpace ) );

  			}

  		}

  		return Promise.all( pending );

  	}

  }

  /**
   * Materials Emissive Strength Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/blob/5768b3ce0ef32bc39cdf1bef10b948586635ead3/extensions/2.0/Khronos/KHR_materials_emissive_strength/README.md
   */
  class GLTFMaterialsEmissiveStrengthExtension {

  	constructor( parser ) {

  		this.parser = parser;
  		this.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH;

  	}

  	extendMaterialParams( materialIndex, materialParams ) {

  		const parser = this.parser;
  		const materialDef = parser.json.materials[ materialIndex ];

  		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

  			return Promise.resolve();

  		}

  		const emissiveStrength = materialDef.extensions[ this.name ].emissiveStrength;

  		if ( emissiveStrength !== undefined ) {

  			materialParams.emissiveIntensity = emissiveStrength;

  		}

  		return Promise.resolve();

  	}

  }

  /**
   * Clearcoat Materials Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat
   */
  class GLTFMaterialsClearcoatExtension {

  	constructor( parser ) {

  		this.parser = parser;
  		this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;

  	}

  	getMaterialType( materialIndex ) {

  		const parser = this.parser;
  		const materialDef = parser.json.materials[ materialIndex ];

  		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

  		return MeshPhysicalMaterial;

  	}

  	extendMaterialParams( materialIndex, materialParams ) {

  		const parser = this.parser;
  		const materialDef = parser.json.materials[ materialIndex ];

  		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

  			return Promise.resolve();

  		}

  		const pending = [];

  		const extension = materialDef.extensions[ this.name ];

  		if ( extension.clearcoatFactor !== undefined ) {

  			materialParams.clearcoat = extension.clearcoatFactor;

  		}

  		if ( extension.clearcoatTexture !== undefined ) {

  			pending.push( parser.assignTexture( materialParams, 'clearcoatMap', extension.clearcoatTexture ) );

  		}

  		if ( extension.clearcoatRoughnessFactor !== undefined ) {

  			materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;

  		}

  		if ( extension.clearcoatRoughnessTexture !== undefined ) {

  			pending.push( parser.assignTexture( materialParams, 'clearcoatRoughnessMap', extension.clearcoatRoughnessTexture ) );

  		}

  		if ( extension.clearcoatNormalTexture !== undefined ) {

  			pending.push( parser.assignTexture( materialParams, 'clearcoatNormalMap', extension.clearcoatNormalTexture ) );

  			if ( extension.clearcoatNormalTexture.scale !== undefined ) {

  				const scale = extension.clearcoatNormalTexture.scale;

  				materialParams.clearcoatNormalScale = new Vector2( scale, scale );

  			}

  		}

  		return Promise.all( pending );

  	}

  }

  /**
   * Materials dispersion Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_dispersion
   */
  class GLTFMaterialsDispersionExtension {

  	constructor( parser ) {

  		this.parser = parser;
  		this.name = EXTENSIONS.KHR_MATERIALS_DISPERSION;

  	}

  	getMaterialType( materialIndex ) {

  		const parser = this.parser;
  		const materialDef = parser.json.materials[ materialIndex ];

  		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

  		return MeshPhysicalMaterial;

  	}

  	extendMaterialParams( materialIndex, materialParams ) {

  		const parser = this.parser;
  		const materialDef = parser.json.materials[ materialIndex ];

  		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

  			return Promise.resolve();

  		}

  		const extension = materialDef.extensions[ this.name ];

  		materialParams.dispersion = extension.dispersion !== undefined ? extension.dispersion : 0;

  		return Promise.resolve();

  	}

  }

  /**
   * Iridescence Materials Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_iridescence
   */
  class GLTFMaterialsIridescenceExtension {

  	constructor( parser ) {

  		this.parser = parser;
  		this.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE;

  	}

  	getMaterialType( materialIndex ) {

  		const parser = this.parser;
  		const materialDef = parser.json.materials[ materialIndex ];

  		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

  		return MeshPhysicalMaterial;

  	}

  	extendMaterialParams( materialIndex, materialParams ) {

  		const parser = this.parser;
  		const materialDef = parser.json.materials[ materialIndex ];

  		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

  			return Promise.resolve();

  		}

  		const pending = [];

  		const extension = materialDef.extensions[ this.name ];

  		if ( extension.iridescenceFactor !== undefined ) {

  			materialParams.iridescence = extension.iridescenceFactor;

  		}

  		if ( extension.iridescenceTexture !== undefined ) {

  			pending.push( parser.assignTexture( materialParams, 'iridescenceMap', extension.iridescenceTexture ) );

  		}

  		if ( extension.iridescenceIor !== undefined ) {

  			materialParams.iridescenceIOR = extension.iridescenceIor;

  		}

  		if ( materialParams.iridescenceThicknessRange === undefined ) {

  			materialParams.iridescenceThicknessRange = [ 100, 400 ];

  		}

  		if ( extension.iridescenceThicknessMinimum !== undefined ) {

  			materialParams.iridescenceThicknessRange[ 0 ] = extension.iridescenceThicknessMinimum;

  		}

  		if ( extension.iridescenceThicknessMaximum !== undefined ) {

  			materialParams.iridescenceThicknessRange[ 1 ] = extension.iridescenceThicknessMaximum;

  		}

  		if ( extension.iridescenceThicknessTexture !== undefined ) {

  			pending.push( parser.assignTexture( materialParams, 'iridescenceThicknessMap', extension.iridescenceThicknessTexture ) );

  		}

  		return Promise.all( pending );

  	}

  }

  /**
   * Sheen Materials Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen
   */
  class GLTFMaterialsSheenExtension {

  	constructor( parser ) {

  		this.parser = parser;
  		this.name = EXTENSIONS.KHR_MATERIALS_SHEEN;

  	}

  	getMaterialType( materialIndex ) {

  		const parser = this.parser;
  		const materialDef = parser.json.materials[ materialIndex ];

  		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

  		return MeshPhysicalMaterial;

  	}

  	extendMaterialParams( materialIndex, materialParams ) {

  		const parser = this.parser;
  		const materialDef = parser.json.materials[ materialIndex ];

  		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

  			return Promise.resolve();

  		}

  		const pending = [];

  		materialParams.sheenColor = new Color( 0, 0, 0 );
  		materialParams.sheenRoughness = 0;
  		materialParams.sheen = 1;

  		const extension = materialDef.extensions[ this.name ];

  		if ( extension.sheenColorFactor !== undefined ) {

  			const colorFactor = extension.sheenColorFactor;
  			materialParams.sheenColor.setRGB( colorFactor[ 0 ], colorFactor[ 1 ], colorFactor[ 2 ], LinearSRGBColorSpace );

  		}

  		if ( extension.sheenRoughnessFactor !== undefined ) {

  			materialParams.sheenRoughness = extension.sheenRoughnessFactor;

  		}

  		if ( extension.sheenColorTexture !== undefined ) {

  			pending.push( parser.assignTexture( materialParams, 'sheenColorMap', extension.sheenColorTexture, SRGBColorSpace ) );

  		}

  		if ( extension.sheenRoughnessTexture !== undefined ) {

  			pending.push( parser.assignTexture( materialParams, 'sheenRoughnessMap', extension.sheenRoughnessTexture ) );

  		}

  		return Promise.all( pending );

  	}

  }

  /**
   * Transmission Materials Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission
   * Draft: https://github.com/KhronosGroup/glTF/pull/1698
   */
  class GLTFMaterialsTransmissionExtension {

  	constructor( parser ) {

  		this.parser = parser;
  		this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;

  	}

  	getMaterialType( materialIndex ) {

  		const parser = this.parser;
  		const materialDef = parser.json.materials[ materialIndex ];

  		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

  		return MeshPhysicalMaterial;

  	}

  	extendMaterialParams( materialIndex, materialParams ) {

  		const parser = this.parser;
  		const materialDef = parser.json.materials[ materialIndex ];

  		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

  			return Promise.resolve();

  		}

  		const pending = [];

  		const extension = materialDef.extensions[ this.name ];

  		if ( extension.transmissionFactor !== undefined ) {

  			materialParams.transmission = extension.transmissionFactor;

  		}

  		if ( extension.transmissionTexture !== undefined ) {

  			pending.push( parser.assignTexture( materialParams, 'transmissionMap', extension.transmissionTexture ) );

  		}

  		return Promise.all( pending );

  	}

  }

  /**
   * Materials Volume Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume
   */
  class GLTFMaterialsVolumeExtension {

  	constructor( parser ) {

  		this.parser = parser;
  		this.name = EXTENSIONS.KHR_MATERIALS_VOLUME;

  	}

  	getMaterialType( materialIndex ) {

  		const parser = this.parser;
  		const materialDef = parser.json.materials[ materialIndex ];

  		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

  		return MeshPhysicalMaterial;

  	}

  	extendMaterialParams( materialIndex, materialParams ) {

  		const parser = this.parser;
  		const materialDef = parser.json.materials[ materialIndex ];

  		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

  			return Promise.resolve();

  		}

  		const pending = [];

  		const extension = materialDef.extensions[ this.name ];

  		materialParams.thickness = extension.thicknessFactor !== undefined ? extension.thicknessFactor : 0;

  		if ( extension.thicknessTexture !== undefined ) {

  			pending.push( parser.assignTexture( materialParams, 'thicknessMap', extension.thicknessTexture ) );

  		}

  		materialParams.attenuationDistance = extension.attenuationDistance || Infinity;

  		const colorArray = extension.attenuationColor || [ 1, 1, 1 ];
  		materialParams.attenuationColor = new Color().setRGB( colorArray[ 0 ], colorArray[ 1 ], colorArray[ 2 ], LinearSRGBColorSpace );

  		return Promise.all( pending );

  	}

  }

  /**
   * Materials ior Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_ior
   */
  class GLTFMaterialsIorExtension {

  	constructor( parser ) {

  		this.parser = parser;
  		this.name = EXTENSIONS.KHR_MATERIALS_IOR;

  	}

  	getMaterialType( materialIndex ) {

  		const parser = this.parser;
  		const materialDef = parser.json.materials[ materialIndex ];

  		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

  		return MeshPhysicalMaterial;

  	}

  	extendMaterialParams( materialIndex, materialParams ) {

  		const parser = this.parser;
  		const materialDef = parser.json.materials[ materialIndex ];

  		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

  			return Promise.resolve();

  		}

  		const extension = materialDef.extensions[ this.name ];

  		materialParams.ior = extension.ior !== undefined ? extension.ior : 1.5;

  		return Promise.resolve();

  	}

  }

  /**
   * Materials specular Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_specular
   */
  class GLTFMaterialsSpecularExtension {

  	constructor( parser ) {

  		this.parser = parser;
  		this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;

  	}

  	getMaterialType( materialIndex ) {

  		const parser = this.parser;
  		const materialDef = parser.json.materials[ materialIndex ];

  		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

  		return MeshPhysicalMaterial;

  	}

  	extendMaterialParams( materialIndex, materialParams ) {

  		const parser = this.parser;
  		const materialDef = parser.json.materials[ materialIndex ];

  		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

  			return Promise.resolve();

  		}

  		const pending = [];

  		const extension = materialDef.extensions[ this.name ];

  		materialParams.specularIntensity = extension.specularFactor !== undefined ? extension.specularFactor : 1.0;

  		if ( extension.specularTexture !== undefined ) {

  			pending.push( parser.assignTexture( materialParams, 'specularIntensityMap', extension.specularTexture ) );

  		}

  		const colorArray = extension.specularColorFactor || [ 1, 1, 1 ];
  		materialParams.specularColor = new Color().setRGB( colorArray[ 0 ], colorArray[ 1 ], colorArray[ 2 ], LinearSRGBColorSpace );

  		if ( extension.specularColorTexture !== undefined ) {

  			pending.push( parser.assignTexture( materialParams, 'specularColorMap', extension.specularColorTexture, SRGBColorSpace ) );

  		}

  		return Promise.all( pending );

  	}

  }


  /**
   * Materials bump Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/EXT_materials_bump
   */
  class GLTFMaterialsBumpExtension {

  	constructor( parser ) {

  		this.parser = parser;
  		this.name = EXTENSIONS.EXT_MATERIALS_BUMP;

  	}

  	getMaterialType( materialIndex ) {

  		const parser = this.parser;
  		const materialDef = parser.json.materials[ materialIndex ];

  		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

  		return MeshPhysicalMaterial;

  	}

  	extendMaterialParams( materialIndex, materialParams ) {

  		const parser = this.parser;
  		const materialDef = parser.json.materials[ materialIndex ];

  		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

  			return Promise.resolve();

  		}

  		const pending = [];

  		const extension = materialDef.extensions[ this.name ];

  		materialParams.bumpScale = extension.bumpFactor !== undefined ? extension.bumpFactor : 1.0;

  		if ( extension.bumpTexture !== undefined ) {

  			pending.push( parser.assignTexture( materialParams, 'bumpMap', extension.bumpTexture ) );

  		}

  		return Promise.all( pending );

  	}

  }

  /**
   * Materials anisotropy Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_anisotropy
   */
  class GLTFMaterialsAnisotropyExtension {

  	constructor( parser ) {

  		this.parser = parser;
  		this.name = EXTENSIONS.KHR_MATERIALS_ANISOTROPY;

  	}

  	getMaterialType( materialIndex ) {

  		const parser = this.parser;
  		const materialDef = parser.json.materials[ materialIndex ];

  		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

  		return MeshPhysicalMaterial;

  	}

  	extendMaterialParams( materialIndex, materialParams ) {

  		const parser = this.parser;
  		const materialDef = parser.json.materials[ materialIndex ];

  		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

  			return Promise.resolve();

  		}

  		const pending = [];

  		const extension = materialDef.extensions[ this.name ];

  		if ( extension.anisotropyStrength !== undefined ) {

  			materialParams.anisotropy = extension.anisotropyStrength;

  		}

  		if ( extension.anisotropyRotation !== undefined ) {

  			materialParams.anisotropyRotation = extension.anisotropyRotation;

  		}

  		if ( extension.anisotropyTexture !== undefined ) {

  			pending.push( parser.assignTexture( materialParams, 'anisotropyMap', extension.anisotropyTexture ) );

  		}

  		return Promise.all( pending );

  	}

  }

  /**
   * BasisU Texture Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu
   */
  class GLTFTextureBasisUExtension {

  	constructor( parser ) {

  		this.parser = parser;
  		this.name = EXTENSIONS.KHR_TEXTURE_BASISU;

  	}

  	loadTexture( textureIndex ) {

  		const parser = this.parser;
  		const json = parser.json;

  		const textureDef = json.textures[ textureIndex ];

  		if ( ! textureDef.extensions || ! textureDef.extensions[ this.name ] ) {

  			return null;

  		}

  		const extension = textureDef.extensions[ this.name ];
  		const loader = parser.options.ktx2Loader;

  		if ( ! loader ) {

  			if ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {

  				throw new Error( 'THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures' );

  			} else {

  				// Assumes that the extension is optional and that a fallback texture is present
  				return null;

  			}

  		}

  		return parser.loadTextureImage( textureIndex, extension.source, loader );

  	}

  }

  /**
   * WebP Texture Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp
   */
  class GLTFTextureWebPExtension {

  	constructor( parser ) {

  		this.parser = parser;
  		this.name = EXTENSIONS.EXT_TEXTURE_WEBP;
  		this.isSupported = null;

  	}

  	loadTexture( textureIndex ) {

  		const name = this.name;
  		const parser = this.parser;
  		const json = parser.json;

  		const textureDef = json.textures[ textureIndex ];

  		if ( ! textureDef.extensions || ! textureDef.extensions[ name ] ) {

  			return null;

  		}

  		const extension = textureDef.extensions[ name ];
  		const source = json.images[ extension.source ];

  		let loader = parser.textureLoader;
  		if ( source.uri ) {

  			const handler = parser.options.manager.getHandler( source.uri );
  			if ( handler !== null ) loader = handler;

  		}

  		return this.detectSupport().then( function ( isSupported ) {

  			if ( isSupported ) return parser.loadTextureImage( textureIndex, extension.source, loader );

  			if ( json.extensionsRequired && json.extensionsRequired.indexOf( name ) >= 0 ) {

  				throw new Error( 'THREE.GLTFLoader: WebP required by asset but unsupported.' );

  			}

  			// Fall back to PNG or JPEG.
  			return parser.loadTexture( textureIndex );

  		} );

  	}

  	detectSupport() {

  		if ( ! this.isSupported ) {

  			this.isSupported = new Promise( function ( resolve ) {

  				const image = new Image();

  				// Lossy test image. Support for lossy images doesn't guarantee support for all
  				// WebP images, unfortunately.
  				image.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA';

  				image.onload = image.onerror = function () {

  					resolve( image.height === 1 );

  				};

  			} );

  		}

  		return this.isSupported;

  	}

  }

  /**
   * AVIF Texture Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_avif
   */
  class GLTFTextureAVIFExtension {

  	constructor( parser ) {

  		this.parser = parser;
  		this.name = EXTENSIONS.EXT_TEXTURE_AVIF;
  		this.isSupported = null;

  	}

  	loadTexture( textureIndex ) {

  		const name = this.name;
  		const parser = this.parser;
  		const json = parser.json;

  		const textureDef = json.textures[ textureIndex ];

  		if ( ! textureDef.extensions || ! textureDef.extensions[ name ] ) {

  			return null;

  		}

  		const extension = textureDef.extensions[ name ];
  		const source = json.images[ extension.source ];

  		let loader = parser.textureLoader;
  		if ( source.uri ) {

  			const handler = parser.options.manager.getHandler( source.uri );
  			if ( handler !== null ) loader = handler;

  		}

  		return this.detectSupport().then( function ( isSupported ) {

  			if ( isSupported ) return parser.loadTextureImage( textureIndex, extension.source, loader );

  			if ( json.extensionsRequired && json.extensionsRequired.indexOf( name ) >= 0 ) {

  				throw new Error( 'THREE.GLTFLoader: AVIF required by asset but unsupported.' );

  			}

  			// Fall back to PNG or JPEG.
  			return parser.loadTexture( textureIndex );

  		} );

  	}

  	detectSupport() {

  		if ( ! this.isSupported ) {

  			this.isSupported = new Promise( function ( resolve ) {

  				const image = new Image();

  				// Lossy test image.
  				image.src = 'data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=';
  				image.onload = image.onerror = function () {

  					resolve( image.height === 1 );

  				};

  			} );

  		}

  		return this.isSupported;

  	}

  }

  /**
   * meshopt BufferView Compression Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_meshopt_compression
   */
  class GLTFMeshoptCompression {

  	constructor( parser ) {

  		this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;
  		this.parser = parser;

  	}

  	loadBufferView( index ) {

  		const json = this.parser.json;
  		const bufferView = json.bufferViews[ index ];

  		if ( bufferView.extensions && bufferView.extensions[ this.name ] ) {

  			const extensionDef = bufferView.extensions[ this.name ];

  			const buffer = this.parser.getDependency( 'buffer', extensionDef.buffer );
  			const decoder = this.parser.options.meshoptDecoder;

  			if ( ! decoder || ! decoder.supported ) {

  				if ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {

  					throw new Error( 'THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files' );

  				} else {

  					// Assumes that the extension is optional and that fallback buffer data is present
  					return null;

  				}

  			}

  			return buffer.then( function ( res ) {

  				const byteOffset = extensionDef.byteOffset || 0;
  				const byteLength = extensionDef.byteLength || 0;

  				const count = extensionDef.count;
  				const stride = extensionDef.byteStride;

  				const source = new Uint8Array( res, byteOffset, byteLength );

  				if ( decoder.decodeGltfBufferAsync ) {

  					return decoder.decodeGltfBufferAsync( count, stride, source, extensionDef.mode, extensionDef.filter ).then( function ( res ) {

  						return res.buffer;

  					} );

  				} else {

  					// Support for MeshoptDecoder 0.18 or earlier, without decodeGltfBufferAsync
  					return decoder.ready.then( function () {

  						const result = new ArrayBuffer( count * stride );
  						decoder.decodeGltfBuffer( new Uint8Array( result ), count, stride, source, extensionDef.mode, extensionDef.filter );
  						return result;

  					} );

  				}

  			} );

  		} else {

  			return null;

  		}

  	}

  }

  /**
   * GPU Instancing Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_mesh_gpu_instancing
   *
   */
  class GLTFMeshGpuInstancing {

  	constructor( parser ) {

  		this.name = EXTENSIONS.EXT_MESH_GPU_INSTANCING;
  		this.parser = parser;

  	}

  	createNodeMesh( nodeIndex ) {

  		const json = this.parser.json;
  		const nodeDef = json.nodes[ nodeIndex ];

  		if ( ! nodeDef.extensions || ! nodeDef.extensions[ this.name ] ||
  			nodeDef.mesh === undefined ) {

  			return null;

  		}

  		const meshDef = json.meshes[ nodeDef.mesh ];

  		// No Points or Lines + Instancing support yet

  		for ( const primitive of meshDef.primitives ) {

  			if ( primitive.mode !== WEBGL_CONSTANTS.TRIANGLES &&
  				 primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_STRIP &&
  				 primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_FAN &&
  				 primitive.mode !== undefined ) {

  				return null;

  			}

  		}

  		const extensionDef = nodeDef.extensions[ this.name ];
  		const attributesDef = extensionDef.attributes;

  		// @TODO: Can we support InstancedMesh + SkinnedMesh?

  		const pending = [];
  		const attributes = {};

  		for ( const key in attributesDef ) {

  			pending.push( this.parser.getDependency( 'accessor', attributesDef[ key ] ).then( accessor => {

  				attributes[ key ] = accessor;
  				return attributes[ key ];

  			} ) );

  		}

  		if ( pending.length < 1 ) {

  			return null;

  		}

  		pending.push( this.parser.createNodeMesh( nodeIndex ) );

  		return Promise.all( pending ).then( results => {

  			const nodeObject = results.pop();
  			const meshes = nodeObject.isGroup ? nodeObject.children : [ nodeObject ];
  			const count = results[ 0 ].count; // All attribute counts should be same
  			const instancedMeshes = [];

  			for ( const mesh of meshes ) {

  				// Temporal variables
  				const m = new Matrix4();
  				const p = new Vector3();
  				const q = new Quaternion();
  				const s = new Vector3( 1, 1, 1 );

  				const instancedMesh = new InstancedMesh( mesh.geometry, mesh.material, count );

  				for ( let i = 0; i < count; i ++ ) {

  					if ( attributes.TRANSLATION ) {

  						p.fromBufferAttribute( attributes.TRANSLATION, i );

  					}

  					if ( attributes.ROTATION ) {

  						q.fromBufferAttribute( attributes.ROTATION, i );

  					}

  					if ( attributes.SCALE ) {

  						s.fromBufferAttribute( attributes.SCALE, i );

  					}

  					instancedMesh.setMatrixAt( i, m.compose( p, q, s ) );

  				}

  				// Add instance attributes to the geometry, excluding TRS.
  				for ( const attributeName in attributes ) {

  					if ( attributeName === '_COLOR_0' ) {

  						const attr = attributes[ attributeName ];
  						instancedMesh.instanceColor = new InstancedBufferAttribute( attr.array, attr.itemSize, attr.normalized );

  					} else if ( attributeName !== 'TRANSLATION' &&
  						 attributeName !== 'ROTATION' &&
  						 attributeName !== 'SCALE' ) {

  						mesh.geometry.setAttribute( attributeName, attributes[ attributeName ] );

  					}

  				}

  				// Just in case
  				Object3D.prototype.copy.call( instancedMesh, mesh );

  				this.parser.assignFinalMaterial( instancedMesh );

  				instancedMeshes.push( instancedMesh );

  			}

  			if ( nodeObject.isGroup ) {

  				nodeObject.clear();

  				nodeObject.add( ... instancedMeshes );

  				return nodeObject;

  			}

  			return instancedMeshes[ 0 ];

  		} );

  	}

  }

  /* BINARY EXTENSION */
  const BINARY_EXTENSION_HEADER_MAGIC = 'glTF';
  const BINARY_EXTENSION_HEADER_LENGTH = 12;
  const BINARY_EXTENSION_CHUNK_TYPES = { JSON: 0x4E4F534A, BIN: 0x004E4942 };

  class GLTFBinaryExtension {

  	constructor( data ) {

  		this.name = EXTENSIONS.KHR_BINARY_GLTF;
  		this.content = null;
  		this.body = null;

  		const headerView = new DataView( data, 0, BINARY_EXTENSION_HEADER_LENGTH );
  		const textDecoder = new TextDecoder();

  		this.header = {
  			magic: textDecoder.decode( new Uint8Array( data.slice( 0, 4 ) ) ),
  			version: headerView.getUint32( 4, true ),
  			length: headerView.getUint32( 8, true )
  		};

  		if ( this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC ) {

  			throw new Error( 'THREE.GLTFLoader: Unsupported glTF-Binary header.' );

  		} else if ( this.header.version < 2.0 ) {

  			throw new Error( 'THREE.GLTFLoader: Legacy binary file detected.' );

  		}

  		const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;
  		const chunkView = new DataView( data, BINARY_EXTENSION_HEADER_LENGTH );
  		let chunkIndex = 0;

  		while ( chunkIndex < chunkContentsLength ) {

  			const chunkLength = chunkView.getUint32( chunkIndex, true );
  			chunkIndex += 4;

  			const chunkType = chunkView.getUint32( chunkIndex, true );
  			chunkIndex += 4;

  			if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON ) {

  				const contentArray = new Uint8Array( data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength );
  				this.content = textDecoder.decode( contentArray );

  			} else if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN ) {

  				const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;
  				this.body = data.slice( byteOffset, byteOffset + chunkLength );

  			}

  			// Clients must ignore chunks with unknown types.

  			chunkIndex += chunkLength;

  		}

  		if ( this.content === null ) {

  			throw new Error( 'THREE.GLTFLoader: JSON content not found.' );

  		}

  	}

  }

  /**
   * DRACO Mesh Compression Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression
   */
  class GLTFDracoMeshCompressionExtension {

  	constructor( json, dracoLoader ) {

  		if ( ! dracoLoader ) {

  			throw new Error( 'THREE.GLTFLoader: No DRACOLoader instance provided.' );

  		}

  		this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;
  		this.json = json;
  		this.dracoLoader = dracoLoader;
  		this.dracoLoader.preload();

  	}

  	decodePrimitive( primitive, parser ) {

  		const json = this.json;
  		const dracoLoader = this.dracoLoader;
  		const bufferViewIndex = primitive.extensions[ this.name ].bufferView;
  		const gltfAttributeMap = primitive.extensions[ this.name ].attributes;
  		const threeAttributeMap = {};
  		const attributeNormalizedMap = {};
  		const attributeTypeMap = {};

  		for ( const attributeName in gltfAttributeMap ) {

  			const threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();

  			threeAttributeMap[ threeAttributeName ] = gltfAttributeMap[ attributeName ];

  		}

  		for ( const attributeName in primitive.attributes ) {

  			const threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();

  			if ( gltfAttributeMap[ attributeName ] !== undefined ) {

  				const accessorDef = json.accessors[ primitive.attributes[ attributeName ] ];
  				const componentType = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];

  				attributeTypeMap[ threeAttributeName ] = componentType.name;
  				attributeNormalizedMap[ threeAttributeName ] = accessorDef.normalized === true;

  			}

  		}

  		return parser.getDependency( 'bufferView', bufferViewIndex ).then( function ( bufferView ) {

  			return new Promise( function ( resolve, reject ) {

  				dracoLoader.decodeDracoFile( bufferView, function ( geometry ) {

  					for ( const attributeName in geometry.attributes ) {

  						const attribute = geometry.attributes[ attributeName ];
  						const normalized = attributeNormalizedMap[ attributeName ];

  						if ( normalized !== undefined ) attribute.normalized = normalized;

  					}

  					resolve( geometry );

  				}, threeAttributeMap, attributeTypeMap, LinearSRGBColorSpace, reject );

  			} );

  		} );

  	}

  }

  /**
   * Texture Transform Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform
   */
  class GLTFTextureTransformExtension {

  	constructor() {

  		this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;

  	}

  	extendTexture( texture, transform ) {

  		if ( ( transform.texCoord === undefined || transform.texCoord === texture.channel )
  			&& transform.offset === undefined
  			&& transform.rotation === undefined
  			&& transform.scale === undefined ) {

  			// See https://github.com/mrdoob/three.js/issues/21819.
  			return texture;

  		}

  		texture = texture.clone();

  		if ( transform.texCoord !== undefined ) {

  			texture.channel = transform.texCoord;

  		}

  		if ( transform.offset !== undefined ) {

  			texture.offset.fromArray( transform.offset );

  		}

  		if ( transform.rotation !== undefined ) {

  			texture.rotation = transform.rotation;

  		}

  		if ( transform.scale !== undefined ) {

  			texture.repeat.fromArray( transform.scale );

  		}

  		texture.needsUpdate = true;

  		return texture;

  	}

  }

  /**
   * Mesh Quantization Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization
   */
  class GLTFMeshQuantizationExtension {

  	constructor() {

  		this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;

  	}

  }

  /*********************************/
  /********** INTERPOLATION ********/
  /*********************************/

  // Spline Interpolation
  // Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation
  class GLTFCubicSplineInterpolant extends Interpolant {

  	constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

  		super( parameterPositions, sampleValues, sampleSize, resultBuffer );

  	}

  	copySampleValue_( index ) {

  		// Copies a sample value to the result buffer. See description of glTF
  		// CUBICSPLINE values layout in interpolate_() function below.

  		const result = this.resultBuffer,
  			values = this.sampleValues,
  			valueSize = this.valueSize,
  			offset = index * valueSize * 3 + valueSize;

  		for ( let i = 0; i !== valueSize; i ++ ) {

  			result[ i ] = values[ offset + i ];

  		}

  		return result;

  	}

  	interpolate_( i1, t0, t, t1 ) {

  		const result = this.resultBuffer;
  		const values = this.sampleValues;
  		const stride = this.valueSize;

  		const stride2 = stride * 2;
  		const stride3 = stride * 3;

  		const td = t1 - t0;

  		const p = ( t - t0 ) / td;
  		const pp = p * p;
  		const ppp = pp * p;

  		const offset1 = i1 * stride3;
  		const offset0 = offset1 - stride3;

  		const s2 = - 2 * ppp + 3 * pp;
  		const s3 = ppp - pp;
  		const s0 = 1 - s2;
  		const s1 = s3 - pp + p;

  		// Layout of keyframe output values for CUBICSPLINE animations:
  		//   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]
  		for ( let i = 0; i !== stride; i ++ ) {

  			const p0 = values[ offset0 + i + stride ]; // splineVertex_k
  			const m0 = values[ offset0 + i + stride2 ] * td; // outTangent_k * (t_k+1 - t_k)
  			const p1 = values[ offset1 + i + stride ]; // splineVertex_k+1
  			const m1 = values[ offset1 + i ] * td; // inTangent_k+1 * (t_k+1 - t_k)

  			result[ i ] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;

  		}

  		return result;

  	}

  }

  const _q = new Quaternion();

  class GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {

  	interpolate_( i1, t0, t, t1 ) {

  		const result = super.interpolate_( i1, t0, t, t1 );

  		_q.fromArray( result ).normalize().toArray( result );

  		return result;

  	}

  }


  /*********************************/
  /********** INTERNALS ************/
  /*********************************/

  /* CONSTANTS */

  const WEBGL_CONSTANTS = {
  	FLOAT: 5126,
  	//FLOAT_MAT2: 35674,
  	FLOAT_MAT3: 35675,
  	FLOAT_MAT4: 35676,
  	FLOAT_VEC2: 35664,
  	FLOAT_VEC3: 35665,
  	FLOAT_VEC4: 35666,
  	LINEAR: 9729,
  	REPEAT: 10497,
  	SAMPLER_2D: 35678,
  	POINTS: 0,
  	LINES: 1,
  	LINE_LOOP: 2,
  	LINE_STRIP: 3,
  	TRIANGLES: 4,
  	TRIANGLE_STRIP: 5,
  	TRIANGLE_FAN: 6,
  	UNSIGNED_BYTE: 5121,
  	UNSIGNED_SHORT: 5123
  };

  const WEBGL_COMPONENT_TYPES = {
  	5120: Int8Array,
  	5121: Uint8Array,
  	5122: Int16Array,
  	5123: Uint16Array,
  	5125: Uint32Array,
  	5126: Float32Array
  };

  const WEBGL_FILTERS = {
  	9728: NearestFilter,
  	9729: LinearFilter,
  	9984: NearestMipmapNearestFilter,
  	9985: LinearMipmapNearestFilter,
  	9986: NearestMipmapLinearFilter,
  	9987: LinearMipmapLinearFilter
  };

  const WEBGL_WRAPPINGS = {
  	33071: ClampToEdgeWrapping,
  	33648: MirroredRepeatWrapping,
  	10497: RepeatWrapping
  };

  const WEBGL_TYPE_SIZES = {
  	'SCALAR': 1,
  	'VEC2': 2,
  	'VEC3': 3,
  	'VEC4': 4,
  	'MAT2': 4,
  	'MAT3': 9,
  	'MAT4': 16
  };

  const ATTRIBUTES = {
  	POSITION: 'position',
  	NORMAL: 'normal',
  	TANGENT: 'tangent',
  	TEXCOORD_0: 'uv',
  	TEXCOORD_1: 'uv1',
  	TEXCOORD_2: 'uv2',
  	TEXCOORD_3: 'uv3',
  	COLOR_0: 'color',
  	WEIGHTS_0: 'skinWeight',
  	JOINTS_0: 'skinIndex',
  };

  const PATH_PROPERTIES = {
  	scale: 'scale',
  	translation: 'position',
  	rotation: 'quaternion',
  	weights: 'morphTargetInfluences'
  };

  const INTERPOLATION = {
  	CUBICSPLINE: undefined, // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
  		                        // keyframe track will be initialized with a default interpolation type, then modified.
  	LINEAR: InterpolateLinear,
  	STEP: InterpolateDiscrete
  };

  const ALPHA_MODES = {
  	OPAQUE: 'OPAQUE',
  	MASK: 'MASK',
  	BLEND: 'BLEND'
  };

  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material
   */
  function createDefaultMaterial( cache ) {

  	if ( cache[ 'DefaultMaterial' ] === undefined ) {

  		cache[ 'DefaultMaterial' ] = new MeshStandardMaterial( {
  			color: 0xFFFFFF,
  			emissive: 0x000000,
  			metalness: 1,
  			roughness: 1,
  			transparent: false,
  			depthTest: true,
  			side: FrontSide
  		} );

  	}

  	return cache[ 'DefaultMaterial' ];

  }

  function addUnknownExtensionsToUserData( knownExtensions, object, objectDef ) {

  	// Add unknown glTF extensions to an object's userData.

  	for ( const name in objectDef.extensions ) {

  		if ( knownExtensions[ name ] === undefined ) {

  			object.userData.gltfExtensions = object.userData.gltfExtensions || {};
  			object.userData.gltfExtensions[ name ] = objectDef.extensions[ name ];

  		}

  	}

  }

  /**
   * @param {Object3D|Material|BufferGeometry} object
   * @param {GLTF.definition} gltfDef
   */
  function assignExtrasToUserData( object, gltfDef ) {

  	if ( gltfDef.extras !== undefined ) {

  		if ( typeof gltfDef.extras === 'object' ) {

  			Object.assign( object.userData, gltfDef.extras );

  		} else {

  			console.warn( 'THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras );

  		}

  	}

  }

  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets
   *
   * @param {BufferGeometry} geometry
   * @param {Array<GLTF.Target>} targets
   * @param {GLTFParser} parser
   * @return {Promise<BufferGeometry>}
   */
  function addMorphTargets( geometry, targets, parser ) {

  	let hasMorphPosition = false;
  	let hasMorphNormal = false;
  	let hasMorphColor = false;

  	for ( let i = 0, il = targets.length; i < il; i ++ ) {

  		const target = targets[ i ];

  		if ( target.POSITION !== undefined ) hasMorphPosition = true;
  		if ( target.NORMAL !== undefined ) hasMorphNormal = true;
  		if ( target.COLOR_0 !== undefined ) hasMorphColor = true;

  		if ( hasMorphPosition && hasMorphNormal && hasMorphColor ) break;

  	}

  	if ( ! hasMorphPosition && ! hasMorphNormal && ! hasMorphColor ) return Promise.resolve( geometry );

  	const pendingPositionAccessors = [];
  	const pendingNormalAccessors = [];
  	const pendingColorAccessors = [];

  	for ( let i = 0, il = targets.length; i < il; i ++ ) {

  		const target = targets[ i ];

  		if ( hasMorphPosition ) {

  			const pendingAccessor = target.POSITION !== undefined
  				? parser.getDependency( 'accessor', target.POSITION )
  				: geometry.attributes.position;

  			pendingPositionAccessors.push( pendingAccessor );

  		}

  		if ( hasMorphNormal ) {

  			const pendingAccessor = target.NORMAL !== undefined
  				? parser.getDependency( 'accessor', target.NORMAL )
  				: geometry.attributes.normal;

  			pendingNormalAccessors.push( pendingAccessor );

  		}

  		if ( hasMorphColor ) {

  			const pendingAccessor = target.COLOR_0 !== undefined
  				? parser.getDependency( 'accessor', target.COLOR_0 )
  				: geometry.attributes.color;

  			pendingColorAccessors.push( pendingAccessor );

  		}

  	}

  	return Promise.all( [
  		Promise.all( pendingPositionAccessors ),
  		Promise.all( pendingNormalAccessors ),
  		Promise.all( pendingColorAccessors )
  	] ).then( function ( accessors ) {

  		const morphPositions = accessors[ 0 ];
  		const morphNormals = accessors[ 1 ];
  		const morphColors = accessors[ 2 ];

  		if ( hasMorphPosition ) geometry.morphAttributes.position = morphPositions;
  		if ( hasMorphNormal ) geometry.morphAttributes.normal = morphNormals;
  		if ( hasMorphColor ) geometry.morphAttributes.color = morphColors;
  		geometry.morphTargetsRelative = true;

  		return geometry;

  	} );

  }

  /**
   * @param {Mesh} mesh
   * @param {GLTF.Mesh} meshDef
   */
  function updateMorphTargets( mesh, meshDef ) {

  	mesh.updateMorphTargets();

  	if ( meshDef.weights !== undefined ) {

  		for ( let i = 0, il = meshDef.weights.length; i < il; i ++ ) {

  			mesh.morphTargetInfluences[ i ] = meshDef.weights[ i ];

  		}

  	}

  	// .extras has user-defined data, so check that .extras.targetNames is an array.
  	if ( meshDef.extras && Array.isArray( meshDef.extras.targetNames ) ) {

  		const targetNames = meshDef.extras.targetNames;

  		if ( mesh.morphTargetInfluences.length === targetNames.length ) {

  			mesh.morphTargetDictionary = {};

  			for ( let i = 0, il = targetNames.length; i < il; i ++ ) {

  				mesh.morphTargetDictionary[ targetNames[ i ] ] = i;

  			}

  		} else {

  			console.warn( 'THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.' );

  		}

  	}

  }

  function createPrimitiveKey( primitiveDef ) {

  	let geometryKey;

  	const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ];

  	if ( dracoExtension ) {

  		geometryKey = 'draco:' + dracoExtension.bufferView
  				+ ':' + dracoExtension.indices
  				+ ':' + createAttributesKey( dracoExtension.attributes );

  	} else {

  		geometryKey = primitiveDef.indices + ':' + createAttributesKey( primitiveDef.attributes ) + ':' + primitiveDef.mode;

  	}

  	if ( primitiveDef.targets !== undefined ) {

  		for ( let i = 0, il = primitiveDef.targets.length; i < il; i ++ ) {

  			geometryKey += ':' + createAttributesKey( primitiveDef.targets[ i ] );

  		}

  	}

  	return geometryKey;

  }

  function createAttributesKey( attributes ) {

  	let attributesKey = '';

  	const keys = Object.keys( attributes ).sort();

  	for ( let i = 0, il = keys.length; i < il; i ++ ) {

  		attributesKey += keys[ i ] + ':' + attributes[ keys[ i ] ] + ';';

  	}

  	return attributesKey;

  }

  function getNormalizedComponentScale( constructor ) {

  	// Reference:
  	// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization#encoding-quantized-data

  	switch ( constructor ) {

  		case Int8Array:
  			return 1 / 127;

  		case Uint8Array:
  			return 1 / 255;

  		case Int16Array:
  			return 1 / 32767;

  		case Uint16Array:
  			return 1 / 65535;

  		default:
  			throw new Error( 'THREE.GLTFLoader: Unsupported normalized accessor component type.' );

  	}

  }

  function getImageURIMimeType( uri ) {

  	if ( uri.search( /\.jpe?g($|\?)/i ) > 0 || uri.search( /^data\:image\/jpeg/ ) === 0 ) return 'image/jpeg';
  	if ( uri.search( /\.webp($|\?)/i ) > 0 || uri.search( /^data\:image\/webp/ ) === 0 ) return 'image/webp';

  	return 'image/png';

  }

  const _identityMatrix = new Matrix4();

  /* GLTF PARSER */

  class GLTFParser {

  	constructor( json = {}, options = {} ) {

  		this.json = json;
  		this.extensions = {};
  		this.plugins = {};
  		this.options = options;

  		// loader object cache
  		this.cache = new GLTFRegistry();

  		// associations between Three.js objects and glTF elements
  		this.associations = new Map();

  		// BufferGeometry caching
  		this.primitiveCache = {};

  		// Node cache
  		this.nodeCache = {};

  		// Object3D instance caches
  		this.meshCache = { refs: {}, uses: {} };
  		this.cameraCache = { refs: {}, uses: {} };
  		this.lightCache = { refs: {}, uses: {} };

  		this.sourceCache = {};
  		this.textureCache = {};

  		// Track node names, to ensure no duplicates
  		this.nodeNamesUsed = {};

  		// Use an ImageBitmapLoader if imageBitmaps are supported. Moves much of the
  		// expensive work of uploading a texture to the GPU off the main thread.

  		let isSafari = false;
  		let safariVersion = - 1;
  		let isFirefox = false;
  		let firefoxVersion = - 1;

  		if ( typeof navigator !== 'undefined' ) {

  			const userAgent = navigator.userAgent;

  			isSafari = /^((?!chrome|android).)*safari/i.test( userAgent ) === true;
  			const safariMatch = userAgent.match( /Version\/(\d+)/ );
  			safariVersion = isSafari && safariMatch ? parseInt( safariMatch[ 1 ], 10 ) : - 1;

  			isFirefox = userAgent.indexOf( 'Firefox' ) > - 1;
  			firefoxVersion = isFirefox ? userAgent.match( /Firefox\/([0-9]+)\./ )[ 1 ] : - 1;

  		}

  		if ( typeof createImageBitmap === 'undefined' || ( isSafari && safariVersion < 17 ) || ( isFirefox && firefoxVersion < 98 ) ) {

  			this.textureLoader = new TextureLoader( this.options.manager );

  		} else {

  			this.textureLoader = new ImageBitmapLoader( this.options.manager );

  		}

  		this.textureLoader.setCrossOrigin( this.options.crossOrigin );
  		this.textureLoader.setRequestHeader( this.options.requestHeader );

  		this.fileLoader = new FileLoader( this.options.manager );
  		this.fileLoader.setResponseType( 'arraybuffer' );

  		if ( this.options.crossOrigin === 'use-credentials' ) {

  			this.fileLoader.setWithCredentials( true );

  		}

  	}

  	setExtensions( extensions ) {

  		this.extensions = extensions;

  	}

  	setPlugins( plugins ) {

  		this.plugins = plugins;

  	}

  	parse( onLoad, onError ) {

  		const parser = this;
  		const json = this.json;
  		const extensions = this.extensions;

  		// Clear the loader cache
  		this.cache.removeAll();
  		this.nodeCache = {};

  		// Mark the special nodes/meshes in json for efficient parse
  		this._invokeAll( function ( ext ) {

  			return ext._markDefs && ext._markDefs();

  		} );

  		Promise.all( this._invokeAll( function ( ext ) {

  			return ext.beforeRoot && ext.beforeRoot();

  		} ) ).then( function () {

  			return Promise.all( [

  				parser.getDependencies( 'scene' ),
  				parser.getDependencies( 'animation' ),
  				parser.getDependencies( 'camera' ),

  			] );

  		} ).then( function ( dependencies ) {

  			const result = {
  				scene: dependencies[ 0 ][ json.scene || 0 ],
  				scenes: dependencies[ 0 ],
  				animations: dependencies[ 1 ],
  				cameras: dependencies[ 2 ],
  				asset: json.asset,
  				parser: parser,
  				userData: {}
  			};

  			addUnknownExtensionsToUserData( extensions, result, json );

  			assignExtrasToUserData( result, json );

  			return Promise.all( parser._invokeAll( function ( ext ) {

  				return ext.afterRoot && ext.afterRoot( result );

  			} ) ).then( function () {

  				for ( const scene of result.scenes ) {

  					scene.updateMatrixWorld();

  				}

  				onLoad( result );

  			} );

  		} ).catch( onError );

  	}

  	/**
  	 * Marks the special nodes/meshes in json for efficient parse.
  	 */
  	_markDefs() {

  		const nodeDefs = this.json.nodes || [];
  		const skinDefs = this.json.skins || [];
  		const meshDefs = this.json.meshes || [];

  		// Nothing in the node definition indicates whether it is a Bone or an
  		// Object3D. Use the skins' joint references to mark bones.
  		for ( let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex ++ ) {

  			const joints = skinDefs[ skinIndex ].joints;

  			for ( let i = 0, il = joints.length; i < il; i ++ ) {

  				nodeDefs[ joints[ i ] ].isBone = true;

  			}

  		}

  		// Iterate over all nodes, marking references to shared resources,
  		// as well as skeleton joints.
  		for ( let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {

  			const nodeDef = nodeDefs[ nodeIndex ];

  			if ( nodeDef.mesh !== undefined ) {

  				this._addNodeRef( this.meshCache, nodeDef.mesh );

  				// Nothing in the mesh definition indicates whether it is
  				// a SkinnedMesh or Mesh. Use the node's mesh reference
  				// to mark SkinnedMesh if node has skin.
  				if ( nodeDef.skin !== undefined ) {

  					meshDefs[ nodeDef.mesh ].isSkinnedMesh = true;

  				}

  			}

  			if ( nodeDef.camera !== undefined ) {

  				this._addNodeRef( this.cameraCache, nodeDef.camera );

  			}

  		}

  	}

  	/**
  	 * Counts references to shared node / Object3D resources. These resources
  	 * can be reused, or "instantiated", at multiple nodes in the scene
  	 * hierarchy. Mesh, Camera, and Light instances are instantiated and must
  	 * be marked. Non-scenegraph resources (like Materials, Geometries, and
  	 * Textures) can be reused directly and are not marked here.
  	 *
  	 * Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
  	 */
  	_addNodeRef( cache, index ) {

  		if ( index === undefined ) return;

  		if ( cache.refs[ index ] === undefined ) {

  			cache.refs[ index ] = cache.uses[ index ] = 0;

  		}

  		cache.refs[ index ] ++;

  	}

  	/** Returns a reference to a shared resource, cloning it if necessary. */
  	_getNodeRef( cache, index, object ) {

  		if ( cache.refs[ index ] <= 1 ) return object;

  		const ref = object.clone();

  		// Propagates mappings to the cloned object, prevents mappings on the
  		// original object from being lost.
  		const updateMappings = ( original, clone ) => {

  			const mappings = this.associations.get( original );
  			if ( mappings != null ) {

  				this.associations.set( clone, mappings );

  			}

  			for ( const [ i, child ] of original.children.entries() ) {

  				updateMappings( child, clone.children[ i ] );

  			}

  		};

  		updateMappings( object, ref );

  		ref.name += '_instance_' + ( cache.uses[ index ] ++ );

  		return ref;

  	}

  	_invokeOne( func ) {

  		const extensions = Object.values( this.plugins );
  		extensions.push( this );

  		for ( let i = 0; i < extensions.length; i ++ ) {

  			const result = func( extensions[ i ] );

  			if ( result ) return result;

  		}

  		return null;

  	}

  	_invokeAll( func ) {

  		const extensions = Object.values( this.plugins );
  		extensions.unshift( this );

  		const pending = [];

  		for ( let i = 0; i < extensions.length; i ++ ) {

  			const result = func( extensions[ i ] );

  			if ( result ) pending.push( result );

  		}

  		return pending;

  	}

  	/**
  	 * Requests the specified dependency asynchronously, with caching.
  	 * @param {string} type
  	 * @param {number} index
  	 * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}
  	 */
  	getDependency( type, index ) {

  		const cacheKey = type + ':' + index;
  		let dependency = this.cache.get( cacheKey );

  		if ( ! dependency ) {

  			switch ( type ) {

  				case 'scene':
  					dependency = this.loadScene( index );
  					break;

  				case 'node':
  					dependency = this._invokeOne( function ( ext ) {

  						return ext.loadNode && ext.loadNode( index );

  					} );
  					break;

  				case 'mesh':
  					dependency = this._invokeOne( function ( ext ) {

  						return ext.loadMesh && ext.loadMesh( index );

  					} );
  					break;

  				case 'accessor':
  					dependency = this.loadAccessor( index );
  					break;

  				case 'bufferView':
  					dependency = this._invokeOne( function ( ext ) {

  						return ext.loadBufferView && ext.loadBufferView( index );

  					} );
  					break;

  				case 'buffer':
  					dependency = this.loadBuffer( index );
  					break;

  				case 'material':
  					dependency = this._invokeOne( function ( ext ) {

  						return ext.loadMaterial && ext.loadMaterial( index );

  					} );
  					break;

  				case 'texture':
  					dependency = this._invokeOne( function ( ext ) {

  						return ext.loadTexture && ext.loadTexture( index );

  					} );
  					break;

  				case 'skin':
  					dependency = this.loadSkin( index );
  					break;

  				case 'animation':
  					dependency = this._invokeOne( function ( ext ) {

  						return ext.loadAnimation && ext.loadAnimation( index );

  					} );
  					break;

  				case 'camera':
  					dependency = this.loadCamera( index );
  					break;

  				default:
  					dependency = this._invokeOne( function ( ext ) {

  						return ext != this && ext.getDependency && ext.getDependency( type, index );

  					} );

  					if ( ! dependency ) {

  						throw new Error( 'Unknown type: ' + type );

  					}

  					break;

  			}

  			this.cache.add( cacheKey, dependency );

  		}

  		return dependency;

  	}

  	/**
  	 * Requests all dependencies of the specified type asynchronously, with caching.
  	 * @param {string} type
  	 * @return {Promise<Array<Object>>}
  	 */
  	getDependencies( type ) {

  		let dependencies = this.cache.get( type );

  		if ( ! dependencies ) {

  			const parser = this;
  			const defs = this.json[ type + ( type === 'mesh' ? 'es' : 's' ) ] || [];

  			dependencies = Promise.all( defs.map( function ( def, index ) {

  				return parser.getDependency( type, index );

  			} ) );

  			this.cache.add( type, dependencies );

  		}

  		return dependencies;

  	}

  	/**
  	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
  	 * @param {number} bufferIndex
  	 * @return {Promise<ArrayBuffer>}
  	 */
  	loadBuffer( bufferIndex ) {

  		const bufferDef = this.json.buffers[ bufferIndex ];
  		const loader = this.fileLoader;

  		if ( bufferDef.type && bufferDef.type !== 'arraybuffer' ) {

  			throw new Error( 'THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.' );

  		}

  		// If present, GLB container is required to be the first buffer.
  		if ( bufferDef.uri === undefined && bufferIndex === 0 ) {

  			return Promise.resolve( this.extensions[ EXTENSIONS.KHR_BINARY_GLTF ].body );

  		}

  		const options = this.options;

  		return new Promise( function ( resolve, reject ) {

  			loader.load( LoaderUtils.resolveURL( bufferDef.uri, options.path ), resolve, undefined, function () {

  				reject( new Error( 'THREE.GLTFLoader: Failed to load buffer "' + bufferDef.uri + '".' ) );

  			} );

  		} );

  	}

  	/**
  	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
  	 * @param {number} bufferViewIndex
  	 * @return {Promise<ArrayBuffer>}
  	 */
  	loadBufferView( bufferViewIndex ) {

  		const bufferViewDef = this.json.bufferViews[ bufferViewIndex ];

  		return this.getDependency( 'buffer', bufferViewDef.buffer ).then( function ( buffer ) {

  			const byteLength = bufferViewDef.byteLength || 0;
  			const byteOffset = bufferViewDef.byteOffset || 0;
  			return buffer.slice( byteOffset, byteOffset + byteLength );

  		} );

  	}

  	/**
  	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
  	 * @param {number} accessorIndex
  	 * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
  	 */
  	loadAccessor( accessorIndex ) {

  		const parser = this;
  		const json = this.json;

  		const accessorDef = this.json.accessors[ accessorIndex ];

  		if ( accessorDef.bufferView === undefined && accessorDef.sparse === undefined ) {

  			const itemSize = WEBGL_TYPE_SIZES[ accessorDef.type ];
  			const TypedArray = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];
  			const normalized = accessorDef.normalized === true;

  			const array = new TypedArray( accessorDef.count * itemSize );
  			return Promise.resolve( new BufferAttribute( array, itemSize, normalized ) );

  		}

  		const pendingBufferViews = [];

  		if ( accessorDef.bufferView !== undefined ) {

  			pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.bufferView ) );

  		} else {

  			pendingBufferViews.push( null );

  		}

  		if ( accessorDef.sparse !== undefined ) {

  			pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.indices.bufferView ) );
  			pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.values.bufferView ) );

  		}

  		return Promise.all( pendingBufferViews ).then( function ( bufferViews ) {

  			const bufferView = bufferViews[ 0 ];

  			const itemSize = WEBGL_TYPE_SIZES[ accessorDef.type ];
  			const TypedArray = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];

  			// For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.
  			const elementBytes = TypedArray.BYTES_PER_ELEMENT;
  			const itemBytes = elementBytes * itemSize;
  			const byteOffset = accessorDef.byteOffset || 0;
  			const byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[ accessorDef.bufferView ].byteStride : undefined;
  			const normalized = accessorDef.normalized === true;
  			let array, bufferAttribute;

  			// The buffer is not interleaved if the stride is the item size in bytes.
  			if ( byteStride && byteStride !== itemBytes ) {

  				// Each "slice" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer
  				// This makes sure that IBA.count reflects accessor.count properly
  				const ibSlice = Math.floor( byteOffset / byteStride );
  				const ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType + ':' + ibSlice + ':' + accessorDef.count;
  				let ib = parser.cache.get( ibCacheKey );

  				if ( ! ib ) {

  					array = new TypedArray( bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes );

  					// Integer parameters to IB/IBA are in array elements, not bytes.
  					ib = new InterleavedBuffer( array, byteStride / elementBytes );

  					parser.cache.add( ibCacheKey, ib );

  				}

  				bufferAttribute = new InterleavedBufferAttribute( ib, itemSize, ( byteOffset % byteStride ) / elementBytes, normalized );

  			} else {

  				if ( bufferView === null ) {

  					array = new TypedArray( accessorDef.count * itemSize );

  				} else {

  					array = new TypedArray( bufferView, byteOffset, accessorDef.count * itemSize );

  				}

  				bufferAttribute = new BufferAttribute( array, itemSize, normalized );

  			}

  			// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors
  			if ( accessorDef.sparse !== undefined ) {

  				const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;
  				const TypedArrayIndices = WEBGL_COMPONENT_TYPES[ accessorDef.sparse.indices.componentType ];

  				const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;
  				const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;

  				const sparseIndices = new TypedArrayIndices( bufferViews[ 1 ], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices );
  				const sparseValues = new TypedArray( bufferViews[ 2 ], byteOffsetValues, accessorDef.sparse.count * itemSize );

  				if ( bufferView !== null ) {

  					// Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.
  					bufferAttribute = new BufferAttribute( bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized );

  				}

  				for ( let i = 0, il = sparseIndices.length; i < il; i ++ ) {

  					const index = sparseIndices[ i ];

  					bufferAttribute.setX( index, sparseValues[ i * itemSize ] );
  					if ( itemSize >= 2 ) bufferAttribute.setY( index, sparseValues[ i * itemSize + 1 ] );
  					if ( itemSize >= 3 ) bufferAttribute.setZ( index, sparseValues[ i * itemSize + 2 ] );
  					if ( itemSize >= 4 ) bufferAttribute.setW( index, sparseValues[ i * itemSize + 3 ] );
  					if ( itemSize >= 5 ) throw new Error( 'THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.' );

  				}

  			}

  			return bufferAttribute;

  		} );

  	}

  	/**
  	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
  	 * @param {number} textureIndex
  	 * @return {Promise<THREE.Texture|null>}
  	 */
  	loadTexture( textureIndex ) {

  		const json = this.json;
  		const options = this.options;
  		const textureDef = json.textures[ textureIndex ];
  		const sourceIndex = textureDef.source;
  		const sourceDef = json.images[ sourceIndex ];

  		let loader = this.textureLoader;

  		if ( sourceDef.uri ) {

  			const handler = options.manager.getHandler( sourceDef.uri );
  			if ( handler !== null ) loader = handler;

  		}

  		return this.loadTextureImage( textureIndex, sourceIndex, loader );

  	}

  	loadTextureImage( textureIndex, sourceIndex, loader ) {

  		const parser = this;
  		const json = this.json;

  		const textureDef = json.textures[ textureIndex ];
  		const sourceDef = json.images[ sourceIndex ];

  		const cacheKey = ( sourceDef.uri || sourceDef.bufferView ) + ':' + textureDef.sampler;

  		if ( this.textureCache[ cacheKey ] ) {

  			// See https://github.com/mrdoob/three.js/issues/21559.
  			return this.textureCache[ cacheKey ];

  		}

  		const promise = this.loadImageSource( sourceIndex, loader ).then( function ( texture ) {

  			texture.flipY = false;

  			texture.name = textureDef.name || sourceDef.name || '';

  			if ( texture.name === '' && typeof sourceDef.uri === 'string' && sourceDef.uri.startsWith( 'data:image/' ) === false ) {

  				texture.name = sourceDef.uri;

  			}

  			const samplers = json.samplers || {};
  			const sampler = samplers[ textureDef.sampler ] || {};

  			texture.magFilter = WEBGL_FILTERS[ sampler.magFilter ] || LinearFilter;
  			texture.minFilter = WEBGL_FILTERS[ sampler.minFilter ] || LinearMipmapLinearFilter;
  			texture.wrapS = WEBGL_WRAPPINGS[ sampler.wrapS ] || RepeatWrapping;
  			texture.wrapT = WEBGL_WRAPPINGS[ sampler.wrapT ] || RepeatWrapping;

  			parser.associations.set( texture, { textures: textureIndex } );

  			return texture;

  		} ).catch( function () {

  			return null;

  		} );

  		this.textureCache[ cacheKey ] = promise;

  		return promise;

  	}

  	loadImageSource( sourceIndex, loader ) {

  		const parser = this;
  		const json = this.json;
  		const options = this.options;

  		if ( this.sourceCache[ sourceIndex ] !== undefined ) {

  			return this.sourceCache[ sourceIndex ].then( ( texture ) => texture.clone() );

  		}

  		const sourceDef = json.images[ sourceIndex ];

  		const URL = self.URL || self.webkitURL;

  		let sourceURI = sourceDef.uri || '';
  		let isObjectURL = false;

  		if ( sourceDef.bufferView !== undefined ) {

  			// Load binary image data from bufferView, if provided.

  			sourceURI = parser.getDependency( 'bufferView', sourceDef.bufferView ).then( function ( bufferView ) {

  				isObjectURL = true;
  				const blob = new Blob( [ bufferView ], { type: sourceDef.mimeType } );
  				sourceURI = URL.createObjectURL( blob );
  				return sourceURI;

  			} );

  		} else if ( sourceDef.uri === undefined ) {

  			throw new Error( 'THREE.GLTFLoader: Image ' + sourceIndex + ' is missing URI and bufferView' );

  		}

  		const promise = Promise.resolve( sourceURI ).then( function ( sourceURI ) {

  			return new Promise( function ( resolve, reject ) {

  				let onLoad = resolve;

  				if ( loader.isImageBitmapLoader === true ) {

  					onLoad = function ( imageBitmap ) {

  						const texture = new Texture( imageBitmap );
  						texture.needsUpdate = true;

  						resolve( texture );

  					};

  				}

  				loader.load( LoaderUtils.resolveURL( sourceURI, options.path ), onLoad, undefined, reject );

  			} );

  		} ).then( function ( texture ) {

  			// Clean up resources and configure Texture.

  			if ( isObjectURL === true ) {

  				URL.revokeObjectURL( sourceURI );

  			}

  			assignExtrasToUserData( texture, sourceDef );

  			texture.userData.mimeType = sourceDef.mimeType || getImageURIMimeType( sourceDef.uri );

  			return texture;

  		} ).catch( function ( error ) {

  			console.error( 'THREE.GLTFLoader: Couldn\'t load texture', sourceURI );
  			throw error;

  		} );

  		this.sourceCache[ sourceIndex ] = promise;
  		return promise;

  	}

  	/**
  	 * Asynchronously assigns a texture to the given material parameters.
  	 * @param {Object} materialParams
  	 * @param {string} mapName
  	 * @param {Object} mapDef
  	 * @return {Promise<Texture>}
  	 */
  	assignTexture( materialParams, mapName, mapDef, colorSpace ) {

  		const parser = this;

  		return this.getDependency( 'texture', mapDef.index ).then( function ( texture ) {

  			if ( ! texture ) return null;

  			if ( mapDef.texCoord !== undefined && mapDef.texCoord > 0 ) {

  				texture = texture.clone();
  				texture.channel = mapDef.texCoord;

  			}

  			if ( parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] ) {

  				const transform = mapDef.extensions !== undefined ? mapDef.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] : undefined;

  				if ( transform ) {

  					const gltfReference = parser.associations.get( texture );
  					texture = parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ].extendTexture( texture, transform );
  					parser.associations.set( texture, gltfReference );

  				}

  			}

  			if ( colorSpace !== undefined ) {

  				texture.colorSpace = colorSpace;

  			}

  			materialParams[ mapName ] = texture;

  			return texture;

  		} );

  	}

  	/**
  	 * Assigns final material to a Mesh, Line, or Points instance. The instance
  	 * already has a material (generated from the glTF material options alone)
  	 * but reuse of the same glTF material may require multiple threejs materials
  	 * to accommodate different primitive types, defines, etc. New materials will
  	 * be created if necessary, and reused from a cache.
  	 * @param  {Object3D} mesh Mesh, Line, or Points instance.
  	 */
  	assignFinalMaterial( mesh ) {

  		const geometry = mesh.geometry;
  		let material = mesh.material;

  		const useDerivativeTangents = geometry.attributes.tangent === undefined;
  		const useVertexColors = geometry.attributes.color !== undefined;
  		const useFlatShading = geometry.attributes.normal === undefined;

  		if ( mesh.isPoints ) {

  			const cacheKey = 'PointsMaterial:' + material.uuid;

  			let pointsMaterial = this.cache.get( cacheKey );

  			if ( ! pointsMaterial ) {

  				pointsMaterial = new PointsMaterial();
  				Material.prototype.copy.call( pointsMaterial, material );
  				pointsMaterial.color.copy( material.color );
  				pointsMaterial.map = material.map;
  				pointsMaterial.sizeAttenuation = false; // glTF spec says points should be 1px

  				this.cache.add( cacheKey, pointsMaterial );

  			}

  			material = pointsMaterial;

  		} else if ( mesh.isLine ) {

  			const cacheKey = 'LineBasicMaterial:' + material.uuid;

  			let lineMaterial = this.cache.get( cacheKey );

  			if ( ! lineMaterial ) {

  				lineMaterial = new LineBasicMaterial();
  				Material.prototype.copy.call( lineMaterial, material );
  				lineMaterial.color.copy( material.color );
  				lineMaterial.map = material.map;

  				this.cache.add( cacheKey, lineMaterial );

  			}

  			material = lineMaterial;

  		}

  		// Clone the material if it will be modified
  		if ( useDerivativeTangents || useVertexColors || useFlatShading ) {

  			let cacheKey = 'ClonedMaterial:' + material.uuid + ':';

  			if ( useDerivativeTangents ) cacheKey += 'derivative-tangents:';
  			if ( useVertexColors ) cacheKey += 'vertex-colors:';
  			if ( useFlatShading ) cacheKey += 'flat-shading:';

  			let cachedMaterial = this.cache.get( cacheKey );

  			if ( ! cachedMaterial ) {

  				cachedMaterial = material.clone();

  				if ( useVertexColors ) cachedMaterial.vertexColors = true;
  				if ( useFlatShading ) cachedMaterial.flatShading = true;

  				if ( useDerivativeTangents ) {

  					// https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995
  					if ( cachedMaterial.normalScale ) cachedMaterial.normalScale.y *= - 1;
  					if ( cachedMaterial.clearcoatNormalScale ) cachedMaterial.clearcoatNormalScale.y *= - 1;

  				}

  				this.cache.add( cacheKey, cachedMaterial );

  				this.associations.set( cachedMaterial, this.associations.get( material ) );

  			}

  			material = cachedMaterial;

  		}

  		mesh.material = material;

  	}

  	getMaterialType( /* materialIndex */ ) {

  		return MeshStandardMaterial;

  	}

  	/**
  	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
  	 * @param {number} materialIndex
  	 * @return {Promise<Material>}
  	 */
  	loadMaterial( materialIndex ) {

  		const parser = this;
  		const json = this.json;
  		const extensions = this.extensions;
  		const materialDef = json.materials[ materialIndex ];

  		let materialType;
  		const materialParams = {};
  		const materialExtensions = materialDef.extensions || {};

  		const pending = [];

  		if ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ] ) {

  			const kmuExtension = extensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ];
  			materialType = kmuExtension.getMaterialType();
  			pending.push( kmuExtension.extendParams( materialParams, materialDef, parser ) );

  		} else {

  			// Specification:
  			// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material

  			const metallicRoughness = materialDef.pbrMetallicRoughness || {};

  			materialParams.color = new Color( 1.0, 1.0, 1.0 );
  			materialParams.opacity = 1.0;

  			if ( Array.isArray( metallicRoughness.baseColorFactor ) ) {

  				const array = metallicRoughness.baseColorFactor;

  				materialParams.color.setRGB( array[ 0 ], array[ 1 ], array[ 2 ], LinearSRGBColorSpace );
  				materialParams.opacity = array[ 3 ];

  			}

  			if ( metallicRoughness.baseColorTexture !== undefined ) {

  				pending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture, SRGBColorSpace ) );

  			}

  			materialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;
  			materialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;

  			if ( metallicRoughness.metallicRoughnessTexture !== undefined ) {

  				pending.push( parser.assignTexture( materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture ) );
  				pending.push( parser.assignTexture( materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture ) );

  			}

  			materialType = this._invokeOne( function ( ext ) {

  				return ext.getMaterialType && ext.getMaterialType( materialIndex );

  			} );

  			pending.push( Promise.all( this._invokeAll( function ( ext ) {

  				return ext.extendMaterialParams && ext.extendMaterialParams( materialIndex, materialParams );

  			} ) ) );

  		}

  		if ( materialDef.doubleSided === true ) {

  			materialParams.side = DoubleSide;

  		}

  		const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;

  		if ( alphaMode === ALPHA_MODES.BLEND ) {

  			materialParams.transparent = true;

  			// See: https://github.com/mrdoob/three.js/issues/17706
  			materialParams.depthWrite = false;

  		} else {

  			materialParams.transparent = false;

  			if ( alphaMode === ALPHA_MODES.MASK ) {

  				materialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;

  			}

  		}

  		if ( materialDef.normalTexture !== undefined && materialType !== MeshBasicMaterial ) {

  			pending.push( parser.assignTexture( materialParams, 'normalMap', materialDef.normalTexture ) );

  			materialParams.normalScale = new Vector2( 1, 1 );

  			if ( materialDef.normalTexture.scale !== undefined ) {

  				const scale = materialDef.normalTexture.scale;

  				materialParams.normalScale.set( scale, scale );

  			}

  		}

  		if ( materialDef.occlusionTexture !== undefined && materialType !== MeshBasicMaterial ) {

  			pending.push( parser.assignTexture( materialParams, 'aoMap', materialDef.occlusionTexture ) );

  			if ( materialDef.occlusionTexture.strength !== undefined ) {

  				materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;

  			}

  		}

  		if ( materialDef.emissiveFactor !== undefined && materialType !== MeshBasicMaterial ) {

  			const emissiveFactor = materialDef.emissiveFactor;
  			materialParams.emissive = new Color().setRGB( emissiveFactor[ 0 ], emissiveFactor[ 1 ], emissiveFactor[ 2 ], LinearSRGBColorSpace );

  		}

  		if ( materialDef.emissiveTexture !== undefined && materialType !== MeshBasicMaterial ) {

  			pending.push( parser.assignTexture( materialParams, 'emissiveMap', materialDef.emissiveTexture, SRGBColorSpace ) );

  		}

  		return Promise.all( pending ).then( function () {

  			const material = new materialType( materialParams );

  			if ( materialDef.name ) material.name = materialDef.name;

  			assignExtrasToUserData( material, materialDef );

  			parser.associations.set( material, { materials: materialIndex } );

  			if ( materialDef.extensions ) addUnknownExtensionsToUserData( extensions, material, materialDef );

  			return material;

  		} );

  	}

  	/** When Object3D instances are targeted by animation, they need unique names. */
  	createUniqueName( originalName ) {

  		const sanitizedName = PropertyBinding.sanitizeNodeName( originalName || '' );

  		if ( sanitizedName in this.nodeNamesUsed ) {

  			return sanitizedName + '_' + ( ++ this.nodeNamesUsed[ sanitizedName ] );

  		} else {

  			this.nodeNamesUsed[ sanitizedName ] = 0;

  			return sanitizedName;

  		}

  	}

  	/**
  	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
  	 *
  	 * Creates BufferGeometries from primitives.
  	 *
  	 * @param {Array<GLTF.Primitive>} primitives
  	 * @return {Promise<Array<BufferGeometry>>}
  	 */
  	loadGeometries( primitives ) {

  		const parser = this;
  		const extensions = this.extensions;
  		const cache = this.primitiveCache;

  		function createDracoPrimitive( primitive ) {

  			return extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ]
  				.decodePrimitive( primitive, parser )
  				.then( function ( geometry ) {

  					return addPrimitiveAttributes( geometry, primitive, parser );

  				} );

  		}

  		const pending = [];

  		for ( let i = 0, il = primitives.length; i < il; i ++ ) {

  			const primitive = primitives[ i ];
  			const cacheKey = createPrimitiveKey( primitive );

  			// See if we've already created this geometry
  			const cached = cache[ cacheKey ];

  			if ( cached ) {

  				// Use the cached geometry if it exists
  				pending.push( cached.promise );

  			} else {

  				let geometryPromise;

  				if ( primitive.extensions && primitive.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ] ) {

  					// Use DRACO geometry if available
  					geometryPromise = createDracoPrimitive( primitive );

  				} else {

  					// Otherwise create a new geometry
  					geometryPromise = addPrimitiveAttributes( new BufferGeometry(), primitive, parser );

  				}

  				// Cache this geometry
  				cache[ cacheKey ] = { primitive: primitive, promise: geometryPromise };

  				pending.push( geometryPromise );

  			}

  		}

  		return Promise.all( pending );

  	}

  	/**
  	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
  	 * @param {number} meshIndex
  	 * @return {Promise<Group|Mesh|SkinnedMesh>}
  	 */
  	loadMesh( meshIndex ) {

  		const parser = this;
  		const json = this.json;
  		const extensions = this.extensions;

  		const meshDef = json.meshes[ meshIndex ];
  		const primitives = meshDef.primitives;

  		const pending = [];

  		for ( let i = 0, il = primitives.length; i < il; i ++ ) {

  			const material = primitives[ i ].material === undefined
  				? createDefaultMaterial( this.cache )
  				: this.getDependency( 'material', primitives[ i ].material );

  			pending.push( material );

  		}

  		pending.push( parser.loadGeometries( primitives ) );

  		return Promise.all( pending ).then( function ( results ) {

  			const materials = results.slice( 0, results.length - 1 );
  			const geometries = results[ results.length - 1 ];

  			const meshes = [];

  			for ( let i = 0, il = geometries.length; i < il; i ++ ) {

  				const geometry = geometries[ i ];
  				const primitive = primitives[ i ];

  				// 1. create Mesh

  				let mesh;

  				const material = materials[ i ];

  				if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLES ||
  						primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ||
  						primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ||
  						primitive.mode === undefined ) {

  					// .isSkinnedMesh isn't in glTF spec. See ._markDefs()
  					mesh = meshDef.isSkinnedMesh === true
  						? new SkinnedMesh( geometry, material )
  						: new Mesh( geometry, material );

  					if ( mesh.isSkinnedMesh === true ) {

  						// normalize skin weights to fix malformed assets (see #15319)
  						mesh.normalizeSkinWeights();

  					}

  					if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ) {

  						mesh.geometry = toTrianglesDrawMode( mesh.geometry, TriangleStripDrawMode );

  					} else if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ) {

  						mesh.geometry = toTrianglesDrawMode( mesh.geometry, TriangleFanDrawMode );

  					}

  				} else if ( primitive.mode === WEBGL_CONSTANTS.LINES ) {

  					mesh = new LineSegments( geometry, material );

  				} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_STRIP ) {

  					mesh = new Line( geometry, material );

  				} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_LOOP ) {

  					mesh = new LineLoop( geometry, material );

  				} else if ( primitive.mode === WEBGL_CONSTANTS.POINTS ) {

  					mesh = new Points( geometry, material );

  				} else {

  					throw new Error( 'THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode );

  				}

  				if ( Object.keys( mesh.geometry.morphAttributes ).length > 0 ) {

  					updateMorphTargets( mesh, meshDef );

  				}

  				mesh.name = parser.createUniqueName( meshDef.name || ( 'mesh_' + meshIndex ) );

  				assignExtrasToUserData( mesh, meshDef );

  				if ( primitive.extensions ) addUnknownExtensionsToUserData( extensions, mesh, primitive );

  				parser.assignFinalMaterial( mesh );

  				meshes.push( mesh );

  			}

  			for ( let i = 0, il = meshes.length; i < il; i ++ ) {

  				parser.associations.set( meshes[ i ], {
  					meshes: meshIndex,
  					primitives: i
  				} );

  			}

  			if ( meshes.length === 1 ) {

  				if ( meshDef.extensions ) addUnknownExtensionsToUserData( extensions, meshes[ 0 ], meshDef );

  				return meshes[ 0 ];

  			}

  			const group = new Group();

  			if ( meshDef.extensions ) addUnknownExtensionsToUserData( extensions, group, meshDef );

  			parser.associations.set( group, { meshes: meshIndex } );

  			for ( let i = 0, il = meshes.length; i < il; i ++ ) {

  				group.add( meshes[ i ] );

  			}

  			return group;

  		} );

  	}

  	/**
  	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
  	 * @param {number} cameraIndex
  	 * @return {Promise<THREE.Camera>}
  	 */
  	loadCamera( cameraIndex ) {

  		let camera;
  		const cameraDef = this.json.cameras[ cameraIndex ];
  		const params = cameraDef[ cameraDef.type ];

  		if ( ! params ) {

  			console.warn( 'THREE.GLTFLoader: Missing camera parameters.' );
  			return;

  		}

  		if ( cameraDef.type === 'perspective' ) {

  			camera = new PerspectiveCamera( MathUtils.radToDeg( params.yfov ), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6 );

  		} else if ( cameraDef.type === 'orthographic' ) {

  			camera = new OrthographicCamera( - params.xmag, params.xmag, params.ymag, - params.ymag, params.znear, params.zfar );

  		}

  		if ( cameraDef.name ) camera.name = this.createUniqueName( cameraDef.name );

  		assignExtrasToUserData( camera, cameraDef );

  		return Promise.resolve( camera );

  	}

  	/**
  	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
  	 * @param {number} skinIndex
  	 * @return {Promise<Skeleton>}
  	 */
  	loadSkin( skinIndex ) {

  		const skinDef = this.json.skins[ skinIndex ];

  		const pending = [];

  		for ( let i = 0, il = skinDef.joints.length; i < il; i ++ ) {

  			pending.push( this._loadNodeShallow( skinDef.joints[ i ] ) );

  		}

  		if ( skinDef.inverseBindMatrices !== undefined ) {

  			pending.push( this.getDependency( 'accessor', skinDef.inverseBindMatrices ) );

  		} else {

  			pending.push( null );

  		}

  		return Promise.all( pending ).then( function ( results ) {

  			const inverseBindMatrices = results.pop();
  			const jointNodes = results;

  			// Note that bones (joint nodes) may or may not be in the
  			// scene graph at this time.

  			const bones = [];
  			const boneInverses = [];

  			for ( let i = 0, il = jointNodes.length; i < il; i ++ ) {

  				const jointNode = jointNodes[ i ];

  				if ( jointNode ) {

  					bones.push( jointNode );

  					const mat = new Matrix4();

  					if ( inverseBindMatrices !== null ) {

  						mat.fromArray( inverseBindMatrices.array, i * 16 );

  					}

  					boneInverses.push( mat );

  				} else {

  					console.warn( 'THREE.GLTFLoader: Joint "%s" could not be found.', skinDef.joints[ i ] );

  				}

  			}

  			return new Skeleton( bones, boneInverses );

  		} );

  	}

  	/**
  	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
  	 * @param {number} animationIndex
  	 * @return {Promise<AnimationClip>}
  	 */
  	loadAnimation( animationIndex ) {

  		const json = this.json;
  		const parser = this;

  		const animationDef = json.animations[ animationIndex ];
  		const animationName = animationDef.name ? animationDef.name : 'animation_' + animationIndex;

  		const pendingNodes = [];
  		const pendingInputAccessors = [];
  		const pendingOutputAccessors = [];
  		const pendingSamplers = [];
  		const pendingTargets = [];

  		for ( let i = 0, il = animationDef.channels.length; i < il; i ++ ) {

  			const channel = animationDef.channels[ i ];
  			const sampler = animationDef.samplers[ channel.sampler ];
  			const target = channel.target;
  			const name = target.node;
  			const input = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.input ] : sampler.input;
  			const output = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.output ] : sampler.output;

  			if ( target.node === undefined ) continue;

  			pendingNodes.push( this.getDependency( 'node', name ) );
  			pendingInputAccessors.push( this.getDependency( 'accessor', input ) );
  			pendingOutputAccessors.push( this.getDependency( 'accessor', output ) );
  			pendingSamplers.push( sampler );
  			pendingTargets.push( target );

  		}

  		return Promise.all( [

  			Promise.all( pendingNodes ),
  			Promise.all( pendingInputAccessors ),
  			Promise.all( pendingOutputAccessors ),
  			Promise.all( pendingSamplers ),
  			Promise.all( pendingTargets )

  		] ).then( function ( dependencies ) {

  			const nodes = dependencies[ 0 ];
  			const inputAccessors = dependencies[ 1 ];
  			const outputAccessors = dependencies[ 2 ];
  			const samplers = dependencies[ 3 ];
  			const targets = dependencies[ 4 ];

  			const tracks = [];

  			for ( let i = 0, il = nodes.length; i < il; i ++ ) {

  				const node = nodes[ i ];
  				const inputAccessor = inputAccessors[ i ];
  				const outputAccessor = outputAccessors[ i ];
  				const sampler = samplers[ i ];
  				const target = targets[ i ];

  				if ( node === undefined ) continue;

  				if ( node.updateMatrix ) {

  					node.updateMatrix();

  				}

  				const createdTracks = parser._createAnimationTracks( node, inputAccessor, outputAccessor, sampler, target );

  				if ( createdTracks ) {

  					for ( let k = 0; k < createdTracks.length; k ++ ) {

  						tracks.push( createdTracks[ k ] );

  					}

  				}

  			}

  			return new AnimationClip( animationName, undefined, tracks );

  		} );

  	}

  	createNodeMesh( nodeIndex ) {

  		const json = this.json;
  		const parser = this;
  		const nodeDef = json.nodes[ nodeIndex ];

  		if ( nodeDef.mesh === undefined ) return null;

  		return parser.getDependency( 'mesh', nodeDef.mesh ).then( function ( mesh ) {

  			const node = parser._getNodeRef( parser.meshCache, nodeDef.mesh, mesh );

  			// if weights are provided on the node, override weights on the mesh.
  			if ( nodeDef.weights !== undefined ) {

  				node.traverse( function ( o ) {

  					if ( ! o.isMesh ) return;

  					for ( let i = 0, il = nodeDef.weights.length; i < il; i ++ ) {

  						o.morphTargetInfluences[ i ] = nodeDef.weights[ i ];

  					}

  				} );

  			}

  			return node;

  		} );

  	}

  	/**
  	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
  	 * @param {number} nodeIndex
  	 * @return {Promise<Object3D>}
  	 */
  	loadNode( nodeIndex ) {

  		const json = this.json;
  		const parser = this;

  		const nodeDef = json.nodes[ nodeIndex ];

  		const nodePending = parser._loadNodeShallow( nodeIndex );

  		const childPending = [];
  		const childrenDef = nodeDef.children || [];

  		for ( let i = 0, il = childrenDef.length; i < il; i ++ ) {

  			childPending.push( parser.getDependency( 'node', childrenDef[ i ] ) );

  		}

  		const skeletonPending = nodeDef.skin === undefined
  			? Promise.resolve( null )
  			: parser.getDependency( 'skin', nodeDef.skin );

  		return Promise.all( [
  			nodePending,
  			Promise.all( childPending ),
  			skeletonPending
  		] ).then( function ( results ) {

  			const node = results[ 0 ];
  			const children = results[ 1 ];
  			const skeleton = results[ 2 ];

  			if ( skeleton !== null ) {

  				// This full traverse should be fine because
  				// child glTF nodes have not been added to this node yet.
  				node.traverse( function ( mesh ) {

  					if ( ! mesh.isSkinnedMesh ) return;

  					mesh.bind( skeleton, _identityMatrix );

  				} );

  			}

  			for ( let i = 0, il = children.length; i < il; i ++ ) {

  				node.add( children[ i ] );

  			}

  			return node;

  		} );

  	}

  	// ._loadNodeShallow() parses a single node.
  	// skin and child nodes are created and added in .loadNode() (no '_' prefix).
  	_loadNodeShallow( nodeIndex ) {

  		const json = this.json;
  		const extensions = this.extensions;
  		const parser = this;

  		// This method is called from .loadNode() and .loadSkin().
  		// Cache a node to avoid duplication.

  		if ( this.nodeCache[ nodeIndex ] !== undefined ) {

  			return this.nodeCache[ nodeIndex ];

  		}

  		const nodeDef = json.nodes[ nodeIndex ];

  		// reserve node's name before its dependencies, so the root has the intended name.
  		const nodeName = nodeDef.name ? parser.createUniqueName( nodeDef.name ) : '';

  		const pending = [];

  		const meshPromise = parser._invokeOne( function ( ext ) {

  			return ext.createNodeMesh && ext.createNodeMesh( nodeIndex );

  		} );

  		if ( meshPromise ) {

  			pending.push( meshPromise );

  		}

  		if ( nodeDef.camera !== undefined ) {

  			pending.push( parser.getDependency( 'camera', nodeDef.camera ).then( function ( camera ) {

  				return parser._getNodeRef( parser.cameraCache, nodeDef.camera, camera );

  			} ) );

  		}

  		parser._invokeAll( function ( ext ) {

  			return ext.createNodeAttachment && ext.createNodeAttachment( nodeIndex );

  		} ).forEach( function ( promise ) {

  			pending.push( promise );

  		} );

  		this.nodeCache[ nodeIndex ] = Promise.all( pending ).then( function ( objects ) {

  			let node;

  			// .isBone isn't in glTF spec. See ._markDefs
  			if ( nodeDef.isBone === true ) {

  				node = new Bone();

  			} else if ( objects.length > 1 ) {

  				node = new Group();

  			} else if ( objects.length === 1 ) {

  				node = objects[ 0 ];

  			} else {

  				node = new Object3D();

  			}

  			if ( node !== objects[ 0 ] ) {

  				for ( let i = 0, il = objects.length; i < il; i ++ ) {

  					node.add( objects[ i ] );

  				}

  			}

  			if ( nodeDef.name ) {

  				node.userData.name = nodeDef.name;
  				node.name = nodeName;

  			}

  			assignExtrasToUserData( node, nodeDef );

  			if ( nodeDef.extensions ) addUnknownExtensionsToUserData( extensions, node, nodeDef );

  			if ( nodeDef.matrix !== undefined ) {

  				const matrix = new Matrix4();
  				matrix.fromArray( nodeDef.matrix );
  				node.applyMatrix4( matrix );

  			} else {

  				if ( nodeDef.translation !== undefined ) {

  					node.position.fromArray( nodeDef.translation );

  				}

  				if ( nodeDef.rotation !== undefined ) {

  					node.quaternion.fromArray( nodeDef.rotation );

  				}

  				if ( nodeDef.scale !== undefined ) {

  					node.scale.fromArray( nodeDef.scale );

  				}

  			}

  			if ( ! parser.associations.has( node ) ) {

  				parser.associations.set( node, {} );

  			}

  			parser.associations.get( node ).nodes = nodeIndex;

  			return node;

  		} );

  		return this.nodeCache[ nodeIndex ];

  	}

  	/**
  	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
  	 * @param {number} sceneIndex
  	 * @return {Promise<Group>}
  	 */
  	loadScene( sceneIndex ) {

  		const extensions = this.extensions;
  		const sceneDef = this.json.scenes[ sceneIndex ];
  		const parser = this;

  		// Loader returns Group, not Scene.
  		// See: https://github.com/mrdoob/three.js/issues/18342#issuecomment-578981172
  		const scene = new Group();
  		if ( sceneDef.name ) scene.name = parser.createUniqueName( sceneDef.name );

  		assignExtrasToUserData( scene, sceneDef );

  		if ( sceneDef.extensions ) addUnknownExtensionsToUserData( extensions, scene, sceneDef );

  		const nodeIds = sceneDef.nodes || [];

  		const pending = [];

  		for ( let i = 0, il = nodeIds.length; i < il; i ++ ) {

  			pending.push( parser.getDependency( 'node', nodeIds[ i ] ) );

  		}

  		return Promise.all( pending ).then( function ( nodes ) {

  			for ( let i = 0, il = nodes.length; i < il; i ++ ) {

  				scene.add( nodes[ i ] );

  			}

  			// Removes dangling associations, associations that reference a node that
  			// didn't make it into the scene.
  			const reduceAssociations = ( node ) => {

  				const reducedAssociations = new Map();

  				for ( const [ key, value ] of parser.associations ) {

  					if ( key instanceof Material || key instanceof Texture ) {

  						reducedAssociations.set( key, value );

  					}

  				}

  				node.traverse( ( node ) => {

  					const mappings = parser.associations.get( node );

  					if ( mappings != null ) {

  						reducedAssociations.set( node, mappings );

  					}

  				} );

  				return reducedAssociations;

  			};

  			parser.associations = reduceAssociations( scene );

  			return scene;

  		} );

  	}

  	_createAnimationTracks( node, inputAccessor, outputAccessor, sampler, target ) {

  		const tracks = [];

  		const targetName = node.name ? node.name : node.uuid;
  		const targetNames = [];

  		if ( PATH_PROPERTIES[ target.path ] === PATH_PROPERTIES.weights ) {

  			node.traverse( function ( object ) {

  				if ( object.morphTargetInfluences ) {

  					targetNames.push( object.name ? object.name : object.uuid );

  				}

  			} );

  		} else {

  			targetNames.push( targetName );

  		}

  		let TypedKeyframeTrack;

  		switch ( PATH_PROPERTIES[ target.path ] ) {

  			case PATH_PROPERTIES.weights:

  				TypedKeyframeTrack = NumberKeyframeTrack;
  				break;

  			case PATH_PROPERTIES.rotation:

  				TypedKeyframeTrack = QuaternionKeyframeTrack;
  				break;

  			case PATH_PROPERTIES.position:
  			case PATH_PROPERTIES.scale:

  				TypedKeyframeTrack = VectorKeyframeTrack;
  				break;

  			default:

  				switch ( outputAccessor.itemSize ) {

  					case 1:
  						TypedKeyframeTrack = NumberKeyframeTrack;
  						break;
  					case 2:
  					case 3:
  					default:
  						TypedKeyframeTrack = VectorKeyframeTrack;
  						break;

  				}

  				break;

  		}

  		const interpolation = sampler.interpolation !== undefined ? INTERPOLATION[ sampler.interpolation ] : InterpolateLinear;


  		const outputArray = this._getArrayFromAccessor( outputAccessor );

  		for ( let j = 0, jl = targetNames.length; j < jl; j ++ ) {

  			const track = new TypedKeyframeTrack(
  				targetNames[ j ] + '.' + PATH_PROPERTIES[ target.path ],
  				inputAccessor.array,
  				outputArray,
  				interpolation
  			);

  			// Override interpolation with custom factory method.
  			if ( sampler.interpolation === 'CUBICSPLINE' ) {

  				this._createCubicSplineTrackInterpolant( track );

  			}

  			tracks.push( track );

  		}

  		return tracks;

  	}

  	_getArrayFromAccessor( accessor ) {

  		let outputArray = accessor.array;

  		if ( accessor.normalized ) {

  			const scale = getNormalizedComponentScale( outputArray.constructor );
  			const scaled = new Float32Array( outputArray.length );

  			for ( let j = 0, jl = outputArray.length; j < jl; j ++ ) {

  				scaled[ j ] = outputArray[ j ] * scale;

  			}

  			outputArray = scaled;

  		}

  		return outputArray;

  	}

  	_createCubicSplineTrackInterpolant( track ) {

  		track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline( result ) {

  			// A CUBICSPLINE keyframe in glTF has three output values for each input value,
  			// representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()
  			// must be divided by three to get the interpolant's sampleSize argument.

  			const interpolantType = ( this instanceof QuaternionKeyframeTrack ) ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;

  			return new interpolantType( this.times, this.values, this.getValueSize() / 3, result );

  		};

  		// Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.
  		track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;

  	}

  }

  /**
   * @param {BufferGeometry} geometry
   * @param {GLTF.Primitive} primitiveDef
   * @param {GLTFParser} parser
   */
  function computeBounds( geometry, primitiveDef, parser ) {

  	const attributes = primitiveDef.attributes;

  	const box = new Box3();

  	if ( attributes.POSITION !== undefined ) {

  		const accessor = parser.json.accessors[ attributes.POSITION ];

  		const min = accessor.min;
  		const max = accessor.max;

  		// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.

  		if ( min !== undefined && max !== undefined ) {

  			box.set(
  				new Vector3( min[ 0 ], min[ 1 ], min[ 2 ] ),
  				new Vector3( max[ 0 ], max[ 1 ], max[ 2 ] )
  			);

  			if ( accessor.normalized ) {

  				const boxScale = getNormalizedComponentScale( WEBGL_COMPONENT_TYPES[ accessor.componentType ] );
  				box.min.multiplyScalar( boxScale );
  				box.max.multiplyScalar( boxScale );

  			}

  		} else {

  			console.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );

  			return;

  		}

  	} else {

  		return;

  	}

  	const targets = primitiveDef.targets;

  	if ( targets !== undefined ) {

  		const maxDisplacement = new Vector3();
  		const vector = new Vector3();

  		for ( let i = 0, il = targets.length; i < il; i ++ ) {

  			const target = targets[ i ];

  			if ( target.POSITION !== undefined ) {

  				const accessor = parser.json.accessors[ target.POSITION ];
  				const min = accessor.min;
  				const max = accessor.max;

  				// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.

  				if ( min !== undefined && max !== undefined ) {

  					// we need to get max of absolute components because target weight is [-1,1]
  					vector.setX( Math.max( Math.abs( min[ 0 ] ), Math.abs( max[ 0 ] ) ) );
  					vector.setY( Math.max( Math.abs( min[ 1 ] ), Math.abs( max[ 1 ] ) ) );
  					vector.setZ( Math.max( Math.abs( min[ 2 ] ), Math.abs( max[ 2 ] ) ) );


  					if ( accessor.normalized ) {

  						const boxScale = getNormalizedComponentScale( WEBGL_COMPONENT_TYPES[ accessor.componentType ] );
  						vector.multiplyScalar( boxScale );

  					}

  					// Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative
  					// to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets
  					// are used to implement key-frame animations and as such only two are active at a time - this results in very large
  					// boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size.
  					maxDisplacement.max( vector );

  				} else {

  					console.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );

  				}

  			}

  		}

  		// As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets.
  		box.expandByVector( maxDisplacement );

  	}

  	geometry.boundingBox = box;

  	const sphere = new Sphere();

  	box.getCenter( sphere.center );
  	sphere.radius = box.min.distanceTo( box.max ) / 2;

  	geometry.boundingSphere = sphere;

  }

  /**
   * @param {BufferGeometry} geometry
   * @param {GLTF.Primitive} primitiveDef
   * @param {GLTFParser} parser
   * @return {Promise<BufferGeometry>}
   */
  function addPrimitiveAttributes( geometry, primitiveDef, parser ) {

  	const attributes = primitiveDef.attributes;

  	const pending = [];

  	function assignAttributeAccessor( accessorIndex, attributeName ) {

  		return parser.getDependency( 'accessor', accessorIndex )
  			.then( function ( accessor ) {

  				geometry.setAttribute( attributeName, accessor );

  			} );

  	}

  	for ( const gltfAttributeName in attributes ) {

  		const threeAttributeName = ATTRIBUTES[ gltfAttributeName ] || gltfAttributeName.toLowerCase();

  		// Skip attributes already provided by e.g. Draco extension.
  		if ( threeAttributeName in geometry.attributes ) continue;

  		pending.push( assignAttributeAccessor( attributes[ gltfAttributeName ], threeAttributeName ) );

  	}

  	if ( primitiveDef.indices !== undefined && ! geometry.index ) {

  		const accessor = parser.getDependency( 'accessor', primitiveDef.indices ).then( function ( accessor ) {

  			geometry.setIndex( accessor );

  		} );

  		pending.push( accessor );

  	}

  	if ( ColorManagement.workingColorSpace !== LinearSRGBColorSpace && 'COLOR_0' in attributes ) {

  		console.warn( `THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${ColorManagement.workingColorSpace}" not supported.` );

  	}

  	assignExtrasToUserData( geometry, primitiveDef );

  	computeBounds( geometry, primitiveDef, parser );

  	return Promise.all( pending ).then( function () {

  		return primitiveDef.targets !== undefined
  			? addMorphTargets( geometry, primitiveDef.targets, parser )
  			: geometry;

  	} );

  }

  function vrma2motion(vrmaObject, vrm, onProgress) {
    var clip = createVRMAnimationClip(vrmaObject, vrm);
    return {
      clip: clip
    };
  }

  function abFetch(_x) {
    return _abFetch.apply(this, arguments);
  }
  function _abFetch() {
    _abFetch = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(filePath) {
      var onProgress,
        _args = arguments;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            onProgress = _args.length > 1 && _args[1] !== undefined ? _args[1] : function (_1, _2) {};
            return _context.abrupt("return", new Promise(function (resolve, reject) {
              var xhr = new XMLHttpRequest();
              xhr.open("GET", filePath, true);
              xhr.responseType = "arraybuffer";
              xhr.onprogress = function (e) {
                if (e.lengthComputable) {
                  onProgress("File Donwloader - ".concat(filePath), e.loaded / e.total);
                }
              };
              xhr.onload = function () {
                if (xhr.status === 200) {
                  resolve(xhr.response);
                } else {
                  reject(new Error("Failed to fetch ".concat(filePath)));
                }
              };
              xhr.onerror = function () {
                reject(new Error("Failed to fetch ".concat(filePath)));
              };
              xhr.send();
            }));
          case 2:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return _abFetch.apply(this, arguments);
  }

  var VRMAConverter = /*#__PURE__*/function () {
    function VRMAConverter(vrm) {
      var worker = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
      _classCallCheck(this, VRMAConverter);
      this._vrm = vrm;
      this._vrmas = {};
      this._loader = new GLTFLoader();
      this._loader.register(function (parser) {
        return new VRMAnimationLoaderPlugin(parser);
      });
      this._worker = worker;
    }
    return _createClass(VRMAConverter, [{
      key: "vrma2motion",
      value: function () {
        var _vrma2motion = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(filePath) {
          var _this = this;
          var onProgress,
            buffer,
            _args3 = arguments;
          return _regeneratorRuntime().wrap(function _callee3$(_context3) {
            while (1) switch (_context3.prev = _context3.next) {
              case 0:
                onProgress = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : function (_1, _2) {};
                buffer = _args3.length > 2 ? _args3[2] : undefined;
                if (!(this._vrmas[filePath] && this._vrmas[filePath].motionExpression)) {
                  _context3.next = 4;
                  break;
                }
                return _context3.abrupt("return", this._vrmas[filePath].motionExpression);
              case 4:
                this._vrmas[filePath] = {
                  motionExpression: undefined
                };
                if (buffer) {
                  _context3.next = 15;
                  break;
                }
                if (!(this._worker && Object.keys(this._worker.prefetchFiles).includes(filePath))) {
                  _context3.next = 12;
                  break;
                }
                _context3.next = 9;
                return this._worker.prefetchFiles[filePath];
              case 9:
                buffer = _context3.sent;
                _context3.next = 15;
                break;
              case 12:
                _context3.next = 14;
                return abFetch(filePath, onProgress);
              case 14:
                buffer = _context3.sent;
              case 15:
                return _context3.abrupt("return", new Promise(/*#__PURE__*/function () {
                  var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(resolve, reject) {
                    var data;
                    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
                      while (1) switch (_context2.prev = _context2.next) {
                        case 0:
                          if (!_this._worker) {
                            _context2.next = 10;
                            break;
                          }
                          _context2.next = 3;
                          return _this.workerConvertVrmaToMotion(filePath, buffer, onProgress);
                        case 3:
                          data = _context2.sent;
                          if (data) {
                            _context2.next = 7;
                            break;
                          }
                          reject("An error occured while trying to convert ".concat(filePath, " to motion from its arrayBuffer using the worker"));
                          return _context2.abrupt("return");
                        case 7:
                          _this._vrmas[data.filePath].motionExpression = data.motion;
                          resolve(data.motion);
                          return _context2.abrupt("return");
                        case 10:
                          _this._loader.parse(buffer, filePath, /*#__PURE__*/function () {
                            var _ref2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(gltf) {
                              var vrma, motion;
                              return _regeneratorRuntime().wrap(function _callee$(_context) {
                                while (1) switch (_context.prev = _context.next) {
                                  case 0:
                                    vrma = gltf.userData.vrmAnimations[0];
                                    if (vrma) {
                                      _context.next = 4;
                                      break;
                                    }
                                    reject("An error occured while trying to load ".concat(filePath, " from its arrayBuffer"));
                                    return _context.abrupt("return");
                                  case 4:
                                    _context.next = 6;
                                    return _this.convertVrmaToMotion(vrma, onProgress);
                                  case 6:
                                    motion = _context.sent;
                                    if (!motion) {
                                      _context.next = 13;
                                      break;
                                    }
                                    _this._vrmas[filePath].motionExpression = motion;
                                    resolve(motion);
                                    return _context.abrupt("return");
                                  case 13:
                                    reject("An error occured while trying to convert ".concat(filePath, " to motion from its arrayBuffer"));
                                    return _context.abrupt("return");
                                  case 15:
                                  case "end":
                                    return _context.stop();
                                }
                              }, _callee);
                            }));
                            return function (_x4) {
                              return _ref2.apply(this, arguments);
                            };
                          }(), function (e) {
                            reject(e);
                          });
                        case 11:
                        case "end":
                          return _context2.stop();
                      }
                    }, _callee2);
                  }));
                  return function (_x2, _x3) {
                    return _ref.apply(this, arguments);
                  };
                }()));
              case 16:
              case "end":
                return _context3.stop();
            }
          }, _callee3, this);
        }));
        function vrma2motion(_x) {
          return _vrma2motion.apply(this, arguments);
        }
        return vrma2motion;
      }()
    }, {
      key: "workerConvertVrmaToMotion",
      value: function () {
        var _workerConvertVrmaToMotion = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4(filePath, arrayBuffer) {
          var onProgress,
            _args4 = arguments;
          return _regeneratorRuntime().wrap(function _callee4$(_context4) {
            while (1) switch (_context4.prev = _context4.next) {
              case 0:
                onProgress = _args4.length > 2 && _args4[2] !== undefined ? _args4[2] : function (_1, _2) {};
                _context4.next = 3;
                return this._worker.vrma2motion(filePath, arrayBuffer, onProgress);
              case 3:
                return _context4.abrupt("return", _context4.sent);
              case 4:
              case "end":
                return _context4.stop();
            }
          }, _callee4, this);
        }));
        function workerConvertVrmaToMotion(_x5, _x6) {
          return _workerConvertVrmaToMotion.apply(this, arguments);
        }
        return workerConvertVrmaToMotion;
      }()
    }, {
      key: "convertVrmaToMotion",
      value: function convertVrmaToMotion(object) {
        if (object.humanoidTracks) {
          return vrma2motion(object, this._vrm);
        }
      }
    }]);
  }();

  function arrayBufferToString(buffer) {
    var uint8Array = new Uint8Array(buffer);
    var string = String.fromCharCode.apply(String, _toConsumableArray(uint8Array));
    return string;
  }

  var BVHConverter = /*#__PURE__*/function () {
    function BVHConverter(vrm) {
      var worker = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
      _classCallCheck(this, BVHConverter);
      this._vrm = vrm;
      this._bvhs = {};
      this._loader = new BVHLoader();
      this._vrmaConverter = new VRMAConverter(vrm, worker);
    }
    return _createClass(BVHConverter, [{
      key: "bvh2motion",
      value: function () {
        var _bvh2motion = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(filePath) {
          var _this = this;
          var onProgress,
            buffer,
            _args2 = arguments;
          return _regeneratorRuntime().wrap(function _callee2$(_context2) {
            while (1) switch (_context2.prev = _context2.next) {
              case 0:
                onProgress = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : function (_1, _2) {};
                buffer = _args2.length > 2 ? _args2[2] : undefined;
                if (!(this._bvhs[filePath] && this._bvhs[filePath].motionExpression)) {
                  _context2.next = 4;
                  break;
                }
                return _context2.abrupt("return", this._bvhs[filePath].motionExpression);
              case 4:
                this._bvhs[filePath] = {
                  motionExpression: undefined
                };
                if (buffer) {
                  _context2.next = 15;
                  break;
                }
                if (!(this._worker && Object.keys(this._worker.prefetchFiles).includes(filePath))) {
                  _context2.next = 12;
                  break;
                }
                _context2.next = 9;
                return this._worker.prefetchFiles[filePath];
              case 9:
                buffer = _context2.sent;
                _context2.next = 15;
                break;
              case 12:
                _context2.next = 14;
                return abFetch(filePath, onProgress);
              case 14:
                buffer = _context2.sent;
              case 15:
                return _context2.abrupt("return", new Promise(/*#__PURE__*/function () {
                  var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(resolve, reject) {
                    var data, bvhPlainText, bvh, motion;
                    return _regeneratorRuntime().wrap(function _callee$(_context) {
                      while (1) switch (_context.prev = _context.next) {
                        case 0:
                          if (!_this._worker) {
                            _context.next = 10;
                            break;
                          }
                          _context.next = 3;
                          return _this.workerConvertBvhToMotion(filePath, buffer, onProgress);
                        case 3:
                          data = _context.sent;
                          if (data) {
                            _context.next = 7;
                            break;
                          }
                          reject("An error occured while trying to convert ".concat(filePath, " to motion from its arrayBuffer using the worker"));
                          return _context.abrupt("return");
                        case 7:
                          _this._bvhs[data.filePath].motionExpression = data.motion;
                          resolve(data.motion);
                          return _context.abrupt("return");
                        case 10:
                          bvhPlainText = arrayBufferToString(buffer);
                          bvh = _this._loader.parse(bvhPlainText);
                          _context.next = 14;
                          return _this.convertBvhToMotion(bvh, onProgress);
                        case 14:
                          motion = _context.sent;
                          if (!motion) {
                            _context.next = 21;
                            break;
                          }
                          _this._bvhs[filePath].motionExpression = motion;
                          resolve(motion);
                          return _context.abrupt("return");
                        case 21:
                          reject("An error occured while trying to convert ".concat(filePath, " to motion from its arrayBuffer"));
                          return _context.abrupt("return");
                        case 23:
                        case "end":
                          return _context.stop();
                      }
                    }, _callee);
                  }));
                  return function (_x2, _x3) {
                    return _ref.apply(this, arguments);
                  };
                }()));
              case 16:
              case "end":
                return _context2.stop();
            }
          }, _callee2, this);
        }));
        function bvh2motion(_x) {
          return _bvh2motion.apply(this, arguments);
        }
        return bvh2motion;
      }()
    }, {
      key: "workerConvertBvhToMotion",
      value: function () {
        var _workerConvertBvhToMotion = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(filePath, arrayBuffer) {
          var onProgress,
            _args3 = arguments;
          return _regeneratorRuntime().wrap(function _callee3$(_context3) {
            while (1) switch (_context3.prev = _context3.next) {
              case 0:
                onProgress = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : function (_1, _2) {};
                return _context3.abrupt("return", this._worker.bvh2motion(filePath, arrayBuffer, onProgress));
              case 2:
              case "end":
                return _context3.stop();
            }
          }, _callee3, this);
        }));
        function workerConvertBvhToMotion(_x4, _x5) {
          return _workerConvertBvhToMotion.apply(this, arguments);
        }
        return workerConvertBvhToMotion;
      }()
    }, {
      key: "convertBvhToMotion",
      value: function () {
        var _convertBvhToMotion = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4(object) {
          var onProgress,
            vrmaBlob,
            blobUrl,
            _args4 = arguments;
          return _regeneratorRuntime().wrap(function _callee4$(_context4) {
            while (1) switch (_context4.prev = _context4.next) {
              case 0:
                onProgress = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : function (_1, _2) {};
                if (!object.clip) {
                  _context4.next = 11;
                  break;
                }
                _context4.t0 = object.clip.name;
                _context4.next = _context4.t0 === "animation" ? 5 : 10;
                break;
              case 5:
                _context4.next = 7;
                return animationBvh2vrmaBlob(object, this._vrm, onProgress);
              case 7:
                vrmaBlob = _context4.sent;
                blobUrl = URL.createObjectURL(vrmaBlob);
                return _context4.abrupt("return", this._vrmaConverter.vrma2motion(blobUrl, onProgress));
              case 10:
                return _context4.abrupt("return", undefined);
              case 11:
              case "end":
                return _context4.stop();
            }
          }, _callee4, this);
        }));
        function convertBvhToMotion(_x6) {
          return _convertBvhToMotion.apply(this, arguments);
        }
        return convertBvhToMotion;
      }()
    }]);
  }();

  /*!
  fflate - fast JavaScript compression/decompression
  <https://101arrowz.github.io/fflate>
  Licensed under MIT. https://github.com/101arrowz/fflate/blob/master/LICENSE
  version 0.8.2
  */


  // aliases for shorter compressed code (most minifers don't do this)
  var u8 = Uint8Array, u16 = Uint16Array, i32 = Int32Array;
  // fixed length extra bits
  var fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, /* unused */ 0, 0, /* impossible */ 0]);
  // fixed distance extra bits
  var fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, /* unused */ 0, 0]);
  // code length index map
  var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
  // get base, reverse index map from extra bits
  var freb = function (eb, start) {
      var b = new u16(31);
      for (var i = 0; i < 31; ++i) {
          b[i] = start += 1 << eb[i - 1];
      }
      // numbers here are at max 18 bits
      var r = new i32(b[30]);
      for (var i = 1; i < 30; ++i) {
          for (var j = b[i]; j < b[i + 1]; ++j) {
              r[j] = ((j - b[i]) << 5) | i;
          }
      }
      return { b: b, r: r };
  };
  var _a = freb(fleb, 2), fl = _a.b, revfl = _a.r;
  // we can ignore the fact that the other numbers are wrong; they never happen anyway
  fl[28] = 258, revfl[258] = 28;
  var _b = freb(fdeb, 0), fd = _b.b;
  // map of value to reverse (assuming 16 bits)
  var rev = new u16(32768);
  for (var i = 0; i < 32768; ++i) {
      // reverse table algorithm from SO
      var x = ((i & 0xAAAA) >> 1) | ((i & 0x5555) << 1);
      x = ((x & 0xCCCC) >> 2) | ((x & 0x3333) << 2);
      x = ((x & 0xF0F0) >> 4) | ((x & 0x0F0F) << 4);
      rev[i] = (((x & 0xFF00) >> 8) | ((x & 0x00FF) << 8)) >> 1;
  }
  // create huffman tree from u8 "map": index -> code length for code index
  // mb (max bits) must be at most 15
  // TODO: optimize/split up?
  var hMap = (function (cd, mb, r) {
      var s = cd.length;
      // index
      var i = 0;
      // u16 "map": index -> # of codes with bit length = index
      var l = new u16(mb);
      // length of cd must be 288 (total # of codes)
      for (; i < s; ++i) {
          if (cd[i])
              ++l[cd[i] - 1];
      }
      // u16 "map": index -> minimum code for bit length = index
      var le = new u16(mb);
      for (i = 1; i < mb; ++i) {
          le[i] = (le[i - 1] + l[i - 1]) << 1;
      }
      var co;
      if (r) {
          // u16 "map": index -> number of actual bits, symbol for code
          co = new u16(1 << mb);
          // bits to remove for reverser
          var rvb = 15 - mb;
          for (i = 0; i < s; ++i) {
              // ignore 0 lengths
              if (cd[i]) {
                  // num encoding both symbol and bits read
                  var sv = (i << 4) | cd[i];
                  // free bits
                  var r_1 = mb - cd[i];
                  // start value
                  var v = le[cd[i] - 1]++ << r_1;
                  // m is end value
                  for (var m = v | ((1 << r_1) - 1); v <= m; ++v) {
                      // every 16 bit value starting with the code yields the same result
                      co[rev[v] >> rvb] = sv;
                  }
              }
          }
      }
      else {
          co = new u16(s);
          for (i = 0; i < s; ++i) {
              if (cd[i]) {
                  co[i] = rev[le[cd[i] - 1]++] >> (15 - cd[i]);
              }
          }
      }
      return co;
  });
  // fixed length tree
  var flt = new u8(288);
  for (var i = 0; i < 144; ++i)
      flt[i] = 8;
  for (var i = 144; i < 256; ++i)
      flt[i] = 9;
  for (var i = 256; i < 280; ++i)
      flt[i] = 7;
  for (var i = 280; i < 288; ++i)
      flt[i] = 8;
  // fixed distance tree
  var fdt = new u8(32);
  for (var i = 0; i < 32; ++i)
      fdt[i] = 5;
  // fixed length map
  var flrm = /*#__PURE__*/ hMap(flt, 9, 1);
  // fixed distance map
  var fdrm = /*#__PURE__*/ hMap(fdt, 5, 1);
  // find max of array
  var max = function (a) {
      var m = a[0];
      for (var i = 1; i < a.length; ++i) {
          if (a[i] > m)
              m = a[i];
      }
      return m;
  };
  // read d, starting at bit p and mask with m
  var bits = function (d, p, m) {
      var o = (p / 8) | 0;
      return ((d[o] | (d[o + 1] << 8)) >> (p & 7)) & m;
  };
  // read d, starting at bit p continuing for at least 16 bits
  var bits16 = function (d, p) {
      var o = (p / 8) | 0;
      return ((d[o] | (d[o + 1] << 8) | (d[o + 2] << 16)) >> (p & 7));
  };
  // get end of byte
  var shft = function (p) { return ((p + 7) / 8) | 0; };
  // typed array slice - allows garbage collector to free original reference,
  // while being more compatible than .slice
  var slc = function (v, s, e) {
      if (e == null || e > v.length)
          e = v.length;
      // can't use .constructor in case user-supplied
      return new u8(v.subarray(s, e));
  };
  // error codes
  var ec = [
      'unexpected EOF',
      'invalid block type',
      'invalid length/literal',
      'invalid distance',
      'stream finished',
      'no stream handler',
      ,
      'no callback',
      'invalid UTF-8 data',
      'extra field too long',
      'date not in range 1980-2099',
      'filename too long',
      'stream finishing',
      'invalid zip data'
      // determined by unknown compression method
  ];
  var err = function (ind, msg, nt) {
      var e = new Error(msg || ec[ind]);
      e.code = ind;
      if (Error.captureStackTrace)
          Error.captureStackTrace(e, err);
      if (!nt)
          throw e;
      return e;
  };
  // expands raw DEFLATE data
  var inflt = function (dat, st, buf, dict) {
      // source length       dict length
      var sl = dat.length, dl = 0;
      if (!sl || st.f && !st.l)
          return buf || new u8(0);
      var noBuf = !buf;
      // have to estimate size
      var resize = noBuf || st.i != 2;
      // no state
      var noSt = st.i;
      // Assumes roughly 33% compression ratio average
      if (noBuf)
          buf = new u8(sl * 3);
      // ensure buffer can fit at least l elements
      var cbuf = function (l) {
          var bl = buf.length;
          // need to increase size to fit
          if (l > bl) {
              // Double or set to necessary, whichever is greater
              var nbuf = new u8(Math.max(bl * 2, l));
              nbuf.set(buf);
              buf = nbuf;
          }
      };
      //  last chunk         bitpos           bytes
      var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;
      // total bits
      var tbts = sl * 8;
      do {
          if (!lm) {
              // BFINAL - this is only 1 when last chunk is next
              final = bits(dat, pos, 1);
              // type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman
              var type = bits(dat, pos + 1, 3);
              pos += 3;
              if (!type) {
                  // go to end of byte boundary
                  var s = shft(pos) + 4, l = dat[s - 4] | (dat[s - 3] << 8), t = s + l;
                  if (t > sl) {
                      if (noSt)
                          err(0);
                      break;
                  }
                  // ensure size
                  if (resize)
                      cbuf(bt + l);
                  // Copy over uncompressed data
                  buf.set(dat.subarray(s, t), bt);
                  // Get new bitpos, update byte count
                  st.b = bt += l, st.p = pos = t * 8, st.f = final;
                  continue;
              }
              else if (type == 1)
                  lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
              else if (type == 2) {
                  //  literal                            lengths
                  var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
                  var tl = hLit + bits(dat, pos + 5, 31) + 1;
                  pos += 14;
                  // length+distance tree
                  var ldt = new u8(tl);
                  // code length tree
                  var clt = new u8(19);
                  for (var i = 0; i < hcLen; ++i) {
                      // use index map to get real code
                      clt[clim[i]] = bits(dat, pos + i * 3, 7);
                  }
                  pos += hcLen * 3;
                  // code lengths bits
                  var clb = max(clt), clbmsk = (1 << clb) - 1;
                  // code lengths map
                  var clm = hMap(clt, clb, 1);
                  for (var i = 0; i < tl;) {
                      var r = clm[bits(dat, pos, clbmsk)];
                      // bits read
                      pos += r & 15;
                      // symbol
                      var s = r >> 4;
                      // code length to copy
                      if (s < 16) {
                          ldt[i++] = s;
                      }
                      else {
                          //  copy   count
                          var c = 0, n = 0;
                          if (s == 16)
                              n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];
                          else if (s == 17)
                              n = 3 + bits(dat, pos, 7), pos += 3;
                          else if (s == 18)
                              n = 11 + bits(dat, pos, 127), pos += 7;
                          while (n--)
                              ldt[i++] = c;
                      }
                  }
                  //    length tree                 distance tree
                  var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);
                  // max length bits
                  lbt = max(lt);
                  // max dist bits
                  dbt = max(dt);
                  lm = hMap(lt, lbt, 1);
                  dm = hMap(dt, dbt, 1);
              }
              else
                  err(1);
              if (pos > tbts) {
                  if (noSt)
                      err(0);
                  break;
              }
          }
          // Make sure the buffer can hold this + the largest possible addition
          // Maximum chunk size (practically, theoretically infinite) is 2^17
          if (resize)
              cbuf(bt + 131072);
          var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
          var lpos = pos;
          for (;; lpos = pos) {
              // bits read, code
              var c = lm[bits16(dat, pos) & lms], sym = c >> 4;
              pos += c & 15;
              if (pos > tbts) {
                  if (noSt)
                      err(0);
                  break;
              }
              if (!c)
                  err(2);
              if (sym < 256)
                  buf[bt++] = sym;
              else if (sym == 256) {
                  lpos = pos, lm = null;
                  break;
              }
              else {
                  var add = sym - 254;
                  // no extra bits needed if less
                  if (sym > 264) {
                      // index
                      var i = sym - 257, b = fleb[i];
                      add = bits(dat, pos, (1 << b) - 1) + fl[i];
                      pos += b;
                  }
                  // dist
                  var d = dm[bits16(dat, pos) & dms], dsym = d >> 4;
                  if (!d)
                      err(3);
                  pos += d & 15;
                  var dt = fd[dsym];
                  if (dsym > 3) {
                      var b = fdeb[dsym];
                      dt += bits16(dat, pos) & (1 << b) - 1, pos += b;
                  }
                  if (pos > tbts) {
                      if (noSt)
                          err(0);
                      break;
                  }
                  if (resize)
                      cbuf(bt + 131072);
                  var end = bt + add;
                  if (bt < dt) {
                      var shift = dl - dt, dend = Math.min(dt, end);
                      if (shift + bt < 0)
                          err(3);
                      for (; bt < dend; ++bt)
                          buf[bt] = dict[shift + bt];
                  }
                  for (; bt < end; ++bt)
                      buf[bt] = buf[bt - dt];
              }
          }
          st.l = lm, st.p = lpos, st.b = bt, st.f = final;
          if (lm)
              final = 1, st.m = lbt, st.d = dm, st.n = dbt;
      } while (!final);
      // don't reallocate for streams or user buffers
      return bt != buf.length && noBuf ? slc(buf, 0, bt) : buf.subarray(0, bt);
  };
  // empty
  var et = /*#__PURE__*/ new u8(0);
  // zlib start
  var zls = function (d, dict) {
      if ((d[0] & 15) != 8 || (d[0] >> 4) > 7 || ((d[0] << 8 | d[1]) % 31))
          err(6, 'invalid zlib data');
      if ((d[1] >> 5 & 1) == +!dict)
          err(6, 'invalid zlib data: ' + (d[1] & 32 ? 'need' : 'unexpected') + ' dictionary');
      return (d[1] >> 3 & 4) + 2;
  };
  /**
   * Expands Zlib data
   * @param data The data to decompress
   * @param opts The decompression options
   * @returns The decompressed version of the data
   */
  function unzlibSync(data, opts) {
      return inflt(data.subarray(zls(data, opts), -4), { i: 2 }, opts, opts);
  }
  // text decoder
  var td = typeof TextDecoder != 'undefined' && /*#__PURE__*/ new TextDecoder();
  // text decoder stream
  var tds = 0;
  try {
      td.decode(et, { stream: true });
      tds = 1;
  }
  catch (e) { }

  /**
   * NURBS utils
   *
   * See NURBSCurve and NURBSSurface.
   **/


  /**************************************************************
   *	NURBS Utils
   **************************************************************/

  /*
  Finds knot vector span.

  p : degree
  u : parametric value
  U : knot vector

  returns the span
  */
  function findSpan( p, u, U ) {

  	const n = U.length - p - 1;

  	if ( u >= U[ n ] ) {

  		return n - 1;

  	}

  	if ( u <= U[ p ] ) {

  		return p;

  	}

  	let low = p;
  	let high = n;
  	let mid = Math.floor( ( low + high ) / 2 );

  	while ( u < U[ mid ] || u >= U[ mid + 1 ] ) {

  		if ( u < U[ mid ] ) {

  			high = mid;

  		} else {

  			low = mid;

  		}

  		mid = Math.floor( ( low + high ) / 2 );

  	}

  	return mid;

  }


  /*
  Calculate basis functions. See The NURBS Book, page 70, algorithm A2.2

  span : span in which u lies
  u    : parametric point
  p    : degree
  U    : knot vector

  returns array[p+1] with basis functions values.
  */
  function calcBasisFunctions( span, u, p, U ) {

  	const N = [];
  	const left = [];
  	const right = [];
  	N[ 0 ] = 1.0;

  	for ( let j = 1; j <= p; ++ j ) {

  		left[ j ] = u - U[ span + 1 - j ];
  		right[ j ] = U[ span + j ] - u;

  		let saved = 0.0;

  		for ( let r = 0; r < j; ++ r ) {

  			const rv = right[ r + 1 ];
  			const lv = left[ j - r ];
  			const temp = N[ r ] / ( rv + lv );
  			N[ r ] = saved + rv * temp;
  			saved = lv * temp;

  		}

  		N[ j ] = saved;

  	}

  	return N;

  }


  /*
  Calculate B-Spline curve points. See The NURBS Book, page 82, algorithm A3.1.

  p : degree of B-Spline
  U : knot vector
  P : control points (x, y, z, w)
  u : parametric point

  returns point for given u
  */
  function calcBSplinePoint( p, U, P, u ) {

  	const span = findSpan( p, u, U );
  	const N = calcBasisFunctions( span, u, p, U );
  	const C = new Vector4( 0, 0, 0, 0 );

  	for ( let j = 0; j <= p; ++ j ) {

  		const point = P[ span - p + j ];
  		const Nj = N[ j ];
  		const wNj = point.w * Nj;
  		C.x += point.x * wNj;
  		C.y += point.y * wNj;
  		C.z += point.z * wNj;
  		C.w += point.w * Nj;

  	}

  	return C;

  }


  /*
  Calculate basis functions derivatives. See The NURBS Book, page 72, algorithm A2.3.

  span : span in which u lies
  u    : parametric point
  p    : degree
  n    : number of derivatives to calculate
  U    : knot vector

  returns array[n+1][p+1] with basis functions derivatives
  */
  function calcBasisFunctionDerivatives( span, u, p, n, U ) {

  	const zeroArr = [];
  	for ( let i = 0; i <= p; ++ i )
  		zeroArr[ i ] = 0.0;

  	const ders = [];

  	for ( let i = 0; i <= n; ++ i )
  		ders[ i ] = zeroArr.slice( 0 );

  	const ndu = [];

  	for ( let i = 0; i <= p; ++ i )
  		ndu[ i ] = zeroArr.slice( 0 );

  	ndu[ 0 ][ 0 ] = 1.0;

  	const left = zeroArr.slice( 0 );
  	const right = zeroArr.slice( 0 );

  	for ( let j = 1; j <= p; ++ j ) {

  		left[ j ] = u - U[ span + 1 - j ];
  		right[ j ] = U[ span + j ] - u;

  		let saved = 0.0;

  		for ( let r = 0; r < j; ++ r ) {

  			const rv = right[ r + 1 ];
  			const lv = left[ j - r ];
  			ndu[ j ][ r ] = rv + lv;

  			const temp = ndu[ r ][ j - 1 ] / ndu[ j ][ r ];
  			ndu[ r ][ j ] = saved + rv * temp;
  			saved = lv * temp;

  		}

  		ndu[ j ][ j ] = saved;

  	}

  	for ( let j = 0; j <= p; ++ j ) {

  		ders[ 0 ][ j ] = ndu[ j ][ p ];

  	}

  	for ( let r = 0; r <= p; ++ r ) {

  		let s1 = 0;
  		let s2 = 1;

  		const a = [];
  		for ( let i = 0; i <= p; ++ i ) {

  			a[ i ] = zeroArr.slice( 0 );

  		}

  		a[ 0 ][ 0 ] = 1.0;

  		for ( let k = 1; k <= n; ++ k ) {

  			let d = 0.0;
  			const rk = r - k;
  			const pk = p - k;

  			if ( r >= k ) {

  				a[ s2 ][ 0 ] = a[ s1 ][ 0 ] / ndu[ pk + 1 ][ rk ];
  				d = a[ s2 ][ 0 ] * ndu[ rk ][ pk ];

  			}

  			const j1 = ( rk >= - 1 ) ? 1 : - rk;
  			const j2 = ( r - 1 <= pk ) ? k - 1 : p - r;

  			for ( let j = j1; j <= j2; ++ j ) {

  				a[ s2 ][ j ] = ( a[ s1 ][ j ] - a[ s1 ][ j - 1 ] ) / ndu[ pk + 1 ][ rk + j ];
  				d += a[ s2 ][ j ] * ndu[ rk + j ][ pk ];

  			}

  			if ( r <= pk ) {

  				a[ s2 ][ k ] = - a[ s1 ][ k - 1 ] / ndu[ pk + 1 ][ r ];
  				d += a[ s2 ][ k ] * ndu[ r ][ pk ];

  			}

  			ders[ k ][ r ] = d;

  			const j = s1;
  			s1 = s2;
  			s2 = j;

  		}

  	}

  	let r = p;

  	for ( let k = 1; k <= n; ++ k ) {

  		for ( let j = 0; j <= p; ++ j ) {

  			ders[ k ][ j ] *= r;

  		}

  		r *= p - k;

  	}

  	return ders;

  }


  /*
  	Calculate derivatives of a B-Spline. See The NURBS Book, page 93, algorithm A3.2.

  	p  : degree
  	U  : knot vector
  	P  : control points
  	u  : Parametric points
  	nd : number of derivatives

  	returns array[d+1] with derivatives
  	*/
  function calcBSplineDerivatives( p, U, P, u, nd ) {

  	const du = nd < p ? nd : p;
  	const CK = [];
  	const span = findSpan( p, u, U );
  	const nders = calcBasisFunctionDerivatives( span, u, p, du, U );
  	const Pw = [];

  	for ( let i = 0; i < P.length; ++ i ) {

  		const point = P[ i ].clone();
  		const w = point.w;

  		point.x *= w;
  		point.y *= w;
  		point.z *= w;

  		Pw[ i ] = point;

  	}

  	for ( let k = 0; k <= du; ++ k ) {

  		const point = Pw[ span - p ].clone().multiplyScalar( nders[ k ][ 0 ] );

  		for ( let j = 1; j <= p; ++ j ) {

  			point.add( Pw[ span - p + j ].clone().multiplyScalar( nders[ k ][ j ] ) );

  		}

  		CK[ k ] = point;

  	}

  	for ( let k = du + 1; k <= nd + 1; ++ k ) {

  		CK[ k ] = new Vector4( 0, 0, 0 );

  	}

  	return CK;

  }


  /*
  Calculate "K over I"

  returns k!/(i!(k-i)!)
  */
  function calcKoverI( k, i ) {

  	let nom = 1;

  	for ( let j = 2; j <= k; ++ j ) {

  		nom *= j;

  	}

  	let denom = 1;

  	for ( let j = 2; j <= i; ++ j ) {

  		denom *= j;

  	}

  	for ( let j = 2; j <= k - i; ++ j ) {

  		denom *= j;

  	}

  	return nom / denom;

  }


  /*
  Calculate derivatives (0-nd) of rational curve. See The NURBS Book, page 127, algorithm A4.2.

  Pders : result of function calcBSplineDerivatives

  returns array with derivatives for rational curve.
  */
  function calcRationalCurveDerivatives( Pders ) {

  	const nd = Pders.length;
  	const Aders = [];
  	const wders = [];

  	for ( let i = 0; i < nd; ++ i ) {

  		const point = Pders[ i ];
  		Aders[ i ] = new Vector3( point.x, point.y, point.z );
  		wders[ i ] = point.w;

  	}

  	const CK = [];

  	for ( let k = 0; k < nd; ++ k ) {

  		const v = Aders[ k ].clone();

  		for ( let i = 1; i <= k; ++ i ) {

  			v.sub( CK[ k - i ].clone().multiplyScalar( calcKoverI( k, i ) * wders[ i ] ) );

  		}

  		CK[ k ] = v.divideScalar( wders[ 0 ] );

  	}

  	return CK;

  }


  /*
  Calculate NURBS curve derivatives. See The NURBS Book, page 127, algorithm A4.2.

  p  : degree
  U  : knot vector
  P  : control points in homogeneous space
  u  : parametric points
  nd : number of derivatives

  returns array with derivatives.
  */
  function calcNURBSDerivatives( p, U, P, u, nd ) {

  	const Pders = calcBSplineDerivatives( p, U, P, u, nd );
  	return calcRationalCurveDerivatives( Pders );

  }

  /**
   * NURBS curve object
   *
   * Derives from Curve, overriding getPoint and getTangent.
   *
   * Implementation is based on (x, y [, z=0 [, w=1]]) control points with w=weight.
   *
   **/

  class NURBSCurve extends Curve {

  	constructor(
  		degree,
  		knots /* array of reals */,
  		controlPoints /* array of Vector(2|3|4) */,
  		startKnot /* index in knots */,
  		endKnot /* index in knots */
  	) {

  		super();

  		this.degree = degree;
  		this.knots = knots;
  		this.controlPoints = [];
  		// Used by periodic NURBS to remove hidden spans
  		this.startKnot = startKnot || 0;
  		this.endKnot = endKnot || ( this.knots.length - 1 );

  		for ( let i = 0; i < controlPoints.length; ++ i ) {

  			// ensure Vector4 for control points
  			const point = controlPoints[ i ];
  			this.controlPoints[ i ] = new Vector4( point.x, point.y, point.z, point.w );

  		}

  	}

  	getPoint( t, optionalTarget = new Vector3() ) {

  		const point = optionalTarget;

  		const u = this.knots[ this.startKnot ] + t * ( this.knots[ this.endKnot ] - this.knots[ this.startKnot ] ); // linear mapping t->u

  		// following results in (wx, wy, wz, w) homogeneous point
  		const hpoint = calcBSplinePoint( this.degree, this.knots, this.controlPoints, u );

  		if ( hpoint.w !== 1.0 ) {

  			// project to 3D space: (wx, wy, wz, w) -> (x, y, z, 1)
  			hpoint.divideScalar( hpoint.w );

  		}

  		return point.set( hpoint.x, hpoint.y, hpoint.z );

  	}

  	getTangent( t, optionalTarget = new Vector3() ) {

  		const tangent = optionalTarget;

  		const u = this.knots[ 0 ] + t * ( this.knots[ this.knots.length - 1 ] - this.knots[ 0 ] );
  		const ders = calcNURBSDerivatives( this.degree, this.knots, this.controlPoints, u, 1 );
  		tangent.copy( ders[ 1 ] ).normalize();

  		return tangent;

  	}

  }

  /**
   * Loader loads FBX file and generates Group representing FBX scene.
   * Requires FBX file to be >= 7.0 and in ASCII or >= 6400 in Binary format
   * Versions lower than this may load but will probably have errors
   *
   * Needs Support:
   *  Morph normals / blend shape normals
   *
   * FBX format references:
   * 	https://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_index_html (C++ SDK reference)
   *
   * Binary format specification:
   *	https://code.blender.org/2013/08/fbx-binary-file-format-specification/
   */


  let fbxTree;
  let connections;
  let sceneGraph;

  class FBXLoader extends Loader {

  	constructor( manager ) {

  		super( manager );

  	}

  	load( url, onLoad, onProgress, onError ) {

  		const scope = this;

  		const path = ( scope.path === '' ) ? LoaderUtils.extractUrlBase( url ) : scope.path;

  		const loader = new FileLoader( this.manager );
  		loader.setPath( scope.path );
  		loader.setResponseType( 'arraybuffer' );
  		loader.setRequestHeader( scope.requestHeader );
  		loader.setWithCredentials( scope.withCredentials );

  		loader.load( url, function ( buffer ) {

  			try {

  				onLoad( scope.parse( buffer, path ) );

  			} catch ( e ) {

  				if ( onError ) {

  					onError( e );

  				} else {

  					console.error( e );

  				}

  				scope.manager.itemError( url );

  			}

  		}, onProgress, onError );

  	}

  	parse( FBXBuffer, path ) {

  		if ( isFbxFormatBinary( FBXBuffer ) ) {

  			fbxTree = new BinaryParser().parse( FBXBuffer );

  		} else {

  			const FBXText = convertArrayBufferToString( FBXBuffer );

  			if ( ! isFbxFormatASCII( FBXText ) ) {

  				throw new Error( 'THREE.FBXLoader: Unknown format.' );

  			}

  			if ( getFbxVersion( FBXText ) < 7000 ) {

  				throw new Error( 'THREE.FBXLoader: FBX version not supported, FileVersion: ' + getFbxVersion( FBXText ) );

  			}

  			fbxTree = new TextParser().parse( FBXText );

  		}

  		// console.log( fbxTree );

  		const textureLoader = new TextureLoader( this.manager ).setPath( this.resourcePath || path ).setCrossOrigin( this.crossOrigin );

  		return new FBXTreeParser( textureLoader, this.manager ).parse( fbxTree );

  	}

  }

  // Parse the FBXTree object returned by the BinaryParser or TextParser and return a Group
  class FBXTreeParser {

  	constructor( textureLoader, manager ) {

  		this.textureLoader = textureLoader;
  		this.manager = manager;

  	}

  	parse() {

  		connections = this.parseConnections();

  		const images = this.parseImages();
  		const textures = this.parseTextures( images );
  		const materials = this.parseMaterials( textures );
  		const deformers = this.parseDeformers();
  		const geometryMap = new GeometryParser().parse( deformers );

  		this.parseScene( deformers, geometryMap, materials );

  		return sceneGraph;

  	}

  	// Parses FBXTree.Connections which holds parent-child connections between objects (e.g. material -> texture, model->geometry )
  	// and details the connection type
  	parseConnections() {

  		const connectionMap = new Map();

  		if ( 'Connections' in fbxTree ) {

  			const rawConnections = fbxTree.Connections.connections;

  			rawConnections.forEach( function ( rawConnection ) {

  				const fromID = rawConnection[ 0 ];
  				const toID = rawConnection[ 1 ];
  				const relationship = rawConnection[ 2 ];

  				if ( ! connectionMap.has( fromID ) ) {

  					connectionMap.set( fromID, {
  						parents: [],
  						children: []
  					} );

  				}

  				const parentRelationship = { ID: toID, relationship: relationship };
  				connectionMap.get( fromID ).parents.push( parentRelationship );

  				if ( ! connectionMap.has( toID ) ) {

  					connectionMap.set( toID, {
  						parents: [],
  						children: []
  					} );

  				}

  				const childRelationship = { ID: fromID, relationship: relationship };
  				connectionMap.get( toID ).children.push( childRelationship );

  			} );

  		}

  		return connectionMap;

  	}

  	// Parse FBXTree.Objects.Video for embedded image data
  	// These images are connected to textures in FBXTree.Objects.Textures
  	// via FBXTree.Connections.
  	parseImages() {

  		const images = {};
  		const blobs = {};

  		if ( 'Video' in fbxTree.Objects ) {

  			const videoNodes = fbxTree.Objects.Video;

  			for ( const nodeID in videoNodes ) {

  				const videoNode = videoNodes[ nodeID ];

  				const id = parseInt( nodeID );

  				images[ id ] = videoNode.RelativeFilename || videoNode.Filename;

  				// raw image data is in videoNode.Content
  				if ( 'Content' in videoNode ) {

  					const arrayBufferContent = ( videoNode.Content instanceof ArrayBuffer ) && ( videoNode.Content.byteLength > 0 );
  					const base64Content = ( typeof videoNode.Content === 'string' ) && ( videoNode.Content !== '' );

  					if ( arrayBufferContent || base64Content ) {

  						const image = this.parseImage( videoNodes[ nodeID ] );

  						blobs[ videoNode.RelativeFilename || videoNode.Filename ] = image;

  					}

  				}

  			}

  		}

  		for ( const id in images ) {

  			const filename = images[ id ];

  			if ( blobs[ filename ] !== undefined ) images[ id ] = blobs[ filename ];
  			else images[ id ] = images[ id ].split( '\\' ).pop();

  		}

  		return images;

  	}

  	// Parse embedded image data in FBXTree.Video.Content
  	parseImage( videoNode ) {

  		const content = videoNode.Content;
  		const fileName = videoNode.RelativeFilename || videoNode.Filename;
  		const extension = fileName.slice( fileName.lastIndexOf( '.' ) + 1 ).toLowerCase();

  		let type;

  		switch ( extension ) {

  			case 'bmp':

  				type = 'image/bmp';
  				break;

  			case 'jpg':
  			case 'jpeg':

  				type = 'image/jpeg';
  				break;

  			case 'png':

  				type = 'image/png';
  				break;

  			case 'tif':

  				type = 'image/tiff';
  				break;

  			case 'tga':

  				if ( this.manager.getHandler( '.tga' ) === null ) {

  					console.warn( 'FBXLoader: TGA loader not found, skipping ', fileName );

  				}

  				type = 'image/tga';
  				break;

  			default:

  				console.warn( 'FBXLoader: Image type "' + extension + '" is not supported.' );
  				return;

  		}

  		if ( typeof content === 'string' ) { // ASCII format

  			return 'data:' + type + ';base64,' + content;

  		} else { // Binary Format

  			const array = new Uint8Array( content );
  			return window.URL.createObjectURL( new Blob( [ array ], { type: type } ) );

  		}

  	}

  	// Parse nodes in FBXTree.Objects.Texture
  	// These contain details such as UV scaling, cropping, rotation etc and are connected
  	// to images in FBXTree.Objects.Video
  	parseTextures( images ) {

  		const textureMap = new Map();

  		if ( 'Texture' in fbxTree.Objects ) {

  			const textureNodes = fbxTree.Objects.Texture;
  			for ( const nodeID in textureNodes ) {

  				const texture = this.parseTexture( textureNodes[ nodeID ], images );
  				textureMap.set( parseInt( nodeID ), texture );

  			}

  		}

  		return textureMap;

  	}

  	// Parse individual node in FBXTree.Objects.Texture
  	parseTexture( textureNode, images ) {

  		const texture = this.loadTexture( textureNode, images );

  		texture.ID = textureNode.id;

  		texture.name = textureNode.attrName;

  		const wrapModeU = textureNode.WrapModeU;
  		const wrapModeV = textureNode.WrapModeV;

  		const valueU = wrapModeU !== undefined ? wrapModeU.value : 0;
  		const valueV = wrapModeV !== undefined ? wrapModeV.value : 0;

  		// http://download.autodesk.com/us/fbx/SDKdocs/FBX_SDK_Help/files/fbxsdkref/class_k_fbx_texture.html#889640e63e2e681259ea81061b85143a
  		// 0: repeat(default), 1: clamp

  		texture.wrapS = valueU === 0 ? RepeatWrapping : ClampToEdgeWrapping;
  		texture.wrapT = valueV === 0 ? RepeatWrapping : ClampToEdgeWrapping;

  		if ( 'Scaling' in textureNode ) {

  			const values = textureNode.Scaling.value;

  			texture.repeat.x = values[ 0 ];
  			texture.repeat.y = values[ 1 ];

  		}

  		if ( 'Translation' in textureNode ) {

  			const values = textureNode.Translation.value;

  			texture.offset.x = values[ 0 ];
  			texture.offset.y = values[ 1 ];

  		}

  		return texture;

  	}

  	// load a texture specified as a blob or data URI, or via an external URL using TextureLoader
  	loadTexture( textureNode, images ) {

  		const nonNativeExtensions = new Set( [ 'tga', 'tif', 'tiff', 'exr', 'dds', 'hdr', 'ktx2' ] );

  		const extension = textureNode.FileName.split( '.' ).pop().toLowerCase();

  		const loader = nonNativeExtensions.has( extension ) ? this.manager.getHandler( `.${extension}` ) : this.textureLoader;

  		if ( ! loader ) {

  			console.warn(
  				`FBXLoader: ${extension.toUpperCase()} loader not found, creating placeholder texture for`,
  				textureNode.RelativeFilename
  			);
  			return new Texture();

  		}

  		const loaderPath = loader.path;

  		if ( ! loaderPath ) {

  			loader.setPath( this.textureLoader.path );

  		}

  		const children = connections.get( textureNode.id ).children;

  		let fileName;

  		if ( children !== undefined && children.length > 0 && images[ children[ 0 ].ID ] !== undefined ) {

  			fileName = images[ children[ 0 ].ID ];

  			if ( fileName.indexOf( 'blob:' ) === 0 || fileName.indexOf( 'data:' ) === 0 ) {

  				loader.setPath( undefined );

  			}

  		}

  		const texture = loader.load( fileName );

  		// revert to initial path
  		loader.setPath( loaderPath );

  		return texture;

  	}

  	// Parse nodes in FBXTree.Objects.Material
  	parseMaterials( textureMap ) {

  		const materialMap = new Map();

  		if ( 'Material' in fbxTree.Objects ) {

  			const materialNodes = fbxTree.Objects.Material;

  			for ( const nodeID in materialNodes ) {

  				const material = this.parseMaterial( materialNodes[ nodeID ], textureMap );

  				if ( material !== null ) materialMap.set( parseInt( nodeID ), material );

  			}

  		}

  		return materialMap;

  	}

  	// Parse single node in FBXTree.Objects.Material
  	// Materials are connected to texture maps in FBXTree.Objects.Textures
  	// FBX format currently only supports Lambert and Phong shading models
  	parseMaterial( materialNode, textureMap ) {

  		const ID = materialNode.id;
  		const name = materialNode.attrName;
  		let type = materialNode.ShadingModel;

  		// Case where FBX wraps shading model in property object.
  		if ( typeof type === 'object' ) {

  			type = type.value;

  		}

  		// Ignore unused materials which don't have any connections.
  		if ( ! connections.has( ID ) ) return null;

  		const parameters = this.parseParameters( materialNode, textureMap, ID );

  		let material;

  		switch ( type.toLowerCase() ) {

  			case 'phong':
  				material = new MeshPhongMaterial();
  				break;
  			case 'lambert':
  				material = new MeshLambertMaterial();
  				break;
  			default:
  				console.warn( 'THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.', type );
  				material = new MeshPhongMaterial();
  				break;

  		}

  		material.setValues( parameters );
  		material.name = name;

  		return material;

  	}

  	// Parse FBX material and return parameters suitable for a three.js material
  	// Also parse the texture map and return any textures associated with the material
  	parseParameters( materialNode, textureMap, ID ) {

  		const parameters = {};

  		if ( materialNode.BumpFactor ) {

  			parameters.bumpScale = materialNode.BumpFactor.value;

  		}

  		if ( materialNode.Diffuse ) {

  			parameters.color = new Color().fromArray( materialNode.Diffuse.value ).convertSRGBToLinear();

  		} else if ( materialNode.DiffuseColor && ( materialNode.DiffuseColor.type === 'Color' || materialNode.DiffuseColor.type === 'ColorRGB' ) ) {

  			// The blender exporter exports diffuse here instead of in materialNode.Diffuse
  			parameters.color = new Color().fromArray( materialNode.DiffuseColor.value ).convertSRGBToLinear();

  		}

  		if ( materialNode.DisplacementFactor ) {

  			parameters.displacementScale = materialNode.DisplacementFactor.value;

  		}

  		if ( materialNode.Emissive ) {

  			parameters.emissive = new Color().fromArray( materialNode.Emissive.value ).convertSRGBToLinear();

  		} else if ( materialNode.EmissiveColor && ( materialNode.EmissiveColor.type === 'Color' || materialNode.EmissiveColor.type === 'ColorRGB' ) ) {

  			// The blender exporter exports emissive color here instead of in materialNode.Emissive
  			parameters.emissive = new Color().fromArray( materialNode.EmissiveColor.value ).convertSRGBToLinear();

  		}

  		if ( materialNode.EmissiveFactor ) {

  			parameters.emissiveIntensity = parseFloat( materialNode.EmissiveFactor.value );

  		}

  		if ( materialNode.Opacity ) {

  			parameters.opacity = parseFloat( materialNode.Opacity.value );

  		}

  		if ( parameters.opacity < 1.0 ) {

  			parameters.transparent = true;

  		}

  		if ( materialNode.ReflectionFactor ) {

  			parameters.reflectivity = materialNode.ReflectionFactor.value;

  		}

  		if ( materialNode.Shininess ) {

  			parameters.shininess = materialNode.Shininess.value;

  		}

  		if ( materialNode.Specular ) {

  			parameters.specular = new Color().fromArray( materialNode.Specular.value ).convertSRGBToLinear();

  		} else if ( materialNode.SpecularColor && materialNode.SpecularColor.type === 'Color' ) {

  			// The blender exporter exports specular color here instead of in materialNode.Specular
  			parameters.specular = new Color().fromArray( materialNode.SpecularColor.value ).convertSRGBToLinear();

  		}

  		const scope = this;
  		connections.get( ID ).children.forEach( function ( child ) {

  			const type = child.relationship;

  			switch ( type ) {

  				case 'Bump':
  					parameters.bumpMap = scope.getTexture( textureMap, child.ID );
  					break;

  				case 'Maya|TEX_ao_map':
  					parameters.aoMap = scope.getTexture( textureMap, child.ID );
  					break;

  				case 'DiffuseColor':
  				case 'Maya|TEX_color_map':
  					parameters.map = scope.getTexture( textureMap, child.ID );
  					if ( parameters.map !== undefined ) {

  						parameters.map.colorSpace = SRGBColorSpace;

  					}

  					break;

  				case 'DisplacementColor':
  					parameters.displacementMap = scope.getTexture( textureMap, child.ID );
  					break;

  				case 'EmissiveColor':
  					parameters.emissiveMap = scope.getTexture( textureMap, child.ID );
  					if ( parameters.emissiveMap !== undefined ) {

  						parameters.emissiveMap.colorSpace = SRGBColorSpace;

  					}

  					break;

  				case 'NormalMap':
  				case 'Maya|TEX_normal_map':
  					parameters.normalMap = scope.getTexture( textureMap, child.ID );
  					break;

  				case 'ReflectionColor':
  					parameters.envMap = scope.getTexture( textureMap, child.ID );
  					if ( parameters.envMap !== undefined ) {

  						parameters.envMap.mapping = EquirectangularReflectionMapping;
  						parameters.envMap.colorSpace = SRGBColorSpace;

  					}

  					break;

  				case 'SpecularColor':
  					parameters.specularMap = scope.getTexture( textureMap, child.ID );
  					if ( parameters.specularMap !== undefined ) {

  						parameters.specularMap.colorSpace = SRGBColorSpace;

  					}

  					break;

  				case 'TransparentColor':
  				case 'TransparencyFactor':
  					parameters.alphaMap = scope.getTexture( textureMap, child.ID );
  					parameters.transparent = true;
  					break;

  				case 'AmbientColor':
  				case 'ShininessExponent': // AKA glossiness map
  				case 'SpecularFactor': // AKA specularLevel
  				case 'VectorDisplacementColor': // NOTE: Seems to be a copy of DisplacementColor
  				default:
  					console.warn( 'THREE.FBXLoader: %s map is not supported in three.js, skipping texture.', type );
  					break;

  			}

  		} );

  		return parameters;

  	}

  	// get a texture from the textureMap for use by a material.
  	getTexture( textureMap, id ) {

  		// if the texture is a layered texture, just use the first layer and issue a warning
  		if ( 'LayeredTexture' in fbxTree.Objects && id in fbxTree.Objects.LayeredTexture ) {

  			console.warn( 'THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer.' );
  			id = connections.get( id ).children[ 0 ].ID;

  		}

  		return textureMap.get( id );

  	}

  	// Parse nodes in FBXTree.Objects.Deformer
  	// Deformer node can contain skinning or Vertex Cache animation data, however only skinning is supported here
  	// Generates map of Skeleton-like objects for use later when generating and binding skeletons.
  	parseDeformers() {

  		const skeletons = {};
  		const morphTargets = {};

  		if ( 'Deformer' in fbxTree.Objects ) {

  			const DeformerNodes = fbxTree.Objects.Deformer;

  			for ( const nodeID in DeformerNodes ) {

  				const deformerNode = DeformerNodes[ nodeID ];

  				const relationships = connections.get( parseInt( nodeID ) );

  				if ( deformerNode.attrType === 'Skin' ) {

  					const skeleton = this.parseSkeleton( relationships, DeformerNodes );
  					skeleton.ID = nodeID;

  					if ( relationships.parents.length > 1 ) console.warn( 'THREE.FBXLoader: skeleton attached to more than one geometry is not supported.' );
  					skeleton.geometryID = relationships.parents[ 0 ].ID;

  					skeletons[ nodeID ] = skeleton;

  				} else if ( deformerNode.attrType === 'BlendShape' ) {

  					const morphTarget = {
  						id: nodeID,
  					};

  					morphTarget.rawTargets = this.parseMorphTargets( relationships, DeformerNodes );
  					morphTarget.id = nodeID;

  					if ( relationships.parents.length > 1 ) console.warn( 'THREE.FBXLoader: morph target attached to more than one geometry is not supported.' );

  					morphTargets[ nodeID ] = morphTarget;

  				}

  			}

  		}

  		return {

  			skeletons: skeletons,
  			morphTargets: morphTargets,

  		};

  	}

  	// Parse single nodes in FBXTree.Objects.Deformer
  	// The top level skeleton node has type 'Skin' and sub nodes have type 'Cluster'
  	// Each skin node represents a skeleton and each cluster node represents a bone
  	parseSkeleton( relationships, deformerNodes ) {

  		const rawBones = [];

  		relationships.children.forEach( function ( child ) {

  			const boneNode = deformerNodes[ child.ID ];

  			if ( boneNode.attrType !== 'Cluster' ) return;

  			const rawBone = {

  				ID: child.ID,
  				indices: [],
  				weights: [],
  				transformLink: new Matrix4().fromArray( boneNode.TransformLink.a ),
  				// transform: new Matrix4().fromArray( boneNode.Transform.a ),
  				// linkMode: boneNode.Mode,

  			};

  			if ( 'Indexes' in boneNode ) {

  				rawBone.indices = boneNode.Indexes.a;
  				rawBone.weights = boneNode.Weights.a;

  			}

  			rawBones.push( rawBone );

  		} );

  		return {

  			rawBones: rawBones,
  			bones: []

  		};

  	}

  	// The top level morph deformer node has type "BlendShape" and sub nodes have type "BlendShapeChannel"
  	parseMorphTargets( relationships, deformerNodes ) {

  		const rawMorphTargets = [];

  		for ( let i = 0; i < relationships.children.length; i ++ ) {

  			const child = relationships.children[ i ];

  			const morphTargetNode = deformerNodes[ child.ID ];

  			const rawMorphTarget = {

  				name: morphTargetNode.attrName,
  				initialWeight: morphTargetNode.DeformPercent,
  				id: morphTargetNode.id,
  				fullWeights: morphTargetNode.FullWeights.a

  			};

  			if ( morphTargetNode.attrType !== 'BlendShapeChannel' ) return;

  			rawMorphTarget.geoID = connections.get( parseInt( child.ID ) ).children.filter( function ( child ) {

  				return child.relationship === undefined;

  			} )[ 0 ].ID;

  			rawMorphTargets.push( rawMorphTarget );

  		}

  		return rawMorphTargets;

  	}

  	// create the main Group() to be returned by the loader
  	parseScene( deformers, geometryMap, materialMap ) {

  		sceneGraph = new Group();

  		const modelMap = this.parseModels( deformers.skeletons, geometryMap, materialMap );

  		const modelNodes = fbxTree.Objects.Model;

  		const scope = this;
  		modelMap.forEach( function ( model ) {

  			const modelNode = modelNodes[ model.ID ];
  			scope.setLookAtProperties( model, modelNode );

  			const parentConnections = connections.get( model.ID ).parents;

  			parentConnections.forEach( function ( connection ) {

  				const parent = modelMap.get( connection.ID );
  				if ( parent !== undefined ) parent.add( model );

  			} );

  			if ( model.parent === null ) {

  				sceneGraph.add( model );

  			}


  		} );

  		this.bindSkeleton( deformers.skeletons, geometryMap, modelMap );

  		this.addGlobalSceneSettings();

  		sceneGraph.traverse( function ( node ) {

  			if ( node.userData.transformData ) {

  				if ( node.parent ) {

  					node.userData.transformData.parentMatrix = node.parent.matrix;
  					node.userData.transformData.parentMatrixWorld = node.parent.matrixWorld;

  				}

  				const transform = generateTransform( node.userData.transformData );

  				node.applyMatrix4( transform );
  				node.updateWorldMatrix();

  			}

  		} );

  		const animations = new AnimationParser().parse();

  		// if all the models where already combined in a single group, just return that
  		if ( sceneGraph.children.length === 1 && sceneGraph.children[ 0 ].isGroup ) {

  			sceneGraph.children[ 0 ].animations = animations;
  			sceneGraph = sceneGraph.children[ 0 ];

  		}

  		sceneGraph.animations = animations;

  	}

  	// parse nodes in FBXTree.Objects.Model
  	parseModels( skeletons, geometryMap, materialMap ) {

  		const modelMap = new Map();
  		const modelNodes = fbxTree.Objects.Model;

  		for ( const nodeID in modelNodes ) {

  			const id = parseInt( nodeID );
  			const node = modelNodes[ nodeID ];
  			const relationships = connections.get( id );

  			let model = this.buildSkeleton( relationships, skeletons, id, node.attrName );

  			if ( ! model ) {

  				switch ( node.attrType ) {

  					case 'Camera':
  						model = this.createCamera( relationships );
  						break;
  					case 'Light':
  						model = this.createLight( relationships );
  						break;
  					case 'Mesh':
  						model = this.createMesh( relationships, geometryMap, materialMap );
  						break;
  					case 'NurbsCurve':
  						model = this.createCurve( relationships, geometryMap );
  						break;
  					case 'LimbNode':
  					case 'Root':
  						model = new Bone();
  						break;
  					case 'Null':
  					default:
  						model = new Group();
  						break;

  				}

  				model.name = node.attrName ? PropertyBinding.sanitizeNodeName( node.attrName ) : '';
  				model.userData.originalName = node.attrName;

  				model.ID = id;

  			}

  			this.getTransformData( model, node );
  			modelMap.set( id, model );

  		}

  		return modelMap;

  	}

  	buildSkeleton( relationships, skeletons, id, name ) {

  		let bone = null;

  		relationships.parents.forEach( function ( parent ) {

  			for ( const ID in skeletons ) {

  				const skeleton = skeletons[ ID ];

  				skeleton.rawBones.forEach( function ( rawBone, i ) {

  					if ( rawBone.ID === parent.ID ) {

  						const subBone = bone;
  						bone = new Bone();

  						bone.matrixWorld.copy( rawBone.transformLink );

  						// set name and id here - otherwise in cases where "subBone" is created it will not have a name / id

  						bone.name = name ? PropertyBinding.sanitizeNodeName( name ) : '';
  						bone.userData.originalName = name;
  						bone.ID = id;

  						skeleton.bones[ i ] = bone;

  						// In cases where a bone is shared between multiple meshes
  						// duplicate the bone here and and it as a child of the first bone
  						if ( subBone !== null ) {

  							bone.add( subBone );

  						}

  					}

  				} );

  			}

  		} );

  		return bone;

  	}

  	// create a PerspectiveCamera or OrthographicCamera
  	createCamera( relationships ) {

  		let model;
  		let cameraAttribute;

  		relationships.children.forEach( function ( child ) {

  			const attr = fbxTree.Objects.NodeAttribute[ child.ID ];

  			if ( attr !== undefined ) {

  				cameraAttribute = attr;

  			}

  		} );

  		if ( cameraAttribute === undefined ) {

  			model = new Object3D();

  		} else {

  			let type = 0;
  			if ( cameraAttribute.CameraProjectionType !== undefined && cameraAttribute.CameraProjectionType.value === 1 ) {

  				type = 1;

  			}

  			let nearClippingPlane = 1;
  			if ( cameraAttribute.NearPlane !== undefined ) {

  				nearClippingPlane = cameraAttribute.NearPlane.value / 1000;

  			}

  			let farClippingPlane = 1000;
  			if ( cameraAttribute.FarPlane !== undefined ) {

  				farClippingPlane = cameraAttribute.FarPlane.value / 1000;

  			}


  			let width = window.innerWidth;
  			let height = window.innerHeight;

  			if ( cameraAttribute.AspectWidth !== undefined && cameraAttribute.AspectHeight !== undefined ) {

  				width = cameraAttribute.AspectWidth.value;
  				height = cameraAttribute.AspectHeight.value;

  			}

  			const aspect = width / height;

  			let fov = 45;
  			if ( cameraAttribute.FieldOfView !== undefined ) {

  				fov = cameraAttribute.FieldOfView.value;

  			}

  			const focalLength = cameraAttribute.FocalLength ? cameraAttribute.FocalLength.value : null;

  			switch ( type ) {

  				case 0: // Perspective
  					model = new PerspectiveCamera( fov, aspect, nearClippingPlane, farClippingPlane );
  					if ( focalLength !== null ) model.setFocalLength( focalLength );
  					break;

  				case 1: // Orthographic
  					model = new OrthographicCamera( - width / 2, width / 2, height / 2, - height / 2, nearClippingPlane, farClippingPlane );
  					break;

  				default:
  					console.warn( 'THREE.FBXLoader: Unknown camera type ' + type + '.' );
  					model = new Object3D();
  					break;

  			}

  		}

  		return model;

  	}

  	// Create a DirectionalLight, PointLight or SpotLight
  	createLight( relationships ) {

  		let model;
  		let lightAttribute;

  		relationships.children.forEach( function ( child ) {

  			const attr = fbxTree.Objects.NodeAttribute[ child.ID ];

  			if ( attr !== undefined ) {

  				lightAttribute = attr;

  			}

  		} );

  		if ( lightAttribute === undefined ) {

  			model = new Object3D();

  		} else {

  			let type;

  			// LightType can be undefined for Point lights
  			if ( lightAttribute.LightType === undefined ) {

  				type = 0;

  			} else {

  				type = lightAttribute.LightType.value;

  			}

  			let color = 0xffffff;

  			if ( lightAttribute.Color !== undefined ) {

  				color = new Color().fromArray( lightAttribute.Color.value ).convertSRGBToLinear();

  			}

  			let intensity = ( lightAttribute.Intensity === undefined ) ? 1 : lightAttribute.Intensity.value / 100;

  			// light disabled
  			if ( lightAttribute.CastLightOnObject !== undefined && lightAttribute.CastLightOnObject.value === 0 ) {

  				intensity = 0;

  			}

  			let distance = 0;
  			if ( lightAttribute.FarAttenuationEnd !== undefined ) {

  				if ( lightAttribute.EnableFarAttenuation !== undefined && lightAttribute.EnableFarAttenuation.value === 0 ) {

  					distance = 0;

  				} else {

  					distance = lightAttribute.FarAttenuationEnd.value;

  				}

  			}

  			// TODO: could this be calculated linearly from FarAttenuationStart to FarAttenuationEnd?
  			const decay = 1;

  			switch ( type ) {

  				case 0: // Point
  					model = new PointLight( color, intensity, distance, decay );
  					break;

  				case 1: // Directional
  					model = new DirectionalLight( color, intensity );
  					break;

  				case 2: // Spot
  					let angle = Math.PI / 3;

  					if ( lightAttribute.InnerAngle !== undefined ) {

  						angle = MathUtils.degToRad( lightAttribute.InnerAngle.value );

  					}

  					let penumbra = 0;
  					if ( lightAttribute.OuterAngle !== undefined ) {

  						// TODO: this is not correct - FBX calculates outer and inner angle in degrees
  						// with OuterAngle > InnerAngle && OuterAngle <= Math.PI
  						// while three.js uses a penumbra between (0, 1) to attenuate the inner angle
  						penumbra = MathUtils.degToRad( lightAttribute.OuterAngle.value );
  						penumbra = Math.max( penumbra, 1 );

  					}

  					model = new SpotLight( color, intensity, distance, angle, penumbra, decay );
  					break;

  				default:
  					console.warn( 'THREE.FBXLoader: Unknown light type ' + lightAttribute.LightType.value + ', defaulting to a PointLight.' );
  					model = new PointLight( color, intensity );
  					break;

  			}

  			if ( lightAttribute.CastShadows !== undefined && lightAttribute.CastShadows.value === 1 ) {

  				model.castShadow = true;

  			}

  		}

  		return model;

  	}

  	createMesh( relationships, geometryMap, materialMap ) {

  		let model;
  		let geometry = null;
  		let material = null;
  		const materials = [];

  		// get geometry and materials(s) from connections
  		relationships.children.forEach( function ( child ) {

  			if ( geometryMap.has( child.ID ) ) {

  				geometry = geometryMap.get( child.ID );

  			}

  			if ( materialMap.has( child.ID ) ) {

  				materials.push( materialMap.get( child.ID ) );

  			}

  		} );

  		if ( materials.length > 1 ) {

  			material = materials;

  		} else if ( materials.length > 0 ) {

  			material = materials[ 0 ];

  		} else {

  			material = new MeshPhongMaterial( {
  				name: Loader.DEFAULT_MATERIAL_NAME,
  				color: 0xcccccc
  			} );
  			materials.push( material );

  		}

  		if ( 'color' in geometry.attributes ) {

  			materials.forEach( function ( material ) {

  				material.vertexColors = true;

  			} );

  		}

  		if ( geometry.FBX_Deformer ) {

  			model = new SkinnedMesh( geometry, material );
  			model.normalizeSkinWeights();

  		} else {

  			model = new Mesh( geometry, material );

  		}

  		return model;

  	}

  	createCurve( relationships, geometryMap ) {

  		const geometry = relationships.children.reduce( function ( geo, child ) {

  			if ( geometryMap.has( child.ID ) ) geo = geometryMap.get( child.ID );

  			return geo;

  		}, null );

  		// FBX does not list materials for Nurbs lines, so we'll just put our own in here.
  		const material = new LineBasicMaterial( {
  			name: Loader.DEFAULT_MATERIAL_NAME,
  			color: 0x3300ff,
  			linewidth: 1
  		} );
  		return new Line( geometry, material );

  	}

  	// parse the model node for transform data
  	getTransformData( model, modelNode ) {

  		const transformData = {};

  		if ( 'InheritType' in modelNode ) transformData.inheritType = parseInt( modelNode.InheritType.value );

  		if ( 'RotationOrder' in modelNode ) transformData.eulerOrder = getEulerOrder( modelNode.RotationOrder.value );
  		else transformData.eulerOrder = 'ZYX';

  		if ( 'Lcl_Translation' in modelNode ) transformData.translation = modelNode.Lcl_Translation.value;

  		if ( 'PreRotation' in modelNode ) transformData.preRotation = modelNode.PreRotation.value;
  		if ( 'Lcl_Rotation' in modelNode ) transformData.rotation = modelNode.Lcl_Rotation.value;
  		if ( 'PostRotation' in modelNode ) transformData.postRotation = modelNode.PostRotation.value;

  		if ( 'Lcl_Scaling' in modelNode ) transformData.scale = modelNode.Lcl_Scaling.value;

  		if ( 'ScalingOffset' in modelNode ) transformData.scalingOffset = modelNode.ScalingOffset.value;
  		if ( 'ScalingPivot' in modelNode ) transformData.scalingPivot = modelNode.ScalingPivot.value;

  		if ( 'RotationOffset' in modelNode ) transformData.rotationOffset = modelNode.RotationOffset.value;
  		if ( 'RotationPivot' in modelNode ) transformData.rotationPivot = modelNode.RotationPivot.value;

  		model.userData.transformData = transformData;

  	}

  	setLookAtProperties( model, modelNode ) {

  		if ( 'LookAtProperty' in modelNode ) {

  			const children = connections.get( model.ID ).children;

  			children.forEach( function ( child ) {

  				if ( child.relationship === 'LookAtProperty' ) {

  					const lookAtTarget = fbxTree.Objects.Model[ child.ID ];

  					if ( 'Lcl_Translation' in lookAtTarget ) {

  						const pos = lookAtTarget.Lcl_Translation.value;

  						// DirectionalLight, SpotLight
  						if ( model.target !== undefined ) {

  							model.target.position.fromArray( pos );
  							sceneGraph.add( model.target );

  						} else { // Cameras and other Object3Ds

  							model.lookAt( new Vector3().fromArray( pos ) );

  						}

  					}

  				}

  			} );

  		}

  	}

  	bindSkeleton( skeletons, geometryMap, modelMap ) {

  		const bindMatrices = this.parsePoseNodes();

  		for ( const ID in skeletons ) {

  			const skeleton = skeletons[ ID ];

  			const parents = connections.get( parseInt( skeleton.ID ) ).parents;

  			parents.forEach( function ( parent ) {

  				if ( geometryMap.has( parent.ID ) ) {

  					const geoID = parent.ID;
  					const geoRelationships = connections.get( geoID );

  					geoRelationships.parents.forEach( function ( geoConnParent ) {

  						if ( modelMap.has( geoConnParent.ID ) ) {

  							const model = modelMap.get( geoConnParent.ID );

  							model.bind( new Skeleton( skeleton.bones ), bindMatrices[ geoConnParent.ID ] );

  						}

  					} );

  				}

  			} );

  		}

  	}

  	parsePoseNodes() {

  		const bindMatrices = {};

  		if ( 'Pose' in fbxTree.Objects ) {

  			const BindPoseNode = fbxTree.Objects.Pose;

  			for ( const nodeID in BindPoseNode ) {

  				if ( BindPoseNode[ nodeID ].attrType === 'BindPose' && BindPoseNode[ nodeID ].NbPoseNodes > 0 ) {

  					const poseNodes = BindPoseNode[ nodeID ].PoseNode;

  					if ( Array.isArray( poseNodes ) ) {

  						poseNodes.forEach( function ( poseNode ) {

  							bindMatrices[ poseNode.Node ] = new Matrix4().fromArray( poseNode.Matrix.a );

  						} );

  					} else {

  						bindMatrices[ poseNodes.Node ] = new Matrix4().fromArray( poseNodes.Matrix.a );

  					}

  				}

  			}

  		}

  		return bindMatrices;

  	}

  	addGlobalSceneSettings() {

  		if ( 'GlobalSettings' in fbxTree ) {

  			if ( 'AmbientColor' in fbxTree.GlobalSettings ) {

  				// Parse ambient color - if it's not set to black (default), create an ambient light

  				const ambientColor = fbxTree.GlobalSettings.AmbientColor.value;
  				const r = ambientColor[ 0 ];
  				const g = ambientColor[ 1 ];
  				const b = ambientColor[ 2 ];

  				if ( r !== 0 || g !== 0 || b !== 0 ) {

  					const color = new Color( r, g, b ).convertSRGBToLinear();
  					sceneGraph.add( new AmbientLight( color, 1 ) );

  				}

  			}

  			if ( 'UnitScaleFactor' in fbxTree.GlobalSettings ) {

  				sceneGraph.userData.unitScaleFactor = fbxTree.GlobalSettings.UnitScaleFactor.value;

  			}

  		}

  	}

  }

  // parse Geometry data from FBXTree and return map of BufferGeometries
  class GeometryParser {

  	constructor() {

  		this.negativeMaterialIndices = false;

  	}

  	// Parse nodes in FBXTree.Objects.Geometry
  	parse( deformers ) {

  		const geometryMap = new Map();

  		if ( 'Geometry' in fbxTree.Objects ) {

  			const geoNodes = fbxTree.Objects.Geometry;

  			for ( const nodeID in geoNodes ) {

  				const relationships = connections.get( parseInt( nodeID ) );
  				const geo = this.parseGeometry( relationships, geoNodes[ nodeID ], deformers );

  				geometryMap.set( parseInt( nodeID ), geo );

  			}

  		}

  		// report warnings

  		if ( this.negativeMaterialIndices === true ) {

  			console.warn( 'THREE.FBXLoader: The FBX file contains invalid (negative) material indices. The asset might not render as expected.' );

  		}

  		return geometryMap;

  	}

  	// Parse single node in FBXTree.Objects.Geometry
  	parseGeometry( relationships, geoNode, deformers ) {

  		switch ( geoNode.attrType ) {

  			case 'Mesh':
  				return this.parseMeshGeometry( relationships, geoNode, deformers );

  			case 'NurbsCurve':
  				return this.parseNurbsGeometry( geoNode );

  		}

  	}

  	// Parse single node mesh geometry in FBXTree.Objects.Geometry
  	parseMeshGeometry( relationships, geoNode, deformers ) {

  		const skeletons = deformers.skeletons;
  		const morphTargets = [];

  		const modelNodes = relationships.parents.map( function ( parent ) {

  			return fbxTree.Objects.Model[ parent.ID ];

  		} );

  		// don't create geometry if it is not associated with any models
  		if ( modelNodes.length === 0 ) return;

  		const skeleton = relationships.children.reduce( function ( skeleton, child ) {

  			if ( skeletons[ child.ID ] !== undefined ) skeleton = skeletons[ child.ID ];

  			return skeleton;

  		}, null );

  		relationships.children.forEach( function ( child ) {

  			if ( deformers.morphTargets[ child.ID ] !== undefined ) {

  				morphTargets.push( deformers.morphTargets[ child.ID ] );

  			}

  		} );

  		// Assume one model and get the preRotation from that
  		// if there is more than one model associated with the geometry this may cause problems
  		const modelNode = modelNodes[ 0 ];

  		const transformData = {};

  		if ( 'RotationOrder' in modelNode ) transformData.eulerOrder = getEulerOrder( modelNode.RotationOrder.value );
  		if ( 'InheritType' in modelNode ) transformData.inheritType = parseInt( modelNode.InheritType.value );

  		if ( 'GeometricTranslation' in modelNode ) transformData.translation = modelNode.GeometricTranslation.value;
  		if ( 'GeometricRotation' in modelNode ) transformData.rotation = modelNode.GeometricRotation.value;
  		if ( 'GeometricScaling' in modelNode ) transformData.scale = modelNode.GeometricScaling.value;

  		const transform = generateTransform( transformData );

  		return this.genGeometry( geoNode, skeleton, morphTargets, transform );

  	}

  	// Generate a BufferGeometry from a node in FBXTree.Objects.Geometry
  	genGeometry( geoNode, skeleton, morphTargets, preTransform ) {

  		const geo = new BufferGeometry();
  		if ( geoNode.attrName ) geo.name = geoNode.attrName;

  		const geoInfo = this.parseGeoNode( geoNode, skeleton );
  		const buffers = this.genBuffers( geoInfo );

  		const positionAttribute = new Float32BufferAttribute( buffers.vertex, 3 );

  		positionAttribute.applyMatrix4( preTransform );

  		geo.setAttribute( 'position', positionAttribute );

  		if ( buffers.colors.length > 0 ) {

  			geo.setAttribute( 'color', new Float32BufferAttribute( buffers.colors, 3 ) );

  		}

  		if ( skeleton ) {

  			geo.setAttribute( 'skinIndex', new Uint16BufferAttribute( buffers.weightsIndices, 4 ) );

  			geo.setAttribute( 'skinWeight', new Float32BufferAttribute( buffers.vertexWeights, 4 ) );

  			// used later to bind the skeleton to the model
  			geo.FBX_Deformer = skeleton;

  		}

  		if ( buffers.normal.length > 0 ) {

  			const normalMatrix = new Matrix3().getNormalMatrix( preTransform );

  			const normalAttribute = new Float32BufferAttribute( buffers.normal, 3 );
  			normalAttribute.applyNormalMatrix( normalMatrix );

  			geo.setAttribute( 'normal', normalAttribute );

  		}

  		buffers.uvs.forEach( function ( uvBuffer, i ) {

  			const name = i === 0 ? 'uv' : `uv${ i }`;

  			geo.setAttribute( name, new Float32BufferAttribute( buffers.uvs[ i ], 2 ) );

  		} );

  		if ( geoInfo.material && geoInfo.material.mappingType !== 'AllSame' ) {

  			// Convert the material indices of each vertex into rendering groups on the geometry.
  			let prevMaterialIndex = buffers.materialIndex[ 0 ];
  			let startIndex = 0;

  			buffers.materialIndex.forEach( function ( currentIndex, i ) {

  				if ( currentIndex !== prevMaterialIndex ) {

  					geo.addGroup( startIndex, i - startIndex, prevMaterialIndex );

  					prevMaterialIndex = currentIndex;
  					startIndex = i;

  				}

  			} );

  			// the loop above doesn't add the last group, do that here.
  			if ( geo.groups.length > 0 ) {

  				const lastGroup = geo.groups[ geo.groups.length - 1 ];
  				const lastIndex = lastGroup.start + lastGroup.count;

  				if ( lastIndex !== buffers.materialIndex.length ) {

  					geo.addGroup( lastIndex, buffers.materialIndex.length - lastIndex, prevMaterialIndex );

  				}

  			}

  			// case where there are multiple materials but the whole geometry is only
  			// using one of them
  			if ( geo.groups.length === 0 ) {

  				geo.addGroup( 0, buffers.materialIndex.length, buffers.materialIndex[ 0 ] );

  			}

  		}

  		this.addMorphTargets( geo, geoNode, morphTargets, preTransform );

  		return geo;

  	}

  	parseGeoNode( geoNode, skeleton ) {

  		const geoInfo = {};

  		geoInfo.vertexPositions = ( geoNode.Vertices !== undefined ) ? geoNode.Vertices.a : [];
  		geoInfo.vertexIndices = ( geoNode.PolygonVertexIndex !== undefined ) ? geoNode.PolygonVertexIndex.a : [];

  		if ( geoNode.LayerElementColor ) {

  			geoInfo.color = this.parseVertexColors( geoNode.LayerElementColor[ 0 ] );

  		}

  		if ( geoNode.LayerElementMaterial ) {

  			geoInfo.material = this.parseMaterialIndices( geoNode.LayerElementMaterial[ 0 ] );

  		}

  		if ( geoNode.LayerElementNormal ) {

  			geoInfo.normal = this.parseNormals( geoNode.LayerElementNormal[ 0 ] );

  		}

  		if ( geoNode.LayerElementUV ) {

  			geoInfo.uv = [];

  			let i = 0;
  			while ( geoNode.LayerElementUV[ i ] ) {

  				if ( geoNode.LayerElementUV[ i ].UV ) {

  					geoInfo.uv.push( this.parseUVs( geoNode.LayerElementUV[ i ] ) );

  				}

  				i ++;

  			}

  		}

  		geoInfo.weightTable = {};

  		if ( skeleton !== null ) {

  			geoInfo.skeleton = skeleton;

  			skeleton.rawBones.forEach( function ( rawBone, i ) {

  				// loop over the bone's vertex indices and weights
  				rawBone.indices.forEach( function ( index, j ) {

  					if ( geoInfo.weightTable[ index ] === undefined ) geoInfo.weightTable[ index ] = [];

  					geoInfo.weightTable[ index ].push( {

  						id: i,
  						weight: rawBone.weights[ j ],

  					} );

  				} );

  			} );

  		}

  		return geoInfo;

  	}

  	genBuffers( geoInfo ) {

  		const buffers = {
  			vertex: [],
  			normal: [],
  			colors: [],
  			uvs: [],
  			materialIndex: [],
  			vertexWeights: [],
  			weightsIndices: [],
  		};

  		let polygonIndex = 0;
  		let faceLength = 0;
  		let displayedWeightsWarning = false;

  		// these will hold data for a single face
  		let facePositionIndexes = [];
  		let faceNormals = [];
  		let faceColors = [];
  		let faceUVs = [];
  		let faceWeights = [];
  		let faceWeightIndices = [];

  		const scope = this;
  		geoInfo.vertexIndices.forEach( function ( vertexIndex, polygonVertexIndex ) {

  			let materialIndex;
  			let endOfFace = false;

  			// Face index and vertex index arrays are combined in a single array
  			// A cube with quad faces looks like this:
  			// PolygonVertexIndex: *24 {
  			//  a: 0, 1, 3, -3, 2, 3, 5, -5, 4, 5, 7, -7, 6, 7, 1, -1, 1, 7, 5, -4, 6, 0, 2, -5
  			//  }
  			// Negative numbers mark the end of a face - first face here is 0, 1, 3, -3
  			// to find index of last vertex bit shift the index: ^ - 1
  			if ( vertexIndex < 0 ) {

  				vertexIndex = vertexIndex ^ - 1; // equivalent to ( x * -1 ) - 1
  				endOfFace = true;

  			}

  			let weightIndices = [];
  			let weights = [];

  			facePositionIndexes.push( vertexIndex * 3, vertexIndex * 3 + 1, vertexIndex * 3 + 2 );

  			if ( geoInfo.color ) {

  				const data = getData( polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.color );

  				faceColors.push( data[ 0 ], data[ 1 ], data[ 2 ] );

  			}

  			if ( geoInfo.skeleton ) {

  				if ( geoInfo.weightTable[ vertexIndex ] !== undefined ) {

  					geoInfo.weightTable[ vertexIndex ].forEach( function ( wt ) {

  						weights.push( wt.weight );
  						weightIndices.push( wt.id );

  					} );


  				}

  				if ( weights.length > 4 ) {

  					if ( ! displayedWeightsWarning ) {

  						console.warn( 'THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights.' );
  						displayedWeightsWarning = true;

  					}

  					const wIndex = [ 0, 0, 0, 0 ];
  					const Weight = [ 0, 0, 0, 0 ];

  					weights.forEach( function ( weight, weightIndex ) {

  						let currentWeight = weight;
  						let currentIndex = weightIndices[ weightIndex ];

  						Weight.forEach( function ( comparedWeight, comparedWeightIndex, comparedWeightArray ) {

  							if ( currentWeight > comparedWeight ) {

  								comparedWeightArray[ comparedWeightIndex ] = currentWeight;
  								currentWeight = comparedWeight;

  								const tmp = wIndex[ comparedWeightIndex ];
  								wIndex[ comparedWeightIndex ] = currentIndex;
  								currentIndex = tmp;

  							}

  						} );

  					} );

  					weightIndices = wIndex;
  					weights = Weight;

  				}

  				// if the weight array is shorter than 4 pad with 0s
  				while ( weights.length < 4 ) {

  					weights.push( 0 );
  					weightIndices.push( 0 );

  				}

  				for ( let i = 0; i < 4; ++ i ) {

  					faceWeights.push( weights[ i ] );
  					faceWeightIndices.push( weightIndices[ i ] );

  				}

  			}

  			if ( geoInfo.normal ) {

  				const data = getData( polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.normal );

  				faceNormals.push( data[ 0 ], data[ 1 ], data[ 2 ] );

  			}

  			if ( geoInfo.material && geoInfo.material.mappingType !== 'AllSame' ) {

  				materialIndex = getData( polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.material )[ 0 ];

  				if ( materialIndex < 0 ) {

  					scope.negativeMaterialIndices = true;
  					materialIndex = 0; // fallback

  				}

  			}

  			if ( geoInfo.uv ) {

  				geoInfo.uv.forEach( function ( uv, i ) {

  					const data = getData( polygonVertexIndex, polygonIndex, vertexIndex, uv );

  					if ( faceUVs[ i ] === undefined ) {

  						faceUVs[ i ] = [];

  					}

  					faceUVs[ i ].push( data[ 0 ] );
  					faceUVs[ i ].push( data[ 1 ] );

  				} );

  			}

  			faceLength ++;

  			if ( endOfFace ) {

  				scope.genFace( buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength );

  				polygonIndex ++;
  				faceLength = 0;

  				// reset arrays for the next face
  				facePositionIndexes = [];
  				faceNormals = [];
  				faceColors = [];
  				faceUVs = [];
  				faceWeights = [];
  				faceWeightIndices = [];

  			}

  		} );

  		return buffers;

  	}

  	// See https://www.khronos.org/opengl/wiki/Calculating_a_Surface_Normal
  	getNormalNewell( vertices ) {

  		const normal = new Vector3( 0.0, 0.0, 0.0 );

  		for ( let i = 0; i < vertices.length; i ++ ) {

  			const current = vertices[ i ];
  			const next = vertices[ ( i + 1 ) % vertices.length ];

  			normal.x += ( current.y - next.y ) * ( current.z + next.z );
  			normal.y += ( current.z - next.z ) * ( current.x + next.x );
  			normal.z += ( current.x - next.x ) * ( current.y + next.y );

  		}

  		normal.normalize();

  		return normal;

  	}

  	getNormalTangentAndBitangent( vertices ) {

  		const normalVector = this.getNormalNewell( vertices );
  		// Avoid up being equal or almost equal to normalVector
  		const up = Math.abs( normalVector.z ) > 0.5 ? new Vector3( 0.0, 1.0, 0.0 ) : new Vector3( 0.0, 0.0, 1.0 );
  		const tangent = up.cross( normalVector ).normalize();
  		const bitangent = normalVector.clone().cross( tangent ).normalize();

  		return {
  			normal: normalVector,
  			tangent: tangent,
  			bitangent: bitangent
  		};

  	}

  	flattenVertex( vertex, normalTangent, normalBitangent ) {

  		return new Vector2(
  			vertex.dot( normalTangent ),
  			vertex.dot( normalBitangent )
  		);

  	}

  	// Generate data for a single face in a geometry. If the face is a quad then split it into 2 tris
  	genFace( buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength ) {

  		let triangles;

  		if ( faceLength > 3 ) {

  			// Triangulate n-gon using earcut

  			const vertices = [];
  			// in morphing scenario vertexPositions represent morphPositions
  			// while baseVertexPositions represent the original geometry's positions
  			const positions = geoInfo.baseVertexPositions || geoInfo.vertexPositions;
  			for ( let i = 0; i < facePositionIndexes.length; i += 3 ) {

  				vertices.push(
  					new Vector3(
  						positions[ facePositionIndexes[ i ] ],
  						positions[ facePositionIndexes[ i + 1 ] ],
  						positions[ facePositionIndexes[ i + 2 ] ]
  					)
  				);

  			}

  			const { tangent, bitangent } = this.getNormalTangentAndBitangent( vertices );
  			const triangulationInput = [];

  			for ( const vertex of vertices ) {

  				triangulationInput.push( this.flattenVertex( vertex, tangent, bitangent ) );

  			}

  			// When vertices is an array of [0,0,0] elements (which is the case for vertices not participating in morph)
  			// the triangulationInput will be an array of [0,0] elements
  			// resulting in an array of 0 triangles being returned from ShapeUtils.triangulateShape
  			// leading to not pushing into buffers.vertex the redundant vertices (the vertices that are not morphed).
  			// That's why, in order to support morphing scenario, "positions" is looking first for baseVertexPositions,
  			// so that we don't end up with an array of 0 triangles for the faces not participating in morph.
  			triangles = ShapeUtils.triangulateShape( triangulationInput, [] );

  		} else {

  			// Regular triangle, skip earcut triangulation step
  			triangles = [[ 0, 1, 2 ]];

  		}

  		for ( const [ i0, i1, i2 ] of triangles ) {

  			buffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i0 * 3 ] ] );
  			buffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i0 * 3 + 1 ] ] );
  			buffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i0 * 3 + 2 ] ] );

  			buffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i1 * 3 ] ] );
  			buffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i1 * 3 + 1 ] ] );
  			buffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i1 * 3 + 2 ] ] );

  			buffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i2 * 3 ] ] );
  			buffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i2 * 3 + 1 ] ] );
  			buffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i2 * 3 + 2 ] ] );

  			if ( geoInfo.skeleton ) {

  				buffers.vertexWeights.push( faceWeights[ i0 * 4 ] );
  				buffers.vertexWeights.push( faceWeights[ i0 * 4 + 1 ] );
  				buffers.vertexWeights.push( faceWeights[ i0 * 4 + 2 ] );
  				buffers.vertexWeights.push( faceWeights[ i0 * 4 + 3 ] );

  				buffers.vertexWeights.push( faceWeights[ i1 * 4 ] );
  				buffers.vertexWeights.push( faceWeights[ i1 * 4 + 1 ] );
  				buffers.vertexWeights.push( faceWeights[ i1 * 4 + 2 ] );
  				buffers.vertexWeights.push( faceWeights[ i1 * 4 + 3 ] );

  				buffers.vertexWeights.push( faceWeights[ i2 * 4 ] );
  				buffers.vertexWeights.push( faceWeights[ i2 * 4 + 1 ] );
  				buffers.vertexWeights.push( faceWeights[ i2 * 4 + 2 ] );
  				buffers.vertexWeights.push( faceWeights[ i2 * 4 + 3 ] );

  				buffers.weightsIndices.push( faceWeightIndices[ i0 * 4 ] );
  				buffers.weightsIndices.push( faceWeightIndices[ i0 * 4 + 1 ] );
  				buffers.weightsIndices.push( faceWeightIndices[ i0 * 4 + 2 ] );
  				buffers.weightsIndices.push( faceWeightIndices[ i0 * 4 + 3 ] );

  				buffers.weightsIndices.push( faceWeightIndices[ i1 * 4 ] );
  				buffers.weightsIndices.push( faceWeightIndices[ i1 * 4 + 1 ] );
  				buffers.weightsIndices.push( faceWeightIndices[ i1 * 4 + 2 ] );
  				buffers.weightsIndices.push( faceWeightIndices[ i1 * 4 + 3 ] );

  				buffers.weightsIndices.push( faceWeightIndices[ i2 * 4 ] );
  				buffers.weightsIndices.push( faceWeightIndices[ i2 * 4 + 1 ] );
  				buffers.weightsIndices.push( faceWeightIndices[ i2 * 4 + 2 ] );
  				buffers.weightsIndices.push( faceWeightIndices[ i2 * 4 + 3 ] );

  			}

  			if ( geoInfo.color ) {

  				buffers.colors.push( faceColors[ i0 * 3 ] );
  				buffers.colors.push( faceColors[ i0 * 3 + 1 ] );
  				buffers.colors.push( faceColors[ i0 * 3 + 2 ] );

  				buffers.colors.push( faceColors[ i1 * 3 ] );
  				buffers.colors.push( faceColors[ i1 * 3 + 1 ] );
  				buffers.colors.push( faceColors[ i1 * 3 + 2 ] );

  				buffers.colors.push( faceColors[ i2 * 3 ] );
  				buffers.colors.push( faceColors[ i2 * 3 + 1 ] );
  				buffers.colors.push( faceColors[ i2 * 3 + 2 ] );

  			}

  			if ( geoInfo.material && geoInfo.material.mappingType !== 'AllSame' ) {

  				buffers.materialIndex.push( materialIndex );
  				buffers.materialIndex.push( materialIndex );
  				buffers.materialIndex.push( materialIndex );

  			}

  			if ( geoInfo.normal ) {

  				buffers.normal.push( faceNormals[ i0 * 3 ] );
  				buffers.normal.push( faceNormals[ i0 * 3 + 1 ] );
  				buffers.normal.push( faceNormals[ i0 * 3 + 2 ] );

  				buffers.normal.push( faceNormals[ i1 * 3 ] );
  				buffers.normal.push( faceNormals[ i1 * 3 + 1 ] );
  				buffers.normal.push( faceNormals[ i1 * 3 + 2 ] );

  				buffers.normal.push( faceNormals[ i2 * 3 ] );
  				buffers.normal.push( faceNormals[ i2 * 3 + 1 ] );
  				buffers.normal.push( faceNormals[ i2 * 3 + 2 ] );

  			}

  			if ( geoInfo.uv ) {

  				geoInfo.uv.forEach( function ( uv, j ) {

  					if ( buffers.uvs[ j ] === undefined ) buffers.uvs[ j ] = [];

  					buffers.uvs[ j ].push( faceUVs[ j ][ i0 * 2 ] );
  					buffers.uvs[ j ].push( faceUVs[ j ][ i0 * 2 + 1 ] );

  					buffers.uvs[ j ].push( faceUVs[ j ][ i1 * 2 ] );
  					buffers.uvs[ j ].push( faceUVs[ j ][ i1 * 2 + 1 ] );

  					buffers.uvs[ j ].push( faceUVs[ j ][ i2 * 2 ] );
  					buffers.uvs[ j ].push( faceUVs[ j ][ i2 * 2 + 1 ] );

  				} );

  			}

  		}

  	}

  	addMorphTargets( parentGeo, parentGeoNode, morphTargets, preTransform ) {

  		if ( morphTargets.length === 0 ) return;

  		parentGeo.morphTargetsRelative = true;

  		parentGeo.morphAttributes.position = [];
  		// parentGeo.morphAttributes.normal = []; // not implemented

  		const scope = this;
  		morphTargets.forEach( function ( morphTarget ) {

  			morphTarget.rawTargets.forEach( function ( rawTarget ) {

  				const morphGeoNode = fbxTree.Objects.Geometry[ rawTarget.geoID ];

  				if ( morphGeoNode !== undefined ) {

  					scope.genMorphGeometry( parentGeo, parentGeoNode, morphGeoNode, preTransform, rawTarget.name );

  				}

  			} );

  		} );

  	}

  	// a morph geometry node is similar to a standard  node, and the node is also contained
  	// in FBXTree.Objects.Geometry, however it can only have attributes for position, normal
  	// and a special attribute Index defining which vertices of the original geometry are affected
  	// Normal and position attributes only have data for the vertices that are affected by the morph
  	genMorphGeometry( parentGeo, parentGeoNode, morphGeoNode, preTransform, name ) {

  		const basePositions = parentGeoNode.Vertices !== undefined ? parentGeoNode.Vertices.a : [];
  		const baseIndices = parentGeoNode.PolygonVertexIndex !== undefined ? parentGeoNode.PolygonVertexIndex.a : [];

  		const morphPositionsSparse = morphGeoNode.Vertices !== undefined ? morphGeoNode.Vertices.a : [];
  		const morphIndices = morphGeoNode.Indexes !== undefined ? morphGeoNode.Indexes.a : [];

  		const length = parentGeo.attributes.position.count * 3;
  		const morphPositions = new Float32Array( length );

  		for ( let i = 0; i < morphIndices.length; i ++ ) {

  			const morphIndex = morphIndices[ i ] * 3;

  			morphPositions[ morphIndex ] = morphPositionsSparse[ i * 3 ];
  			morphPositions[ morphIndex + 1 ] = morphPositionsSparse[ i * 3 + 1 ];
  			morphPositions[ morphIndex + 2 ] = morphPositionsSparse[ i * 3 + 2 ];

  		}

  		// TODO: add morph normal support
  		const morphGeoInfo = {
  			vertexIndices: baseIndices,
  			vertexPositions: morphPositions,
  			baseVertexPositions: basePositions
  		};

  		const morphBuffers = this.genBuffers( morphGeoInfo );

  		const positionAttribute = new Float32BufferAttribute( morphBuffers.vertex, 3 );
  		positionAttribute.name = name || morphGeoNode.attrName;

  		positionAttribute.applyMatrix4( preTransform );

  		parentGeo.morphAttributes.position.push( positionAttribute );

  	}

  	// Parse normal from FBXTree.Objects.Geometry.LayerElementNormal if it exists
  	parseNormals( NormalNode ) {

  		const mappingType = NormalNode.MappingInformationType;
  		const referenceType = NormalNode.ReferenceInformationType;
  		const buffer = NormalNode.Normals.a;
  		let indexBuffer = [];
  		if ( referenceType === 'IndexToDirect' ) {

  			if ( 'NormalIndex' in NormalNode ) {

  				indexBuffer = NormalNode.NormalIndex.a;

  			} else if ( 'NormalsIndex' in NormalNode ) {

  				indexBuffer = NormalNode.NormalsIndex.a;

  			}

  		}

  		return {
  			dataSize: 3,
  			buffer: buffer,
  			indices: indexBuffer,
  			mappingType: mappingType,
  			referenceType: referenceType
  		};

  	}

  	// Parse UVs from FBXTree.Objects.Geometry.LayerElementUV if it exists
  	parseUVs( UVNode ) {

  		const mappingType = UVNode.MappingInformationType;
  		const referenceType = UVNode.ReferenceInformationType;
  		const buffer = UVNode.UV.a;
  		let indexBuffer = [];
  		if ( referenceType === 'IndexToDirect' ) {

  			indexBuffer = UVNode.UVIndex.a;

  		}

  		return {
  			dataSize: 2,
  			buffer: buffer,
  			indices: indexBuffer,
  			mappingType: mappingType,
  			referenceType: referenceType
  		};

  	}

  	// Parse Vertex Colors from FBXTree.Objects.Geometry.LayerElementColor if it exists
  	parseVertexColors( ColorNode ) {

  		const mappingType = ColorNode.MappingInformationType;
  		const referenceType = ColorNode.ReferenceInformationType;
  		const buffer = ColorNode.Colors.a;
  		let indexBuffer = [];
  		if ( referenceType === 'IndexToDirect' ) {

  			indexBuffer = ColorNode.ColorIndex.a;

  		}

  		for ( let i = 0, c = new Color(); i < buffer.length; i += 4 ) {

  			c.fromArray( buffer, i ).convertSRGBToLinear().toArray( buffer, i );

  		}

  		return {
  			dataSize: 4,
  			buffer: buffer,
  			indices: indexBuffer,
  			mappingType: mappingType,
  			referenceType: referenceType
  		};

  	}

  	// Parse mapping and material data in FBXTree.Objects.Geometry.LayerElementMaterial if it exists
  	parseMaterialIndices( MaterialNode ) {

  		const mappingType = MaterialNode.MappingInformationType;
  		const referenceType = MaterialNode.ReferenceInformationType;

  		if ( mappingType === 'NoMappingInformation' ) {

  			return {
  				dataSize: 1,
  				buffer: [ 0 ],
  				indices: [ 0 ],
  				mappingType: 'AllSame',
  				referenceType: referenceType
  			};

  		}

  		const materialIndexBuffer = MaterialNode.Materials.a;

  		// Since materials are stored as indices, there's a bit of a mismatch between FBX and what
  		// we expect.So we create an intermediate buffer that points to the index in the buffer,
  		// for conforming with the other functions we've written for other data.
  		const materialIndices = [];

  		for ( let i = 0; i < materialIndexBuffer.length; ++ i ) {

  			materialIndices.push( i );

  		}

  		return {
  			dataSize: 1,
  			buffer: materialIndexBuffer,
  			indices: materialIndices,
  			mappingType: mappingType,
  			referenceType: referenceType
  		};

  	}

  	// Generate a NurbGeometry from a node in FBXTree.Objects.Geometry
  	parseNurbsGeometry( geoNode ) {

  		const order = parseInt( geoNode.Order );

  		if ( isNaN( order ) ) {

  			console.error( 'THREE.FBXLoader: Invalid Order %s given for geometry ID: %s', geoNode.Order, geoNode.id );
  			return new BufferGeometry();

  		}

  		const degree = order - 1;

  		const knots = geoNode.KnotVector.a;
  		const controlPoints = [];
  		const pointsValues = geoNode.Points.a;

  		for ( let i = 0, l = pointsValues.length; i < l; i += 4 ) {

  			controlPoints.push( new Vector4().fromArray( pointsValues, i ) );

  		}

  		let startKnot, endKnot;

  		if ( geoNode.Form === 'Closed' ) {

  			controlPoints.push( controlPoints[ 0 ] );

  		} else if ( geoNode.Form === 'Periodic' ) {

  			startKnot = degree;
  			endKnot = knots.length - 1 - startKnot;

  			for ( let i = 0; i < degree; ++ i ) {

  				controlPoints.push( controlPoints[ i ] );

  			}

  		}

  		const curve = new NURBSCurve( degree, knots, controlPoints, startKnot, endKnot );
  		const points = curve.getPoints( controlPoints.length * 12 );

  		return new BufferGeometry().setFromPoints( points );

  	}

  }

  // parse animation data from FBXTree
  class AnimationParser {

  	// take raw animation clips and turn them into three.js animation clips
  	parse() {

  		const animationClips = [];

  		const rawClips = this.parseClips();

  		if ( rawClips !== undefined ) {

  			for ( const key in rawClips ) {

  				const rawClip = rawClips[ key ];

  				const clip = this.addClip( rawClip );

  				animationClips.push( clip );

  			}

  		}

  		return animationClips;

  	}

  	parseClips() {

  		// since the actual transformation data is stored in FBXTree.Objects.AnimationCurve,
  		// if this is undefined we can safely assume there are no animations
  		if ( fbxTree.Objects.AnimationCurve === undefined ) return undefined;

  		const curveNodesMap = this.parseAnimationCurveNodes();

  		this.parseAnimationCurves( curveNodesMap );

  		const layersMap = this.parseAnimationLayers( curveNodesMap );
  		const rawClips = this.parseAnimStacks( layersMap );

  		return rawClips;

  	}

  	// parse nodes in FBXTree.Objects.AnimationCurveNode
  	// each AnimationCurveNode holds data for an animation transform for a model (e.g. left arm rotation )
  	// and is referenced by an AnimationLayer
  	parseAnimationCurveNodes() {

  		const rawCurveNodes = fbxTree.Objects.AnimationCurveNode;

  		const curveNodesMap = new Map();

  		for ( const nodeID in rawCurveNodes ) {

  			const rawCurveNode = rawCurveNodes[ nodeID ];

  			if ( rawCurveNode.attrName.match( /S|R|T|DeformPercent/ ) !== null ) {

  				const curveNode = {

  					id: rawCurveNode.id,
  					attr: rawCurveNode.attrName,
  					curves: {},

  				};

  				curveNodesMap.set( curveNode.id, curveNode );

  			}

  		}

  		return curveNodesMap;

  	}

  	// parse nodes in FBXTree.Objects.AnimationCurve and connect them up to
  	// previously parsed AnimationCurveNodes. Each AnimationCurve holds data for a single animated
  	// axis ( e.g. times and values of x rotation)
  	parseAnimationCurves( curveNodesMap ) {

  		const rawCurves = fbxTree.Objects.AnimationCurve;

  		// TODO: Many values are identical up to roundoff error, but won't be optimised
  		// e.g. position times: [0, 0.4, 0. 8]
  		// position values: [7.23538335023477e-7, 93.67518615722656, -0.9982695579528809, 7.23538335023477e-7, 93.67518615722656, -0.9982695579528809, 7.235384487103147e-7, 93.67520904541016, -0.9982695579528809]
  		// clearly, this should be optimised to
  		// times: [0], positions [7.23538335023477e-7, 93.67518615722656, -0.9982695579528809]
  		// this shows up in nearly every FBX file, and generally time array is length > 100

  		for ( const nodeID in rawCurves ) {

  			const animationCurve = {

  				id: rawCurves[ nodeID ].id,
  				times: rawCurves[ nodeID ].KeyTime.a.map( convertFBXTimeToSeconds ),
  				values: rawCurves[ nodeID ].KeyValueFloat.a,

  			};

  			const relationships = connections.get( animationCurve.id );

  			if ( relationships !== undefined ) {

  				const animationCurveID = relationships.parents[ 0 ].ID;
  				const animationCurveRelationship = relationships.parents[ 0 ].relationship;

  				if ( animationCurveRelationship.match( /X/ ) ) {

  					curveNodesMap.get( animationCurveID ).curves[ 'x' ] = animationCurve;

  				} else if ( animationCurveRelationship.match( /Y/ ) ) {

  					curveNodesMap.get( animationCurveID ).curves[ 'y' ] = animationCurve;

  				} else if ( animationCurveRelationship.match( /Z/ ) ) {

  					curveNodesMap.get( animationCurveID ).curves[ 'z' ] = animationCurve;

  				} else if ( animationCurveRelationship.match( /DeformPercent/ ) && curveNodesMap.has( animationCurveID ) ) {

  					curveNodesMap.get( animationCurveID ).curves[ 'morph' ] = animationCurve;

  				}

  			}

  		}

  	}

  	// parse nodes in FBXTree.Objects.AnimationLayer. Each layers holds references
  	// to various AnimationCurveNodes and is referenced by an AnimationStack node
  	// note: theoretically a stack can have multiple layers, however in practice there always seems to be one per stack
  	parseAnimationLayers( curveNodesMap ) {

  		const rawLayers = fbxTree.Objects.AnimationLayer;

  		const layersMap = new Map();

  		for ( const nodeID in rawLayers ) {

  			const layerCurveNodes = [];

  			const connection = connections.get( parseInt( nodeID ) );

  			if ( connection !== undefined ) {

  				// all the animationCurveNodes used in the layer
  				const children = connection.children;

  				children.forEach( function ( child, i ) {

  					if ( curveNodesMap.has( child.ID ) ) {

  						const curveNode = curveNodesMap.get( child.ID );

  						// check that the curves are defined for at least one axis, otherwise ignore the curveNode
  						if ( curveNode.curves.x !== undefined || curveNode.curves.y !== undefined || curveNode.curves.z !== undefined ) {

  							if ( layerCurveNodes[ i ] === undefined ) {

  								const modelID = connections.get( child.ID ).parents.filter( function ( parent ) {

  									return parent.relationship !== undefined;

  								} )[ 0 ].ID;

  								if ( modelID !== undefined ) {

  									const rawModel = fbxTree.Objects.Model[ modelID.toString() ];

  									if ( rawModel === undefined ) {

  										console.warn( 'THREE.FBXLoader: Encountered a unused curve.', child );
  										return;

  									}

  									const node = {

  										modelName: rawModel.attrName ? PropertyBinding.sanitizeNodeName( rawModel.attrName ) : '',
  										ID: rawModel.id,
  										initialPosition: [ 0, 0, 0 ],
  										initialRotation: [ 0, 0, 0 ],
  										initialScale: [ 1, 1, 1 ],

  									};

  									sceneGraph.traverse( function ( child ) {

  										if ( child.ID === rawModel.id ) {

  											node.transform = child.matrix;

  											if ( child.userData.transformData ) node.eulerOrder = child.userData.transformData.eulerOrder;

  										}

  									} );

  									if ( ! node.transform ) node.transform = new Matrix4();

  									// if the animated model is pre rotated, we'll have to apply the pre rotations to every
  									// animation value as well
  									if ( 'PreRotation' in rawModel ) node.preRotation = rawModel.PreRotation.value;
  									if ( 'PostRotation' in rawModel ) node.postRotation = rawModel.PostRotation.value;

  									layerCurveNodes[ i ] = node;

  								}

  							}

  							if ( layerCurveNodes[ i ] ) layerCurveNodes[ i ][ curveNode.attr ] = curveNode;

  						} else if ( curveNode.curves.morph !== undefined ) {

  							if ( layerCurveNodes[ i ] === undefined ) {

  								const deformerID = connections.get( child.ID ).parents.filter( function ( parent ) {

  									return parent.relationship !== undefined;

  								} )[ 0 ].ID;

  								const morpherID = connections.get( deformerID ).parents[ 0 ].ID;
  								const geoID = connections.get( morpherID ).parents[ 0 ].ID;

  								// assuming geometry is not used in more than one model
  								const modelID = connections.get( geoID ).parents[ 0 ].ID;

  								const rawModel = fbxTree.Objects.Model[ modelID ];

  								const node = {

  									modelName: rawModel.attrName ? PropertyBinding.sanitizeNodeName( rawModel.attrName ) : '',
  									morphName: fbxTree.Objects.Deformer[ deformerID ].attrName,

  								};

  								layerCurveNodes[ i ] = node;

  							}

  							layerCurveNodes[ i ][ curveNode.attr ] = curveNode;

  						}

  					}

  				} );

  				layersMap.set( parseInt( nodeID ), layerCurveNodes );

  			}

  		}

  		return layersMap;

  	}

  	// parse nodes in FBXTree.Objects.AnimationStack. These are the top level node in the animation
  	// hierarchy. Each Stack node will be used to create a AnimationClip
  	parseAnimStacks( layersMap ) {

  		const rawStacks = fbxTree.Objects.AnimationStack;

  		// connect the stacks (clips) up to the layers
  		const rawClips = {};

  		for ( const nodeID in rawStacks ) {

  			const children = connections.get( parseInt( nodeID ) ).children;

  			if ( children.length > 1 ) {

  				// it seems like stacks will always be associated with a single layer. But just in case there are files
  				// where there are multiple layers per stack, we'll display a warning
  				console.warn( 'THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.' );

  			}

  			const layer = layersMap.get( children[ 0 ].ID );

  			rawClips[ nodeID ] = {

  				name: rawStacks[ nodeID ].attrName,
  				layer: layer,

  			};

  		}

  		return rawClips;

  	}

  	addClip( rawClip ) {

  		let tracks = [];

  		const scope = this;
  		rawClip.layer.forEach( function ( rawTracks ) {

  			tracks = tracks.concat( scope.generateTracks( rawTracks ) );

  		} );

  		return new AnimationClip( rawClip.name, - 1, tracks );

  	}

  	generateTracks( rawTracks ) {

  		const tracks = [];

  		let initialPosition = new Vector3();
  		let initialScale = new Vector3();

  		if ( rawTracks.transform ) rawTracks.transform.decompose( initialPosition, new Quaternion(), initialScale );

  		initialPosition = initialPosition.toArray();
  		initialScale = initialScale.toArray();

  		if ( rawTracks.T !== undefined && Object.keys( rawTracks.T.curves ).length > 0 ) {

  			const positionTrack = this.generateVectorTrack( rawTracks.modelName, rawTracks.T.curves, initialPosition, 'position' );
  			if ( positionTrack !== undefined ) tracks.push( positionTrack );

  		}

  		if ( rawTracks.R !== undefined && Object.keys( rawTracks.R.curves ).length > 0 ) {

  			const rotationTrack = this.generateRotationTrack( rawTracks.modelName, rawTracks.R.curves, rawTracks.preRotation, rawTracks.postRotation, rawTracks.eulerOrder );
  			if ( rotationTrack !== undefined ) tracks.push( rotationTrack );

  		}

  		if ( rawTracks.S !== undefined && Object.keys( rawTracks.S.curves ).length > 0 ) {

  			const scaleTrack = this.generateVectorTrack( rawTracks.modelName, rawTracks.S.curves, initialScale, 'scale' );
  			if ( scaleTrack !== undefined ) tracks.push( scaleTrack );

  		}

  		if ( rawTracks.DeformPercent !== undefined ) {

  			const morphTrack = this.generateMorphTrack( rawTracks );
  			if ( morphTrack !== undefined ) tracks.push( morphTrack );

  		}

  		return tracks;

  	}

  	generateVectorTrack( modelName, curves, initialValue, type ) {

  		const times = this.getTimesForAllAxes( curves );
  		const values = this.getKeyframeTrackValues( times, curves, initialValue );

  		return new VectorKeyframeTrack( modelName + '.' + type, times, values );

  	}

  	generateRotationTrack( modelName, curves, preRotation, postRotation, eulerOrder ) {

  		let times;
  		let values;

  		if ( curves.x !== undefined && curves.y !== undefined && curves.z !== undefined ) {

  			const result = this.interpolateRotations( curves.x, curves.y, curves.z, eulerOrder );

  			times = result[ 0 ];
  			values = result[ 1 ];

  		}

  		if ( preRotation !== undefined ) {

  			preRotation = preRotation.map( MathUtils.degToRad );
  			preRotation.push( eulerOrder );

  			preRotation = new Euler().fromArray( preRotation );
  			preRotation = new Quaternion().setFromEuler( preRotation );

  		}

  		if ( postRotation !== undefined ) {

  			postRotation = postRotation.map( MathUtils.degToRad );
  			postRotation.push( eulerOrder );

  			postRotation = new Euler().fromArray( postRotation );
  			postRotation = new Quaternion().setFromEuler( postRotation ).invert();

  		}

  		const quaternion = new Quaternion();
  		const euler = new Euler();

  		const quaternionValues = [];

  		if ( ! values || ! times ) return new QuaternionKeyframeTrack( modelName + '.quaternion', [ 0 ], [ 0 ] );

  		for ( let i = 0; i < values.length; i += 3 ) {

  			euler.set( values[ i ], values[ i + 1 ], values[ i + 2 ], eulerOrder );
  			quaternion.setFromEuler( euler );

  			if ( preRotation !== undefined ) quaternion.premultiply( preRotation );
  			if ( postRotation !== undefined ) quaternion.multiply( postRotation );

  			// Check unroll
  			if ( i > 2 ) {

  				const prevQuat = new Quaternion().fromArray(
  					quaternionValues,
  					( ( i - 3 ) / 3 ) * 4
  				);

  				if ( prevQuat.dot( quaternion ) < 0 ) {

  					quaternion.set( - quaternion.x, - quaternion.y, - quaternion.z, - quaternion.w );

  				}

  			}

  			quaternion.toArray( quaternionValues, ( i / 3 ) * 4 );

  		}

  		return new QuaternionKeyframeTrack( modelName + '.quaternion', times, quaternionValues );

  	}

  	generateMorphTrack( rawTracks ) {

  		const curves = rawTracks.DeformPercent.curves.morph;
  		const values = curves.values.map( function ( val ) {

  			return val / 100;

  		} );

  		const morphNum = sceneGraph.getObjectByName( rawTracks.modelName ).morphTargetDictionary[ rawTracks.morphName ];

  		return new NumberKeyframeTrack( rawTracks.modelName + '.morphTargetInfluences[' + morphNum + ']', curves.times, values );

  	}

  	// For all animated objects, times are defined separately for each axis
  	// Here we'll combine the times into one sorted array without duplicates
  	getTimesForAllAxes( curves ) {

  		let times = [];

  		// first join together the times for each axis, if defined
  		if ( curves.x !== undefined ) times = times.concat( curves.x.times );
  		if ( curves.y !== undefined ) times = times.concat( curves.y.times );
  		if ( curves.z !== undefined ) times = times.concat( curves.z.times );

  		// then sort them
  		times = times.sort( function ( a, b ) {

  			return a - b;

  		} );

  		// and remove duplicates
  		if ( times.length > 1 ) {

  			let targetIndex = 1;
  			let lastValue = times[ 0 ];
  			for ( let i = 1; i < times.length; i ++ ) {

  				const currentValue = times[ i ];
  				if ( currentValue !== lastValue ) {

  					times[ targetIndex ] = currentValue;
  					lastValue = currentValue;
  					targetIndex ++;

  				}

  			}

  			times = times.slice( 0, targetIndex );

  		}

  		return times;

  	}

  	getKeyframeTrackValues( times, curves, initialValue ) {

  		const prevValue = initialValue;

  		const values = [];

  		let xIndex = - 1;
  		let yIndex = - 1;
  		let zIndex = - 1;

  		times.forEach( function ( time ) {

  			if ( curves.x ) xIndex = curves.x.times.indexOf( time );
  			if ( curves.y ) yIndex = curves.y.times.indexOf( time );
  			if ( curves.z ) zIndex = curves.z.times.indexOf( time );

  			// if there is an x value defined for this frame, use that
  			if ( xIndex !== - 1 ) {

  				const xValue = curves.x.values[ xIndex ];
  				values.push( xValue );
  				prevValue[ 0 ] = xValue;

  			} else {

  				// otherwise use the x value from the previous frame
  				values.push( prevValue[ 0 ] );

  			}

  			if ( yIndex !== - 1 ) {

  				const yValue = curves.y.values[ yIndex ];
  				values.push( yValue );
  				prevValue[ 1 ] = yValue;

  			} else {

  				values.push( prevValue[ 1 ] );

  			}

  			if ( zIndex !== - 1 ) {

  				const zValue = curves.z.values[ zIndex ];
  				values.push( zValue );
  				prevValue[ 2 ] = zValue;

  			} else {

  				values.push( prevValue[ 2 ] );

  			}

  		} );

  		return values;

  	}

  	// Rotations are defined as Euler angles which can have values  of any size
  	// These will be converted to quaternions which don't support values greater than
  	// PI, so we'll interpolate large rotations
  	interpolateRotations( curvex, curvey, curvez, eulerOrder ) {

  		const times = [];
  		const values = [];

  		// Add first frame
  		times.push( curvex.times[ 0 ] );
  		values.push( MathUtils.degToRad( curvex.values[ 0 ] ) );
  		values.push( MathUtils.degToRad( curvey.values[ 0 ] ) );
  		values.push( MathUtils.degToRad( curvez.values[ 0 ] ) );

  		for ( let i = 1; i < curvex.values.length; i ++ ) {

  			const initialValue = [
  				curvex.values[ i - 1 ],
  				curvey.values[ i - 1 ],
  				curvez.values[ i - 1 ],
  			];

  			if ( isNaN( initialValue[ 0 ] ) || isNaN( initialValue[ 1 ] ) || isNaN( initialValue[ 2 ] ) ) {

  				continue;

  			}

  			const initialValueRad = initialValue.map( MathUtils.degToRad );

  			const currentValue = [
  				curvex.values[ i ],
  				curvey.values[ i ],
  				curvez.values[ i ],
  			];

  			if ( isNaN( currentValue[ 0 ] ) || isNaN( currentValue[ 1 ] ) || isNaN( currentValue[ 2 ] ) ) {

  				continue;

  			}

  			const currentValueRad = currentValue.map( MathUtils.degToRad );

  			const valuesSpan = [
  				currentValue[ 0 ] - initialValue[ 0 ],
  				currentValue[ 1 ] - initialValue[ 1 ],
  				currentValue[ 2 ] - initialValue[ 2 ],
  			];

  			const absoluteSpan = [
  				Math.abs( valuesSpan[ 0 ] ),
  				Math.abs( valuesSpan[ 1 ] ),
  				Math.abs( valuesSpan[ 2 ] ),
  			];

  			if ( absoluteSpan[ 0 ] >= 180 || absoluteSpan[ 1 ] >= 180 || absoluteSpan[ 2 ] >= 180 ) {

  				const maxAbsSpan = Math.max( ...absoluteSpan );

  				const numSubIntervals = maxAbsSpan / 180;

  				const E1 = new Euler( ...initialValueRad, eulerOrder );
  				const E2 = new Euler( ...currentValueRad, eulerOrder );

  				const Q1 = new Quaternion().setFromEuler( E1 );
  				const Q2 = new Quaternion().setFromEuler( E2 );

  				// Check unroll
  				if ( Q1.dot( Q2 ) ) {

  					Q2.set( - Q2.x, - Q2.y, - Q2.z, - Q2.w );

  				}

  				// Interpolate
  				const initialTime = curvex.times[ i - 1 ];
  				const timeSpan = curvex.times[ i ] - initialTime;

  				const Q = new Quaternion();
  				const E = new Euler();
  				for ( let t = 0; t < 1; t += 1 / numSubIntervals ) {

  					Q.copy( Q1.clone().slerp( Q2.clone(), t ) );

  					times.push( initialTime + t * timeSpan );
  					E.setFromQuaternion( Q, eulerOrder );

  					values.push( E.x );
  					values.push( E.y );
  					values.push( E.z );

  				}

  			} else {

  				times.push( curvex.times[ i ] );
  				values.push( MathUtils.degToRad( curvex.values[ i ] ) );
  				values.push( MathUtils.degToRad( curvey.values[ i ] ) );
  				values.push( MathUtils.degToRad( curvez.values[ i ] ) );

  			}

  		}

  		return [ times, values ];

  	}

  }

  // parse an FBX file in ASCII format
  class TextParser {

  	getPrevNode() {

  		return this.nodeStack[ this.currentIndent - 2 ];

  	}

  	getCurrentNode() {

  		return this.nodeStack[ this.currentIndent - 1 ];

  	}

  	getCurrentProp() {

  		return this.currentProp;

  	}

  	pushStack( node ) {

  		this.nodeStack.push( node );
  		this.currentIndent += 1;

  	}

  	popStack() {

  		this.nodeStack.pop();
  		this.currentIndent -= 1;

  	}

  	setCurrentProp( val, name ) {

  		this.currentProp = val;
  		this.currentPropName = name;

  	}

  	parse( text ) {

  		this.currentIndent = 0;

  		this.allNodes = new FBXTree();
  		this.nodeStack = [];
  		this.currentProp = [];
  		this.currentPropName = '';

  		const scope = this;

  		const split = text.split( /[\r\n]+/ );

  		split.forEach( function ( line, i ) {

  			const matchComment = line.match( /^[\s\t]*;/ );
  			const matchEmpty = line.match( /^[\s\t]*$/ );

  			if ( matchComment || matchEmpty ) return;

  			const matchBeginning = line.match( '^\\t{' + scope.currentIndent + '}(\\w+):(.*){', '' );
  			const matchProperty = line.match( '^\\t{' + ( scope.currentIndent ) + '}(\\w+):[\\s\\t\\r\\n](.*)' );
  			const matchEnd = line.match( '^\\t{' + ( scope.currentIndent - 1 ) + '}}' );

  			if ( matchBeginning ) {

  				scope.parseNodeBegin( line, matchBeginning );

  			} else if ( matchProperty ) {

  				scope.parseNodeProperty( line, matchProperty, split[ ++ i ] );

  			} else if ( matchEnd ) {

  				scope.popStack();

  			} else if ( line.match( /^[^\s\t}]/ ) ) {

  				// large arrays are split over multiple lines terminated with a ',' character
  				// if this is encountered the line needs to be joined to the previous line
  				scope.parseNodePropertyContinued( line );

  			}

  		} );

  		return this.allNodes;

  	}

  	parseNodeBegin( line, property ) {

  		const nodeName = property[ 1 ].trim().replace( /^"/, '' ).replace( /"$/, '' );

  		const nodeAttrs = property[ 2 ].split( ',' ).map( function ( attr ) {

  			return attr.trim().replace( /^"/, '' ).replace( /"$/, '' );

  		} );

  		const node = { name: nodeName };
  		const attrs = this.parseNodeAttr( nodeAttrs );

  		const currentNode = this.getCurrentNode();

  		// a top node
  		if ( this.currentIndent === 0 ) {

  			this.allNodes.add( nodeName, node );

  		} else { // a subnode

  			// if the subnode already exists, append it
  			if ( nodeName in currentNode ) {

  				// special case Pose needs PoseNodes as an array
  				if ( nodeName === 'PoseNode' ) {

  					currentNode.PoseNode.push( node );

  				} else if ( currentNode[ nodeName ].id !== undefined ) {

  					currentNode[ nodeName ] = {};
  					currentNode[ nodeName ][ currentNode[ nodeName ].id ] = currentNode[ nodeName ];

  				}

  				if ( attrs.id !== '' ) currentNode[ nodeName ][ attrs.id ] = node;

  			} else if ( typeof attrs.id === 'number' ) {

  				currentNode[ nodeName ] = {};
  				currentNode[ nodeName ][ attrs.id ] = node;

  			} else if ( nodeName !== 'Properties70' ) {

  				if ( nodeName === 'PoseNode' )	currentNode[ nodeName ] = [ node ];
  				else currentNode[ nodeName ] = node;

  			}

  		}

  		if ( typeof attrs.id === 'number' ) node.id = attrs.id;
  		if ( attrs.name !== '' ) node.attrName = attrs.name;
  		if ( attrs.type !== '' ) node.attrType = attrs.type;

  		this.pushStack( node );

  	}

  	parseNodeAttr( attrs ) {

  		let id = attrs[ 0 ];

  		if ( attrs[ 0 ] !== '' ) {

  			id = parseInt( attrs[ 0 ] );

  			if ( isNaN( id ) ) {

  				id = attrs[ 0 ];

  			}

  		}

  		let name = '', type = '';

  		if ( attrs.length > 1 ) {

  			name = attrs[ 1 ].replace( /^(\w+)::/, '' );
  			type = attrs[ 2 ];

  		}

  		return { id: id, name: name, type: type };

  	}

  	parseNodeProperty( line, property, contentLine ) {

  		let propName = property[ 1 ].replace( /^"/, '' ).replace( /"$/, '' ).trim();
  		let propValue = property[ 2 ].replace( /^"/, '' ).replace( /"$/, '' ).trim();

  		// for special case: base64 image data follows "Content: ," line
  		//	Content: ,
  		//	 "/9j/4RDaRXhpZgAATU0A..."
  		if ( propName === 'Content' && propValue === ',' ) {

  			propValue = contentLine.replace( /"/g, '' ).replace( /,$/, '' ).trim();

  		}

  		const currentNode = this.getCurrentNode();
  		const parentName = currentNode.name;

  		if ( parentName === 'Properties70' ) {

  			this.parseNodeSpecialProperty( line, propName, propValue );
  			return;

  		}

  		// Connections
  		if ( propName === 'C' ) {

  			const connProps = propValue.split( ',' ).slice( 1 );
  			const from = parseInt( connProps[ 0 ] );
  			const to = parseInt( connProps[ 1 ] );

  			let rest = propValue.split( ',' ).slice( 3 );

  			rest = rest.map( function ( elem ) {

  				return elem.trim().replace( /^"/, '' );

  			} );

  			propName = 'connections';
  			propValue = [ from, to ];
  			append( propValue, rest );

  			if ( currentNode[ propName ] === undefined ) {

  				currentNode[ propName ] = [];

  			}

  		}

  		// Node
  		if ( propName === 'Node' ) currentNode.id = propValue;

  		// connections
  		if ( propName in currentNode && Array.isArray( currentNode[ propName ] ) ) {

  			currentNode[ propName ].push( propValue );

  		} else {

  			if ( propName !== 'a' ) currentNode[ propName ] = propValue;
  			else currentNode.a = propValue;

  		}

  		this.setCurrentProp( currentNode, propName );

  		// convert string to array, unless it ends in ',' in which case more will be added to it
  		if ( propName === 'a' && propValue.slice( - 1 ) !== ',' ) {

  			currentNode.a = parseNumberArray( propValue );

  		}

  	}

  	parseNodePropertyContinued( line ) {

  		const currentNode = this.getCurrentNode();

  		currentNode.a += line;

  		// if the line doesn't end in ',' we have reached the end of the property value
  		// so convert the string to an array
  		if ( line.slice( - 1 ) !== ',' ) {

  			currentNode.a = parseNumberArray( currentNode.a );

  		}

  	}

  	// parse "Property70"
  	parseNodeSpecialProperty( line, propName, propValue ) {

  		// split this
  		// P: "Lcl Scaling", "Lcl Scaling", "", "A",1,1,1
  		// into array like below
  		// ["Lcl Scaling", "Lcl Scaling", "", "A", "1,1,1" ]
  		const props = propValue.split( '",' ).map( function ( prop ) {

  			return prop.trim().replace( /^\"/, '' ).replace( /\s/, '_' );

  		} );

  		const innerPropName = props[ 0 ];
  		const innerPropType1 = props[ 1 ];
  		const innerPropType2 = props[ 2 ];
  		const innerPropFlag = props[ 3 ];
  		let innerPropValue = props[ 4 ];

  		// cast values where needed, otherwise leave as strings
  		switch ( innerPropType1 ) {

  			case 'int':
  			case 'enum':
  			case 'bool':
  			case 'ULongLong':
  			case 'double':
  			case 'Number':
  			case 'FieldOfView':
  				innerPropValue = parseFloat( innerPropValue );
  				break;

  			case 'Color':
  			case 'ColorRGB':
  			case 'Vector3D':
  			case 'Lcl_Translation':
  			case 'Lcl_Rotation':
  			case 'Lcl_Scaling':
  				innerPropValue = parseNumberArray( innerPropValue );
  				break;

  		}

  		// CAUTION: these props must append to parent's parent
  		this.getPrevNode()[ innerPropName ] = {

  			'type': innerPropType1,
  			'type2': innerPropType2,
  			'flag': innerPropFlag,
  			'value': innerPropValue

  		};

  		this.setCurrentProp( this.getPrevNode(), innerPropName );

  	}

  }

  // Parse an FBX file in Binary format
  class BinaryParser {

  	parse( buffer ) {

  		const reader = new BinaryReader( buffer );
  		reader.skip( 23 ); // skip magic 23 bytes

  		const version = reader.getUint32();

  		if ( version < 6400 ) {

  			throw new Error( 'THREE.FBXLoader: FBX version not supported, FileVersion: ' + version );

  		}

  		const allNodes = new FBXTree();

  		while ( ! this.endOfContent( reader ) ) {

  			const node = this.parseNode( reader, version );
  			if ( node !== null ) allNodes.add( node.name, node );

  		}

  		return allNodes;

  	}

  	// Check if reader has reached the end of content.
  	endOfContent( reader ) {

  		// footer size: 160bytes + 16-byte alignment padding
  		// - 16bytes: magic
  		// - padding til 16-byte alignment (at least 1byte?)
  		//	(seems like some exporters embed fixed 15 or 16bytes?)
  		// - 4bytes: magic
  		// - 4bytes: version
  		// - 120bytes: zero
  		// - 16bytes: magic
  		if ( reader.size() % 16 === 0 ) {

  			return ( ( reader.getOffset() + 160 + 16 ) & ~ 0xf ) >= reader.size();

  		} else {

  			return reader.getOffset() + 160 + 16 >= reader.size();

  		}

  	}

  	// recursively parse nodes until the end of the file is reached
  	parseNode( reader, version ) {

  		const node = {};

  		// The first three data sizes depends on version.
  		const endOffset = ( version >= 7500 ) ? reader.getUint64() : reader.getUint32();
  		const numProperties = ( version >= 7500 ) ? reader.getUint64() : reader.getUint32();

  		( version >= 7500 ) ? reader.getUint64() : reader.getUint32(); // the returned propertyListLen is not used

  		const nameLen = reader.getUint8();
  		const name = reader.getString( nameLen );

  		// Regards this node as NULL-record if endOffset is zero
  		if ( endOffset === 0 ) return null;

  		const propertyList = [];

  		for ( let i = 0; i < numProperties; i ++ ) {

  			propertyList.push( this.parseProperty( reader ) );

  		}

  		// Regards the first three elements in propertyList as id, attrName, and attrType
  		const id = propertyList.length > 0 ? propertyList[ 0 ] : '';
  		const attrName = propertyList.length > 1 ? propertyList[ 1 ] : '';
  		const attrType = propertyList.length > 2 ? propertyList[ 2 ] : '';

  		// check if this node represents just a single property
  		// like (name, 0) set or (name2, [0, 1, 2]) set of {name: 0, name2: [0, 1, 2]}
  		node.singleProperty = ( numProperties === 1 && reader.getOffset() === endOffset ) ? true : false;

  		while ( endOffset > reader.getOffset() ) {

  			const subNode = this.parseNode( reader, version );

  			if ( subNode !== null ) this.parseSubNode( name, node, subNode );

  		}

  		node.propertyList = propertyList; // raw property list used by parent

  		if ( typeof id === 'number' ) node.id = id;
  		if ( attrName !== '' ) node.attrName = attrName;
  		if ( attrType !== '' ) node.attrType = attrType;
  		if ( name !== '' ) node.name = name;

  		return node;

  	}

  	parseSubNode( name, node, subNode ) {

  		// special case: child node is single property
  		if ( subNode.singleProperty === true ) {

  			const value = subNode.propertyList[ 0 ];

  			if ( Array.isArray( value ) ) {

  				node[ subNode.name ] = subNode;

  				subNode.a = value;

  			} else {

  				node[ subNode.name ] = value;

  			}

  		} else if ( name === 'Connections' && subNode.name === 'C' ) {

  			const array = [];

  			subNode.propertyList.forEach( function ( property, i ) {

  				// first Connection is FBX type (OO, OP, etc.). We'll discard these
  				if ( i !== 0 ) array.push( property );

  			} );

  			if ( node.connections === undefined ) {

  				node.connections = [];

  			}

  			node.connections.push( array );

  		} else if ( subNode.name === 'Properties70' ) {

  			const keys = Object.keys( subNode );

  			keys.forEach( function ( key ) {

  				node[ key ] = subNode[ key ];

  			} );

  		} else if ( name === 'Properties70' && subNode.name === 'P' ) {

  			let innerPropName = subNode.propertyList[ 0 ];
  			let innerPropType1 = subNode.propertyList[ 1 ];
  			const innerPropType2 = subNode.propertyList[ 2 ];
  			const innerPropFlag = subNode.propertyList[ 3 ];
  			let innerPropValue;

  			if ( innerPropName.indexOf( 'Lcl ' ) === 0 ) innerPropName = innerPropName.replace( 'Lcl ', 'Lcl_' );
  			if ( innerPropType1.indexOf( 'Lcl ' ) === 0 ) innerPropType1 = innerPropType1.replace( 'Lcl ', 'Lcl_' );

  			if ( innerPropType1 === 'Color' || innerPropType1 === 'ColorRGB' || innerPropType1 === 'Vector' || innerPropType1 === 'Vector3D' || innerPropType1.indexOf( 'Lcl_' ) === 0 ) {

  				innerPropValue = [
  					subNode.propertyList[ 4 ],
  					subNode.propertyList[ 5 ],
  					subNode.propertyList[ 6 ]
  				];

  			} else {

  				innerPropValue = subNode.propertyList[ 4 ];

  			}

  			// this will be copied to parent, see above
  			node[ innerPropName ] = {

  				'type': innerPropType1,
  				'type2': innerPropType2,
  				'flag': innerPropFlag,
  				'value': innerPropValue

  			};

  		} else if ( node[ subNode.name ] === undefined ) {

  			if ( typeof subNode.id === 'number' ) {

  				node[ subNode.name ] = {};
  				node[ subNode.name ][ subNode.id ] = subNode;

  			} else {

  				node[ subNode.name ] = subNode;

  			}

  		} else {

  			if ( subNode.name === 'PoseNode' ) {

  				if ( ! Array.isArray( node[ subNode.name ] ) ) {

  					node[ subNode.name ] = [ node[ subNode.name ] ];

  				}

  				node[ subNode.name ].push( subNode );

  			} else if ( node[ subNode.name ][ subNode.id ] === undefined ) {

  				node[ subNode.name ][ subNode.id ] = subNode;

  			}

  		}

  	}

  	parseProperty( reader ) {

  		const type = reader.getString( 1 );
  		let length;

  		switch ( type ) {

  			case 'C':
  				return reader.getBoolean();

  			case 'D':
  				return reader.getFloat64();

  			case 'F':
  				return reader.getFloat32();

  			case 'I':
  				return reader.getInt32();

  			case 'L':
  				return reader.getInt64();

  			case 'R':
  				length = reader.getUint32();
  				return reader.getArrayBuffer( length );

  			case 'S':
  				length = reader.getUint32();
  				return reader.getString( length );

  			case 'Y':
  				return reader.getInt16();

  			case 'b':
  			case 'c':
  			case 'd':
  			case 'f':
  			case 'i':
  			case 'l':

  				const arrayLength = reader.getUint32();
  				const encoding = reader.getUint32(); // 0: non-compressed, 1: compressed
  				const compressedLength = reader.getUint32();

  				if ( encoding === 0 ) {

  					switch ( type ) {

  						case 'b':
  						case 'c':
  							return reader.getBooleanArray( arrayLength );

  						case 'd':
  							return reader.getFloat64Array( arrayLength );

  						case 'f':
  							return reader.getFloat32Array( arrayLength );

  						case 'i':
  							return reader.getInt32Array( arrayLength );

  						case 'l':
  							return reader.getInt64Array( arrayLength );

  					}

  				}

  				const data = unzlibSync( new Uint8Array( reader.getArrayBuffer( compressedLength ) ) );
  				const reader2 = new BinaryReader( data.buffer );

  				switch ( type ) {

  					case 'b':
  					case 'c':
  						return reader2.getBooleanArray( arrayLength );

  					case 'd':
  						return reader2.getFloat64Array( arrayLength );

  					case 'f':
  						return reader2.getFloat32Array( arrayLength );

  					case 'i':
  						return reader2.getInt32Array( arrayLength );

  					case 'l':
  						return reader2.getInt64Array( arrayLength );

  				}

  				break; // cannot happen but is required by the DeepScan

  			default:
  				throw new Error( 'THREE.FBXLoader: Unknown property type ' + type );

  		}

  	}

  }

  class BinaryReader {

  	constructor( buffer, littleEndian ) {

  		this.dv = new DataView( buffer );
  		this.offset = 0;
  		this.littleEndian = ( littleEndian !== undefined ) ? littleEndian : true;
  		this._textDecoder = new TextDecoder();

  	}

  	getOffset() {

  		return this.offset;

  	}

  	size() {

  		return this.dv.buffer.byteLength;

  	}

  	skip( length ) {

  		this.offset += length;

  	}

  	// seems like true/false representation depends on exporter.
  	// true: 1 or 'Y'(=0x59), false: 0 or 'T'(=0x54)
  	// then sees LSB.
  	getBoolean() {

  		return ( this.getUint8() & 1 ) === 1;

  	}

  	getBooleanArray( size ) {

  		const a = [];

  		for ( let i = 0; i < size; i ++ ) {

  			a.push( this.getBoolean() );

  		}

  		return a;

  	}

  	getUint8() {

  		const value = this.dv.getUint8( this.offset );
  		this.offset += 1;
  		return value;

  	}

  	getInt16() {

  		const value = this.dv.getInt16( this.offset, this.littleEndian );
  		this.offset += 2;
  		return value;

  	}

  	getInt32() {

  		const value = this.dv.getInt32( this.offset, this.littleEndian );
  		this.offset += 4;
  		return value;

  	}

  	getInt32Array( size ) {

  		const a = [];

  		for ( let i = 0; i < size; i ++ ) {

  			a.push( this.getInt32() );

  		}

  		return a;

  	}

  	getUint32() {

  		const value = this.dv.getUint32( this.offset, this.littleEndian );
  		this.offset += 4;
  		return value;

  	}

  	// JavaScript doesn't support 64-bit integer so calculate this here
  	// 1 << 32 will return 1 so using multiply operation instead here.
  	// There's a possibility that this method returns wrong value if the value
  	// is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.
  	// TODO: safely handle 64-bit integer
  	getInt64() {

  		let low, high;

  		if ( this.littleEndian ) {

  			low = this.getUint32();
  			high = this.getUint32();

  		} else {

  			high = this.getUint32();
  			low = this.getUint32();

  		}

  		// calculate negative value
  		if ( high & 0x80000000 ) {

  			high = ~ high & 0xFFFFFFFF;
  			low = ~ low & 0xFFFFFFFF;

  			if ( low === 0xFFFFFFFF ) high = ( high + 1 ) & 0xFFFFFFFF;

  			low = ( low + 1 ) & 0xFFFFFFFF;

  			return - ( high * 0x100000000 + low );

  		}

  		return high * 0x100000000 + low;

  	}

  	getInt64Array( size ) {

  		const a = [];

  		for ( let i = 0; i < size; i ++ ) {

  			a.push( this.getInt64() );

  		}

  		return a;

  	}

  	// Note: see getInt64() comment
  	getUint64() {

  		let low, high;

  		if ( this.littleEndian ) {

  			low = this.getUint32();
  			high = this.getUint32();

  		} else {

  			high = this.getUint32();
  			low = this.getUint32();

  		}

  		return high * 0x100000000 + low;

  	}

  	getFloat32() {

  		const value = this.dv.getFloat32( this.offset, this.littleEndian );
  		this.offset += 4;
  		return value;

  	}

  	getFloat32Array( size ) {

  		const a = [];

  		for ( let i = 0; i < size; i ++ ) {

  			a.push( this.getFloat32() );

  		}

  		return a;

  	}

  	getFloat64() {

  		const value = this.dv.getFloat64( this.offset, this.littleEndian );
  		this.offset += 8;
  		return value;

  	}

  	getFloat64Array( size ) {

  		const a = [];

  		for ( let i = 0; i < size; i ++ ) {

  			a.push( this.getFloat64() );

  		}

  		return a;

  	}

  	getArrayBuffer( size ) {

  		const value = this.dv.buffer.slice( this.offset, this.offset + size );
  		this.offset += size;
  		return value;

  	}

  	getString( size ) {

  		const start = this.offset;
  		let a = new Uint8Array( this.dv.buffer, start, size );

  		this.skip( size );

  		const nullByte = a.indexOf( 0 );
  		if ( nullByte >= 0 ) a = new Uint8Array( this.dv.buffer, start, nullByte );

  		return this._textDecoder.decode( a );

  	}

  }

  // FBXTree holds a representation of the FBX data, returned by the TextParser ( FBX ASCII format)
  // and BinaryParser( FBX Binary format)
  class FBXTree {

  	add( key, val ) {

  		this[ key ] = val;

  	}

  }

  // ************** UTILITY FUNCTIONS **************

  function isFbxFormatBinary( buffer ) {

  	const CORRECT = 'Kaydara\u0020FBX\u0020Binary\u0020\u0020\0';

  	return buffer.byteLength >= CORRECT.length && CORRECT === convertArrayBufferToString( buffer, 0, CORRECT.length );

  }

  function isFbxFormatASCII( text ) {

  	const CORRECT = [ 'K', 'a', 'y', 'd', 'a', 'r', 'a', '\\', 'F', 'B', 'X', '\\', 'B', 'i', 'n', 'a', 'r', 'y', '\\', '\\' ];

  	let cursor = 0;

  	function read( offset ) {

  		const result = text[ offset - 1 ];
  		text = text.slice( cursor + offset );
  		cursor ++;
  		return result;

  	}

  	for ( let i = 0; i < CORRECT.length; ++ i ) {

  		const num = read( 1 );
  		if ( num === CORRECT[ i ] ) {

  			return false;

  		}

  	}

  	return true;

  }

  function getFbxVersion( text ) {

  	const versionRegExp = /FBXVersion: (\d+)/;
  	const match = text.match( versionRegExp );

  	if ( match ) {

  		const version = parseInt( match[ 1 ] );
  		return version;

  	}

  	throw new Error( 'THREE.FBXLoader: Cannot find the version number for the file given.' );

  }

  // Converts FBX ticks into real time seconds.
  function convertFBXTimeToSeconds( time ) {

  	return time / 46186158000;

  }

  const dataArray = [];

  // extracts the data from the correct position in the FBX array based on indexing type
  function getData( polygonVertexIndex, polygonIndex, vertexIndex, infoObject ) {

  	let index;

  	switch ( infoObject.mappingType ) {

  		case 'ByPolygonVertex' :
  			index = polygonVertexIndex;
  			break;
  		case 'ByPolygon' :
  			index = polygonIndex;
  			break;
  		case 'ByVertice' :
  			index = vertexIndex;
  			break;
  		case 'AllSame' :
  			index = infoObject.indices[ 0 ];
  			break;
  		default :
  			console.warn( 'THREE.FBXLoader: unknown attribute mapping type ' + infoObject.mappingType );

  	}

  	if ( infoObject.referenceType === 'IndexToDirect' ) index = infoObject.indices[ index ];

  	const from = index * infoObject.dataSize;
  	const to = from + infoObject.dataSize;

  	return slice( dataArray, infoObject.buffer, from, to );

  }

  const tempEuler = new Euler();
  const tempVec = new Vector3();

  // generate transformation from FBX transform data
  // ref: https://help.autodesk.com/view/FBX/2017/ENU/?guid=__files_GUID_10CDD63C_79C1_4F2D_BB28_AD2BE65A02ED_htm
  // ref: http://docs.autodesk.com/FBX/2014/ENU/FBX-SDK-Documentation/index.html?url=cpp_ref/_transformations_2main_8cxx-example.html,topicNumber=cpp_ref__transformations_2main_8cxx_example_htmlfc10a1e1-b18d-4e72-9dc0-70d0f1959f5e
  function generateTransform( transformData ) {

  	const lTranslationM = new Matrix4();
  	const lPreRotationM = new Matrix4();
  	const lRotationM = new Matrix4();
  	const lPostRotationM = new Matrix4();

  	const lScalingM = new Matrix4();
  	const lScalingPivotM = new Matrix4();
  	const lScalingOffsetM = new Matrix4();
  	const lRotationOffsetM = new Matrix4();
  	const lRotationPivotM = new Matrix4();

  	const lParentGX = new Matrix4();
  	const lParentLX = new Matrix4();
  	const lGlobalT = new Matrix4();

  	const inheritType = ( transformData.inheritType ) ? transformData.inheritType : 0;

  	if ( transformData.translation ) lTranslationM.setPosition( tempVec.fromArray( transformData.translation ) );

  	if ( transformData.preRotation ) {

  		const array = transformData.preRotation.map( MathUtils.degToRad );
  		array.push( transformData.eulerOrder || Euler.DEFAULT_ORDER );
  		lPreRotationM.makeRotationFromEuler( tempEuler.fromArray( array ) );

  	}

  	if ( transformData.rotation ) {

  		const array = transformData.rotation.map( MathUtils.degToRad );
  		array.push( transformData.eulerOrder || Euler.DEFAULT_ORDER );
  		lRotationM.makeRotationFromEuler( tempEuler.fromArray( array ) );

  	}

  	if ( transformData.postRotation ) {

  		const array = transformData.postRotation.map( MathUtils.degToRad );
  		array.push( transformData.eulerOrder || Euler.DEFAULT_ORDER );
  		lPostRotationM.makeRotationFromEuler( tempEuler.fromArray( array ) );
  		lPostRotationM.invert();

  	}

  	if ( transformData.scale ) lScalingM.scale( tempVec.fromArray( transformData.scale ) );

  	// Pivots and offsets
  	if ( transformData.scalingOffset ) lScalingOffsetM.setPosition( tempVec.fromArray( transformData.scalingOffset ) );
  	if ( transformData.scalingPivot ) lScalingPivotM.setPosition( tempVec.fromArray( transformData.scalingPivot ) );
  	if ( transformData.rotationOffset ) lRotationOffsetM.setPosition( tempVec.fromArray( transformData.rotationOffset ) );
  	if ( transformData.rotationPivot ) lRotationPivotM.setPosition( tempVec.fromArray( transformData.rotationPivot ) );

  	// parent transform
  	if ( transformData.parentMatrixWorld ) {

  		lParentLX.copy( transformData.parentMatrix );
  		lParentGX.copy( transformData.parentMatrixWorld );

  	}

  	const lLRM = lPreRotationM.clone().multiply( lRotationM ).multiply( lPostRotationM );
  	// Global Rotation
  	const lParentGRM = new Matrix4();
  	lParentGRM.extractRotation( lParentGX );

  	// Global Shear*Scaling
  	const lParentTM = new Matrix4();
  	lParentTM.copyPosition( lParentGX );

  	const lParentGRSM = lParentTM.clone().invert().multiply( lParentGX );
  	const lParentGSM = lParentGRM.clone().invert().multiply( lParentGRSM );
  	const lLSM = lScalingM;

  	const lGlobalRS = new Matrix4();

  	if ( inheritType === 0 ) {

  		lGlobalRS.copy( lParentGRM ).multiply( lLRM ).multiply( lParentGSM ).multiply( lLSM );

  	} else if ( inheritType === 1 ) {

  		lGlobalRS.copy( lParentGRM ).multiply( lParentGSM ).multiply( lLRM ).multiply( lLSM );

  	} else {

  		const lParentLSM = new Matrix4().scale( new Vector3().setFromMatrixScale( lParentLX ) );
  		const lParentLSM_inv = lParentLSM.clone().invert();
  		const lParentGSM_noLocal = lParentGSM.clone().multiply( lParentLSM_inv );

  		lGlobalRS.copy( lParentGRM ).multiply( lLRM ).multiply( lParentGSM_noLocal ).multiply( lLSM );

  	}

  	const lRotationPivotM_inv = lRotationPivotM.clone().invert();
  	const lScalingPivotM_inv = lScalingPivotM.clone().invert();
  	// Calculate the local transform matrix
  	let lTransform = lTranslationM.clone().multiply( lRotationOffsetM ).multiply( lRotationPivotM ).multiply( lPreRotationM ).multiply( lRotationM ).multiply( lPostRotationM ).multiply( lRotationPivotM_inv ).multiply( lScalingOffsetM ).multiply( lScalingPivotM ).multiply( lScalingM ).multiply( lScalingPivotM_inv );

  	const lLocalTWithAllPivotAndOffsetInfo = new Matrix4().copyPosition( lTransform );

  	const lGlobalTranslation = lParentGX.clone().multiply( lLocalTWithAllPivotAndOffsetInfo );
  	lGlobalT.copyPosition( lGlobalTranslation );

  	lTransform = lGlobalT.clone().multiply( lGlobalRS );

  	// from global to local
  	lTransform.premultiply( lParentGX.invert() );

  	return lTransform;

  }

  // Returns the three.js intrinsic Euler order corresponding to FBX extrinsic Euler order
  // ref: http://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_class_fbx_euler_html
  function getEulerOrder( order ) {

  	order = order || 0;

  	const enums = [
  		'ZYX', // -> XYZ extrinsic
  		'YZX', // -> XZY extrinsic
  		'XZY', // -> YZX extrinsic
  		'ZXY', // -> YXZ extrinsic
  		'YXZ', // -> ZXY extrinsic
  		'XYZ', // -> ZYX extrinsic
  		//'SphericXYZ', // not possible to support
  	];

  	if ( order === 6 ) {

  		console.warn( 'THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect.' );
  		return enums[ 0 ];

  	}

  	return enums[ order ];

  }

  // Parses comma separated list of numbers and returns them an array.
  // Used internally by the TextParser
  function parseNumberArray( value ) {

  	const array = value.split( ',' ).map( function ( val ) {

  		return parseFloat( val );

  	} );

  	return array;

  }

  function convertArrayBufferToString( buffer, from, to ) {

  	if ( from === undefined ) from = 0;
  	if ( to === undefined ) to = buffer.byteLength;

  	return new TextDecoder().decode( new Uint8Array( buffer, from, to ) );

  }

  function append( a, b ) {

  	for ( let i = 0, j = a.length, l = b.length; i < l; i ++, j ++ ) {

  		a[ j ] = b[ i ];

  	}

  }

  function slice( a, b, from, to ) {

  	for ( let i = from, j = 0; i < to; i ++, j ++ ) {

  		a[ j ] = b[ i ];

  	}

  	return a;

  }

  function mixamoFbx2motion(fbxObject, vrm, onProgress) {
    var _fbxObject$getObjectB, _fbxObject$getObjectB2;
    var clip = AnimationClip.findByName(fbxObject.animations, "mixamo.com");
    var animationSpeed = 1;
    var tracks = [];
    var restRotationInverse = new Quaternion();
    var parentRestWorldRotation = new Quaternion();
    var _quatA = new Quaternion();
    var _vec3 = new Vector3();
    var motionHipsHeight = (_fbxObject$getObjectB = (_fbxObject$getObjectB2 = fbxObject.getObjectByName("mixamorigHips")) === null || _fbxObject$getObjectB2 === void 0 ? void 0 : _fbxObject$getObjectB2.position.y) !== null && _fbxObject$getObjectB !== void 0 ? _fbxObject$getObjectB : 2;
    var vrmHips = vrm.humanoid.getNormalizedBoneNode("hips");
    var vrmHipsY = vrmHips.getWorldPosition(_vec3).y;
    var vrmRootY = vrm.scene.getWorldPosition(_vec3).y;
    var vrmHipsHeight = Math.abs(vrmHipsY - vrmRootY);
    var hipsPositionScale = vrmHipsHeight / (motionHipsHeight == 0 ? 1 : motionHipsHeight);
    var VRMRigMap = mixamoVRMRigMap;
    clip.tracks.forEach(function (track, i) {
      var _vrm$humanoid;
      var trackName = track.name;
      if (trackName.startsWith(".")) {
        trackName = trackName.substring(1);
      }

      // Convert each tracks for VRM use, and push to `tracks`
      var trackSplitted = trackName.split(".");
      var mixamoRigName = trackSplitted[0];
      var vrmBoneName = VRMRigMap[mixamoRigName];
      var vrmNodeName = (_vrm$humanoid = vrm.humanoid) === null || _vrm$humanoid === void 0 || (_vrm$humanoid = _vrm$humanoid.getNormalizedBoneNode(vrmBoneName)) === null || _vrm$humanoid === void 0 ? void 0 : _vrm$humanoid.name;
      var mixamoRigNode;
      if (typeof fbxObject.getObjectByName !== "undefined") {
        mixamoRigNode = fbxObject.getObjectByName(mixamoRigName);
      }
      if (vrmNodeName != null) {
        var _mixamoRigNode, _mixamoRigNode2;
        var propertyName = trackSplitted[1];

        // Store rotations of rest-pose.
        (_mixamoRigNode = mixamoRigNode) === null || _mixamoRigNode === void 0 || _mixamoRigNode.getWorldQuaternion(restRotationInverse).invert();
        (_mixamoRigNode2 = mixamoRigNode) === null || _mixamoRigNode2 === void 0 || (_mixamoRigNode2 = _mixamoRigNode2.parent) === null || _mixamoRigNode2 === void 0 || _mixamoRigNode2.getWorldQuaternion(parentRestWorldRotation);
        if (track instanceof QuaternionKeyframeTrack) {
          var _loop = function _loop(_i) {
            var flatQuaternion = track.values.slice(_i, _i + 4);
            _quatA.fromArray(flatQuaternion);
            _quatA.premultiply(parentRestWorldRotation).multiply(restRotationInverse);
            _quatA.toArray(flatQuaternion);
            flatQuaternion.forEach(function (v, index) {
              track.values[index + _i] = v;
            });
          };
          // Retarget rotation of mixamoRig to NormalizedBone.
          for (var _i = 0; _i < track.values.length; _i += 4) {
            _loop(_i);
          }
          tracks.push(new QuaternionKeyframeTrack("".concat(vrmNodeName, ".").concat(propertyName), track.times.map(function (e) {
            return e / animationSpeed;
          }), track.values.map(function (v, i) {
            var _vrm$meta;
            return ((_vrm$meta = vrm.meta) === null || _vrm$meta === void 0 ? void 0 : _vrm$meta.metaVersion) === "0" && i % 2 === 0 ? -v : v;
          })));
        } else if (track instanceof VectorKeyframeTrack) {
          var value = track.values.map(function (v, i) {
            var _vrm$meta2;
            return (((_vrm$meta2 = vrm.meta) === null || _vrm$meta2 === void 0 ? void 0 : _vrm$meta2.metaVersion) === "0" && i % 3 !== 1 ? -v : v) * hipsPositionScale;
          });
          tracks.push(new VectorKeyframeTrack("".concat(vrmNodeName, ".").concat(propertyName), track.times, value));
        }
      }
    });
    return {
      clip: new AnimationClip("vrmAnimation", clip.duration, tracks)
    };
  }
  var mixamoVRMRigMap = {
    mixamorigHips: "hips",
    mixamorigSpine: "spine",
    mixamorigSpine1: "chest",
    mixamorigSpine2: "upperChest",
    mixamorigNeck: "neck",
    mixamorigHead: "head",
    mixamorigLeftShoulder: "leftShoulder",
    mixamorigLeftArm: "leftUpperArm",
    mixamorigLeftForeArm: "leftLowerArm",
    mixamorigLeftHand: "leftHand",
    mixamorigLeftHandThumb1: "leftThumbProximal",
    mixamorigLeftHandThumb3: "leftThumbDistal",
    mixamorigLeftHandIndex1: "leftIndexProximal",
    mixamorigLeftHandIndex2: "leftIndexIntermediate",
    mixamorigLeftHandIndex3: "leftIndexDistal",
    mixamorigLeftHandMiddle1: "leftMiddleProximal",
    mixamorigLeftHandMiddle2: "leftMiddleIntermediate",
    mixamorigLeftHandMiddle3: "leftMiddleDistal",
    mixamorigLeftHandRing1: "leftRingProximal",
    mixamorigLeftHandRing2: "leftRingIntermediate",
    mixamorigLeftHandRing3: "leftRingDistal",
    mixamorigLeftHandPinky1: "leftLittleProximal",
    mixamorigLeftHandPinky2: "leftLittleIntermediate",
    mixamorigLeftHandPinky3: "leftLittleDistal",
    mixamorigRightShoulder: "rightShoulder",
    mixamorigRightArm: "rightUpperArm",
    mixamorigRightForeArm: "rightLowerArm",
    mixamorigRightHand: "rightHand",
    mixamorigRightHandPinky1: "rightLittleProximal",
    mixamorigRightHandPinky2: "rightLittleIntermediate",
    mixamorigRightHandPinky3: "rightLittleDistal",
    mixamorigRightHandRing1: "rightRingProximal",
    mixamorigRightHandRing2: "rightRingIntermediate",
    mixamorigRightHandRing3: "rightRingDistal",
    mixamorigRightHandMiddle1: "rightMiddleProximal",
    mixamorigRightHandMiddle2: "rightMiddleIntermediate",
    mixamorigRightHandMiddle3: "rightMiddleDistal",
    mixamorigRightHandIndex1: "rightIndexProximal",
    mixamorigRightHandIndex2: "rightIndexIntermediate",
    mixamorigRightHandIndex3: "rightIndexDistal",
    mixamorigRightHandThumb1: "rightThumbProximal",
    mixamorigRightHandThumb3: "rightThumbDistal",
    mixamorigLeftUpLeg: "leftUpperLeg",
    mixamorigLeftLeg: "leftLowerLeg",
    mixamorigLeftFoot: "leftFoot",
    mixamorigLeftToeBase: "leftToes",
    mixamorigRightUpLeg: "rightUpperLeg",
    mixamorigRightLeg: "rightLowerLeg",
    mixamorigRightFoot: "rightFoot",
    mixamorigRightToeBase: "rightToes"
  };

  function mootionFbx2motion(fbxObject, vrm, onProgress) {
    var _fbxObject$getObjectB, _fbxObject$getObjectB2;
    var clip = AnimationClip.findByName(fbxObject.animations, fbxObject.animations[0].name);
    var animationSpeed = 1;
    var tracks = [];
    var restRotationInverse = new Quaternion();
    var parentRestWorldRotation = new Quaternion();
    var _quatA = new Quaternion();
    var _vec3 = new Vector3();
    var motionHipsHeight = (_fbxObject$getObjectB = (_fbxObject$getObjectB2 = fbxObject.getObjectByName("MootionRigHips")) === null || _fbxObject$getObjectB2 === void 0 ? void 0 : _fbxObject$getObjectB2.position.y) !== null && _fbxObject$getObjectB !== void 0 ? _fbxObject$getObjectB : 2;
    var vrmHips = vrm.humanoid.getNormalizedBoneNode("hips");
    var vrmHipsY = vrmHips.getWorldPosition(_vec3).y;
    var vrmRootY = vrm.scene.getWorldPosition(_vec3).y;
    var vrmHipsHeight = Math.abs(vrmHipsY - vrmRootY);
    var hipsPositionScale = vrmHipsHeight / (motionHipsHeight == 0 ? 1 : motionHipsHeight);
    var VRMRigMap = mootionVRMRigMap;
    clip.tracks.forEach(function (track, i) {
      var _vrm$humanoid;
      var trackName = track.name;
      if (trackName.startsWith(".")) {
        trackName = trackName.substring(1);
      }

      // Convert each tracks for VRM use, and push to `tracks`
      var trackSplitted = trackName.split(".");
      var mootionRigName = trackSplitted[0];
      var vrmBoneName = VRMRigMap[mootionRigName];
      var vrmNodeName = (_vrm$humanoid = vrm.humanoid) === null || _vrm$humanoid === void 0 || (_vrm$humanoid = _vrm$humanoid.getNormalizedBoneNode(vrmBoneName)) === null || _vrm$humanoid === void 0 ? void 0 : _vrm$humanoid.name;
      var mootionRigNode;
      if (typeof fbxObject.getObjectByName !== "undefined") {
        mootionRigNode = fbxObject.getObjectByName(mootionRigName);
      }
      if (vrmNodeName != null) {
        var _mootionRigNode, _mootionRigNode2;
        var propertyName = trackSplitted[1];

        // Store rotations of rest-pose.
        (_mootionRigNode = mootionRigNode) === null || _mootionRigNode === void 0 || _mootionRigNode.getWorldQuaternion(restRotationInverse).invert();
        (_mootionRigNode2 = mootionRigNode) === null || _mootionRigNode2 === void 0 || (_mootionRigNode2 = _mootionRigNode2.parent) === null || _mootionRigNode2 === void 0 || _mootionRigNode2.getWorldQuaternion(parentRestWorldRotation);
        if (track instanceof QuaternionKeyframeTrack) {
          var _loop = function _loop(_i) {
            var flatQuaternion = track.values.slice(_i, _i + 4);
            _quatA.fromArray(flatQuaternion);
            _quatA.premultiply(parentRestWorldRotation).multiply(restRotationInverse);
            _quatA.toArray(flatQuaternion);
            flatQuaternion.forEach(function (v, index) {
              track.values[index + _i] = v;
            });
          };
          // Retarget rotation of mixamoRig to NormalizedBone.
          for (var _i = 0; _i < track.values.length; _i += 4) {
            _loop(_i);
          }
          tracks.push(new QuaternionKeyframeTrack("".concat(vrmNodeName, ".").concat(propertyName), track.times.map(function (e) {
            return e / animationSpeed;
          }), track.values.map(function (v, i) {
            var _vrm$meta;
            return ((_vrm$meta = vrm.meta) === null || _vrm$meta === void 0 ? void 0 : _vrm$meta.metaVersion) === "0" && i % 2 === 0 ? -v : v;
          })));
        } else if (track instanceof VectorKeyframeTrack) {
          var value = track.values.map(function (v, i) {
            var _vrm$meta2;
            return (((_vrm$meta2 = vrm.meta) === null || _vrm$meta2 === void 0 ? void 0 : _vrm$meta2.metaVersion) === "0" && i % 3 !== 1 ? -v : v) * hipsPositionScale;
          });
          tracks.push(new VectorKeyframeTrack("".concat(vrmNodeName, ".").concat(propertyName), track.times, value));
        }
      }
    });
    return {
      clip: new AnimationClip("vrmAnimation", clip.duration, tracks)
    };
  }
  var mootionVRMRigMap = {
    MootionRigHips: "hips",
    MootionRigSpine: "spine",
    MootionRigLeftUpLeg: "leftUpperLeg",
    MootionRigRightUpLeg: "rightUpperLeg",
    MootionRigLeftLeg: "leftLowerLeg",
    MootionRigRightLeg: "rightLowerLeg",
    MootionRigSpine1: "spine",
    MootionRigLeftFoot: "leftFoot",
    MootionRigRightFoot: "rightFoot",
    MootionRigSpine2: "upperChest",
    MootionRigLeftToeBase: "leftToes",
    MootionRigRightToeBase: "rightToes",
    MootionRigNeck: "neck",
    MootionRigLeftShoulder: "leftShoulder",
    MootionRigRightShoulder: "rightShoulder",
    MootionRigHead: "head",
    MootionRigLeftArm: "leftUpperArm",
    MootionRigRightArm: "rightUpperArm",
    MootionRigLeftForeArm: "leftLowerArm",
    MootionRigRightForeArm: "rightLowerArm",
    MootionRigLeftHand: "leftHand",
    MootionRigRightHand: "rightHand"
  };

  var FBXConverter = /*#__PURE__*/function () {
    function FBXConverter(vrm) {
      var worker = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
      _classCallCheck(this, FBXConverter);
      this._vrm = vrm;
      this._fbxs = {};
      this._loader = new FBXLoader();
      this._worker = worker;
    }
    return _createClass(FBXConverter, [{
      key: "fbx2motion",
      value: function () {
        var _fbx2motion = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(filePath) {
          var _this = this;
          var onProgress,
            buffer,
            _args2 = arguments;
          return _regeneratorRuntime().wrap(function _callee2$(_context2) {
            while (1) switch (_context2.prev = _context2.next) {
              case 0:
                onProgress = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : function (_1, _2) {};
                buffer = _args2.length > 2 ? _args2[2] : undefined;
                if (!(this._fbxs[filePath] && this._fbxs[filePath].motionExpression)) {
                  _context2.next = 4;
                  break;
                }
                return _context2.abrupt("return", this._fbxs[filePath].motionExpression);
              case 4:
                this._fbxs[filePath] = {
                  motionExpression: undefined
                };
                if (buffer) {
                  _context2.next = 15;
                  break;
                }
                if (!(this._worker && Object.keys(this._worker.prefetchFiles).includes(filePath))) {
                  _context2.next = 12;
                  break;
                }
                _context2.next = 9;
                return this._worker.prefetchFiles[filePath];
              case 9:
                buffer = _context2.sent;
                _context2.next = 15;
                break;
              case 12:
                _context2.next = 14;
                return abFetch(filePath, onProgress);
              case 14:
                buffer = _context2.sent;
              case 15:
                return _context2.abrupt("return", new Promise(/*#__PURE__*/function () {
                  var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(resolve, reject) {
                    var data, fbx, motion;
                    return _regeneratorRuntime().wrap(function _callee$(_context) {
                      while (1) switch (_context.prev = _context.next) {
                        case 0:
                          if (!_this._worker) {
                            _context.next = 10;
                            break;
                          }
                          _context.next = 3;
                          return _this.workerConvertFbxToMotion(filePath, buffer, onProgress);
                        case 3:
                          data = _context.sent;
                          if (data) {
                            _context.next = 7;
                            break;
                          }
                          reject("An error occured while trying to convert ".concat(filePath, " to motion from its arrayBuffer using the worker"));
                          return _context.abrupt("return");
                        case 7:
                          _this._fbxs[data.filePath].motionExpression = data.motion;
                          resolve(data.motion);
                          return _context.abrupt("return");
                        case 10:
                          // do it on the current thread
                          fbx = _this._loader.parse(buffer, filePath);
                          motion = _this.convertFbxToMotion(fbx, onProgress);
                          if (!motion) {
                            _context.next = 18;
                            break;
                          }
                          _this._fbxs[filePath].motionExpression = motion;
                          resolve(motion);
                          return _context.abrupt("return");
                        case 18:
                          reject("An error occured while trying to convert ".concat(filePath, " to motion from its arrayBuffer"));
                          return _context.abrupt("return");
                        case 20:
                        case "end":
                          return _context.stop();
                      }
                    }, _callee);
                  }));
                  return function (_x2, _x3) {
                    return _ref.apply(this, arguments);
                  };
                }()));
              case 16:
              case "end":
                return _context2.stop();
            }
          }, _callee2, this);
        }));
        function fbx2motion(_x) {
          return _fbx2motion.apply(this, arguments);
        }
        return fbx2motion;
      }()
    }, {
      key: "workerConvertFbxToMotion",
      value: function () {
        var _workerConvertFbxToMotion = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(filePath, arrayBuffer) {
          var onProgress,
            _args3 = arguments;
          return _regeneratorRuntime().wrap(function _callee3$(_context3) {
            while (1) switch (_context3.prev = _context3.next) {
              case 0:
                onProgress = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : function (_1, _2) {};
                return _context3.abrupt("return", this._worker.fbx2motion(filePath, arrayBuffer, onProgress));
              case 2:
              case "end":
                return _context3.stop();
            }
          }, _callee3, this);
        }));
        function workerConvertFbxToMotion(_x4, _x5) {
          return _workerConvertFbxToMotion.apply(this, arguments);
        }
        return workerConvertFbxToMotion;
      }()
    }, {
      key: "convertFbxToMotion",
      value: function convertFbxToMotion(object) {
        if (object.animations.length > 0) {
          var names = [object.name, object.animations[0].name];
          if (names.some(function (name) {
            return name.includes("mixamo.com");
          })) {
            return mixamoFbx2motion(object, this._vrm);
          } else if (names.some(function (name) {
            return name.includes("Mootion");
          })) {
            return mootionFbx2motion(object, this._vrm);
          }
        }
      }
    }]);
  }();

  /*!
   * @pixiv/three-vrm v3.1.1
   * VRM file loader for three.js.
   *
   * Copyright (c) 2019-2024 pixiv Inc.
   * @pixiv/three-vrm is distributed under MIT License
   * https://github.com/pixiv/three-vrm/blob/release/LICENSE
   */
  var __async = (__this, __arguments, generator) => {
    return new Promise((resolve, reject) => {
      var fulfilled = (value) => {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      };
      var rejected = (value) => {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      };
      var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
      step((generator = generator.apply(__this, __arguments)).next());
    });
  };
  var __async2 = (__this, __arguments, generator) => {
    return new Promise((resolve, reject) => {
      var fulfilled = (value) => {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      };
      var rejected = (value) => {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      };
      var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
      step((generator = generator.apply(__this, __arguments)).next());
    });
  };
  var VRMExpression = class extends Object3D {
    constructor(expressionName) {
      super();
      this.weight = 0;
      this.isBinary = false;
      this.overrideBlink = "none";
      this.overrideLookAt = "none";
      this.overrideMouth = "none";
      this._binds = [];
      this.name = `VRMExpression_${expressionName}`;
      this.expressionName = expressionName;
      this.type = "VRMExpression";
      this.visible = false;
    }
    /**
     * A value represents how much it should override blink expressions.
     * `0.0` == no override at all, `1.0` == completely block the expressions.
     */
    get overrideBlinkAmount() {
      if (this.overrideBlink === "block") {
        return 0 < this.weight ? 1 : 0;
      } else if (this.overrideBlink === "blend") {
        return this.weight;
      } else {
        return 0;
      }
    }
    /**
     * A value represents how much it should override lookAt expressions.
     * `0.0` == no override at all, `1.0` == completely block the expressions.
     */
    get overrideLookAtAmount() {
      if (this.overrideLookAt === "block") {
        return 0 < this.weight ? 1 : 0;
      } else if (this.overrideLookAt === "blend") {
        return this.weight;
      } else {
        return 0;
      }
    }
    /**
     * A value represents how much it should override mouth expressions.
     * `0.0` == no override at all, `1.0` == completely block the expressions.
     */
    get overrideMouthAmount() {
      if (this.overrideMouth === "block") {
        return 0 < this.weight ? 1 : 0;
      } else if (this.overrideMouth === "blend") {
        return this.weight;
      } else {
        return 0;
      }
    }
    addBind(bind) {
      this._binds.push(bind);
    }
    /**
     * Apply weight to every assigned blend shapes.
     * Should be called every frame.
     */
    applyWeight(options) {
      var _a;
      let actualWeight = this.isBinary ? this.weight <= 0.5 ? 0 : 1 : this.weight;
      actualWeight *= (_a = options == null ? void 0 : options.multiplier) != null ? _a : 1;
      this._binds.forEach((bind) => bind.applyWeight(actualWeight));
    }
    /**
     * Clear previously assigned blend shapes.
     */
    clearAppliedWeight() {
      this._binds.forEach((bind) => bind.clearAppliedWeight());
    }
  };
  function extractPrimitivesInternal(gltf, nodeIndex, node) {
    var _a, _b;
    const json = gltf.parser.json;
    const schemaNode = (_a = json.nodes) == null ? void 0 : _a[nodeIndex];
    if (schemaNode == null) {
      console.warn(`extractPrimitivesInternal: Attempt to use nodes[${nodeIndex}] of glTF but the node doesn't exist`);
      return null;
    }
    const meshIndex = schemaNode.mesh;
    if (meshIndex == null) {
      return null;
    }
    const schemaMesh = (_b = json.meshes) == null ? void 0 : _b[meshIndex];
    if (schemaMesh == null) {
      console.warn(`extractPrimitivesInternal: Attempt to use meshes[${meshIndex}] of glTF but the mesh doesn't exist`);
      return null;
    }
    const primitiveCount = schemaMesh.primitives.length;
    const primitives = [];
    node.traverse((object) => {
      if (primitives.length < primitiveCount) {
        if (object.isMesh) {
          primitives.push(object);
        }
      }
    });
    return primitives;
  }
  function gltfExtractPrimitivesFromNode(gltf, nodeIndex) {
    return __async2(this, null, function* () {
      const node = yield gltf.parser.getDependency("node", nodeIndex);
      return extractPrimitivesInternal(gltf, nodeIndex, node);
    });
  }
  function gltfExtractPrimitivesFromNodes(gltf) {
    return __async2(this, null, function* () {
      const nodes = yield gltf.parser.getDependencies("node");
      const map = /* @__PURE__ */ new Map();
      nodes.forEach((node, index) => {
        const result = extractPrimitivesInternal(gltf, index, node);
        if (result != null) {
          map.set(index, result);
        }
      });
      return map;
    });
  }
  var VRMExpressionPresetName = {
    Aa: "aa",
    Ih: "ih",
    Ou: "ou",
    Ee: "ee",
    Oh: "oh",
    Blink: "blink",
    Happy: "happy",
    Angry: "angry",
    Sad: "sad",
    Relaxed: "relaxed",
    LookUp: "lookUp",
    Surprised: "surprised",
    LookDown: "lookDown",
    LookLeft: "lookLeft",
    LookRight: "lookRight",
    BlinkLeft: "blinkLeft",
    BlinkRight: "blinkRight",
    Neutral: "neutral"
  };
  function saturate(value) {
    return Math.max(Math.min(value, 1), 0);
  }
  var VRMExpressionManager = class _VRMExpressionManager {
    /**
     * Create a new {@link VRMExpressionManager}.
     */
    constructor() {
      this.blinkExpressionNames = ["blink", "blinkLeft", "blinkRight"];
      this.lookAtExpressionNames = ["lookLeft", "lookRight", "lookUp", "lookDown"];
      this.mouthExpressionNames = ["aa", "ee", "ih", "oh", "ou"];
      this._expressions = [];
      this._expressionMap = {};
    }
    get expressions() {
      return this._expressions.concat();
    }
    get expressionMap() {
      return Object.assign({}, this._expressionMap);
    }
    /**
     * A map from name to expression, but excluding custom expressions.
     */
    get presetExpressionMap() {
      const result = {};
      const presetNameSet = new Set(Object.values(VRMExpressionPresetName));
      Object.entries(this._expressionMap).forEach(([name, expression]) => {
        if (presetNameSet.has(name)) {
          result[name] = expression;
        }
      });
      return result;
    }
    /**
     * A map from name to expression, but excluding preset expressions.
     */
    get customExpressionMap() {
      const result = {};
      const presetNameSet = new Set(Object.values(VRMExpressionPresetName));
      Object.entries(this._expressionMap).forEach(([name, expression]) => {
        if (!presetNameSet.has(name)) {
          result[name] = expression;
        }
      });
      return result;
    }
    /**
     * Copy the given {@link VRMExpressionManager} into this one.
     * @param source The {@link VRMExpressionManager} you want to copy
     * @returns this
     */
    copy(source) {
      const expressions = this._expressions.concat();
      expressions.forEach((expression) => {
        this.unregisterExpression(expression);
      });
      source._expressions.forEach((expression) => {
        this.registerExpression(expression);
      });
      this.blinkExpressionNames = source.blinkExpressionNames.concat();
      this.lookAtExpressionNames = source.lookAtExpressionNames.concat();
      this.mouthExpressionNames = source.mouthExpressionNames.concat();
      return this;
    }
    /**
     * Returns a clone of this {@link VRMExpressionManager}.
     * @returns Copied {@link VRMExpressionManager}
     */
    clone() {
      return new _VRMExpressionManager().copy(this);
    }
    /**
     * Return a registered expression.
     * If it cannot find an expression, it will return `null` instead.
     *
     * @param name Name or preset name of the expression
     */
    getExpression(name) {
      var _a;
      return (_a = this._expressionMap[name]) != null ? _a : null;
    }
    /**
     * Register an expression.
     *
     * @param expression {@link VRMExpression} that describes the expression
     */
    registerExpression(expression) {
      this._expressions.push(expression);
      this._expressionMap[expression.expressionName] = expression;
    }
    /**
     * Unregister an expression.
     *
     * @param expression The expression you want to unregister
     */
    unregisterExpression(expression) {
      const index = this._expressions.indexOf(expression);
      if (index === -1) {
        console.warn("VRMExpressionManager: The specified expressions is not registered");
      }
      this._expressions.splice(index, 1);
      delete this._expressionMap[expression.expressionName];
    }
    /**
     * Get the current weight of the specified expression.
     * If it doesn't have an expression of given name, it will return `null` instead.
     *
     * @param name Name of the expression
     */
    getValue(name) {
      var _a;
      const expression = this.getExpression(name);
      return (_a = expression == null ? void 0 : expression.weight) != null ? _a : null;
    }
    /**
     * Set a weight to the specified expression.
     *
     * @param name Name of the expression
     * @param weight Weight
     */
    setValue(name, weight) {
      const expression = this.getExpression(name);
      if (expression) {
        expression.weight = saturate(weight);
      }
    }
    /**
     * Reset weights of all expressions to `0.0`.
     */
    resetValues() {
      this._expressions.forEach((expression) => {
        expression.weight = 0;
      });
    }
    /**
     * Get a track name of specified expression.
     * This track name is needed to manipulate its expression via keyframe animations.
     *
     * @example Manipulate an expression using keyframe animation
     * ```js
     * const trackName = vrm.expressionManager.getExpressionTrackName( 'blink' );
     * const track = new THREE.NumberKeyframeTrack(
     *   name,
     *   [ 0.0, 0.5, 1.0 ], // times
     *   [ 0.0, 1.0, 0.0 ] // values
     * );
     *
     * const clip = new THREE.AnimationClip(
     *   'blink', // name
     *   1.0, // duration
     *   [ track ] // tracks
     * );
     *
     * const mixer = new THREE.AnimationMixer( vrm.scene );
     * const action = mixer.clipAction( clip );
     * action.play();
     * ```
     *
     * @param name Name of the expression
     */
    getExpressionTrackName(name) {
      const expression = this.getExpression(name);
      return expression ? `${expression.name}.weight` : null;
    }
    /**
     * Update every expressions.
     */
    update() {
      const weightMultipliers = this._calculateWeightMultipliers();
      this._expressions.forEach((expression) => {
        expression.clearAppliedWeight();
      });
      this._expressions.forEach((expression) => {
        let multiplier = 1;
        const name = expression.expressionName;
        if (this.blinkExpressionNames.indexOf(name) !== -1) {
          multiplier *= weightMultipliers.blink;
        }
        if (this.lookAtExpressionNames.indexOf(name) !== -1) {
          multiplier *= weightMultipliers.lookAt;
        }
        if (this.mouthExpressionNames.indexOf(name) !== -1) {
          multiplier *= weightMultipliers.mouth;
        }
        expression.applyWeight({ multiplier });
      });
    }
    /**
     * Calculate sum of override amounts to see how much we should multiply weights of certain expressions.
     */
    _calculateWeightMultipliers() {
      let blink = 1;
      let lookAt = 1;
      let mouth = 1;
      this._expressions.forEach((expression) => {
        blink -= expression.overrideBlinkAmount;
        lookAt -= expression.overrideLookAtAmount;
        mouth -= expression.overrideMouthAmount;
      });
      blink = Math.max(0, blink);
      lookAt = Math.max(0, lookAt);
      mouth = Math.max(0, mouth);
      return { blink, lookAt, mouth };
    }
  };
  var VRMExpressionMaterialColorType = {
    Color: "color",
    EmissionColor: "emissionColor",
    ShadeColor: "shadeColor",
    MatcapColor: "matcapColor",
    RimColor: "rimColor",
    OutlineColor: "outlineColor"
  };
  var v0ExpressionMaterialColorMap = {
    _Color: VRMExpressionMaterialColorType.Color,
    _EmissionColor: VRMExpressionMaterialColorType.EmissionColor,
    _ShadeColor: VRMExpressionMaterialColorType.ShadeColor,
    _RimColor: VRMExpressionMaterialColorType.RimColor,
    _OutlineColor: VRMExpressionMaterialColorType.OutlineColor
  };
  var _color = new Color();
  var _VRMExpressionMaterialColorBind = class _VRMExpressionMaterialColorBind2 {
    constructor({
      material,
      type,
      targetValue,
      targetAlpha
    }) {
      this.material = material;
      this.type = type;
      this.targetValue = targetValue;
      this.targetAlpha = targetAlpha != null ? targetAlpha : 1;
      const color = this._initColorBindState();
      const alpha = this._initAlphaBindState();
      this._state = { color, alpha };
    }
    applyWeight(weight) {
      const { color, alpha } = this._state;
      if (color != null) {
        const { propertyName, deltaValue } = color;
        const target = this.material[propertyName];
        if (target != void 0) {
          target.add(_color.copy(deltaValue).multiplyScalar(weight));
        }
      }
      if (alpha != null) {
        const { propertyName, deltaValue } = alpha;
        const target = this.material[propertyName];
        if (target != void 0) {
          this.material[propertyName] += deltaValue * weight;
        }
      }
    }
    clearAppliedWeight() {
      const { color, alpha } = this._state;
      if (color != null) {
        const { propertyName, initialValue } = color;
        const target = this.material[propertyName];
        if (target != void 0) {
          target.copy(initialValue);
        }
      }
      if (alpha != null) {
        const { propertyName, initialValue } = alpha;
        const target = this.material[propertyName];
        if (target != void 0) {
          this.material[propertyName] = initialValue;
        }
      }
    }
    _initColorBindState() {
      var _a, _b, _c;
      const { material, type, targetValue } = this;
      const propertyNameMap = this._getPropertyNameMap();
      const propertyName = (_b = (_a = propertyNameMap == null ? void 0 : propertyNameMap[type]) == null ? void 0 : _a[0]) != null ? _b : null;
      if (propertyName == null) {
        console.warn(
          `Tried to add a material color bind to the material ${(_c = material.name) != null ? _c : "(no name)"}, the type ${type} but the material or the type is not supported.`
        );
        return null;
      }
      const target = material[propertyName];
      const initialValue = target.clone();
      const deltaValue = new Color(
        targetValue.r - initialValue.r,
        targetValue.g - initialValue.g,
        targetValue.b - initialValue.b
      );
      return { propertyName, initialValue, deltaValue };
    }
    _initAlphaBindState() {
      var _a, _b, _c;
      const { material, type, targetAlpha } = this;
      const propertyNameMap = this._getPropertyNameMap();
      const propertyName = (_b = (_a = propertyNameMap == null ? void 0 : propertyNameMap[type]) == null ? void 0 : _a[1]) != null ? _b : null;
      if (propertyName == null && targetAlpha !== 1) {
        console.warn(
          `Tried to add a material alpha bind to the material ${(_c = material.name) != null ? _c : "(no name)"}, the type ${type} but the material or the type does not support alpha.`
        );
        return null;
      }
      if (propertyName == null) {
        return null;
      }
      const initialValue = material[propertyName];
      const deltaValue = targetAlpha - initialValue;
      return { propertyName, initialValue, deltaValue };
    }
    _getPropertyNameMap() {
      var _a, _b;
      return (_b = (_a = Object.entries(_VRMExpressionMaterialColorBind2._propertyNameMapMap).find(([distinguisher]) => {
        return this.material[distinguisher] === true;
      })) == null ? void 0 : _a[1]) != null ? _b : null;
    }
  };
  _VRMExpressionMaterialColorBind._propertyNameMapMap = {
    isMeshStandardMaterial: {
      color: ["color", "opacity"],
      emissionColor: ["emissive", null]
    },
    isMeshBasicMaterial: {
      color: ["color", "opacity"]
    },
    isMToonMaterial: {
      color: ["color", "opacity"],
      emissionColor: ["emissive", null],
      outlineColor: ["outlineColorFactor", null],
      matcapColor: ["matcapFactor", null],
      rimColor: ["parametricRimColorFactor", null],
      shadeColor: ["shadeColorFactor", null]
    }
  };
  var VRMExpressionMaterialColorBind = _VRMExpressionMaterialColorBind;
  var VRMExpressionMorphTargetBind = class {
    constructor({
      primitives,
      index,
      weight
    }) {
      this.primitives = primitives;
      this.index = index;
      this.weight = weight;
    }
    applyWeight(weight) {
      this.primitives.forEach((mesh) => {
        var _a;
        if (((_a = mesh.morphTargetInfluences) == null ? void 0 : _a[this.index]) != null) {
          mesh.morphTargetInfluences[this.index] += this.weight * weight;
        }
      });
    }
    clearAppliedWeight() {
      this.primitives.forEach((mesh) => {
        var _a;
        if (((_a = mesh.morphTargetInfluences) == null ? void 0 : _a[this.index]) != null) {
          mesh.morphTargetInfluences[this.index] = 0;
        }
      });
    }
  };
  var _v2 = new Vector2();
  var _VRMExpressionTextureTransformBind = class _VRMExpressionTextureTransformBind2 {
    constructor({
      material,
      scale,
      offset
    }) {
      var _a, _b;
      this.material = material;
      this.scale = scale;
      this.offset = offset;
      const propertyNames = (_a = Object.entries(_VRMExpressionTextureTransformBind2._propertyNamesMap).find(
        ([distinguisher]) => {
          return material[distinguisher] === true;
        }
      )) == null ? void 0 : _a[1];
      if (propertyNames == null) {
        console.warn(
          `Tried to add a texture transform bind to the material ${(_b = material.name) != null ? _b : "(no name)"} but the material is not supported.`
        );
        this._properties = [];
      } else {
        this._properties = [];
        propertyNames.forEach((propertyName) => {
          var _a2;
          const texture = (_a2 = material[propertyName]) == null ? void 0 : _a2.clone();
          if (!texture) {
            return null;
          }
          material[propertyName] = texture;
          const initialOffset = texture.offset.clone();
          const initialScale = texture.repeat.clone();
          const deltaOffset = offset.clone().sub(initialOffset);
          const deltaScale = scale.clone().sub(initialScale);
          this._properties.push({
            name: propertyName,
            initialOffset,
            deltaOffset,
            initialScale,
            deltaScale
          });
        });
      }
    }
    applyWeight(weight) {
      this._properties.forEach((property) => {
        const target = this.material[property.name];
        if (target === void 0) {
          return;
        }
        target.offset.add(_v2.copy(property.deltaOffset).multiplyScalar(weight));
        target.repeat.add(_v2.copy(property.deltaScale).multiplyScalar(weight));
      });
    }
    clearAppliedWeight() {
      this._properties.forEach((property) => {
        const target = this.material[property.name];
        if (target === void 0) {
          return;
        }
        target.offset.copy(property.initialOffset);
        target.repeat.copy(property.initialScale);
      });
    }
  };
  _VRMExpressionTextureTransformBind._propertyNamesMap = {
    isMeshStandardMaterial: [
      "map",
      "emissiveMap",
      "bumpMap",
      "normalMap",
      "displacementMap",
      "roughnessMap",
      "metalnessMap",
      "alphaMap"
    ],
    isMeshBasicMaterial: ["map", "specularMap", "alphaMap"],
    isMToonMaterial: [
      "map",
      "normalMap",
      "emissiveMap",
      "shadeMultiplyTexture",
      "rimMultiplyTexture",
      "outlineWidthMultiplyTexture",
      "uvAnimationMaskTexture"
    ]
  };
  var VRMExpressionTextureTransformBind = _VRMExpressionTextureTransformBind;
  var POSSIBLE_SPEC_VERSIONS = /* @__PURE__ */ new Set(["1.0", "1.0-beta"]);
  var _VRMExpressionLoaderPlugin = class _VRMExpressionLoaderPlugin2 {
    get name() {
      return "VRMExpressionLoaderPlugin";
    }
    constructor(parser) {
      this.parser = parser;
    }
    afterRoot(gltf) {
      return __async2(this, null, function* () {
        gltf.userData.vrmExpressionManager = yield this._import(gltf);
      });
    }
    /**
     * Import a {@link VRMExpressionManager} from a VRM.
     *
     * @param gltf A parsed result of GLTF taken from GLTFLoader
     */
    _import(gltf) {
      return __async2(this, null, function* () {
        const v1Result = yield this._v1Import(gltf);
        if (v1Result) {
          return v1Result;
        }
        const v0Result = yield this._v0Import(gltf);
        if (v0Result) {
          return v0Result;
        }
        return null;
      });
    }
    _v1Import(gltf) {
      return __async2(this, null, function* () {
        var _a, _b;
        const json = this.parser.json;
        const isVRMUsed = ((_a = json.extensionsUsed) == null ? void 0 : _a.indexOf("VRMC_vrm")) !== -1;
        if (!isVRMUsed) {
          return null;
        }
        const extension = (_b = json.extensions) == null ? void 0 : _b["VRMC_vrm"];
        if (!extension) {
          return null;
        }
        const specVersion = extension.specVersion;
        if (!POSSIBLE_SPEC_VERSIONS.has(specVersion)) {
          console.warn(`VRMExpressionLoaderPlugin: Unknown VRMC_vrm specVersion "${specVersion}"`);
          return null;
        }
        const schemaExpressions = extension.expressions;
        if (!schemaExpressions) {
          return null;
        }
        const presetNameSet = new Set(Object.values(VRMExpressionPresetName));
        const nameSchemaExpressionMap = /* @__PURE__ */ new Map();
        if (schemaExpressions.preset != null) {
          Object.entries(schemaExpressions.preset).forEach(([name, schemaExpression]) => {
            if (schemaExpression == null) {
              return;
            }
            if (!presetNameSet.has(name)) {
              console.warn(`VRMExpressionLoaderPlugin: Unknown preset name "${name}" detected. Ignoring the expression`);
              return;
            }
            nameSchemaExpressionMap.set(name, schemaExpression);
          });
        }
        if (schemaExpressions.custom != null) {
          Object.entries(schemaExpressions.custom).forEach(([name, schemaExpression]) => {
            if (presetNameSet.has(name)) {
              console.warn(
                `VRMExpressionLoaderPlugin: Custom expression cannot have preset name "${name}". Ignoring the expression`
              );
              return;
            }
            nameSchemaExpressionMap.set(name, schemaExpression);
          });
        }
        const manager = new VRMExpressionManager();
        yield Promise.all(
          Array.from(nameSchemaExpressionMap.entries()).map((_0) => __async2(this, [_0], function* ([name, schemaExpression]) {
            var _a2, _b2, _c, _d, _e, _f, _g;
            const expression = new VRMExpression(name);
            gltf.scene.add(expression);
            expression.isBinary = (_a2 = schemaExpression.isBinary) != null ? _a2 : false;
            expression.overrideBlink = (_b2 = schemaExpression.overrideBlink) != null ? _b2 : "none";
            expression.overrideLookAt = (_c = schemaExpression.overrideLookAt) != null ? _c : "none";
            expression.overrideMouth = (_d = schemaExpression.overrideMouth) != null ? _d : "none";
            (_e = schemaExpression.morphTargetBinds) == null ? void 0 : _e.forEach((bind) => __async2(this, null, function* () {
              var _a3;
              if (bind.node === void 0 || bind.index === void 0) {
                return;
              }
              const primitives = yield gltfExtractPrimitivesFromNode(gltf, bind.node);
              const morphTargetIndex = bind.index;
              if (!primitives.every(
                (primitive) => Array.isArray(primitive.morphTargetInfluences) && morphTargetIndex < primitive.morphTargetInfluences.length
              )) {
                console.warn(
                  `VRMExpressionLoaderPlugin: ${schemaExpression.name} attempts to index morph #${morphTargetIndex} but not found.`
                );
                return;
              }
              expression.addBind(
                new VRMExpressionMorphTargetBind({
                  primitives,
                  index: morphTargetIndex,
                  weight: (_a3 = bind.weight) != null ? _a3 : 1
                })
              );
            }));
            if (schemaExpression.materialColorBinds || schemaExpression.textureTransformBinds) {
              const gltfMaterials = [];
              gltf.scene.traverse((object) => {
                const material = object.material;
                if (material) {
                  gltfMaterials.push(material);
                }
              });
              (_f = schemaExpression.materialColorBinds) == null ? void 0 : _f.forEach((bind) => __async2(this, null, function* () {
                const materials = gltfMaterials.filter((material) => {
                  var _a3;
                  const materialIndex = (_a3 = this.parser.associations.get(material)) == null ? void 0 : _a3.materials;
                  return bind.material === materialIndex;
                });
                materials.forEach((material) => {
                  expression.addBind(
                    new VRMExpressionMaterialColorBind({
                      material,
                      type: bind.type,
                      targetValue: new Color().fromArray(bind.targetValue),
                      targetAlpha: bind.targetValue[3]
                    })
                  );
                });
              }));
              (_g = schemaExpression.textureTransformBinds) == null ? void 0 : _g.forEach((bind) => __async2(this, null, function* () {
                const materials = gltfMaterials.filter((material) => {
                  var _a3;
                  const materialIndex = (_a3 = this.parser.associations.get(material)) == null ? void 0 : _a3.materials;
                  return bind.material === materialIndex;
                });
                materials.forEach((material) => {
                  var _a3, _b3;
                  expression.addBind(
                    new VRMExpressionTextureTransformBind({
                      material,
                      offset: new Vector2().fromArray((_a3 = bind.offset) != null ? _a3 : [0, 0]),
                      scale: new Vector2().fromArray((_b3 = bind.scale) != null ? _b3 : [1, 1])
                    })
                  );
                });
              }));
            }
            manager.registerExpression(expression);
          }))
        );
        return manager;
      });
    }
    _v0Import(gltf) {
      return __async2(this, null, function* () {
        var _a;
        const json = this.parser.json;
        const vrmExt = (_a = json.extensions) == null ? void 0 : _a.VRM;
        if (!vrmExt) {
          return null;
        }
        const schemaBlendShape = vrmExt.blendShapeMaster;
        if (!schemaBlendShape) {
          return null;
        }
        const manager = new VRMExpressionManager();
        const schemaBlendShapeGroups = schemaBlendShape.blendShapeGroups;
        if (!schemaBlendShapeGroups) {
          return manager;
        }
        const blendShapeNameSet = /* @__PURE__ */ new Set();
        yield Promise.all(
          schemaBlendShapeGroups.map((schemaGroup) => __async2(this, null, function* () {
            var _a2;
            const v0PresetName = schemaGroup.presetName;
            const v1PresetName = v0PresetName != null && _VRMExpressionLoaderPlugin2.v0v1PresetNameMap[v0PresetName] || null;
            const name = v1PresetName != null ? v1PresetName : schemaGroup.name;
            if (name == null) {
              console.warn("VRMExpressionLoaderPlugin: One of custom expressions has no name. Ignoring the expression");
              return;
            }
            if (blendShapeNameSet.has(name)) {
              console.warn(
                `VRMExpressionLoaderPlugin: An expression preset ${v0PresetName} has duplicated entries. Ignoring the expression`
              );
              return;
            }
            blendShapeNameSet.add(name);
            const expression = new VRMExpression(name);
            gltf.scene.add(expression);
            expression.isBinary = (_a2 = schemaGroup.isBinary) != null ? _a2 : false;
            if (schemaGroup.binds) {
              schemaGroup.binds.forEach((bind) => __async2(this, null, function* () {
                var _a3;
                if (bind.mesh === void 0 || bind.index === void 0) {
                  return;
                }
                const nodesUsingMesh = [];
                (_a3 = json.nodes) == null ? void 0 : _a3.forEach((node, i) => {
                  if (node.mesh === bind.mesh) {
                    nodesUsingMesh.push(i);
                  }
                });
                const morphTargetIndex = bind.index;
                yield Promise.all(
                  nodesUsingMesh.map((nodeIndex) => __async2(this, null, function* () {
                    var _a4;
                    const primitives = yield gltfExtractPrimitivesFromNode(gltf, nodeIndex);
                    if (!primitives.every(
                      (primitive) => Array.isArray(primitive.morphTargetInfluences) && morphTargetIndex < primitive.morphTargetInfluences.length
                    )) {
                      console.warn(
                        `VRMExpressionLoaderPlugin: ${schemaGroup.name} attempts to index ${morphTargetIndex}th morph but not found.`
                      );
                      return;
                    }
                    expression.addBind(
                      new VRMExpressionMorphTargetBind({
                        primitives,
                        index: morphTargetIndex,
                        weight: 0.01 * ((_a4 = bind.weight) != null ? _a4 : 100)
                        // narrowing the range from [ 0.0 - 100.0 ] to [ 0.0 - 1.0 ]
                      })
                    );
                  }))
                );
              }));
            }
            const materialValues = schemaGroup.materialValues;
            if (materialValues && materialValues.length !== 0) {
              materialValues.forEach((materialValue) => {
                if (materialValue.materialName === void 0 || materialValue.propertyName === void 0 || materialValue.targetValue === void 0) {
                  return;
                }
                const materials = [];
                gltf.scene.traverse((object) => {
                  if (object.material) {
                    const material = object.material;
                    if (Array.isArray(material)) {
                      materials.push(
                        ...material.filter(
                          (mtl) => (mtl.name === materialValue.materialName || mtl.name === materialValue.materialName + " (Outline)") && materials.indexOf(mtl) === -1
                        )
                      );
                    } else if (material.name === materialValue.materialName && materials.indexOf(material) === -1) {
                      materials.push(material);
                    }
                  }
                });
                const materialPropertyName = materialValue.propertyName;
                materials.forEach((material) => {
                  if (materialPropertyName === "_MainTex_ST") {
                    const scale = new Vector2(materialValue.targetValue[0], materialValue.targetValue[1]);
                    const offset = new Vector2(materialValue.targetValue[2], materialValue.targetValue[3]);
                    offset.y = 1 - offset.y - scale.y;
                    expression.addBind(
                      new VRMExpressionTextureTransformBind({
                        material,
                        scale,
                        offset
                      })
                    );
                    return;
                  }
                  const materialColorType = v0ExpressionMaterialColorMap[materialPropertyName];
                  if (materialColorType) {
                    expression.addBind(
                      new VRMExpressionMaterialColorBind({
                        material,
                        type: materialColorType,
                        targetValue: new Color().fromArray(materialValue.targetValue),
                        targetAlpha: materialValue.targetValue[3]
                      })
                    );
                    return;
                  }
                  console.warn(materialPropertyName + " is not supported");
                });
              });
            }
            manager.registerExpression(expression);
          }))
        );
        return manager;
      });
    }
  };
  _VRMExpressionLoaderPlugin.v0v1PresetNameMap = {
    a: "aa",
    e: "ee",
    i: "ih",
    o: "oh",
    u: "ou",
    blink: "blink",
    joy: "happy",
    angry: "angry",
    sorrow: "sad",
    fun: "relaxed",
    lookup: "lookUp",
    lookdown: "lookDown",
    lookleft: "lookLeft",
    lookright: "lookRight",
    // eslint-disable-next-line @typescript-eslint/naming-convention
    blink_l: "blinkLeft",
    // eslint-disable-next-line @typescript-eslint/naming-convention
    blink_r: "blinkRight",
    neutral: "neutral"
  };
  var VRMExpressionLoaderPlugin = _VRMExpressionLoaderPlugin;
  var _VRMFirstPerson = class _VRMFirstPerson2 {
    /**
     * Create a new VRMFirstPerson object.
     *
     * @param humanoid A {@link VRMHumanoid}
     * @param meshAnnotations A renderer settings. See the description of [[RendererFirstPersonFlags]] for more info
     */
    constructor(humanoid, meshAnnotations) {
      this._firstPersonOnlyLayer = _VRMFirstPerson2.DEFAULT_FIRSTPERSON_ONLY_LAYER;
      this._thirdPersonOnlyLayer = _VRMFirstPerson2.DEFAULT_THIRDPERSON_ONLY_LAYER;
      this._initializedLayers = false;
      this.humanoid = humanoid;
      this.meshAnnotations = meshAnnotations;
    }
    /**
     * Copy the given {@link VRMFirstPerson} into this one.
     * {@link humanoid} must be same as the source one.
     * @param source The {@link VRMFirstPerson} you want to copy
     * @returns this
     */
    copy(source) {
      if (this.humanoid !== source.humanoid) {
        throw new Error("VRMFirstPerson: humanoid must be same in order to copy");
      }
      this.meshAnnotations = source.meshAnnotations.map((annotation) => ({
        meshes: annotation.meshes.concat(),
        type: annotation.type
      }));
      return this;
    }
    /**
     * Returns a clone of this {@link VRMFirstPerson}.
     * @returns Copied {@link VRMFirstPerson}
     */
    clone() {
      return new _VRMFirstPerson2(this.humanoid, this.meshAnnotations).copy(this);
    }
    /**
     * A camera layer represents `FirstPersonOnly` layer.
     * Note that **you must call {@link setup} first before you use the layer feature** or it does not work properly.
     *
     * The value is {@link DEFAULT_FIRSTPERSON_ONLY_LAYER} by default but you can change the layer by specifying via {@link setup} if you prefer.
     *
     * @see https://vrm.dev/en/univrm/api/univrm_use_firstperson/
     * @see https://threejs.org/docs/#api/en/core/Layers
     */
    get firstPersonOnlyLayer() {
      return this._firstPersonOnlyLayer;
    }
    /**
     * A camera layer represents `ThirdPersonOnly` layer.
     * Note that **you must call {@link setup} first before you use the layer feature** or it does not work properly.
     *
     * The value is {@link DEFAULT_THIRDPERSON_ONLY_LAYER} by default but you can change the layer by specifying via {@link setup} if you prefer.
     *
     * @see https://vrm.dev/en/univrm/api/univrm_use_firstperson/
     * @see https://threejs.org/docs/#api/en/core/Layers
     */
    get thirdPersonOnlyLayer() {
      return this._thirdPersonOnlyLayer;
    }
    /**
     * In this method, it assigns layers for every meshes based on mesh annotations.
     * You must call this method first before you use the layer feature.
     *
     * This is an equivalent of [VRMFirstPerson.Setup](https://github.com/vrm-c/UniVRM/blob/73a5bd8fcddaa2a7a8735099a97e63c9db3e5ea0/Assets/VRM/Runtime/FirstPerson/VRMFirstPerson.cs#L295-L299) of the UniVRM.
     *
     * The `cameraLayer` parameter specifies which layer will be assigned for `FirstPersonOnly` / `ThirdPersonOnly`.
     * In UniVRM, we specified those by naming each desired layer as `FIRSTPERSON_ONLY_LAYER` / `THIRDPERSON_ONLY_LAYER`
     * but we are going to specify these layers at here since we are unable to name layers in Three.js.
     *
     * @param cameraLayer Specify which layer will be for `FirstPersonOnly` / `ThirdPersonOnly`.
     */
    setup({
      firstPersonOnlyLayer = _VRMFirstPerson2.DEFAULT_FIRSTPERSON_ONLY_LAYER,
      thirdPersonOnlyLayer = _VRMFirstPerson2.DEFAULT_THIRDPERSON_ONLY_LAYER
    } = {}) {
      if (this._initializedLayers) {
        return;
      }
      this._firstPersonOnlyLayer = firstPersonOnlyLayer;
      this._thirdPersonOnlyLayer = thirdPersonOnlyLayer;
      this.meshAnnotations.forEach((item) => {
        item.meshes.forEach((mesh) => {
          if (item.type === "firstPersonOnly") {
            mesh.layers.set(this._firstPersonOnlyLayer);
            mesh.traverse((child) => child.layers.set(this._firstPersonOnlyLayer));
          } else if (item.type === "thirdPersonOnly") {
            mesh.layers.set(this._thirdPersonOnlyLayer);
            mesh.traverse((child) => child.layers.set(this._thirdPersonOnlyLayer));
          } else if (item.type === "auto") {
            this._createHeadlessModel(mesh);
          }
        });
      });
      this._initializedLayers = true;
    }
    _excludeTriangles(triangles, bws, skinIndex, exclude) {
      let count = 0;
      if (bws != null && bws.length > 0) {
        for (let i = 0; i < triangles.length; i += 3) {
          const a = triangles[i];
          const b = triangles[i + 1];
          const c = triangles[i + 2];
          const bw0 = bws[a];
          const skin0 = skinIndex[a];
          if (bw0[0] > 0 && exclude.includes(skin0[0])) continue;
          if (bw0[1] > 0 && exclude.includes(skin0[1])) continue;
          if (bw0[2] > 0 && exclude.includes(skin0[2])) continue;
          if (bw0[3] > 0 && exclude.includes(skin0[3])) continue;
          const bw1 = bws[b];
          const skin1 = skinIndex[b];
          if (bw1[0] > 0 && exclude.includes(skin1[0])) continue;
          if (bw1[1] > 0 && exclude.includes(skin1[1])) continue;
          if (bw1[2] > 0 && exclude.includes(skin1[2])) continue;
          if (bw1[3] > 0 && exclude.includes(skin1[3])) continue;
          const bw2 = bws[c];
          const skin2 = skinIndex[c];
          if (bw2[0] > 0 && exclude.includes(skin2[0])) continue;
          if (bw2[1] > 0 && exclude.includes(skin2[1])) continue;
          if (bw2[2] > 0 && exclude.includes(skin2[2])) continue;
          if (bw2[3] > 0 && exclude.includes(skin2[3])) continue;
          triangles[count++] = a;
          triangles[count++] = b;
          triangles[count++] = c;
        }
      }
      return count;
    }
    _createErasedMesh(src, erasingBonesIndex) {
      const dst = new SkinnedMesh(src.geometry.clone(), src.material);
      dst.name = `${src.name}(erase)`;
      dst.frustumCulled = src.frustumCulled;
      dst.layers.set(this._firstPersonOnlyLayer);
      const geometry = dst.geometry;
      const skinIndexAttr = geometry.getAttribute("skinIndex");
      const skinIndexAttrArray = skinIndexAttr instanceof GLBufferAttribute ? [] : skinIndexAttr.array;
      const skinIndex = [];
      for (let i = 0; i < skinIndexAttrArray.length; i += 4) {
        skinIndex.push([
          skinIndexAttrArray[i],
          skinIndexAttrArray[i + 1],
          skinIndexAttrArray[i + 2],
          skinIndexAttrArray[i + 3]
        ]);
      }
      const skinWeightAttr = geometry.getAttribute("skinWeight");
      const skinWeightAttrArray = skinWeightAttr instanceof GLBufferAttribute ? [] : skinWeightAttr.array;
      const skinWeight = [];
      for (let i = 0; i < skinWeightAttrArray.length; i += 4) {
        skinWeight.push([
          skinWeightAttrArray[i],
          skinWeightAttrArray[i + 1],
          skinWeightAttrArray[i + 2],
          skinWeightAttrArray[i + 3]
        ]);
      }
      const index = geometry.getIndex();
      if (!index) {
        throw new Error("The geometry doesn't have an index buffer");
      }
      const oldTriangles = Array.from(index.array);
      const count = this._excludeTriangles(oldTriangles, skinWeight, skinIndex, erasingBonesIndex);
      const newTriangle = [];
      for (let i = 0; i < count; i++) {
        newTriangle[i] = oldTriangles[i];
      }
      geometry.setIndex(newTriangle);
      if (src.onBeforeRender) {
        dst.onBeforeRender = src.onBeforeRender;
      }
      dst.bind(new Skeleton(src.skeleton.bones, src.skeleton.boneInverses), new Matrix4());
      return dst;
    }
    _createHeadlessModelForSkinnedMesh(parent, mesh) {
      const eraseBoneIndexes = [];
      mesh.skeleton.bones.forEach((bone, index) => {
        if (this._isEraseTarget(bone)) eraseBoneIndexes.push(index);
      });
      if (!eraseBoneIndexes.length) {
        mesh.layers.enable(this._thirdPersonOnlyLayer);
        mesh.layers.enable(this._firstPersonOnlyLayer);
        return;
      }
      mesh.layers.set(this._thirdPersonOnlyLayer);
      const newMesh = this._createErasedMesh(mesh, eraseBoneIndexes);
      parent.add(newMesh);
    }
    _createHeadlessModel(node) {
      if (node.type === "Group") {
        node.layers.set(this._thirdPersonOnlyLayer);
        if (this._isEraseTarget(node)) {
          node.traverse((child) => child.layers.set(this._thirdPersonOnlyLayer));
        } else {
          const parent = new Group();
          parent.name = `_headless_${node.name}`;
          parent.layers.set(this._firstPersonOnlyLayer);
          node.parent.add(parent);
          node.children.filter((child) => child.type === "SkinnedMesh").forEach((child) => {
            const skinnedMesh = child;
            this._createHeadlessModelForSkinnedMesh(parent, skinnedMesh);
          });
        }
      } else if (node.type === "SkinnedMesh") {
        const skinnedMesh = node;
        this._createHeadlessModelForSkinnedMesh(node.parent, skinnedMesh);
      } else {
        if (this._isEraseTarget(node)) {
          node.layers.set(this._thirdPersonOnlyLayer);
          node.traverse((child) => child.layers.set(this._thirdPersonOnlyLayer));
        }
      }
    }
    _isEraseTarget(bone) {
      if (bone === this.humanoid.getRawBoneNode("head")) {
        return true;
      } else if (!bone.parent) {
        return false;
      } else {
        return this._isEraseTarget(bone.parent);
      }
    }
  };
  _VRMFirstPerson.DEFAULT_FIRSTPERSON_ONLY_LAYER = 9;
  _VRMFirstPerson.DEFAULT_THIRDPERSON_ONLY_LAYER = 10;
  var VRMFirstPerson = _VRMFirstPerson;
  var POSSIBLE_SPEC_VERSIONS2 = /* @__PURE__ */ new Set(["1.0", "1.0-beta"]);
  var VRMFirstPersonLoaderPlugin = class {
    get name() {
      return "VRMFirstPersonLoaderPlugin";
    }
    constructor(parser) {
      this.parser = parser;
    }
    afterRoot(gltf) {
      return __async2(this, null, function* () {
        const vrmHumanoid = gltf.userData.vrmHumanoid;
        if (vrmHumanoid === null) {
          return;
        } else if (vrmHumanoid === void 0) {
          throw new Error(
            "VRMFirstPersonLoaderPlugin: vrmHumanoid is undefined. VRMHumanoidLoaderPlugin have to be used first"
          );
        }
        gltf.userData.vrmFirstPerson = yield this._import(gltf, vrmHumanoid);
      });
    }
    /**
     * Import a {@link VRMFirstPerson} from a VRM.
     *
     * @param gltf A parsed result of GLTF taken from GLTFLoader
     * @param humanoid A {@link VRMHumanoid} instance that represents the VRM
     */
    _import(gltf, humanoid) {
      return __async2(this, null, function* () {
        if (humanoid == null) {
          return null;
        }
        const v1Result = yield this._v1Import(gltf, humanoid);
        if (v1Result) {
          return v1Result;
        }
        const v0Result = yield this._v0Import(gltf, humanoid);
        if (v0Result) {
          return v0Result;
        }
        return null;
      });
    }
    _v1Import(gltf, humanoid) {
      return __async2(this, null, function* () {
        var _a, _b;
        const json = this.parser.json;
        const isVRMUsed = ((_a = json.extensionsUsed) == null ? void 0 : _a.indexOf("VRMC_vrm")) !== -1;
        if (!isVRMUsed) {
          return null;
        }
        const extension = (_b = json.extensions) == null ? void 0 : _b["VRMC_vrm"];
        if (!extension) {
          return null;
        }
        const specVersion = extension.specVersion;
        if (!POSSIBLE_SPEC_VERSIONS2.has(specVersion)) {
          console.warn(`VRMFirstPersonLoaderPlugin: Unknown VRMC_vrm specVersion "${specVersion}"`);
          return null;
        }
        const schemaFirstPerson = extension.firstPerson;
        if (!schemaFirstPerson) {
          return null;
        }
        const meshAnnotations = [];
        const nodePrimitivesMap = yield gltfExtractPrimitivesFromNodes(gltf);
        Array.from(nodePrimitivesMap.entries()).forEach(([nodeIndex, primitives]) => {
          var _a2;
          const annotation = schemaFirstPerson.meshAnnotations ? schemaFirstPerson.meshAnnotations.find((a) => a.node === nodeIndex) : void 0;
          meshAnnotations.push({
            meshes: primitives,
            type: (_a2 = annotation == null ? void 0 : annotation.type) != null ? _a2 : "both"
          });
        });
        return new VRMFirstPerson(humanoid, meshAnnotations);
      });
    }
    _v0Import(gltf, humanoid) {
      return __async2(this, null, function* () {
        var _a;
        const json = this.parser.json;
        const vrmExt = (_a = json.extensions) == null ? void 0 : _a.VRM;
        if (!vrmExt) {
          return null;
        }
        const schemaFirstPerson = vrmExt.firstPerson;
        if (!schemaFirstPerson) {
          return null;
        }
        const meshAnnotations = [];
        const nodePrimitivesMap = yield gltfExtractPrimitivesFromNodes(gltf);
        Array.from(nodePrimitivesMap.entries()).forEach(([nodeIndex, primitives]) => {
          const schemaNode = json.nodes[nodeIndex];
          const flag = schemaFirstPerson.meshAnnotations ? schemaFirstPerson.meshAnnotations.find((a) => a.mesh === schemaNode.mesh) : void 0;
          meshAnnotations.push({
            meshes: primitives,
            type: this._convertV0FlagToV1Type(flag == null ? void 0 : flag.firstPersonFlag)
          });
        });
        return new VRMFirstPerson(humanoid, meshAnnotations);
      });
    }
    _convertV0FlagToV1Type(flag) {
      if (flag === "FirstPersonOnly") {
        return "firstPersonOnly";
      } else if (flag === "ThirdPersonOnly") {
        return "thirdPersonOnly";
      } else if (flag === "Auto") {
        return "auto";
      } else {
        return "both";
      }
    }
  };
  var _v3A = new Vector3();
  var _v3B = new Vector3();
  var _quatA = new Quaternion();
  var VRMHumanoidHelper = class extends Group {
    constructor(humanoid) {
      super();
      this.vrmHumanoid = humanoid;
      this._boneAxesMap = /* @__PURE__ */ new Map();
      Object.values(humanoid.humanBones).forEach((bone) => {
        const helper = new AxesHelper(1);
        helper.matrixAutoUpdate = false;
        helper.material.depthTest = false;
        helper.material.depthWrite = false;
        this.add(helper);
        this._boneAxesMap.set(bone, helper);
      });
    }
    dispose() {
      Array.from(this._boneAxesMap.values()).forEach((axes) => {
        axes.geometry.dispose();
        axes.material.dispose();
      });
    }
    updateMatrixWorld(force) {
      Array.from(this._boneAxesMap.entries()).forEach(([bone, axes]) => {
        bone.node.updateWorldMatrix(true, false);
        bone.node.matrixWorld.decompose(_v3A, _quatA, _v3B);
        const scale = _v3A.set(0.1, 0.1, 0.1).divide(_v3B);
        axes.matrix.copy(bone.node.matrixWorld).scale(scale);
      });
      super.updateMatrixWorld(force);
    }
  };
  var VRMHumanBoneList = [
    "hips",
    "spine",
    "chest",
    "upperChest",
    "neck",
    "head",
    "leftEye",
    "rightEye",
    "jaw",
    "leftUpperLeg",
    "leftLowerLeg",
    "leftFoot",
    "leftToes",
    "rightUpperLeg",
    "rightLowerLeg",
    "rightFoot",
    "rightToes",
    "leftShoulder",
    "leftUpperArm",
    "leftLowerArm",
    "leftHand",
    "rightShoulder",
    "rightUpperArm",
    "rightLowerArm",
    "rightHand",
    "leftThumbMetacarpal",
    "leftThumbProximal",
    "leftThumbDistal",
    "leftIndexProximal",
    "leftIndexIntermediate",
    "leftIndexDistal",
    "leftMiddleProximal",
    "leftMiddleIntermediate",
    "leftMiddleDistal",
    "leftRingProximal",
    "leftRingIntermediate",
    "leftRingDistal",
    "leftLittleProximal",
    "leftLittleIntermediate",
    "leftLittleDistal",
    "rightThumbMetacarpal",
    "rightThumbProximal",
    "rightThumbDistal",
    "rightIndexProximal",
    "rightIndexIntermediate",
    "rightIndexDistal",
    "rightMiddleProximal",
    "rightMiddleIntermediate",
    "rightMiddleDistal",
    "rightRingProximal",
    "rightRingIntermediate",
    "rightRingDistal",
    "rightLittleProximal",
    "rightLittleIntermediate",
    "rightLittleDistal"
  ];
  var VRMHumanBoneParentMap = {
    hips: null,
    spine: "hips",
    chest: "spine",
    upperChest: "chest",
    neck: "upperChest",
    head: "neck",
    leftEye: "head",
    rightEye: "head",
    jaw: "head",
    leftUpperLeg: "hips",
    leftLowerLeg: "leftUpperLeg",
    leftFoot: "leftLowerLeg",
    leftToes: "leftFoot",
    rightUpperLeg: "hips",
    rightLowerLeg: "rightUpperLeg",
    rightFoot: "rightLowerLeg",
    rightToes: "rightFoot",
    leftShoulder: "upperChest",
    leftUpperArm: "leftShoulder",
    leftLowerArm: "leftUpperArm",
    leftHand: "leftLowerArm",
    rightShoulder: "upperChest",
    rightUpperArm: "rightShoulder",
    rightLowerArm: "rightUpperArm",
    rightHand: "rightLowerArm",
    leftThumbMetacarpal: "leftHand",
    leftThumbProximal: "leftThumbMetacarpal",
    leftThumbDistal: "leftThumbProximal",
    leftIndexProximal: "leftHand",
    leftIndexIntermediate: "leftIndexProximal",
    leftIndexDistal: "leftIndexIntermediate",
    leftMiddleProximal: "leftHand",
    leftMiddleIntermediate: "leftMiddleProximal",
    leftMiddleDistal: "leftMiddleIntermediate",
    leftRingProximal: "leftHand",
    leftRingIntermediate: "leftRingProximal",
    leftRingDistal: "leftRingIntermediate",
    leftLittleProximal: "leftHand",
    leftLittleIntermediate: "leftLittleProximal",
    leftLittleDistal: "leftLittleIntermediate",
    rightThumbMetacarpal: "rightHand",
    rightThumbProximal: "rightThumbMetacarpal",
    rightThumbDistal: "rightThumbProximal",
    rightIndexProximal: "rightHand",
    rightIndexIntermediate: "rightIndexProximal",
    rightIndexDistal: "rightIndexIntermediate",
    rightMiddleProximal: "rightHand",
    rightMiddleIntermediate: "rightMiddleProximal",
    rightMiddleDistal: "rightMiddleIntermediate",
    rightRingProximal: "rightHand",
    rightRingIntermediate: "rightRingProximal",
    rightRingDistal: "rightRingIntermediate",
    rightLittleProximal: "rightHand",
    rightLittleIntermediate: "rightLittleProximal",
    rightLittleDistal: "rightLittleIntermediate"
  };
  function quatInvertCompat(target) {
    if (target.invert) {
      target.invert();
    } else {
      target.inverse();
    }
    return target;
  }
  var _v3A2 = new Vector3();
  var _quatA2 = new Quaternion();
  var VRMRig = class {
    /**
     * Create a new {@link VRMHumanoid}.
     * @param humanBones A {@link VRMHumanBones} contains all the bones of the new humanoid
     */
    constructor(humanBones) {
      this.humanBones = humanBones;
      this.restPose = this.getAbsolutePose();
    }
    /**
     * Return the current absolute pose of this humanoid as a {@link VRMPose}.
     * Note that the output result will contain initial state of the VRM and not compatible between different models.
     * You might want to use {@link getPose} instead.
     */
    getAbsolutePose() {
      const pose = {};
      Object.keys(this.humanBones).forEach((vrmBoneNameString) => {
        const vrmBoneName = vrmBoneNameString;
        const node = this.getBoneNode(vrmBoneName);
        if (!node) {
          return;
        }
        _v3A2.copy(node.position);
        _quatA2.copy(node.quaternion);
        pose[vrmBoneName] = {
          position: _v3A2.toArray(),
          rotation: _quatA2.toArray()
        };
      });
      return pose;
    }
    /**
     * Return the current pose of this humanoid as a {@link VRMPose}.
     *
     * Each transform is a local transform relative from rest pose (T-pose).
     */
    getPose() {
      const pose = {};
      Object.keys(this.humanBones).forEach((boneNameString) => {
        const boneName = boneNameString;
        const node = this.getBoneNode(boneName);
        if (!node) {
          return;
        }
        _v3A2.set(0, 0, 0);
        _quatA2.identity();
        const restState = this.restPose[boneName];
        if (restState == null ? void 0 : restState.position) {
          _v3A2.fromArray(restState.position).negate();
        }
        if (restState == null ? void 0 : restState.rotation) {
          quatInvertCompat(_quatA2.fromArray(restState.rotation));
        }
        _v3A2.add(node.position);
        _quatA2.premultiply(node.quaternion);
        pose[boneName] = {
          position: _v3A2.toArray(),
          rotation: _quatA2.toArray()
        };
      });
      return pose;
    }
    /**
     * Let the humanoid do a specified pose.
     *
     * Each transform have to be a local transform relative from rest pose (T-pose).
     * You can pass what you got from {@link getPose}.
     *
     * @param poseObject A [[VRMPose]] that represents a single pose
     */
    setPose(poseObject) {
      Object.entries(poseObject).forEach(([boneNameString, state]) => {
        const boneName = boneNameString;
        const node = this.getBoneNode(boneName);
        if (!node) {
          return;
        }
        const restState = this.restPose[boneName];
        if (!restState) {
          return;
        }
        if (state == null ? void 0 : state.position) {
          node.position.fromArray(state.position);
          if (restState.position) {
            node.position.add(_v3A2.fromArray(restState.position));
          }
        }
        if (state == null ? void 0 : state.rotation) {
          node.quaternion.fromArray(state.rotation);
          if (restState.rotation) {
            node.quaternion.multiply(_quatA2.fromArray(restState.rotation));
          }
        }
      });
    }
    /**
     * Reset the humanoid to its rest pose.
     */
    resetPose() {
      Object.entries(this.restPose).forEach(([boneName, rest]) => {
        const node = this.getBoneNode(boneName);
        if (!node) {
          return;
        }
        if (rest == null ? void 0 : rest.position) {
          node.position.fromArray(rest.position);
        }
        if (rest == null ? void 0 : rest.rotation) {
          node.quaternion.fromArray(rest.rotation);
        }
      });
    }
    /**
     * Return a bone bound to a specified {@link VRMHumanBoneName}, as a {@link VRMHumanBone}.
     *
     * @param name Name of the bone you want
     */
    getBone(name) {
      var _a;
      return (_a = this.humanBones[name]) != null ? _a : void 0;
    }
    /**
     * Return a bone bound to a specified {@link VRMHumanBoneName}, as a `THREE.Object3D`.
     *
     * @param name Name of the bone you want
     */
    getBoneNode(name) {
      var _a, _b;
      return (_b = (_a = this.humanBones[name]) == null ? void 0 : _a.node) != null ? _b : null;
    }
  };
  var _v3A3 = new Vector3();
  var _quatA3 = new Quaternion();
  var _boneWorldPos = new Vector3();
  var VRMHumanoidRig = class _VRMHumanoidRig extends VRMRig {
    static _setupTransforms(modelRig) {
      const root = new Object3D();
      root.name = "VRMHumanoidRig";
      const boneWorldPositions = {};
      const boneRotations = {};
      const parentWorldRotations = {};
      VRMHumanBoneList.forEach((boneName) => {
        var _a;
        const boneNode = modelRig.getBoneNode(boneName);
        if (boneNode) {
          const boneWorldPosition = new Vector3();
          const boneWorldRotation = new Quaternion();
          boneNode.updateWorldMatrix(true, false);
          boneNode.matrixWorld.decompose(boneWorldPosition, boneWorldRotation, _v3A3);
          boneWorldPositions[boneName] = boneWorldPosition;
          boneRotations[boneName] = boneNode.quaternion.clone();
          const parentWorldRotation = new Quaternion();
          (_a = boneNode.parent) == null ? void 0 : _a.matrixWorld.decompose(_v3A3, parentWorldRotation, _v3A3);
          parentWorldRotations[boneName] = parentWorldRotation;
        }
      });
      const rigBones = {};
      VRMHumanBoneList.forEach((boneName) => {
        var _a;
        const boneNode = modelRig.getBoneNode(boneName);
        if (boneNode) {
          const boneWorldPosition = boneWorldPositions[boneName];
          let currentBoneName = boneName;
          let parentBoneWorldPosition;
          while (parentBoneWorldPosition == null) {
            currentBoneName = VRMHumanBoneParentMap[currentBoneName];
            if (currentBoneName == null) {
              break;
            }
            parentBoneWorldPosition = boneWorldPositions[currentBoneName];
          }
          const rigBoneNode = new Object3D();
          rigBoneNode.name = "Normalized_" + boneNode.name;
          const parentRigBoneNode = currentBoneName ? (_a = rigBones[currentBoneName]) == null ? void 0 : _a.node : root;
          parentRigBoneNode.add(rigBoneNode);
          rigBoneNode.position.copy(boneWorldPosition);
          if (parentBoneWorldPosition) {
            rigBoneNode.position.sub(parentBoneWorldPosition);
          }
          rigBones[boneName] = { node: rigBoneNode };
        }
      });
      return {
        rigBones,
        root,
        parentWorldRotations,
        boneRotations
      };
    }
    constructor(humanoid) {
      const { rigBones, root, parentWorldRotations, boneRotations } = _VRMHumanoidRig._setupTransforms(humanoid);
      super(rigBones);
      this.original = humanoid;
      this.root = root;
      this._parentWorldRotations = parentWorldRotations;
      this._boneRotations = boneRotations;
    }
    /**
     * Update this humanoid rig.
     */
    update() {
      VRMHumanBoneList.forEach((boneName) => {
        const boneNode = this.original.getBoneNode(boneName);
        if (boneNode != null) {
          const rigBoneNode = this.getBoneNode(boneName);
          const parentWorldRotation = this._parentWorldRotations[boneName];
          const invParentWorldRotation = _quatA3.copy(parentWorldRotation).invert();
          const boneRotation = this._boneRotations[boneName];
          boneNode.quaternion.copy(rigBoneNode.quaternion).multiply(parentWorldRotation).premultiply(invParentWorldRotation).multiply(boneRotation);
          if (boneName === "hips") {
            const boneWorldPosition = rigBoneNode.getWorldPosition(_boneWorldPos);
            boneNode.parent.updateWorldMatrix(true, false);
            const parentWorldMatrix = boneNode.parent.matrixWorld;
            const localPosition = boneWorldPosition.applyMatrix4(parentWorldMatrix.invert());
            boneNode.position.copy(localPosition);
          }
        }
      });
    }
  };
  var VRMHumanoid = class _VRMHumanoid {
    // TODO: Rename
    /**
     * @deprecated Deprecated. Use either {@link rawRestPose} or {@link normalizedRestPose} instead.
     */
    get restPose() {
      console.warn("VRMHumanoid: restPose is deprecated. Use either rawRestPose or normalizedRestPose instead.");
      return this.rawRestPose;
    }
    /**
     * A {@link VRMPose} of its raw human bones that is its default state.
     * Note that it's not compatible with {@link setRawPose} and {@link getRawPose}, since it contains non-relative values of each local transforms.
     */
    get rawRestPose() {
      return this._rawHumanBones.restPose;
    }
    /**
     * A {@link VRMPose} of its normalized human bones that is its default state.
     * Note that it's not compatible with {@link setNormalizedPose} and {@link getNormalizedPose}, since it contains non-relative values of each local transforms.
     */
    get normalizedRestPose() {
      return this._normalizedHumanBones.restPose;
    }
    /**
     * A map from {@link VRMHumanBoneName} to raw {@link VRMHumanBone}s.
     */
    get humanBones() {
      return this._rawHumanBones.humanBones;
    }
    /**
     * A map from {@link VRMHumanBoneName} to raw {@link VRMHumanBone}s.
     */
    get rawHumanBones() {
      return this._rawHumanBones.humanBones;
    }
    /**
     * A map from {@link VRMHumanBoneName} to normalized {@link VRMHumanBone}s.
     */
    get normalizedHumanBones() {
      return this._normalizedHumanBones.humanBones;
    }
    /**
     * The root of normalized {@link VRMHumanBone}s.
     */
    get normalizedHumanBonesRoot() {
      return this._normalizedHumanBones.root;
    }
    /**
     * Create a new {@link VRMHumanoid}.
     * @param humanBones A {@link VRMHumanBones} contains all the bones of the new humanoid
     * @param autoUpdateHumanBones Whether it copies pose from normalizedHumanBones to rawHumanBones on {@link update}. `true` by default.
     */
    constructor(humanBones, options) {
      var _a;
      this.autoUpdateHumanBones = (_a = options == null ? void 0 : options.autoUpdateHumanBones) != null ? _a : true;
      this._rawHumanBones = new VRMRig(humanBones);
      this._normalizedHumanBones = new VRMHumanoidRig(this._rawHumanBones);
    }
    /**
     * Copy the given {@link VRMHumanoid} into this one.
     * @param source The {@link VRMHumanoid} you want to copy
     * @returns this
     */
    copy(source) {
      this.autoUpdateHumanBones = source.autoUpdateHumanBones;
      this._rawHumanBones = new VRMRig(source.humanBones);
      this._normalizedHumanBones = new VRMHumanoidRig(this._rawHumanBones);
      return this;
    }
    /**
     * Returns a clone of this {@link VRMHumanoid}.
     * @returns Copied {@link VRMHumanoid}
     */
    clone() {
      return new _VRMHumanoid(this.humanBones, { autoUpdateHumanBones: this.autoUpdateHumanBones }).copy(this);
    }
    /**
     * @deprecated Deprecated. Use either {@link getRawAbsolutePose} or {@link getNormalizedAbsolutePose} instead.
     */
    getAbsolutePose() {
      console.warn(
        "VRMHumanoid: getAbsolutePose() is deprecated. Use either getRawAbsolutePose() or getNormalizedAbsolutePose() instead."
      );
      return this.getRawAbsolutePose();
    }
    /**
     * Return the current absolute pose of this raw human bones as a {@link VRMPose}.
     * Note that the output result will contain initial state of the VRM and not compatible between different models.
     * You might want to use {@link getRawPose} instead.
     */
    getRawAbsolutePose() {
      return this._rawHumanBones.getAbsolutePose();
    }
    /**
     * Return the current absolute pose of this normalized human bones as a {@link VRMPose}.
     * Note that the output result will contain initial state of the VRM and not compatible between different models.
     * You might want to use {@link getNormalizedPose} instead.
     */
    getNormalizedAbsolutePose() {
      return this._normalizedHumanBones.getAbsolutePose();
    }
    /**
     * @deprecated Deprecated. Use either {@link getRawPose} or {@link getNormalizedPose} instead.
     */
    getPose() {
      console.warn("VRMHumanoid: getPose() is deprecated. Use either getRawPose() or getNormalizedPose() instead.");
      return this.getRawPose();
    }
    /**
     * Return the current pose of raw human bones as a {@link VRMPose}.
     *
     * Each transform is a local transform relative from rest pose (T-pose).
     */
    getRawPose() {
      return this._rawHumanBones.getPose();
    }
    /**
     * Return the current pose of normalized human bones as a {@link VRMPose}.
     *
     * Each transform is a local transform relative from rest pose (T-pose).
     */
    getNormalizedPose() {
      return this._normalizedHumanBones.getPose();
    }
    /**
     * @deprecated Deprecated. Use either {@link setRawPose} or {@link setNormalizedPose} instead.
     */
    setPose(poseObject) {
      console.warn("VRMHumanoid: setPose() is deprecated. Use either setRawPose() or setNormalizedPose() instead.");
      return this.setRawPose(poseObject);
    }
    /**
     * Let the raw human bones do a specified pose.
     *
     * Each transform have to be a local transform relative from rest pose (T-pose).
     * You can pass what you got from {@link getRawPose}.
     *
     * If you are using {@link autoUpdateHumanBones}, you might want to use {@link setNormalizedPose} instead.
     *
     * @param poseObject A {@link VRMPose} that represents a single pose
     */
    setRawPose(poseObject) {
      return this._rawHumanBones.setPose(poseObject);
    }
    /**
     * Let the normalized human bones do a specified pose.
     *
     * Each transform have to be a local transform relative from rest pose (T-pose).
     * You can pass what you got from {@link getNormalizedPose}.
     *
     * @param poseObject A {@link VRMPose} that represents a single pose
     */
    setNormalizedPose(poseObject) {
      return this._normalizedHumanBones.setPose(poseObject);
    }
    /**
     * @deprecated Deprecated. Use either {@link resetRawPose} or {@link resetNormalizedPose} instead.
     */
    resetPose() {
      console.warn("VRMHumanoid: resetPose() is deprecated. Use either resetRawPose() or resetNormalizedPose() instead.");
      return this.resetRawPose();
    }
    /**
     * Reset the raw humanoid to its rest pose.
     *
     * If you are using {@link autoUpdateHumanBones}, you might want to use {@link resetNormalizedPose} instead.
     */
    resetRawPose() {
      return this._rawHumanBones.resetPose();
    }
    /**
     * Reset the normalized humanoid to its rest pose.
     */
    resetNormalizedPose() {
      return this._normalizedHumanBones.resetPose();
    }
    /**
     * @deprecated Deprecated. Use either {@link getRawBone} or {@link getNormalizedBone} instead.
     */
    getBone(name) {
      console.warn("VRMHumanoid: getBone() is deprecated. Use either getRawBone() or getNormalizedBone() instead.");
      return this.getRawBone(name);
    }
    /**
     * Return a raw {@link VRMHumanBone} bound to a specified {@link VRMHumanBoneName}.
     *
     * @param name Name of the bone you want
     */
    getRawBone(name) {
      return this._rawHumanBones.getBone(name);
    }
    /**
     * Return a normalized {@link VRMHumanBone} bound to a specified {@link VRMHumanBoneName}.
     *
     * @param name Name of the bone you want
     */
    getNormalizedBone(name) {
      return this._normalizedHumanBones.getBone(name);
    }
    /**
     * @deprecated Deprecated. Use either {@link getRawBoneNode} or {@link getNormalizedBoneNode} instead.
     */
    getBoneNode(name) {
      console.warn(
        "VRMHumanoid: getBoneNode() is deprecated. Use either getRawBoneNode() or getNormalizedBoneNode() instead."
      );
      return this.getRawBoneNode(name);
    }
    /**
     * Return a raw bone as a `THREE.Object3D` bound to a specified {@link VRMHumanBoneName}.
     *
     * @param name Name of the bone you want
     */
    getRawBoneNode(name) {
      return this._rawHumanBones.getBoneNode(name);
    }
    /**
     * Return a normalized bone as a `THREE.Object3D` bound to a specified {@link VRMHumanBoneName}.
     *
     * @param name Name of the bone you want
     */
    getNormalizedBoneNode(name) {
      return this._normalizedHumanBones.getBoneNode(name);
    }
    /**
     * Update the humanoid component.
     *
     * If {@link autoUpdateHumanBones} is `true`, it transfers the pose of normalized human bones to raw human bones.
     */
    update() {
      if (this.autoUpdateHumanBones) {
        this._normalizedHumanBones.update();
      }
    }
  };
  var VRMRequiredHumanBoneName = {
    Hips: "hips",
    Spine: "spine",
    Head: "head",
    LeftUpperLeg: "leftUpperLeg",
    LeftLowerLeg: "leftLowerLeg",
    LeftFoot: "leftFoot",
    RightUpperLeg: "rightUpperLeg",
    RightLowerLeg: "rightLowerLeg",
    RightFoot: "rightFoot",
    LeftUpperArm: "leftUpperArm",
    LeftLowerArm: "leftLowerArm",
    LeftHand: "leftHand",
    RightUpperArm: "rightUpperArm",
    RightLowerArm: "rightLowerArm",
    RightHand: "rightHand"
  };
  var POSSIBLE_SPEC_VERSIONS3 = /* @__PURE__ */ new Set(["1.0", "1.0-beta"]);
  var thumbBoneNameMap = {
    leftThumbProximal: "leftThumbMetacarpal",
    leftThumbIntermediate: "leftThumbProximal",
    rightThumbProximal: "rightThumbMetacarpal",
    rightThumbIntermediate: "rightThumbProximal"
  };
  var VRMHumanoidLoaderPlugin = class {
    get name() {
      return "VRMHumanoidLoaderPlugin";
    }
    constructor(parser, options) {
      this.parser = parser;
      this.helperRoot = options == null ? void 0 : options.helperRoot;
      this.autoUpdateHumanBones = options == null ? void 0 : options.autoUpdateHumanBones;
    }
    afterRoot(gltf) {
      return __async2(this, null, function* () {
        gltf.userData.vrmHumanoid = yield this._import(gltf);
      });
    }
    /**
     * Import a {@link VRMHumanoid} from a VRM.
     *
     * @param gltf A parsed result of GLTF taken from GLTFLoader
     */
    _import(gltf) {
      return __async2(this, null, function* () {
        const v1Result = yield this._v1Import(gltf);
        if (v1Result) {
          return v1Result;
        }
        const v0Result = yield this._v0Import(gltf);
        if (v0Result) {
          return v0Result;
        }
        return null;
      });
    }
    _v1Import(gltf) {
      return __async2(this, null, function* () {
        var _a, _b;
        const json = this.parser.json;
        const isVRMUsed = ((_a = json.extensionsUsed) == null ? void 0 : _a.indexOf("VRMC_vrm")) !== -1;
        if (!isVRMUsed) {
          return null;
        }
        const extension = (_b = json.extensions) == null ? void 0 : _b["VRMC_vrm"];
        if (!extension) {
          return null;
        }
        const specVersion = extension.specVersion;
        if (!POSSIBLE_SPEC_VERSIONS3.has(specVersion)) {
          console.warn(`VRMHumanoidLoaderPlugin: Unknown VRMC_vrm specVersion "${specVersion}"`);
          return null;
        }
        const schemaHumanoid = extension.humanoid;
        if (!schemaHumanoid) {
          return null;
        }
        const existsPreviousThumbName = schemaHumanoid.humanBones.leftThumbIntermediate != null || schemaHumanoid.humanBones.rightThumbIntermediate != null;
        const humanBones = {};
        if (schemaHumanoid.humanBones != null) {
          yield Promise.all(
            Object.entries(schemaHumanoid.humanBones).map((_0) => __async2(this, [_0], function* ([boneNameString, schemaHumanBone]) {
              let boneName = boneNameString;
              const index = schemaHumanBone.node;
              if (existsPreviousThumbName) {
                const thumbBoneName = thumbBoneNameMap[boneName];
                if (thumbBoneName != null) {
                  boneName = thumbBoneName;
                }
              }
              const node = yield this.parser.getDependency("node", index);
              if (node == null) {
                console.warn(`A glTF node bound to the humanoid bone ${boneName} (index = ${index}) does not exist`);
                return;
              }
              humanBones[boneName] = { node };
            }))
          );
        }
        const humanoid = new VRMHumanoid(this._ensureRequiredBonesExist(humanBones), {
          autoUpdateHumanBones: this.autoUpdateHumanBones
        });
        gltf.scene.add(humanoid.normalizedHumanBonesRoot);
        if (this.helperRoot) {
          const helper = new VRMHumanoidHelper(humanoid);
          this.helperRoot.add(helper);
          helper.renderOrder = this.helperRoot.renderOrder;
        }
        return humanoid;
      });
    }
    _v0Import(gltf) {
      return __async2(this, null, function* () {
        var _a;
        const json = this.parser.json;
        const vrmExt = (_a = json.extensions) == null ? void 0 : _a.VRM;
        if (!vrmExt) {
          return null;
        }
        const schemaHumanoid = vrmExt.humanoid;
        if (!schemaHumanoid) {
          return null;
        }
        const humanBones = {};
        if (schemaHumanoid.humanBones != null) {
          yield Promise.all(
            schemaHumanoid.humanBones.map((bone) => __async2(this, null, function* () {
              const boneName = bone.bone;
              const index = bone.node;
              if (boneName == null || index == null) {
                return;
              }
              const node = yield this.parser.getDependency("node", index);
              if (node == null) {
                console.warn(`A glTF node bound to the humanoid bone ${boneName} (index = ${index}) does not exist`);
                return;
              }
              const thumbBoneName = thumbBoneNameMap[boneName];
              const newBoneName = thumbBoneName != null ? thumbBoneName : boneName;
              if (humanBones[newBoneName] != null) {
                console.warn(
                  `Multiple bone entries for ${newBoneName} detected (index = ${index}), ignoring duplicated entries.`
                );
                return;
              }
              humanBones[newBoneName] = { node };
            }))
          );
        }
        const humanoid = new VRMHumanoid(this._ensureRequiredBonesExist(humanBones), {
          autoUpdateHumanBones: this.autoUpdateHumanBones
        });
        gltf.scene.add(humanoid.normalizedHumanBonesRoot);
        if (this.helperRoot) {
          const helper = new VRMHumanoidHelper(humanoid);
          this.helperRoot.add(helper);
          helper.renderOrder = this.helperRoot.renderOrder;
        }
        return humanoid;
      });
    }
    /**
     * Ensure required bones exist in given human bones.
     * @param humanBones Human bones
     * @returns Human bones, no longer partial!
     */
    _ensureRequiredBonesExist(humanBones) {
      const missingRequiredBones = Object.values(VRMRequiredHumanBoneName).filter(
        (requiredBoneName) => humanBones[requiredBoneName] == null
      );
      if (missingRequiredBones.length > 0) {
        throw new Error(
          `VRMHumanoidLoaderPlugin: These humanoid bones are required but not exist: ${missingRequiredBones.join(", ")}`
        );
      }
      return humanBones;
    }
  };
  var FanBufferGeometry = class extends BufferGeometry {
    constructor() {
      super();
      this._currentTheta = 0;
      this._currentRadius = 0;
      this.theta = 0;
      this.radius = 0;
      this._currentTheta = 0;
      this._currentRadius = 0;
      this._attrPos = new BufferAttribute(new Float32Array(65 * 3), 3);
      this.setAttribute("position", this._attrPos);
      this._attrIndex = new BufferAttribute(new Uint16Array(3 * 63), 1);
      this.setIndex(this._attrIndex);
      this._buildIndex();
      this.update();
    }
    update() {
      let shouldUpdateGeometry = false;
      if (this._currentTheta !== this.theta) {
        this._currentTheta = this.theta;
        shouldUpdateGeometry = true;
      }
      if (this._currentRadius !== this.radius) {
        this._currentRadius = this.radius;
        shouldUpdateGeometry = true;
      }
      if (shouldUpdateGeometry) {
        this._buildPosition();
      }
    }
    _buildPosition() {
      this._attrPos.setXYZ(0, 0, 0, 0);
      for (let i = 0; i < 64; i++) {
        const t = i / 63 * this._currentTheta;
        this._attrPos.setXYZ(i + 1, this._currentRadius * Math.sin(t), 0, this._currentRadius * Math.cos(t));
      }
      this._attrPos.needsUpdate = true;
    }
    _buildIndex() {
      for (let i = 0; i < 63; i++) {
        this._attrIndex.setXYZ(i * 3, 0, i + 1, i + 2);
      }
      this._attrIndex.needsUpdate = true;
    }
  };
  var LineAndSphereBufferGeometry = class extends BufferGeometry {
    constructor() {
      super();
      this.radius = 0;
      this._currentRadius = 0;
      this.tail = new Vector3();
      this._currentTail = new Vector3();
      this._attrPos = new BufferAttribute(new Float32Array(294), 3);
      this.setAttribute("position", this._attrPos);
      this._attrIndex = new BufferAttribute(new Uint16Array(194), 1);
      this.setIndex(this._attrIndex);
      this._buildIndex();
      this.update();
    }
    update() {
      let shouldUpdateGeometry = false;
      if (this._currentRadius !== this.radius) {
        this._currentRadius = this.radius;
        shouldUpdateGeometry = true;
      }
      if (!this._currentTail.equals(this.tail)) {
        this._currentTail.copy(this.tail);
        shouldUpdateGeometry = true;
      }
      if (shouldUpdateGeometry) {
        this._buildPosition();
      }
    }
    _buildPosition() {
      for (let i = 0; i < 32; i++) {
        const t = i / 16 * Math.PI;
        this._attrPos.setXYZ(i, Math.cos(t), Math.sin(t), 0);
        this._attrPos.setXYZ(32 + i, 0, Math.cos(t), Math.sin(t));
        this._attrPos.setXYZ(64 + i, Math.sin(t), 0, Math.cos(t));
      }
      this.scale(this._currentRadius, this._currentRadius, this._currentRadius);
      this.translate(this._currentTail.x, this._currentTail.y, this._currentTail.z);
      this._attrPos.setXYZ(96, 0, 0, 0);
      this._attrPos.setXYZ(97, this._currentTail.x, this._currentTail.y, this._currentTail.z);
      this._attrPos.needsUpdate = true;
    }
    _buildIndex() {
      for (let i = 0; i < 32; i++) {
        const i1 = (i + 1) % 32;
        this._attrIndex.setXY(i * 2, i, i1);
        this._attrIndex.setXY(64 + i * 2, 32 + i, 32 + i1);
        this._attrIndex.setXY(128 + i * 2, 64 + i, 64 + i1);
      }
      this._attrIndex.setXY(192, 96, 97);
      this._attrIndex.needsUpdate = true;
    }
  };
  var _quatA4 = new Quaternion();
  var _quatB = new Quaternion();
  var _v3A4 = new Vector3();
  var _v3B2 = new Vector3();
  var SQRT_2_OVER_2 = Math.sqrt(2) / 2;
  var QUAT_XY_CW90 = new Quaternion(0, 0, -SQRT_2_OVER_2, SQRT_2_OVER_2);
  var VEC3_POSITIVE_Y = new Vector3(0, 1, 0);
  var VRMLookAtHelper = class extends Group {
    constructor(lookAt) {
      super();
      this.matrixAutoUpdate = false;
      this.vrmLookAt = lookAt;
      {
        const geometry = new FanBufferGeometry();
        geometry.radius = 0.5;
        const material = new MeshBasicMaterial({
          color: 65280,
          transparent: true,
          opacity: 0.5,
          side: DoubleSide,
          depthTest: false,
          depthWrite: false
        });
        this._meshPitch = new Mesh(geometry, material);
        this.add(this._meshPitch);
      }
      {
        const geometry = new FanBufferGeometry();
        geometry.radius = 0.5;
        const material = new MeshBasicMaterial({
          color: 16711680,
          transparent: true,
          opacity: 0.5,
          side: DoubleSide,
          depthTest: false,
          depthWrite: false
        });
        this._meshYaw = new Mesh(geometry, material);
        this.add(this._meshYaw);
      }
      {
        const geometry = new LineAndSphereBufferGeometry();
        geometry.radius = 0.1;
        const material = new LineBasicMaterial({
          color: 16777215,
          depthTest: false,
          depthWrite: false
        });
        this._lineTarget = new LineSegments(geometry, material);
        this._lineTarget.frustumCulled = false;
        this.add(this._lineTarget);
      }
    }
    dispose() {
      this._meshYaw.geometry.dispose();
      this._meshYaw.material.dispose();
      this._meshPitch.geometry.dispose();
      this._meshPitch.material.dispose();
      this._lineTarget.geometry.dispose();
      this._lineTarget.material.dispose();
    }
    updateMatrixWorld(force) {
      const yaw = MathUtils.DEG2RAD * this.vrmLookAt.yaw;
      this._meshYaw.geometry.theta = yaw;
      this._meshYaw.geometry.update();
      const pitch = MathUtils.DEG2RAD * this.vrmLookAt.pitch;
      this._meshPitch.geometry.theta = pitch;
      this._meshPitch.geometry.update();
      this.vrmLookAt.getLookAtWorldPosition(_v3A4);
      this.vrmLookAt.getLookAtWorldQuaternion(_quatA4);
      _quatA4.multiply(this.vrmLookAt.getFaceFrontQuaternion(_quatB));
      this._meshYaw.position.copy(_v3A4);
      this._meshYaw.quaternion.copy(_quatA4);
      this._meshPitch.position.copy(_v3A4);
      this._meshPitch.quaternion.copy(_quatA4);
      this._meshPitch.quaternion.multiply(_quatB.setFromAxisAngle(VEC3_POSITIVE_Y, yaw));
      this._meshPitch.quaternion.multiply(QUAT_XY_CW90);
      const { target, autoUpdate } = this.vrmLookAt;
      if (target != null && autoUpdate) {
        target.getWorldPosition(_v3B2).sub(_v3A4);
        this._lineTarget.geometry.tail.copy(_v3B2);
        this._lineTarget.geometry.update();
        this._lineTarget.position.copy(_v3A4);
      }
      super.updateMatrixWorld(force);
    }
  };
  var _position = new Vector3();
  var _scale = new Vector3();
  function getWorldQuaternionLite(object, out) {
    object.matrixWorld.decompose(_position, out, _scale);
    return out;
  }
  function calcAzimuthAltitude(vector) {
    return [Math.atan2(-vector.z, vector.x), Math.atan2(vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z))];
  }
  function sanitizeAngle(angle) {
    const roundTurn = Math.round(angle / 2 / Math.PI);
    return angle - 2 * Math.PI * roundTurn;
  }
  var VEC3_POSITIVE_Z = new Vector3(0, 0, 1);
  var _v3A5 = new Vector3();
  var _v3B3 = new Vector3();
  var _v3C = new Vector3();
  var _quatA5 = new Quaternion();
  var _quatB2 = new Quaternion();
  var _quatC = new Quaternion();
  var _quatD = new Quaternion();
  var _eulerA = new Euler();
  var _VRMLookAt = class _VRMLookAt2 {
    /**
     * Create a new {@link VRMLookAt}.
     *
     * @param humanoid A {@link VRMHumanoid}
     * @param applier A {@link VRMLookAtApplier}
     */
    constructor(humanoid, applier) {
      this.offsetFromHeadBone = new Vector3();
      this.autoUpdate = true;
      this.faceFront = new Vector3(0, 0, 1);
      this.humanoid = humanoid;
      this.applier = applier;
      this._yaw = 0;
      this._pitch = 0;
      this._needsUpdate = true;
      this._restHeadWorldQuaternion = this.getLookAtWorldQuaternion(new Quaternion());
    }
    /**
     * Its current angle around Y axis, in degree.
     */
    get yaw() {
      return this._yaw;
    }
    /**
     * Its current angle around Y axis, in degree.
     */
    set yaw(value) {
      this._yaw = value;
      this._needsUpdate = true;
    }
    /**
     * Its current angle around X axis, in degree.
     */
    get pitch() {
      return this._pitch;
    }
    /**
     * Its current angle around X axis, in degree.
     */
    set pitch(value) {
      this._pitch = value;
      this._needsUpdate = true;
    }
    /**
     * @deprecated Use {@link getEuler} instead.
     */
    get euler() {
      console.warn("VRMLookAt: euler is deprecated. use getEuler() instead.");
      return this.getEuler(new Euler());
    }
    /**
     * Get its yaw-pitch angles as an `Euler`.
     * Does NOT consider {@link faceFront}; it returns `Euler(0, 0, 0; "YXZ")` by default regardless of the faceFront value.
     *
     * @param target The target euler
     */
    getEuler(target) {
      return target.set(MathUtils.DEG2RAD * this._pitch, MathUtils.DEG2RAD * this._yaw, 0, "YXZ");
    }
    /**
     * Copy the given {@link VRMLookAt} into this one.
     * {@link humanoid} must be same as the source one.
     * {@link applier} will reference the same instance as the source one.
     * @param source The {@link VRMLookAt} you want to copy
     * @returns this
     */
    copy(source) {
      if (this.humanoid !== source.humanoid) {
        throw new Error("VRMLookAt: humanoid must be same in order to copy");
      }
      this.offsetFromHeadBone.copy(source.offsetFromHeadBone);
      this.applier = source.applier;
      this.autoUpdate = source.autoUpdate;
      this.target = source.target;
      this.faceFront.copy(source.faceFront);
      return this;
    }
    /**
     * Returns a clone of this {@link VRMLookAt}.
     * Note that {@link humanoid} and {@link applier} will reference the same instance as this one.
     * @returns Copied {@link VRMLookAt}
     */
    clone() {
      return new _VRMLookAt2(this.humanoid, this.applier).copy(this);
    }
    /**
     * Reset the lookAt direction (yaw and pitch) to the initial direction.
     */
    reset() {
      this._yaw = 0;
      this._pitch = 0;
      this._needsUpdate = true;
    }
    /**
     * Get its lookAt position in world coordinate.
     *
     * @param target A target `THREE.Vector3`
     */
    getLookAtWorldPosition(target) {
      const head = this.humanoid.getRawBoneNode("head");
      return target.copy(this.offsetFromHeadBone).applyMatrix4(head.matrixWorld);
    }
    /**
     * Get its lookAt rotation in world coordinate.
     * Does NOT consider {@link faceFront}.
     *
     * @param target A target `THREE.Quaternion`
     */
    getLookAtWorldQuaternion(target) {
      const head = this.humanoid.getRawBoneNode("head");
      return getWorldQuaternionLite(head, target);
    }
    /**
     * Get a quaternion that rotates the +Z unit vector of the humanoid Head to the {@link faceFront} direction.
     *
     * @param target A target `THREE.Quaternion`
     */
    getFaceFrontQuaternion(target) {
      if (this.faceFront.distanceToSquared(VEC3_POSITIVE_Z) < 0.01) {
        return target.copy(this._restHeadWorldQuaternion).invert();
      }
      const [faceFrontAzimuth, faceFrontAltitude] = calcAzimuthAltitude(this.faceFront);
      _eulerA.set(0, 0.5 * Math.PI + faceFrontAzimuth, faceFrontAltitude, "YZX");
      return target.setFromEuler(_eulerA).premultiply(_quatD.copy(this._restHeadWorldQuaternion).invert());
    }
    /**
     * Get its LookAt direction in world coordinate.
     *
     * @param target A target `THREE.Vector3`
     */
    getLookAtWorldDirection(target) {
      this.getLookAtWorldQuaternion(_quatB2);
      this.getFaceFrontQuaternion(_quatC);
      return target.copy(VEC3_POSITIVE_Z).applyQuaternion(_quatB2).applyQuaternion(_quatC).applyEuler(this.getEuler(_eulerA));
    }
    /**
     * Set its lookAt target position.
     *
     * Note that its result will be instantly overwritten if {@link VRMLookAtHead.autoUpdate} is enabled.
     *
     * If you want to track an object continuously, you might want to use {@link target} instead.
     *
     * @param position A target position, in world space
     */
    lookAt(position) {
      const headRotDiffInv = _quatA5.copy(this._restHeadWorldQuaternion).multiply(quatInvertCompat(this.getLookAtWorldQuaternion(_quatB2)));
      const headPos = this.getLookAtWorldPosition(_v3B3);
      const lookAtDir = _v3C.copy(position).sub(headPos).applyQuaternion(headRotDiffInv).normalize();
      const [azimuthFrom, altitudeFrom] = calcAzimuthAltitude(this.faceFront);
      const [azimuthTo, altitudeTo] = calcAzimuthAltitude(lookAtDir);
      const yaw = sanitizeAngle(azimuthTo - azimuthFrom);
      const pitch = sanitizeAngle(altitudeFrom - altitudeTo);
      this._yaw = MathUtils.RAD2DEG * yaw;
      this._pitch = MathUtils.RAD2DEG * pitch;
      this._needsUpdate = true;
    }
    /**
     * Update the VRMLookAtHead.
     * If {@link autoUpdate} is enabled, this will make it look at the {@link target}.
     *
     * @param delta deltaTime, it isn't used though. You can use the parameter if you want to use this in your own extended {@link VRMLookAt}.
     */
    update(delta) {
      if (this.target != null && this.autoUpdate) {
        this.lookAt(this.target.getWorldPosition(_v3A5));
      }
      if (this._needsUpdate) {
        this._needsUpdate = false;
        this.applier.applyYawPitch(this._yaw, this._pitch);
      }
    }
  };
  _VRMLookAt.EULER_ORDER = "YXZ";
  var VRMLookAt = _VRMLookAt;
  var VEC3_POSITIVE_Z2 = new Vector3(0, 0, 1);
  var _quatA6 = new Quaternion();
  var _quatB3 = new Quaternion();
  var _eulerA2 = new Euler(0, 0, 0, "YXZ");
  var VRMLookAtBoneApplier = class {
    /**
     * Create a new {@link VRMLookAtBoneApplier}.
     *
     * @param humanoid A {@link VRMHumanoid}
     * @param rangeMapHorizontalInner A {@link VRMLookAtRangeMap} used for inner transverse direction
     * @param rangeMapHorizontalOuter A {@link VRMLookAtRangeMap} used for outer transverse direction
     * @param rangeMapVerticalDown A {@link VRMLookAtRangeMap} used for down direction
     * @param rangeMapVerticalUp A {@link VRMLookAtRangeMap} used for up direction
     */
    constructor(humanoid, rangeMapHorizontalInner, rangeMapHorizontalOuter, rangeMapVerticalDown, rangeMapVerticalUp) {
      this.humanoid = humanoid;
      this.rangeMapHorizontalInner = rangeMapHorizontalInner;
      this.rangeMapHorizontalOuter = rangeMapHorizontalOuter;
      this.rangeMapVerticalDown = rangeMapVerticalDown;
      this.rangeMapVerticalUp = rangeMapVerticalUp;
      this.faceFront = new Vector3(0, 0, 1);
      this._restQuatLeftEye = new Quaternion();
      this._restQuatRightEye = new Quaternion();
      this._restLeftEyeParentWorldQuat = new Quaternion();
      this._restRightEyeParentWorldQuat = new Quaternion();
      const leftEye = this.humanoid.getRawBoneNode("leftEye");
      const rightEye = this.humanoid.getRawBoneNode("rightEye");
      if (leftEye) {
        this._restQuatLeftEye.copy(leftEye.quaternion);
        getWorldQuaternionLite(leftEye.parent, this._restLeftEyeParentWorldQuat);
      }
      if (rightEye) {
        this._restQuatRightEye.copy(rightEye.quaternion);
        getWorldQuaternionLite(rightEye.parent, this._restRightEyeParentWorldQuat);
      }
    }
    /**
     * Apply the input angle to its associated VRM model.
     *
     * @param yaw Rotation around Y axis, in degree
     * @param pitch Rotation around X axis, in degree
     */
    applyYawPitch(yaw, pitch) {
      const leftEye = this.humanoid.getRawBoneNode("leftEye");
      const rightEye = this.humanoid.getRawBoneNode("rightEye");
      const leftEyeNormalized = this.humanoid.getNormalizedBoneNode("leftEye");
      const rightEyeNormalized = this.humanoid.getNormalizedBoneNode("rightEye");
      if (leftEye) {
        if (pitch < 0) {
          _eulerA2.x = -MathUtils.DEG2RAD * this.rangeMapVerticalDown.map(-pitch);
        } else {
          _eulerA2.x = MathUtils.DEG2RAD * this.rangeMapVerticalUp.map(pitch);
        }
        if (yaw < 0) {
          _eulerA2.y = -MathUtils.DEG2RAD * this.rangeMapHorizontalInner.map(-yaw);
        } else {
          _eulerA2.y = MathUtils.DEG2RAD * this.rangeMapHorizontalOuter.map(yaw);
        }
        _quatA6.setFromEuler(_eulerA2);
        this._getWorldFaceFrontQuat(_quatB3);
        leftEyeNormalized.quaternion.copy(_quatB3).multiply(_quatA6).multiply(_quatB3.invert());
        _quatA6.copy(this._restLeftEyeParentWorldQuat);
        leftEye.quaternion.copy(leftEyeNormalized.quaternion).multiply(_quatA6).premultiply(_quatA6.invert()).multiply(this._restQuatLeftEye);
      }
      if (rightEye) {
        if (pitch < 0) {
          _eulerA2.x = -MathUtils.DEG2RAD * this.rangeMapVerticalDown.map(-pitch);
        } else {
          _eulerA2.x = MathUtils.DEG2RAD * this.rangeMapVerticalUp.map(pitch);
        }
        if (yaw < 0) {
          _eulerA2.y = -MathUtils.DEG2RAD * this.rangeMapHorizontalOuter.map(-yaw);
        } else {
          _eulerA2.y = MathUtils.DEG2RAD * this.rangeMapHorizontalInner.map(yaw);
        }
        _quatA6.setFromEuler(_eulerA2);
        this._getWorldFaceFrontQuat(_quatB3);
        rightEyeNormalized.quaternion.copy(_quatB3).multiply(_quatA6).multiply(_quatB3.invert());
        _quatA6.copy(this._restRightEyeParentWorldQuat);
        rightEye.quaternion.copy(rightEyeNormalized.quaternion).multiply(_quatA6).premultiply(_quatA6.invert()).multiply(this._restQuatRightEye);
      }
    }
    /**
     * @deprecated Use {@link applyYawPitch} instead.
     */
    lookAt(euler) {
      console.warn("VRMLookAtBoneApplier: lookAt() is deprecated. use apply() instead.");
      const yaw = MathUtils.RAD2DEG * euler.y;
      const pitch = MathUtils.RAD2DEG * euler.x;
      this.applyYawPitch(yaw, pitch);
    }
    /**
     * Get a quaternion that rotates the world-space +Z unit vector to the {@link faceFront} direction.
     *
     * @param target A target `THREE.Quaternion`
     */
    _getWorldFaceFrontQuat(target) {
      if (this.faceFront.distanceToSquared(VEC3_POSITIVE_Z2) < 0.01) {
        return target.identity();
      }
      const [faceFrontAzimuth, faceFrontAltitude] = calcAzimuthAltitude(this.faceFront);
      _eulerA2.set(0, 0.5 * Math.PI + faceFrontAzimuth, faceFrontAltitude, "YZX");
      return target.setFromEuler(_eulerA2);
    }
  };
  VRMLookAtBoneApplier.type = "bone";
  var VRMLookAtExpressionApplier = class {
    /**
     * Create a new {@link VRMLookAtExpressionApplier}.
     *
     * @param expressions A {@link VRMExpressionManager}
     * @param rangeMapHorizontalInner A {@link VRMLookAtRangeMap} used for inner transverse direction
     * @param rangeMapHorizontalOuter A {@link VRMLookAtRangeMap} used for outer transverse direction
     * @param rangeMapVerticalDown A {@link VRMLookAtRangeMap} used for down direction
     * @param rangeMapVerticalUp A {@link VRMLookAtRangeMap} used for up direction
     */
    constructor(expressions, rangeMapHorizontalInner, rangeMapHorizontalOuter, rangeMapVerticalDown, rangeMapVerticalUp) {
      this.expressions = expressions;
      this.rangeMapHorizontalInner = rangeMapHorizontalInner;
      this.rangeMapHorizontalOuter = rangeMapHorizontalOuter;
      this.rangeMapVerticalDown = rangeMapVerticalDown;
      this.rangeMapVerticalUp = rangeMapVerticalUp;
    }
    /**
     * Apply the input angle to its associated VRM model.
     *
     * @param yaw Rotation around Y axis, in degree
     * @param pitch Rotation around X axis, in degree
     */
    applyYawPitch(yaw, pitch) {
      if (pitch < 0) {
        this.expressions.setValue("lookDown", 0);
        this.expressions.setValue("lookUp", this.rangeMapVerticalUp.map(-pitch));
      } else {
        this.expressions.setValue("lookUp", 0);
        this.expressions.setValue("lookDown", this.rangeMapVerticalDown.map(pitch));
      }
      if (yaw < 0) {
        this.expressions.setValue("lookLeft", 0);
        this.expressions.setValue("lookRight", this.rangeMapHorizontalOuter.map(-yaw));
      } else {
        this.expressions.setValue("lookRight", 0);
        this.expressions.setValue("lookLeft", this.rangeMapHorizontalOuter.map(yaw));
      }
    }
    /**
     * @deprecated Use {@link applyYawPitch} instead.
     */
    lookAt(euler) {
      console.warn("VRMLookAtBoneApplier: lookAt() is deprecated. use apply() instead.");
      const yaw = MathUtils.RAD2DEG * euler.y;
      const pitch = MathUtils.RAD2DEG * euler.x;
      this.applyYawPitch(yaw, pitch);
    }
  };
  VRMLookAtExpressionApplier.type = "expression";
  var VRMLookAtRangeMap = class {
    /**
     * Create a new {@link VRMLookAtRangeMap}.
     *
     * @param inputMaxValue The {@link inputMaxValue} of the map
     * @param outputScale The {@link outputScale} of the map
     */
    constructor(inputMaxValue, outputScale) {
      this.inputMaxValue = inputMaxValue;
      this.outputScale = outputScale;
    }
    /**
     * Evaluate an input value and output a mapped value.
     * @param src The input value
     */
    map(src) {
      return this.outputScale * saturate(src / this.inputMaxValue);
    }
  };
  var POSSIBLE_SPEC_VERSIONS4 = /* @__PURE__ */ new Set(["1.0", "1.0-beta"]);
  var INPUT_MAX_VALUE_MINIMUM = 0.01;
  var VRMLookAtLoaderPlugin = class {
    get name() {
      return "VRMLookAtLoaderPlugin";
    }
    constructor(parser, options) {
      this.parser = parser;
      this.helperRoot = options == null ? void 0 : options.helperRoot;
    }
    afterRoot(gltf) {
      return __async2(this, null, function* () {
        const vrmHumanoid = gltf.userData.vrmHumanoid;
        if (vrmHumanoid === null) {
          return;
        } else if (vrmHumanoid === void 0) {
          throw new Error("VRMLookAtLoaderPlugin: vrmHumanoid is undefined. VRMHumanoidLoaderPlugin have to be used first");
        }
        const vrmExpressionManager = gltf.userData.vrmExpressionManager;
        if (vrmExpressionManager === null) {
          return;
        } else if (vrmExpressionManager === void 0) {
          throw new Error(
            "VRMLookAtLoaderPlugin: vrmExpressionManager is undefined. VRMExpressionLoaderPlugin have to be used first"
          );
        }
        gltf.userData.vrmLookAt = yield this._import(gltf, vrmHumanoid, vrmExpressionManager);
      });
    }
    /**
     * Import a {@link VRMLookAt} from a VRM.
     *
     * @param gltf A parsed result of GLTF taken from GLTFLoader
     * @param humanoid A {@link VRMHumanoid} instance that represents the VRM
     * @param expressions A {@link VRMExpressionManager} instance that represents the VRM
     */
    _import(gltf, humanoid, expressions) {
      return __async2(this, null, function* () {
        if (humanoid == null || expressions == null) {
          return null;
        }
        const v1Result = yield this._v1Import(gltf, humanoid, expressions);
        if (v1Result) {
          return v1Result;
        }
        const v0Result = yield this._v0Import(gltf, humanoid, expressions);
        if (v0Result) {
          return v0Result;
        }
        return null;
      });
    }
    _v1Import(gltf, humanoid, expressions) {
      return __async2(this, null, function* () {
        var _a, _b, _c;
        const json = this.parser.json;
        const isVRMUsed = ((_a = json.extensionsUsed) == null ? void 0 : _a.indexOf("VRMC_vrm")) !== -1;
        if (!isVRMUsed) {
          return null;
        }
        const extension = (_b = json.extensions) == null ? void 0 : _b["VRMC_vrm"];
        if (!extension) {
          return null;
        }
        const specVersion = extension.specVersion;
        if (!POSSIBLE_SPEC_VERSIONS4.has(specVersion)) {
          console.warn(`VRMLookAtLoaderPlugin: Unknown VRMC_vrm specVersion "${specVersion}"`);
          return null;
        }
        const schemaLookAt = extension.lookAt;
        if (!schemaLookAt) {
          return null;
        }
        const defaultOutputScale = schemaLookAt.type === "expression" ? 1 : 10;
        const mapHI = this._v1ImportRangeMap(schemaLookAt.rangeMapHorizontalInner, defaultOutputScale);
        const mapHO = this._v1ImportRangeMap(schemaLookAt.rangeMapHorizontalOuter, defaultOutputScale);
        const mapVD = this._v1ImportRangeMap(schemaLookAt.rangeMapVerticalDown, defaultOutputScale);
        const mapVU = this._v1ImportRangeMap(schemaLookAt.rangeMapVerticalUp, defaultOutputScale);
        let applier;
        if (schemaLookAt.type === "expression") {
          applier = new VRMLookAtExpressionApplier(expressions, mapHI, mapHO, mapVD, mapVU);
        } else {
          applier = new VRMLookAtBoneApplier(humanoid, mapHI, mapHO, mapVD, mapVU);
        }
        const lookAt = this._importLookAt(humanoid, applier);
        lookAt.offsetFromHeadBone.fromArray((_c = schemaLookAt.offsetFromHeadBone) != null ? _c : [0, 0.06, 0]);
        return lookAt;
      });
    }
    _v1ImportRangeMap(schemaRangeMap, defaultOutputScale) {
      var _a, _b;
      let inputMaxValue = (_a = schemaRangeMap == null ? void 0 : schemaRangeMap.inputMaxValue) != null ? _a : 90;
      const outputScale = (_b = schemaRangeMap == null ? void 0 : schemaRangeMap.outputScale) != null ? _b : defaultOutputScale;
      if (inputMaxValue < INPUT_MAX_VALUE_MINIMUM) {
        console.warn(
          "VRMLookAtLoaderPlugin: inputMaxValue of a range map is too small. Consider reviewing the range map!"
        );
        inputMaxValue = INPUT_MAX_VALUE_MINIMUM;
      }
      return new VRMLookAtRangeMap(inputMaxValue, outputScale);
    }
    _v0Import(gltf, humanoid, expressions) {
      return __async2(this, null, function* () {
        var _a, _b, _c, _d;
        const json = this.parser.json;
        const vrmExt = (_a = json.extensions) == null ? void 0 : _a.VRM;
        if (!vrmExt) {
          return null;
        }
        const schemaFirstPerson = vrmExt.firstPerson;
        if (!schemaFirstPerson) {
          return null;
        }
        const defaultOutputScale = schemaFirstPerson.lookAtTypeName === "BlendShape" ? 1 : 10;
        const mapHI = this._v0ImportDegreeMap(schemaFirstPerson.lookAtHorizontalInner, defaultOutputScale);
        const mapHO = this._v0ImportDegreeMap(schemaFirstPerson.lookAtHorizontalOuter, defaultOutputScale);
        const mapVD = this._v0ImportDegreeMap(schemaFirstPerson.lookAtVerticalDown, defaultOutputScale);
        const mapVU = this._v0ImportDegreeMap(schemaFirstPerson.lookAtVerticalUp, defaultOutputScale);
        let applier;
        if (schemaFirstPerson.lookAtTypeName === "BlendShape") {
          applier = new VRMLookAtExpressionApplier(expressions, mapHI, mapHO, mapVD, mapVU);
        } else {
          applier = new VRMLookAtBoneApplier(humanoid, mapHI, mapHO, mapVD, mapVU);
        }
        const lookAt = this._importLookAt(humanoid, applier);
        if (schemaFirstPerson.firstPersonBoneOffset) {
          lookAt.offsetFromHeadBone.set(
            (_b = schemaFirstPerson.firstPersonBoneOffset.x) != null ? _b : 0,
            (_c = schemaFirstPerson.firstPersonBoneOffset.y) != null ? _c : 0.06,
            -((_d = schemaFirstPerson.firstPersonBoneOffset.z) != null ? _d : 0)
          );
        } else {
          lookAt.offsetFromHeadBone.set(0, 0.06, 0);
        }
        lookAt.faceFront.set(0, 0, -1);
        if (applier instanceof VRMLookAtBoneApplier) {
          applier.faceFront.set(0, 0, -1);
        }
        return lookAt;
      });
    }
    _v0ImportDegreeMap(schemaDegreeMap, defaultOutputScale) {
      var _a, _b;
      const curve = schemaDegreeMap == null ? void 0 : schemaDegreeMap.curve;
      if (JSON.stringify(curve) !== "[0,0,0,1,1,1,1,0]") {
        console.warn("Curves of LookAtDegreeMap defined in VRM 0.0 are not supported");
      }
      let xRange = (_a = schemaDegreeMap == null ? void 0 : schemaDegreeMap.xRange) != null ? _a : 90;
      const yRange = (_b = schemaDegreeMap == null ? void 0 : schemaDegreeMap.yRange) != null ? _b : defaultOutputScale;
      if (xRange < INPUT_MAX_VALUE_MINIMUM) {
        console.warn("VRMLookAtLoaderPlugin: xRange of a degree map is too small. Consider reviewing the degree map!");
        xRange = INPUT_MAX_VALUE_MINIMUM;
      }
      return new VRMLookAtRangeMap(xRange, yRange);
    }
    _importLookAt(humanoid, applier) {
      const lookAt = new VRMLookAt(humanoid, applier);
      if (this.helperRoot) {
        const helper = new VRMLookAtHelper(lookAt);
        this.helperRoot.add(helper);
        helper.renderOrder = this.helperRoot.renderOrder;
      }
      return lookAt;
    }
  };
  function resolveURL(url, path) {
    if (typeof url !== "string" || url === "") return "";
    if (/^https?:\/\//i.test(path) && /^\//.test(url)) {
      path = path.replace(/(^https?:\/\/[^/]+).*/i, "$1");
    }
    if (/^(https?:)?\/\//i.test(url)) return url;
    if (/^data:.*,.*$/i.test(url)) return url;
    if (/^blob:.*$/i.test(url)) return url;
    return path + url;
  }
  var POSSIBLE_SPEC_VERSIONS5 = /* @__PURE__ */ new Set(["1.0", "1.0-beta"]);
  var VRMMetaLoaderPlugin = class {
    get name() {
      return "VRMMetaLoaderPlugin";
    }
    constructor(parser, options) {
      var _a, _b, _c;
      this.parser = parser;
      this.needThumbnailImage = (_a = options == null ? void 0 : options.needThumbnailImage) != null ? _a : false;
      this.acceptLicenseUrls = (_b = options == null ? void 0 : options.acceptLicenseUrls) != null ? _b : ["https://vrm.dev/licenses/1.0/"];
      this.acceptV0Meta = (_c = options == null ? void 0 : options.acceptV0Meta) != null ? _c : true;
    }
    afterRoot(gltf) {
      return __async2(this, null, function* () {
        gltf.userData.vrmMeta = yield this._import(gltf);
      });
    }
    _import(gltf) {
      return __async2(this, null, function* () {
        const v1Result = yield this._v1Import(gltf);
        if (v1Result != null) {
          return v1Result;
        }
        const v0Result = yield this._v0Import(gltf);
        if (v0Result != null) {
          return v0Result;
        }
        return null;
      });
    }
    _v1Import(gltf) {
      return __async2(this, null, function* () {
        var _a, _b, _c;
        const json = this.parser.json;
        const isVRMUsed = ((_a = json.extensionsUsed) == null ? void 0 : _a.indexOf("VRMC_vrm")) !== -1;
        if (!isVRMUsed) {
          return null;
        }
        const extension = (_b = json.extensions) == null ? void 0 : _b["VRMC_vrm"];
        if (extension == null) {
          return null;
        }
        const specVersion = extension.specVersion;
        if (!POSSIBLE_SPEC_VERSIONS5.has(specVersion)) {
          console.warn(`VRMMetaLoaderPlugin: Unknown VRMC_vrm specVersion "${specVersion}"`);
          return null;
        }
        const schemaMeta = extension.meta;
        if (!schemaMeta) {
          return null;
        }
        const licenseUrl = schemaMeta.licenseUrl;
        const acceptLicenseUrlsSet = new Set(this.acceptLicenseUrls);
        if (!acceptLicenseUrlsSet.has(licenseUrl)) {
          throw new Error(`VRMMetaLoaderPlugin: The license url "${licenseUrl}" is not accepted`);
        }
        let thumbnailImage = void 0;
        if (this.needThumbnailImage && schemaMeta.thumbnailImage != null) {
          thumbnailImage = (_c = yield this._extractGLTFImage(schemaMeta.thumbnailImage)) != null ? _c : void 0;
        }
        return {
          metaVersion: "1",
          name: schemaMeta.name,
          version: schemaMeta.version,
          authors: schemaMeta.authors,
          copyrightInformation: schemaMeta.copyrightInformation,
          contactInformation: schemaMeta.contactInformation,
          references: schemaMeta.references,
          thirdPartyLicenses: schemaMeta.thirdPartyLicenses,
          thumbnailImage,
          licenseUrl: schemaMeta.licenseUrl,
          avatarPermission: schemaMeta.avatarPermission,
          allowExcessivelyViolentUsage: schemaMeta.allowExcessivelyViolentUsage,
          allowExcessivelySexualUsage: schemaMeta.allowExcessivelySexualUsage,
          commercialUsage: schemaMeta.commercialUsage,
          allowPoliticalOrReligiousUsage: schemaMeta.allowPoliticalOrReligiousUsage,
          allowAntisocialOrHateUsage: schemaMeta.allowAntisocialOrHateUsage,
          creditNotation: schemaMeta.creditNotation,
          allowRedistribution: schemaMeta.allowRedistribution,
          modification: schemaMeta.modification,
          otherLicenseUrl: schemaMeta.otherLicenseUrl
        };
      });
    }
    _v0Import(gltf) {
      return __async2(this, null, function* () {
        var _a;
        const json = this.parser.json;
        const vrmExt = (_a = json.extensions) == null ? void 0 : _a.VRM;
        if (!vrmExt) {
          return null;
        }
        const schemaMeta = vrmExt.meta;
        if (!schemaMeta) {
          return null;
        }
        if (!this.acceptV0Meta) {
          throw new Error("VRMMetaLoaderPlugin: Attempted to load VRM0.0 meta but acceptV0Meta is false");
        }
        let texture;
        if (this.needThumbnailImage && schemaMeta.texture != null && schemaMeta.texture !== -1) {
          texture = yield this.parser.getDependency("texture", schemaMeta.texture);
        }
        return {
          metaVersion: "0",
          allowedUserName: schemaMeta.allowedUserName,
          author: schemaMeta.author,
          commercialUssageName: schemaMeta.commercialUssageName,
          contactInformation: schemaMeta.contactInformation,
          licenseName: schemaMeta.licenseName,
          otherLicenseUrl: schemaMeta.otherLicenseUrl,
          otherPermissionUrl: schemaMeta.otherPermissionUrl,
          reference: schemaMeta.reference,
          sexualUssageName: schemaMeta.sexualUssageName,
          texture: texture != null ? texture : void 0,
          title: schemaMeta.title,
          version: schemaMeta.version,
          violentUssageName: schemaMeta.violentUssageName
        };
      });
    }
    _extractGLTFImage(index) {
      return __async2(this, null, function* () {
        var _a;
        const json = this.parser.json;
        const source = (_a = json.images) == null ? void 0 : _a[index];
        if (source == null) {
          console.warn(
            `VRMMetaLoaderPlugin: Attempt to use images[${index}] of glTF as a thumbnail but the image doesn't exist`
          );
          return null;
        }
        let sourceURI = source.uri;
        if (source.bufferView != null) {
          const bufferView = yield this.parser.getDependency("bufferView", source.bufferView);
          const blob = new Blob([bufferView], { type: source.mimeType });
          sourceURI = URL.createObjectURL(blob);
        }
        if (sourceURI == null) {
          console.warn(
            `VRMMetaLoaderPlugin: Attempt to use images[${index}] of glTF as a thumbnail but the image couldn't load properly`
          );
          return null;
        }
        const loader = new ImageLoader();
        return yield loader.loadAsync(resolveURL(sourceURI, this.parser.options.path)).catch((error) => {
          console.error(error);
          console.warn("VRMMetaLoaderPlugin: Failed to load a thumbnail image");
          return null;
        });
      });
    }
  };
  var VRMCore = class {
    /**
     * Create a new VRM instance.
     *
     * @param params [[VRMParameters]] that represents components of the VRM
     */
    constructor(params) {
      this.scene = params.scene;
      this.meta = params.meta;
      this.humanoid = params.humanoid;
      this.expressionManager = params.expressionManager;
      this.firstPerson = params.firstPerson;
      this.lookAt = params.lookAt;
    }
    /**
     * **You need to call this on your update loop.**
     *
     * This function updates every VRM components.
     *
     * @param delta deltaTime
     */
    update(delta) {
      this.humanoid.update();
      if (this.lookAt) {
        this.lookAt.update(delta);
      }
      if (this.expressionManager) {
        this.expressionManager.update();
      }
    }
  };

  // src/VRM.ts
  var VRM = class extends VRMCore {
    /**
     * Create a new VRM instance.
     *
     * @param params [[VRMParameters]] that represents components of the VRM
     */
    constructor(params) {
      super(params);
      this.materials = params.materials;
      this.springBoneManager = params.springBoneManager;
      this.nodeConstraintManager = params.nodeConstraintManager;
    }
    /**
     * **You need to call this on your update loop.**
     *
     * This function updates every VRM components.
     *
     * @param delta deltaTime
     */
    update(delta) {
      super.update(delta);
      if (this.nodeConstraintManager) {
        this.nodeConstraintManager.update();
      }
      if (this.springBoneManager) {
        this.springBoneManager.update(delta);
      }
      if (this.materials) {
        this.materials.forEach((material) => {
          if (material.update) {
            material.update(delta);
          }
        });
      }
    }
  };
  var __defProp = Object.defineProperty;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b)) {
        if (__propIsEnum.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      }
    return a;
  };
  var __async3 = (__this, __arguments, generator) => {
    return new Promise((resolve, reject) => {
      var fulfilled = (value) => {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      };
      var rejected = (value) => {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      };
      var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
      step((generator = generator.apply(__this, __arguments)).next());
    });
  };
  var colorSpaceEncodingMap = {
    // eslint-disable-next-line @typescript-eslint/naming-convention
    "": 3e3,
    srgb: 3001
  };
  function setTextureColorSpace(texture, colorSpace) {
    if (parseInt(REVISION, 10) >= 152) {
      texture.colorSpace = colorSpace;
    } else {
      texture.encoding = colorSpaceEncodingMap[colorSpace];
    }
  }
  var GLTFMToonMaterialParamsAssignHelper = class {
    get pending() {
      return Promise.all(this._pendings);
    }
    constructor(parser, materialParams) {
      this._parser = parser;
      this._materialParams = materialParams;
      this._pendings = [];
    }
    assignPrimitive(key, value) {
      if (value != null) {
        this._materialParams[key] = value;
      }
    }
    assignColor(key, value, convertSRGBToLinear) {
      if (value != null) {
        this._materialParams[key] = new Color().fromArray(value);
        if (convertSRGBToLinear) {
          this._materialParams[key].convertSRGBToLinear();
        }
      }
    }
    assignTexture(key, texture, isColorTexture) {
      return __async3(this, null, function* () {
        const promise = (() => __async3(this, null, function* () {
          if (texture != null) {
            yield this._parser.assignTexture(this._materialParams, key, texture);
            if (isColorTexture) {
              setTextureColorSpace(this._materialParams[key], "srgb");
            }
          }
        }))();
        this._pendings.push(promise);
        return promise;
      });
    }
    assignTextureByIndex(key, textureIndex, isColorTexture) {
      return __async3(this, null, function* () {
        return this.assignTexture(key, textureIndex != null ? { index: textureIndex } : void 0, isColorTexture);
      });
    }
  };
  var mtoon_default = "// #define PHONG\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n  varying vec3 vNormal;\n#endif\n\n#include <common>\n\n// #include <uv_pars_vertex>\n#ifdef MTOON_USE_UV\n  varying vec2 vUv;\n\n  // COMPAT: pre-r151 uses a common uvTransform\n  #if THREE_VRM_THREE_REVISION < 151\n    uniform mat3 uvTransform;\n  #endif\n#endif\n\n// #include <uv2_pars_vertex>\n// COMAPT: pre-r151 uses uv2 for lightMap and aoMap\n#if THREE_VRM_THREE_REVISION < 151\n  #if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n    attribute vec2 uv2;\n    varying vec2 vUv2;\n    uniform mat3 uv2Transform;\n  #endif\n#endif\n\n// #include <displacementmap_pars_vertex>\n// #include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\n#ifdef USE_OUTLINEWIDTHMULTIPLYTEXTURE\n  uniform sampler2D outlineWidthMultiplyTexture;\n  uniform mat3 outlineWidthMultiplyTextureUvTransform;\n#endif\n\nuniform float outlineWidthFactor;\n\nvoid main() {\n\n  // #include <uv_vertex>\n  #ifdef MTOON_USE_UV\n    // COMPAT: pre-r151 uses a common uvTransform\n    #if THREE_VRM_THREE_REVISION >= 151\n      vUv = uv;\n    #else\n      vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n    #endif\n  #endif\n\n  // #include <uv2_vertex>\n  // COMAPT: pre-r151 uses uv2 for lightMap and aoMap\n  #if THREE_VRM_THREE_REVISION < 151\n    #if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n      vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n    #endif\n  #endif\n\n  #include <color_vertex>\n\n  #include <beginnormal_vertex>\n  #include <morphnormal_vertex>\n  #include <skinbase_vertex>\n  #include <skinnormal_vertex>\n\n  // we need this to compute the outline properly\n  objectNormal = normalize( objectNormal );\n\n  #include <defaultnormal_vertex>\n\n  #ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n    vNormal = normalize( transformedNormal );\n  #endif\n\n  #include <begin_vertex>\n\n  #include <morphtarget_vertex>\n  #include <skinning_vertex>\n  // #include <displacementmap_vertex>\n  #include <project_vertex>\n  #include <logdepthbuf_vertex>\n  #include <clipping_planes_vertex>\n\n  vViewPosition = - mvPosition.xyz;\n\n  float outlineTex = 1.0;\n\n  #ifdef OUTLINE\n    #ifdef USE_OUTLINEWIDTHMULTIPLYTEXTURE\n      vec2 outlineWidthMultiplyTextureUv = ( outlineWidthMultiplyTextureUvTransform * vec3( vUv, 1 ) ).xy;\n      outlineTex = texture2D( outlineWidthMultiplyTexture, outlineWidthMultiplyTextureUv ).g;\n    #endif\n\n    #ifdef OUTLINE_WIDTH_WORLD\n      float worldNormalLength = length( transformedNormal );\n      vec3 outlineOffset = outlineWidthFactor * outlineTex * worldNormalLength * objectNormal;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4( outlineOffset + transformed, 1.0 );\n    #endif\n\n    #ifdef OUTLINE_WIDTH_SCREEN\n      vec3 clipNormal = ( projectionMatrix * modelViewMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n      vec2 projectedNormal = normalize( clipNormal.xy );\n      projectedNormal.x *= projectionMatrix[ 0 ].x / projectionMatrix[ 1 ].y;\n      gl_Position.xy += 2.0 * outlineWidthFactor * outlineTex * projectedNormal.xy;\n    #endif\n\n    gl_Position.z += 1E-6 * gl_Position.w; // anti-artifact magic\n  #endif\n\n  #include <worldpos_vertex>\n  // #include <envmap_vertex>\n  #include <shadowmap_vertex>\n  #include <fog_vertex>\n\n}";
  var mtoon_default2 = "// #define PHONG\n\nuniform vec3 litFactor;\n\nuniform float opacity;\n\nuniform vec3 shadeColorFactor;\n#ifdef USE_SHADEMULTIPLYTEXTURE\n  uniform sampler2D shadeMultiplyTexture;\n  uniform mat3 shadeMultiplyTextureUvTransform;\n#endif\n\nuniform float shadingShiftFactor;\nuniform float shadingToonyFactor;\n\n#ifdef USE_SHADINGSHIFTTEXTURE\n  uniform sampler2D shadingShiftTexture;\n  uniform mat3 shadingShiftTextureUvTransform;\n  uniform float shadingShiftTextureScale;\n#endif\n\nuniform float giEqualizationFactor;\n\nuniform vec3 parametricRimColorFactor;\n#ifdef USE_RIMMULTIPLYTEXTURE\n  uniform sampler2D rimMultiplyTexture;\n  uniform mat3 rimMultiplyTextureUvTransform;\n#endif\nuniform float rimLightingMixFactor;\nuniform float parametricRimFresnelPowerFactor;\nuniform float parametricRimLiftFactor;\n\n#ifdef USE_MATCAPTEXTURE\n  uniform vec3 matcapFactor;\n  uniform sampler2D matcapTexture;\n  uniform mat3 matcapTextureUvTransform;\n#endif\n\nuniform vec3 emissive;\nuniform float emissiveIntensity;\n\nuniform vec3 outlineColorFactor;\nuniform float outlineLightingMixFactor;\n\n#ifdef USE_UVANIMATIONMASKTEXTURE\n  uniform sampler2D uvAnimationMaskTexture;\n  uniform mat3 uvAnimationMaskTextureUvTransform;\n#endif\n\nuniform float uvAnimationScrollXOffset;\nuniform float uvAnimationScrollYOffset;\nuniform float uvAnimationRotationPhase;\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n\n// #include <uv_pars_fragment>\n#if ( defined( MTOON_USE_UV ) && !defined( MTOON_UVS_VERTEX_ONLY ) )\n  varying vec2 vUv;\n#endif\n\n// #include <uv2_pars_fragment>\n// COMAPT: pre-r151 uses uv2 for lightMap and aoMap\n#if THREE_VRM_THREE_REVISION < 151\n  #if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n    varying vec2 vUv2;\n  #endif\n#endif\n\n#include <map_pars_fragment>\n\n#ifdef USE_MAP\n  uniform mat3 mapUvTransform;\n#endif\n\n// #include <alphamap_pars_fragment>\n\n#include <alphatest_pars_fragment>\n\n#include <aomap_pars_fragment>\n// #include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n\n#ifdef USE_EMISSIVEMAP\n  uniform mat3 emissiveMapUvTransform;\n#endif\n\n// #include <envmap_common_pars_fragment>\n// #include <envmap_pars_fragment>\n// #include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n\n// #include <bsdfs>\n// COMPAT: pre-r151 doesn't have BRDF_Lambert in <common>\n#if THREE_VRM_THREE_REVISION < 151\n  vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n    return RECIPROCAL_PI * diffuseColor;\n  }\n#endif\n\n#include <lights_pars_begin>\n\n#include <normal_pars_fragment>\n\n// #include <lights_phong_pars_fragment>\nvarying vec3 vViewPosition;\n\nstruct MToonMaterial {\n  vec3 diffuseColor;\n  vec3 shadeColor;\n  float shadingShift;\n};\n\nfloat linearstep( float a, float b, float t ) {\n  return clamp( ( t - a ) / ( b - a ), 0.0, 1.0 );\n}\n\n/**\n * Convert NdotL into toon shading factor using shadingShift and shadingToony\n */\nfloat getShading(\n  const in float dotNL,\n  const in float shadow,\n  const in float shadingShift\n) {\n  float shading = dotNL;\n  shading = shading + shadingShift;\n  shading = linearstep( -1.0 + shadingToonyFactor, 1.0 - shadingToonyFactor, shading );\n  shading *= shadow;\n  return shading;\n}\n\n/**\n * Mix diffuseColor and shadeColor using shading factor and light color\n */\nvec3 getDiffuse(\n  const in MToonMaterial material,\n  const in float shading,\n  in vec3 lightColor\n) {\n  #ifdef DEBUG_LITSHADERATE\n    return vec3( BRDF_Lambert( shading * lightColor ) );\n  #endif\n\n  vec3 col = lightColor * BRDF_Lambert( mix( material.shadeColor, material.diffuseColor, shading ) );\n\n  // The \"comment out if you want to PBR absolutely\" line\n  #ifdef V0_COMPAT_SHADE\n    col = min( col, material.diffuseColor );\n  #endif\n\n  return col;\n}\n\n// COMPAT: pre-r156 uses a struct GeometricContext\n#if THREE_VRM_THREE_REVISION >= 157\n  void RE_Direct_MToon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in MToonMaterial material, const in float shadow, inout ReflectedLight reflectedLight ) {\n    float dotNL = clamp( dot( geometryNormal, directLight.direction ), -1.0, 1.0 );\n    vec3 irradiance = directLight.color;\n\n    // directSpecular will be used for rim lighting, not an actual specular\n    reflectedLight.directSpecular += irradiance;\n\n    irradiance *= dotNL;\n\n    float shading = getShading( dotNL, shadow, material.shadingShift );\n\n    // toon shaded diffuse\n    reflectedLight.directDiffuse += getDiffuse( material, shading, directLight.color );\n  }\n\n  void RE_IndirectDiffuse_MToon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in MToonMaterial material, inout ReflectedLight reflectedLight ) {\n    // indirect diffuse will use diffuseColor, no shadeColor involved\n    reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\n    // directSpecular will be used for rim lighting, not an actual specular\n    reflectedLight.directSpecular += irradiance;\n  }\n#else\n  void RE_Direct_MToon( const in IncidentLight directLight, const in GeometricContext geometry, const in MToonMaterial material, const in float shadow, inout ReflectedLight reflectedLight ) {\n    float dotNL = clamp( dot( geometry.normal, directLight.direction ), -1.0, 1.0 );\n    vec3 irradiance = directLight.color;\n\n    // directSpecular will be used for rim lighting, not an actual specular\n    reflectedLight.directSpecular += irradiance;\n\n    irradiance *= dotNL;\n\n    float shading = getShading( dotNL, shadow, material.shadingShift );\n\n    // toon shaded diffuse\n    reflectedLight.directDiffuse += getDiffuse( material, shading, directLight.color );\n  }\n\n  void RE_IndirectDiffuse_MToon( const in vec3 irradiance, const in GeometricContext geometry, const in MToonMaterial material, inout ReflectedLight reflectedLight ) {\n    // indirect diffuse will use diffuseColor, no shadeColor involved\n    reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\n    // directSpecular will be used for rim lighting, not an actual specular\n    reflectedLight.directSpecular += irradiance;\n  }\n#endif\n\n#define RE_Direct RE_Direct_MToon\n#define RE_IndirectDiffuse RE_IndirectDiffuse_MToon\n#define Material_LightProbeLOD( material ) (0)\n\n#include <shadowmap_pars_fragment>\n// #include <bumpmap_pars_fragment>\n\n// #include <normalmap_pars_fragment>\n#ifdef USE_NORMALMAP\n\n  uniform sampler2D normalMap;\n  uniform mat3 normalMapUvTransform;\n  uniform vec2 normalScale;\n\n#endif\n\n// COMPAT: pre-r151\n// USE_NORMALMAP_OBJECTSPACE used to be OBJECTSPACE_NORMALMAP in pre-r151\n#if defined( USE_NORMALMAP_OBJECTSPACE ) || defined( OBJECTSPACE_NORMALMAP )\n\n  uniform mat3 normalMatrix;\n\n#endif\n\n// COMPAT: pre-r151\n// USE_NORMALMAP_TANGENTSPACE used to be TANGENTSPACE_NORMALMAP in pre-r151\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( TANGENTSPACE_NORMALMAP ) )\n\n  // Per-Pixel Tangent Space Normal Mapping\n  // http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\n\n  // three-vrm specific change: it requires `uv` as an input in order to support uv scrolls\n\n  // Temporary compat against shader change @ Three.js r126, r151\n  #if THREE_VRM_THREE_REVISION >= 151\n\n    mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n\n      vec3 q0 = dFdx( eye_pos.xyz );\n      vec3 q1 = dFdy( eye_pos.xyz );\n      vec2 st0 = dFdx( uv.st );\n      vec2 st1 = dFdy( uv.st );\n\n      vec3 N = surf_norm;\n\n      vec3 q1perp = cross( q1, N );\n      vec3 q0perp = cross( N, q0 );\n\n      vec3 T = q1perp * st0.x + q0perp * st1.x;\n      vec3 B = q1perp * st0.y + q0perp * st1.y;\n\n      float det = max( dot( T, T ), dot( B, B ) );\n      float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n\n      return mat3( T * scale, B * scale, N );\n\n    }\n\n  #else\n\n    vec3 perturbNormal2Arb( vec2 uv, vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\n      vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n      vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n      vec2 st0 = dFdx( uv.st );\n      vec2 st1 = dFdy( uv.st );\n\n      vec3 N = normalize( surf_norm );\n\n      vec3 q1perp = cross( q1, N );\n      vec3 q0perp = cross( N, q0 );\n\n      vec3 T = q1perp * st0.x + q0perp * st1.x;\n      vec3 B = q1perp * st0.y + q0perp * st1.y;\n\n      // three-vrm specific change: Workaround for the issue that happens when delta of uv = 0.0\n      // TODO: Is this still required? Or shall I make a PR about it?\n      if ( length( T ) == 0.0 || length( B ) == 0.0 ) {\n        return surf_norm;\n      }\n\n      float det = max( dot( T, T ), dot( B, B ) );\n      float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\n      return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\n    }\n\n  #endif\n\n#endif\n\n// #include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\n// == post correction ==========================================================\nvoid postCorrection() {\n  #include <tonemapping_fragment>\n  #include <colorspace_fragment>\n  #include <fog_fragment>\n  #include <premultiplied_alpha_fragment>\n  #include <dithering_fragment>\n}\n\n// == main procedure ===========================================================\nvoid main() {\n  #include <clipping_planes_fragment>\n\n  vec2 uv = vec2(0.5, 0.5);\n\n  #if ( defined( MTOON_USE_UV ) && !defined( MTOON_UVS_VERTEX_ONLY ) )\n    uv = vUv;\n\n    float uvAnimMask = 1.0;\n    #ifdef USE_UVANIMATIONMASKTEXTURE\n      vec2 uvAnimationMaskTextureUv = ( uvAnimationMaskTextureUvTransform * vec3( uv, 1 ) ).xy;\n      uvAnimMask = texture2D( uvAnimationMaskTexture, uvAnimationMaskTextureUv ).b;\n    #endif\n\n    float uvRotCos = cos( uvAnimationRotationPhase * uvAnimMask );\n    float uvRotSin = sin( uvAnimationRotationPhase * uvAnimMask );\n    uv = mat2( uvRotCos, -uvRotSin, uvRotSin, uvRotCos ) * ( uv - 0.5 ) + 0.5;\n    uv = uv + vec2( uvAnimationScrollXOffset, uvAnimationScrollYOffset ) * uvAnimMask;\n  #endif\n\n  #ifdef DEBUG_UV\n    gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n    #if ( defined( MTOON_USE_UV ) && !defined( MTOON_UVS_VERTEX_ONLY ) )\n      gl_FragColor = vec4( uv, 0.0, 1.0 );\n    #endif\n    return;\n  #endif\n\n  vec4 diffuseColor = vec4( litFactor, opacity );\n  ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n  vec3 totalEmissiveRadiance = emissive * emissiveIntensity;\n\n  #include <logdepthbuf_fragment>\n\n  // #include <map_fragment>\n  #ifdef USE_MAP\n    vec2 mapUv = ( mapUvTransform * vec3( uv, 1 ) ).xy;\n    vec4 sampledDiffuseColor = texture2D( map, mapUv );\n    #ifdef DECODE_VIDEO_TEXTURE\n      sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n    #endif\n    diffuseColor *= sampledDiffuseColor;\n  #endif\n\n  // #include <color_fragment>\n  #if ( defined( USE_COLOR ) && !defined( IGNORE_VERTEX_COLOR ) )\n    diffuseColor.rgb *= vColor;\n  #endif\n\n  // #include <alphamap_fragment>\n\n  #include <alphatest_fragment>\n\n  // #include <specularmap_fragment>\n\n  // #include <normal_fragment_begin>\n  float faceDirection = gl_FrontFacing ? 1.0 : -1.0;\n\n  #ifdef FLAT_SHADED\n\n    vec3 fdx = dFdx( vViewPosition );\n    vec3 fdy = dFdy( vViewPosition );\n    vec3 normal = normalize( cross( fdx, fdy ) );\n\n  #else\n\n    vec3 normal = normalize( vNormal );\n\n    #ifdef DOUBLE_SIDED\n\n      normal *= faceDirection;\n\n    #endif\n\n  #endif\n\n  #ifdef USE_NORMALMAP\n\n    vec2 normalMapUv = ( normalMapUvTransform * vec3( uv, 1 ) ).xy;\n\n  #endif\n\n  #ifdef USE_NORMALMAP_TANGENTSPACE\n\n    #ifdef USE_TANGENT\n\n      mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\n    #else\n\n      mat3 tbn = getTangentFrame( - vViewPosition, normal, normalMapUv );\n\n    #endif\n\n    #if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\n      tbn[0] *= faceDirection;\n      tbn[1] *= faceDirection;\n\n    #endif\n\n  #endif\n\n  #ifdef USE_CLEARCOAT_NORMALMAP\n\n    #ifdef USE_TANGENT\n\n      mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\n    #else\n\n      mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n\n    #endif\n\n    #if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\n      tbn2[0] *= faceDirection;\n      tbn2[1] *= faceDirection;\n\n    #endif\n\n  #endif\n\n  // non perturbed normal for clearcoat among others\n\n  vec3 nonPerturbedNormal = normal;\n\n  #ifdef OUTLINE\n    normal *= -1.0;\n  #endif\n\n  // #include <normal_fragment_maps>\n\n  // COMPAT: pre-r151\n  // USE_NORMALMAP_OBJECTSPACE used to be OBJECTSPACE_NORMALMAP in pre-r151\n  #if defined( USE_NORMALMAP_OBJECTSPACE ) || defined( OBJECTSPACE_NORMALMAP )\n\n    normal = texture2D( normalMap, normalMapUv ).xyz * 2.0 - 1.0; // overrides both flatShading and attribute normals\n\n    #ifdef FLIP_SIDED\n\n      normal = - normal;\n\n    #endif\n\n    #ifdef DOUBLE_SIDED\n\n      normal = normal * faceDirection;\n\n    #endif\n\n    normal = normalize( normalMatrix * normal );\n\n  // COMPAT: pre-r151\n  // USE_NORMALMAP_TANGENTSPACE used to be TANGENTSPACE_NORMALMAP in pre-r151\n  #elif defined( USE_NORMALMAP_TANGENTSPACE ) || defined( TANGENTSPACE_NORMALMAP )\n\n    vec3 mapN = texture2D( normalMap, normalMapUv ).xyz * 2.0 - 1.0;\n    mapN.xy *= normalScale;\n\n    // COMPAT: pre-r151\n    #if THREE_VRM_THREE_REVISION >= 151 || defined( USE_TANGENT )\n\n      normal = normalize( tbn * mapN );\n\n    #else\n\n      normal = perturbNormal2Arb( uv, -vViewPosition, normal, mapN, faceDirection );\n\n    #endif\n\n  #endif\n\n  // #include <emissivemap_fragment>\n  #ifdef USE_EMISSIVEMAP\n    vec2 emissiveMapUv = ( emissiveMapUvTransform * vec3( uv, 1 ) ).xy;\n    totalEmissiveRadiance *= texture2D( emissiveMap, emissiveMapUv ).rgb;\n  #endif\n\n  #ifdef DEBUG_NORMAL\n    gl_FragColor = vec4( 0.5 + 0.5 * normal, 1.0 );\n    return;\n  #endif\n\n  // -- MToon: lighting --------------------------------------------------------\n  // accumulation\n  // #include <lights_phong_fragment>\n  MToonMaterial material;\n\n  material.diffuseColor = diffuseColor.rgb;\n\n  material.shadeColor = shadeColorFactor;\n  #ifdef USE_SHADEMULTIPLYTEXTURE\n    vec2 shadeMultiplyTextureUv = ( shadeMultiplyTextureUvTransform * vec3( uv, 1 ) ).xy;\n    material.shadeColor *= texture2D( shadeMultiplyTexture, shadeMultiplyTextureUv ).rgb;\n  #endif\n\n  #if ( defined( USE_COLOR ) && !defined( IGNORE_VERTEX_COLOR ) )\n    material.shadeColor.rgb *= vColor;\n  #endif\n\n  material.shadingShift = shadingShiftFactor;\n  #ifdef USE_SHADINGSHIFTTEXTURE\n    vec2 shadingShiftTextureUv = ( shadingShiftTextureUvTransform * vec3( uv, 1 ) ).xy;\n    material.shadingShift += texture2D( shadingShiftTexture, shadingShiftTextureUv ).r * shadingShiftTextureScale;\n  #endif\n\n  // #include <lights_fragment_begin>\n\n  // MToon Specific changes:\n  // Since we want to take shadows into account of shading instead of irradiance,\n  // we had to modify the codes that multiplies the results of shadowmap into color of direct lights.\n\n  // COMPAT: pre-r156 uses a struct GeometricContext\n  #if THREE_VRM_THREE_REVISION >= 157\n    vec3 geometryPosition = - vViewPosition;\n    vec3 geometryNormal = normal;\n    vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n\n    vec3 geometryClearcoatNormal;\n\n    #ifdef USE_CLEARCOAT\n\n      geometryClearcoatNormal = clearcoatNormal;\n\n    #endif\n  #else\n    GeometricContext geometry;\n\n    geometry.position = - vViewPosition;\n    geometry.normal = normal;\n    geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n\n    #ifdef USE_CLEARCOAT\n\n      geometry.clearcoatNormal = clearcoatNormal;\n\n    #endif\n  #endif\n\n  IncidentLight directLight;\n\n  // since these variables will be used in unrolled loop, we have to define in prior\n  float shadow;\n\n  #if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\n    PointLight pointLight;\n    #if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n    PointLightShadow pointLightShadow;\n    #endif\n\n    #pragma unroll_loop_start\n    for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n      pointLight = pointLights[ i ];\n\n      // COMPAT: pre-r156 uses a struct GeometricContext\n      #if THREE_VRM_THREE_REVISION >= 157\n        getPointLightInfo( pointLight, geometryPosition, directLight );\n      #else\n        getPointLightInfo( pointLight, geometry, directLight );\n      #endif\n\n      shadow = 1.0;\n      #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n      pointLightShadow = pointLightShadows[ i ];\n      // COMPAT: pre-r166\n      // r166 introduced shadowIntensity\n      #if THREE_VRM_THREE_REVISION >= 166\n        shadow = all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n      #else\n        shadow = all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n      #endif\n      #endif\n\n      // COMPAT: pre-r156 uses a struct GeometricContext\n      #if THREE_VRM_THREE_REVISION >= 157\n        RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, shadow, reflectedLight );\n      #else\n        RE_Direct( directLight, geometry, material, shadow, reflectedLight );\n      #endif\n\n    }\n    #pragma unroll_loop_end\n\n  #endif\n\n  #if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\n    SpotLight spotLight;\n    #if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n    SpotLightShadow spotLightShadow;\n    #endif\n\n    #pragma unroll_loop_start\n    for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n      spotLight = spotLights[ i ];\n\n      // COMPAT: pre-r156 uses a struct GeometricContext\n      #if THREE_VRM_THREE_REVISION >= 157\n        getSpotLightInfo( spotLight, geometryPosition, directLight );\n      #else\n        getSpotLightInfo( spotLight, geometry, directLight );\n      #endif\n\n      shadow = 1.0;\n      #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n      spotLightShadow = spotLightShadows[ i ];\n      // COMPAT: pre-r166\n      // r166 introduced shadowIntensity\n      #if THREE_VRM_THREE_REVISION >= 166\n        shadow = all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n      #else\n        shadow = all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n      #endif\n      #endif\n\n      // COMPAT: pre-r156 uses a struct GeometricContext\n      #if THREE_VRM_THREE_REVISION >= 157\n        RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, shadow, reflectedLight );\n      #else\n        RE_Direct( directLight, geometry, material, shadow, reflectedLight );\n      #endif\n\n    }\n    #pragma unroll_loop_end\n\n  #endif\n\n  #if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\n    DirectionalLight directionalLight;\n    #if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n    DirectionalLightShadow directionalLightShadow;\n    #endif\n\n    #pragma unroll_loop_start\n    for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n      directionalLight = directionalLights[ i ];\n\n      // COMPAT: pre-r156 uses a struct GeometricContext\n      #if THREE_VRM_THREE_REVISION >= 157\n        getDirectionalLightInfo( directionalLight, directLight );\n      #else\n        getDirectionalLightInfo( directionalLight, geometry, directLight );\n      #endif\n\n      shadow = 1.0;\n      #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n      directionalLightShadow = directionalLightShadows[ i ];\n      // COMPAT: pre-r166\n      // r166 introduced shadowIntensity\n      #if THREE_VRM_THREE_REVISION >= 166\n        shadow = all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n      #else\n        shadow = all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n      #endif\n      #endif\n\n      // COMPAT: pre-r156 uses a struct GeometricContext\n      #if THREE_VRM_THREE_REVISION >= 157\n        RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, shadow, reflectedLight );\n      #else\n        RE_Direct( directLight, geometry, material, shadow, reflectedLight );\n      #endif\n\n    }\n    #pragma unroll_loop_end\n\n  #endif\n\n  // #if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\n  //   RectAreaLight rectAreaLight;\n\n  //   #pragma unroll_loop_start\n  //   for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\n  //     rectAreaLight = rectAreaLights[ i ];\n  //     RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\n  //   }\n  //   #pragma unroll_loop_end\n\n  // #endif\n\n  #if defined( RE_IndirectDiffuse )\n\n    vec3 iblIrradiance = vec3( 0.0 );\n\n    vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\n    // COMPAT: pre-r156 uses a struct GeometricContext\n    // COMPAT: pre-r156 doesn't have a define USE_LIGHT_PROBES\n    #if THREE_VRM_THREE_REVISION >= 157\n      #if defined( USE_LIGHT_PROBES )\n        irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n      #endif\n    #else\n      irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n    #endif\n\n    #if ( NUM_HEMI_LIGHTS > 0 )\n\n      #pragma unroll_loop_start\n      for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\n        // COMPAT: pre-r156 uses a struct GeometricContext\n        #if THREE_VRM_THREE_REVISION >= 157\n          irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n        #else\n          irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n        #endif\n\n      }\n      #pragma unroll_loop_end\n\n    #endif\n\n  #endif\n\n  // #if defined( RE_IndirectSpecular )\n\n  //   vec3 radiance = vec3( 0.0 );\n  //   vec3 clearcoatRadiance = vec3( 0.0 );\n\n  // #endif\n\n  #include <lights_fragment_maps>\n  #include <lights_fragment_end>\n\n  // modulation\n  #include <aomap_fragment>\n\n  vec3 col = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\n  #ifdef DEBUG_LITSHADERATE\n    gl_FragColor = vec4( col, diffuseColor.a );\n    postCorrection();\n    return;\n  #endif\n\n  // -- MToon: rim lighting -----------------------------------------\n  vec3 viewDir = normalize( vViewPosition );\n\n  #ifndef PHYSICALLY_CORRECT_LIGHTS\n    reflectedLight.directSpecular /= PI;\n  #endif\n  vec3 rimMix = mix( vec3( 1.0 ), reflectedLight.directSpecular, 1.0 );\n\n  vec3 rim = parametricRimColorFactor * pow( saturate( 1.0 - dot( viewDir, normal ) + parametricRimLiftFactor ), parametricRimFresnelPowerFactor );\n\n  #ifdef USE_MATCAPTEXTURE\n    {\n      vec3 x = normalize( vec3( viewDir.z, 0.0, -viewDir.x ) );\n      vec3 y = cross( viewDir, x ); // guaranteed to be normalized\n      vec2 sphereUv = 0.5 + 0.5 * vec2( dot( x, normal ), -dot( y, normal ) );\n      sphereUv = ( matcapTextureUvTransform * vec3( sphereUv, 1 ) ).xy;\n      vec3 matcap = texture2D( matcapTexture, sphereUv ).rgb;\n      rim += matcapFactor * matcap;\n    }\n  #endif\n\n  #ifdef USE_RIMMULTIPLYTEXTURE\n    vec2 rimMultiplyTextureUv = ( rimMultiplyTextureUvTransform * vec3( uv, 1 ) ).xy;\n    rim *= texture2D( rimMultiplyTexture, rimMultiplyTextureUv ).rgb;\n  #endif\n\n  col += rimMix * rim;\n\n  // -- MToon: Emission --------------------------------------------------------\n  col += totalEmissiveRadiance;\n\n  // #include <envmap_fragment>\n\n  // -- Almost done! -----------------------------------------------------------\n  #if defined( OUTLINE )\n    col = outlineColorFactor.rgb * mix( vec3( 1.0 ), col, outlineLightingMixFactor );\n  #endif\n\n  #ifdef OPAQUE\n    diffuseColor.a = 1.0;\n  #endif\n\n  gl_FragColor = vec4( col, diffuseColor.a );\n  postCorrection();\n}\n";
  var MToonMaterialDebugMode = {
    /**
     * Render normally.
     */
    None: "none",
    /**
     * Visualize normals of the surface.
     */
    Normal: "normal",
    /**
     * Visualize lit/shade of the surface.
     */
    LitShadeRate: "litShadeRate",
    /**
     * Visualize UV of the surface.
     */
    UV: "uv"
  };
  var MToonMaterialOutlineWidthMode = {
    None: "none",
    WorldCoordinates: "worldCoordinates",
    ScreenCoordinates: "screenCoordinates"
  };
  var encodingColorSpaceMap = {
    // eslint-disable-next-line @typescript-eslint/naming-convention
    3e3: "",
    // eslint-disable-next-line @typescript-eslint/naming-convention
    3001: "srgb"
  };
  function getTextureColorSpace(texture) {
    if (parseInt(REVISION, 10) >= 152) {
      return texture.colorSpace;
    } else {
      return encodingColorSpaceMap[texture.encoding];
    }
  }
  var MToonMaterial = class extends ShaderMaterial {
    constructor(parameters = {}) {
      var _a;
      super({ vertexShader: mtoon_default, fragmentShader: mtoon_default2 });
      this.uvAnimationScrollXSpeedFactor = 0;
      this.uvAnimationScrollYSpeedFactor = 0;
      this.uvAnimationRotationSpeedFactor = 0;
      this.fog = true;
      this.normalMapType = TangentSpaceNormalMap;
      this._ignoreVertexColor = true;
      this._v0CompatShade = false;
      this._debugMode = MToonMaterialDebugMode.None;
      this._outlineWidthMode = MToonMaterialOutlineWidthMode.None;
      this._isOutline = false;
      if (parameters.transparentWithZWrite) {
        parameters.depthWrite = true;
      }
      delete parameters.transparentWithZWrite;
      parameters.fog = true;
      parameters.lights = true;
      parameters.clipping = true;
      this.uniforms = UniformsUtils.merge([
        UniformsLib.common,
        // map
        UniformsLib.normalmap,
        // normalMap
        UniformsLib.emissivemap,
        // emissiveMap
        UniformsLib.fog,
        UniformsLib.lights,
        {
          litFactor: { value: new Color(1, 1, 1) },
          mapUvTransform: { value: new Matrix3() },
          colorAlpha: { value: 1 },
          normalMapUvTransform: { value: new Matrix3() },
          shadeColorFactor: { value: new Color(0, 0, 0) },
          shadeMultiplyTexture: { value: null },
          shadeMultiplyTextureUvTransform: { value: new Matrix3() },
          shadingShiftFactor: { value: 0 },
          shadingShiftTexture: { value: null },
          shadingShiftTextureUvTransform: { value: new Matrix3() },
          shadingShiftTextureScale: { value: 1 },
          shadingToonyFactor: { value: 0.9 },
          giEqualizationFactor: { value: 0.9 },
          matcapFactor: { value: new Color(1, 1, 1) },
          matcapTexture: { value: null },
          matcapTextureUvTransform: { value: new Matrix3() },
          parametricRimColorFactor: { value: new Color(0, 0, 0) },
          rimMultiplyTexture: { value: null },
          rimMultiplyTextureUvTransform: { value: new Matrix3() },
          rimLightingMixFactor: { value: 1 },
          parametricRimFresnelPowerFactor: { value: 5 },
          parametricRimLiftFactor: { value: 0 },
          emissive: { value: new Color(0, 0, 0) },
          emissiveIntensity: { value: 1 },
          emissiveMapUvTransform: { value: new Matrix3() },
          outlineWidthMultiplyTexture: { value: null },
          outlineWidthMultiplyTextureUvTransform: { value: new Matrix3() },
          outlineWidthFactor: { value: 0 },
          outlineColorFactor: { value: new Color(0, 0, 0) },
          outlineLightingMixFactor: { value: 1 },
          uvAnimationMaskTexture: { value: null },
          uvAnimationMaskTextureUvTransform: { value: new Matrix3() },
          uvAnimationScrollXOffset: { value: 0 },
          uvAnimationScrollYOffset: { value: 0 },
          uvAnimationRotationPhase: { value: 0 }
        },
        (_a = parameters.uniforms) != null ? _a : {}
      ]);
      this.setValues(parameters);
      this._uploadUniformsWorkaround();
      this.customProgramCacheKey = () => [
        ...Object.entries(this._generateDefines()).map(([token, macro]) => `${token}:${macro}`),
        this.matcapTexture ? `matcapTextureColorSpace:${getTextureColorSpace(this.matcapTexture)}` : "",
        this.shadeMultiplyTexture ? `shadeMultiplyTextureColorSpace:${getTextureColorSpace(this.shadeMultiplyTexture)}` : "",
        this.rimMultiplyTexture ? `rimMultiplyTextureColorSpace:${getTextureColorSpace(this.rimMultiplyTexture)}` : ""
      ].join(",");
      this.onBeforeCompile = (shader) => {
        const threeRevision = parseInt(REVISION, 10);
        const defines = Object.entries(__spreadValues(__spreadValues({}, this._generateDefines()), this.defines)).filter(([token, macro]) => !!macro).map(([token, macro]) => `#define ${token} ${macro}`).join("\n") + "\n";
        shader.vertexShader = defines + shader.vertexShader;
        shader.fragmentShader = defines + shader.fragmentShader;
        if (threeRevision < 154) {
          shader.fragmentShader = shader.fragmentShader.replace(
            "#include <colorspace_fragment>",
            "#include <encodings_fragment>"
          );
        }
      };
    }
    get color() {
      return this.uniforms.litFactor.value;
    }
    set color(value) {
      this.uniforms.litFactor.value = value;
    }
    get map() {
      return this.uniforms.map.value;
    }
    set map(value) {
      this.uniforms.map.value = value;
    }
    get normalMap() {
      return this.uniforms.normalMap.value;
    }
    set normalMap(value) {
      this.uniforms.normalMap.value = value;
    }
    get normalScale() {
      return this.uniforms.normalScale.value;
    }
    set normalScale(value) {
      this.uniforms.normalScale.value = value;
    }
    get emissive() {
      return this.uniforms.emissive.value;
    }
    set emissive(value) {
      this.uniforms.emissive.value = value;
    }
    get emissiveIntensity() {
      return this.uniforms.emissiveIntensity.value;
    }
    set emissiveIntensity(value) {
      this.uniforms.emissiveIntensity.value = value;
    }
    get emissiveMap() {
      return this.uniforms.emissiveMap.value;
    }
    set emissiveMap(value) {
      this.uniforms.emissiveMap.value = value;
    }
    get shadeColorFactor() {
      return this.uniforms.shadeColorFactor.value;
    }
    set shadeColorFactor(value) {
      this.uniforms.shadeColorFactor.value = value;
    }
    get shadeMultiplyTexture() {
      return this.uniforms.shadeMultiplyTexture.value;
    }
    set shadeMultiplyTexture(value) {
      this.uniforms.shadeMultiplyTexture.value = value;
    }
    get shadingShiftFactor() {
      return this.uniforms.shadingShiftFactor.value;
    }
    set shadingShiftFactor(value) {
      this.uniforms.shadingShiftFactor.value = value;
    }
    get shadingShiftTexture() {
      return this.uniforms.shadingShiftTexture.value;
    }
    set shadingShiftTexture(value) {
      this.uniforms.shadingShiftTexture.value = value;
    }
    get shadingShiftTextureScale() {
      return this.uniforms.shadingShiftTextureScale.value;
    }
    set shadingShiftTextureScale(value) {
      this.uniforms.shadingShiftTextureScale.value = value;
    }
    get shadingToonyFactor() {
      return this.uniforms.shadingToonyFactor.value;
    }
    set shadingToonyFactor(value) {
      this.uniforms.shadingToonyFactor.value = value;
    }
    get giEqualizationFactor() {
      return this.uniforms.giEqualizationFactor.value;
    }
    set giEqualizationFactor(value) {
      this.uniforms.giEqualizationFactor.value = value;
    }
    get matcapFactor() {
      return this.uniforms.matcapFactor.value;
    }
    set matcapFactor(value) {
      this.uniforms.matcapFactor.value = value;
    }
    get matcapTexture() {
      return this.uniforms.matcapTexture.value;
    }
    set matcapTexture(value) {
      this.uniforms.matcapTexture.value = value;
    }
    get parametricRimColorFactor() {
      return this.uniforms.parametricRimColorFactor.value;
    }
    set parametricRimColorFactor(value) {
      this.uniforms.parametricRimColorFactor.value = value;
    }
    get rimMultiplyTexture() {
      return this.uniforms.rimMultiplyTexture.value;
    }
    set rimMultiplyTexture(value) {
      this.uniforms.rimMultiplyTexture.value = value;
    }
    get rimLightingMixFactor() {
      return this.uniforms.rimLightingMixFactor.value;
    }
    set rimLightingMixFactor(value) {
      this.uniforms.rimLightingMixFactor.value = value;
    }
    get parametricRimFresnelPowerFactor() {
      return this.uniforms.parametricRimFresnelPowerFactor.value;
    }
    set parametricRimFresnelPowerFactor(value) {
      this.uniforms.parametricRimFresnelPowerFactor.value = value;
    }
    get parametricRimLiftFactor() {
      return this.uniforms.parametricRimLiftFactor.value;
    }
    set parametricRimLiftFactor(value) {
      this.uniforms.parametricRimLiftFactor.value = value;
    }
    get outlineWidthMultiplyTexture() {
      return this.uniforms.outlineWidthMultiplyTexture.value;
    }
    set outlineWidthMultiplyTexture(value) {
      this.uniforms.outlineWidthMultiplyTexture.value = value;
    }
    get outlineWidthFactor() {
      return this.uniforms.outlineWidthFactor.value;
    }
    set outlineWidthFactor(value) {
      this.uniforms.outlineWidthFactor.value = value;
    }
    get outlineColorFactor() {
      return this.uniforms.outlineColorFactor.value;
    }
    set outlineColorFactor(value) {
      this.uniforms.outlineColorFactor.value = value;
    }
    get outlineLightingMixFactor() {
      return this.uniforms.outlineLightingMixFactor.value;
    }
    set outlineLightingMixFactor(value) {
      this.uniforms.outlineLightingMixFactor.value = value;
    }
    get uvAnimationMaskTexture() {
      return this.uniforms.uvAnimationMaskTexture.value;
    }
    set uvAnimationMaskTexture(value) {
      this.uniforms.uvAnimationMaskTexture.value = value;
    }
    get uvAnimationScrollXOffset() {
      return this.uniforms.uvAnimationScrollXOffset.value;
    }
    set uvAnimationScrollXOffset(value) {
      this.uniforms.uvAnimationScrollXOffset.value = value;
    }
    get uvAnimationScrollYOffset() {
      return this.uniforms.uvAnimationScrollYOffset.value;
    }
    set uvAnimationScrollYOffset(value) {
      this.uniforms.uvAnimationScrollYOffset.value = value;
    }
    get uvAnimationRotationPhase() {
      return this.uniforms.uvAnimationRotationPhase.value;
    }
    set uvAnimationRotationPhase(value) {
      this.uniforms.uvAnimationRotationPhase.value = value;
    }
    /**
     * When this is `true`, vertex colors will be ignored.
     * `true` by default.
     */
    get ignoreVertexColor() {
      return this._ignoreVertexColor;
    }
    set ignoreVertexColor(value) {
      this._ignoreVertexColor = value;
      this.needsUpdate = true;
    }
    /**
     * There is a line of the shader called "comment out if you want to PBR absolutely" in VRM0.0 MToon.
     * When this is true, the material enables the line to make it compatible with the legacy rendering of VRM.
     * Usually not recommended to turn this on.
     * `false` by default.
     */
    get v0CompatShade() {
      return this._v0CompatShade;
    }
    /**
     * There is a line of the shader called "comment out if you want to PBR absolutely" in VRM0.0 MToon.
     * When this is true, the material enables the line to make it compatible with the legacy rendering of VRM.
     * Usually not recommended to turn this on.
     * `false` by default.
     */
    set v0CompatShade(v) {
      this._v0CompatShade = v;
      this.needsUpdate = true;
    }
    /**
     * Debug mode for the material.
     * You can visualize several components for diagnosis using debug mode.
     *
     * See: {@link MToonMaterialDebugMode}
     */
    get debugMode() {
      return this._debugMode;
    }
    /**
     * Debug mode for the material.
     * You can visualize several components for diagnosis using debug mode.
     *
     * See: {@link MToonMaterialDebugMode}
     */
    set debugMode(m) {
      this._debugMode = m;
      this.needsUpdate = true;
    }
    get outlineWidthMode() {
      return this._outlineWidthMode;
    }
    set outlineWidthMode(m) {
      this._outlineWidthMode = m;
      this.needsUpdate = true;
    }
    get isOutline() {
      return this._isOutline;
    }
    set isOutline(b) {
      this._isOutline = b;
      this.needsUpdate = true;
    }
    /**
     * Readonly boolean that indicates this is a [[MToonMaterial]].
     */
    get isMToonMaterial() {
      return true;
    }
    /**
     * Update this material.
     *
     * @param delta deltaTime since last update
     */
    update(delta) {
      this._uploadUniformsWorkaround();
      this._updateUVAnimation(delta);
    }
    copy(source) {
      super.copy(source);
      this.map = source.map;
      this.normalMap = source.normalMap;
      this.emissiveMap = source.emissiveMap;
      this.shadeMultiplyTexture = source.shadeMultiplyTexture;
      this.shadingShiftTexture = source.shadingShiftTexture;
      this.matcapTexture = source.matcapTexture;
      this.rimMultiplyTexture = source.rimMultiplyTexture;
      this.outlineWidthMultiplyTexture = source.outlineWidthMultiplyTexture;
      this.uvAnimationMaskTexture = source.uvAnimationMaskTexture;
      this.normalMapType = source.normalMapType;
      this.uvAnimationScrollXSpeedFactor = source.uvAnimationScrollXSpeedFactor;
      this.uvAnimationScrollYSpeedFactor = source.uvAnimationScrollYSpeedFactor;
      this.uvAnimationRotationSpeedFactor = source.uvAnimationRotationSpeedFactor;
      this.ignoreVertexColor = source.ignoreVertexColor;
      this.v0CompatShade = source.v0CompatShade;
      this.debugMode = source.debugMode;
      this.outlineWidthMode = source.outlineWidthMode;
      this.isOutline = source.isOutline;
      this.needsUpdate = true;
      return this;
    }
    /**
     * Update UV animation state.
     * Intended to be called via {@link update}.
     * @param delta deltaTime
     */
    _updateUVAnimation(delta) {
      this.uniforms.uvAnimationScrollXOffset.value += delta * this.uvAnimationScrollXSpeedFactor;
      this.uniforms.uvAnimationScrollYOffset.value += delta * this.uvAnimationScrollYSpeedFactor;
      this.uniforms.uvAnimationRotationPhase.value += delta * this.uvAnimationRotationSpeedFactor;
      this.uniforms.alphaTest.value = this.alphaTest;
      this.uniformsNeedUpdate = true;
    }
    /**
     * Upload uniforms that need to upload but doesn't automatically because of reasons.
     * Intended to be called via {@link constructor} and {@link update}.
     */
    _uploadUniformsWorkaround() {
      this.uniforms.opacity.value = this.opacity;
      this._updateTextureMatrix(this.uniforms.map, this.uniforms.mapUvTransform);
      this._updateTextureMatrix(this.uniforms.normalMap, this.uniforms.normalMapUvTransform);
      this._updateTextureMatrix(this.uniforms.emissiveMap, this.uniforms.emissiveMapUvTransform);
      this._updateTextureMatrix(this.uniforms.shadeMultiplyTexture, this.uniforms.shadeMultiplyTextureUvTransform);
      this._updateTextureMatrix(this.uniforms.shadingShiftTexture, this.uniforms.shadingShiftTextureUvTransform);
      this._updateTextureMatrix(this.uniforms.matcapTexture, this.uniforms.matcapTextureUvTransform);
      this._updateTextureMatrix(this.uniforms.rimMultiplyTexture, this.uniforms.rimMultiplyTextureUvTransform);
      this._updateTextureMatrix(
        this.uniforms.outlineWidthMultiplyTexture,
        this.uniforms.outlineWidthMultiplyTextureUvTransform
      );
      this._updateTextureMatrix(this.uniforms.uvAnimationMaskTexture, this.uniforms.uvAnimationMaskTextureUvTransform);
      this.uniformsNeedUpdate = true;
    }
    /**
     * Returns a map object of preprocessor token and macro of the shader program.
     */
    _generateDefines() {
      const threeRevision = parseInt(REVISION, 10);
      const useUvInVert = this.outlineWidthMultiplyTexture !== null;
      const useUvInFrag = this.map !== null || this.normalMap !== null || this.emissiveMap !== null || this.shadeMultiplyTexture !== null || this.shadingShiftTexture !== null || this.rimMultiplyTexture !== null || this.uvAnimationMaskTexture !== null;
      return {
        // Temporary compat against shader change @ Three.js r126
        // See: #21205, #21307, #21299
        THREE_VRM_THREE_REVISION: threeRevision,
        OUTLINE: this._isOutline,
        MTOON_USE_UV: useUvInVert || useUvInFrag,
        // we can't use `USE_UV` , it will be redefined in WebGLProgram.js
        MTOON_UVS_VERTEX_ONLY: useUvInVert && !useUvInFrag,
        V0_COMPAT_SHADE: this._v0CompatShade,
        USE_SHADEMULTIPLYTEXTURE: this.shadeMultiplyTexture !== null,
        USE_SHADINGSHIFTTEXTURE: this.shadingShiftTexture !== null,
        USE_MATCAPTEXTURE: this.matcapTexture !== null,
        USE_RIMMULTIPLYTEXTURE: this.rimMultiplyTexture !== null,
        USE_OUTLINEWIDTHMULTIPLYTEXTURE: this._isOutline && this.outlineWidthMultiplyTexture !== null,
        USE_UVANIMATIONMASKTEXTURE: this.uvAnimationMaskTexture !== null,
        IGNORE_VERTEX_COLOR: this._ignoreVertexColor === true,
        DEBUG_NORMAL: this._debugMode === "normal",
        DEBUG_LITSHADERATE: this._debugMode === "litShadeRate",
        DEBUG_UV: this._debugMode === "uv",
        OUTLINE_WIDTH_WORLD: this._isOutline && this._outlineWidthMode === MToonMaterialOutlineWidthMode.WorldCoordinates,
        OUTLINE_WIDTH_SCREEN: this._isOutline && this._outlineWidthMode === MToonMaterialOutlineWidthMode.ScreenCoordinates
      };
    }
    _updateTextureMatrix(src, dst) {
      if (src.value) {
        if (src.value.matrixAutoUpdate) {
          src.value.updateMatrix();
        }
        dst.value.copy(src.value.matrix);
      }
    }
  };
  var POSSIBLE_SPEC_VERSIONS6 = /* @__PURE__ */ new Set(["1.0", "1.0-beta"]);
  var _MToonMaterialLoaderPlugin = class _MToonMaterialLoaderPlugin2 {
    get name() {
      return _MToonMaterialLoaderPlugin2.EXTENSION_NAME;
    }
    constructor(parser, options = {}) {
      var _a, _b, _c, _d;
      this.parser = parser;
      this.materialType = (_a = options.materialType) != null ? _a : MToonMaterial;
      this.renderOrderOffset = (_b = options.renderOrderOffset) != null ? _b : 0;
      this.v0CompatShade = (_c = options.v0CompatShade) != null ? _c : false;
      this.debugMode = (_d = options.debugMode) != null ? _d : "none";
      this._mToonMaterialSet = /* @__PURE__ */ new Set();
    }
    beforeRoot() {
      return __async3(this, null, function* () {
        this._removeUnlitExtensionIfMToonExists();
      });
    }
    afterRoot(gltf) {
      return __async3(this, null, function* () {
        gltf.userData.vrmMToonMaterials = Array.from(this._mToonMaterialSet);
      });
    }
    getMaterialType(materialIndex) {
      const v1Extension = this._getMToonExtension(materialIndex);
      if (v1Extension) {
        return this.materialType;
      }
      return null;
    }
    extendMaterialParams(materialIndex, materialParams) {
      const extension = this._getMToonExtension(materialIndex);
      if (extension) {
        return this._extendMaterialParams(extension, materialParams);
      }
      return null;
    }
    loadMesh(meshIndex) {
      return __async3(this, null, function* () {
        var _a;
        const parser = this.parser;
        const json = parser.json;
        const meshDef = (_a = json.meshes) == null ? void 0 : _a[meshIndex];
        if (meshDef == null) {
          throw new Error(
            `MToonMaterialLoaderPlugin: Attempt to use meshes[${meshIndex}] of glTF but the mesh doesn't exist`
          );
        }
        const primitivesDef = meshDef.primitives;
        const meshOrGroup = yield parser.loadMesh(meshIndex);
        if (primitivesDef.length === 1) {
          const mesh = meshOrGroup;
          const materialIndex = primitivesDef[0].material;
          if (materialIndex != null) {
            this._setupPrimitive(mesh, materialIndex);
          }
        } else {
          const group = meshOrGroup;
          for (let i = 0; i < primitivesDef.length; i++) {
            const mesh = group.children[i];
            const materialIndex = primitivesDef[i].material;
            if (materialIndex != null) {
              this._setupPrimitive(mesh, materialIndex);
            }
          }
        }
        return meshOrGroup;
      });
    }
    /**
     * Delete use of `KHR_materials_unlit` from its `materials` if the material is using MToon.
     *
     * Since GLTFLoader have so many hardcoded procedure related to `KHR_materials_unlit`
     * we have to delete the extension before we start to parse the glTF.
     */
    _removeUnlitExtensionIfMToonExists() {
      const parser = this.parser;
      const json = parser.json;
      const materialDefs = json.materials;
      materialDefs == null ? void 0 : materialDefs.map((materialDef, iMaterial) => {
        var _a;
        const extension = this._getMToonExtension(iMaterial);
        if (extension && ((_a = materialDef.extensions) == null ? void 0 : _a["KHR_materials_unlit"])) {
          delete materialDef.extensions["KHR_materials_unlit"];
        }
      });
    }
    _getMToonExtension(materialIndex) {
      var _a, _b;
      const parser = this.parser;
      const json = parser.json;
      const materialDef = (_a = json.materials) == null ? void 0 : _a[materialIndex];
      if (materialDef == null) {
        console.warn(
          `MToonMaterialLoaderPlugin: Attempt to use materials[${materialIndex}] of glTF but the material doesn't exist`
        );
        return void 0;
      }
      const extension = (_b = materialDef.extensions) == null ? void 0 : _b[_MToonMaterialLoaderPlugin2.EXTENSION_NAME];
      if (extension == null) {
        return void 0;
      }
      const specVersion = extension.specVersion;
      if (!POSSIBLE_SPEC_VERSIONS6.has(specVersion)) {
        console.warn(
          `MToonMaterialLoaderPlugin: Unknown ${_MToonMaterialLoaderPlugin2.EXTENSION_NAME} specVersion "${specVersion}"`
        );
        return void 0;
      }
      return extension;
    }
    _extendMaterialParams(extension, materialParams) {
      return __async3(this, null, function* () {
        var _a;
        delete materialParams.metalness;
        delete materialParams.roughness;
        const assignHelper = new GLTFMToonMaterialParamsAssignHelper(this.parser, materialParams);
        assignHelper.assignPrimitive("transparentWithZWrite", extension.transparentWithZWrite);
        assignHelper.assignColor("shadeColorFactor", extension.shadeColorFactor);
        assignHelper.assignTexture("shadeMultiplyTexture", extension.shadeMultiplyTexture, true);
        assignHelper.assignPrimitive("shadingShiftFactor", extension.shadingShiftFactor);
        assignHelper.assignTexture("shadingShiftTexture", extension.shadingShiftTexture, true);
        assignHelper.assignPrimitive("shadingShiftTextureScale", (_a = extension.shadingShiftTexture) == null ? void 0 : _a.scale);
        assignHelper.assignPrimitive("shadingToonyFactor", extension.shadingToonyFactor);
        assignHelper.assignPrimitive("giEqualizationFactor", extension.giEqualizationFactor);
        assignHelper.assignColor("matcapFactor", extension.matcapFactor);
        assignHelper.assignTexture("matcapTexture", extension.matcapTexture, true);
        assignHelper.assignColor("parametricRimColorFactor", extension.parametricRimColorFactor);
        assignHelper.assignTexture("rimMultiplyTexture", extension.rimMultiplyTexture, true);
        assignHelper.assignPrimitive("rimLightingMixFactor", extension.rimLightingMixFactor);
        assignHelper.assignPrimitive("parametricRimFresnelPowerFactor", extension.parametricRimFresnelPowerFactor);
        assignHelper.assignPrimitive("parametricRimLiftFactor", extension.parametricRimLiftFactor);
        assignHelper.assignPrimitive("outlineWidthMode", extension.outlineWidthMode);
        assignHelper.assignPrimitive("outlineWidthFactor", extension.outlineWidthFactor);
        assignHelper.assignTexture("outlineWidthMultiplyTexture", extension.outlineWidthMultiplyTexture, false);
        assignHelper.assignColor("outlineColorFactor", extension.outlineColorFactor);
        assignHelper.assignPrimitive("outlineLightingMixFactor", extension.outlineLightingMixFactor);
        assignHelper.assignTexture("uvAnimationMaskTexture", extension.uvAnimationMaskTexture, false);
        assignHelper.assignPrimitive("uvAnimationScrollXSpeedFactor", extension.uvAnimationScrollXSpeedFactor);
        assignHelper.assignPrimitive("uvAnimationScrollYSpeedFactor", extension.uvAnimationScrollYSpeedFactor);
        assignHelper.assignPrimitive("uvAnimationRotationSpeedFactor", extension.uvAnimationRotationSpeedFactor);
        assignHelper.assignPrimitive("v0CompatShade", this.v0CompatShade);
        assignHelper.assignPrimitive("debugMode", this.debugMode);
        yield assignHelper.pending;
      });
    }
    /**
     * This will do two processes that is required to render MToon properly.
     *
     * - Set render order
     * - Generate outline
     *
     * @param mesh A target GLTF primitive
     * @param materialIndex The material index of the primitive
     */
    _setupPrimitive(mesh, materialIndex) {
      const extension = this._getMToonExtension(materialIndex);
      if (extension) {
        const renderOrder = this._parseRenderOrder(extension);
        mesh.renderOrder = renderOrder + this.renderOrderOffset;
        this._generateOutline(mesh);
        this._addToMaterialSet(mesh);
        return;
      }
    }
    /**
     * Check whether the material should generate outline or not.
     * @param surfaceMaterial The material to check
     * @returns True if the material should generate outline
     */
    _shouldGenerateOutline(surfaceMaterial) {
      return typeof surfaceMaterial.outlineWidthMode === "string" && surfaceMaterial.outlineWidthMode !== "none" && typeof surfaceMaterial.outlineWidthFactor === "number" && surfaceMaterial.outlineWidthFactor > 0;
    }
    /**
     * Generate outline for the given mesh, if it needs.
     *
     * @param mesh The target mesh
     */
    _generateOutline(mesh) {
      const surfaceMaterial = mesh.material;
      if (!(surfaceMaterial instanceof Material)) {
        return;
      }
      if (!this._shouldGenerateOutline(surfaceMaterial)) {
        return;
      }
      mesh.material = [surfaceMaterial];
      const outlineMaterial = surfaceMaterial.clone();
      outlineMaterial.name += " (Outline)";
      outlineMaterial.isOutline = true;
      outlineMaterial.side = BackSide;
      mesh.material.push(outlineMaterial);
      const geometry = mesh.geometry;
      const primitiveVertices = geometry.index ? geometry.index.count : geometry.attributes.position.count / 3;
      geometry.addGroup(0, primitiveVertices, 0);
      geometry.addGroup(0, primitiveVertices, 1);
    }
    _addToMaterialSet(mesh) {
      const materialOrMaterials = mesh.material;
      const materialSet = /* @__PURE__ */ new Set();
      if (Array.isArray(materialOrMaterials)) {
        materialOrMaterials.forEach((material) => materialSet.add(material));
      } else {
        materialSet.add(materialOrMaterials);
      }
      for (const material of materialSet) {
        this._mToonMaterialSet.add(material);
      }
    }
    _parseRenderOrder(extension) {
      var _a;
      const enabledZWrite = extension.transparentWithZWrite;
      return (enabledZWrite ? 0 : 19) + ((_a = extension.renderQueueOffsetNumber) != null ? _a : 0);
    }
  };
  _MToonMaterialLoaderPlugin.EXTENSION_NAME = "VRMC_materials_mtoon";
  var MToonMaterialLoaderPlugin = _MToonMaterialLoaderPlugin;

  // ../three-vrm-materials-hdr-emissive-multiplier/lib/three-vrm-materials-hdr-emissive-multiplier.module.js
  var __async4 = (__this, __arguments, generator) => {
    return new Promise((resolve, reject) => {
      var fulfilled = (value) => {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      };
      var rejected = (value) => {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      };
      var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
      step((generator = generator.apply(__this, __arguments)).next());
    });
  };
  var _VRMMaterialsHDREmissiveMultiplierLoaderPlugin = class _VRMMaterialsHDREmissiveMultiplierLoaderPlugin2 {
    get name() {
      return _VRMMaterialsHDREmissiveMultiplierLoaderPlugin2.EXTENSION_NAME;
    }
    constructor(parser) {
      this.parser = parser;
    }
    extendMaterialParams(materialIndex, materialParams) {
      return __async4(this, null, function* () {
        const extension = this._getHDREmissiveMultiplierExtension(materialIndex);
        if (extension == null) {
          return;
        }
        console.warn(
          "VRMMaterialsHDREmissiveMultiplierLoaderPlugin: `VRMC_materials_hdr_emissiveMultiplier` is archived. Use `KHR_materials_emissive_strength` instead."
        );
        const emissiveMultiplier = extension.emissiveMultiplier;
        materialParams.emissiveIntensity = emissiveMultiplier;
      });
    }
    _getHDREmissiveMultiplierExtension(materialIndex) {
      var _a, _b;
      const parser = this.parser;
      const json = parser.json;
      const materialDef = (_a = json.materials) == null ? void 0 : _a[materialIndex];
      if (materialDef == null) {
        console.warn(
          `VRMMaterialsHDREmissiveMultiplierLoaderPlugin: Attempt to use materials[${materialIndex}] of glTF but the material doesn't exist`
        );
        return void 0;
      }
      const extension = (_b = materialDef.extensions) == null ? void 0 : _b[_VRMMaterialsHDREmissiveMultiplierLoaderPlugin2.EXTENSION_NAME];
      if (extension == null) {
        return void 0;
      }
      return extension;
    }
  };
  _VRMMaterialsHDREmissiveMultiplierLoaderPlugin.EXTENSION_NAME = "VRMC_materials_hdr_emissiveMultiplier";
  var VRMMaterialsHDREmissiveMultiplierLoaderPlugin = _VRMMaterialsHDREmissiveMultiplierLoaderPlugin;
  var __defProp2 = Object.defineProperty;
  var __defProps = Object.defineProperties;
  var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
  var __getOwnPropSymbols2 = Object.getOwnPropertySymbols;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __propIsEnum2 = Object.prototype.propertyIsEnumerable;
  var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues2 = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp2.call(b, prop))
        __defNormalProp2(a, prop, b[prop]);
    if (__getOwnPropSymbols2)
      for (var prop of __getOwnPropSymbols2(b)) {
        if (__propIsEnum2.call(b, prop))
          __defNormalProp2(a, prop, b[prop]);
      }
    return a;
  };
  var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
  var __async5 = (__this, __arguments, generator) => {
    return new Promise((resolve, reject) => {
      var fulfilled = (value) => {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      };
      var rejected = (value) => {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      };
      var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
      step((generator = generator.apply(__this, __arguments)).next());
    });
  };
  function gammaEOTF(e) {
    return Math.pow(e, 2.2);
  }
  var VRMMaterialsV0CompatPlugin = class {
    get name() {
      return "VRMMaterialsV0CompatPlugin";
    }
    constructor(parser) {
      var _a;
      this.parser = parser;
      this._renderQueueMapTransparent = /* @__PURE__ */ new Map();
      this._renderQueueMapTransparentZWrite = /* @__PURE__ */ new Map();
      const json = this.parser.json;
      json.extensionsUsed = (_a = json.extensionsUsed) != null ? _a : [];
      if (json.extensionsUsed.indexOf("KHR_texture_transform") === -1) {
        json.extensionsUsed.push("KHR_texture_transform");
      }
    }
    beforeRoot() {
      return __async5(this, null, function* () {
        var _a;
        const json = this.parser.json;
        const v0VRMExtension = (_a = json.extensions) == null ? void 0 : _a["VRM"];
        const v0MaterialProperties = v0VRMExtension == null ? void 0 : v0VRMExtension.materialProperties;
        if (!v0MaterialProperties) {
          return;
        }
        this._populateRenderQueueMap(v0MaterialProperties);
        v0MaterialProperties.forEach((materialProperties, materialIndex) => {
          var _a2, _b;
          const materialDef = (_a2 = json.materials) == null ? void 0 : _a2[materialIndex];
          if (materialDef == null) {
            console.warn(
              `VRMMaterialsV0CompatPlugin: Attempt to use materials[${materialIndex}] of glTF but the material doesn't exist`
            );
            return;
          }
          if (materialProperties.shader === "VRM/MToon") {
            const material = this._parseV0MToonProperties(materialProperties, materialDef);
            json.materials[materialIndex] = material;
          } else if ((_b = materialProperties.shader) == null ? void 0 : _b.startsWith("VRM/Unlit")) {
            const material = this._parseV0UnlitProperties(materialProperties, materialDef);
            json.materials[materialIndex] = material;
          } else if (materialProperties.shader === "VRM_USE_GLTFSHADER") ; else {
            console.warn(`VRMMaterialsV0CompatPlugin: Unknown shader: ${materialProperties.shader}`);
          }
        });
      });
    }
    _parseV0MToonProperties(materialProperties, schemaMaterial) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _A, _B, _C, _D, _E, _F, _G, _H, _I, _J, _K, _L, _M, _N, _O, _P, _Q, _R, _S, _T, _U, _V, _W, _X, _Y, _Z, __, _$, _aa;
      const isTransparent = (_b = (_a = materialProperties.keywordMap) == null ? void 0 : _a["_ALPHABLEND_ON"]) != null ? _b : false;
      const enabledZWrite = ((_c = materialProperties.floatProperties) == null ? void 0 : _c["_ZWrite"]) === 1;
      const transparentWithZWrite = enabledZWrite && isTransparent;
      const renderQueueOffsetNumber = this._v0ParseRenderQueue(materialProperties);
      const isCutoff = (_e = (_d = materialProperties.keywordMap) == null ? void 0 : _d["_ALPHATEST_ON"]) != null ? _e : false;
      const alphaMode = isTransparent ? "BLEND" : isCutoff ? "MASK" : "OPAQUE";
      const alphaCutoff = isCutoff ? (_g = (_f = materialProperties.floatProperties) == null ? void 0 : _f["_Cutoff"]) != null ? _g : 0.5 : void 0;
      const cullMode = (_i = (_h = materialProperties.floatProperties) == null ? void 0 : _h["_CullMode"]) != null ? _i : 2;
      const doubleSided = cullMode === 0;
      const textureTransformExt = this._portTextureTransform(materialProperties);
      const baseColorFactor = ((_k = (_j = materialProperties.vectorProperties) == null ? void 0 : _j["_Color"]) != null ? _k : [1, 1, 1, 1]).map(
        (v, i) => i === 3 ? v : gammaEOTF(v)
        // alpha channel is stored in linear
      );
      const baseColorTextureIndex = (_l = materialProperties.textureProperties) == null ? void 0 : _l["_MainTex"];
      const baseColorTexture = baseColorTextureIndex != null ? {
        index: baseColorTextureIndex,
        extensions: __spreadValues2({}, textureTransformExt)
      } : void 0;
      const normalTextureScale = (_n = (_m = materialProperties.floatProperties) == null ? void 0 : _m["_BumpScale"]) != null ? _n : 1;
      const normalTextureIndex = (_o = materialProperties.textureProperties) == null ? void 0 : _o["_BumpMap"];
      const normalTexture = normalTextureIndex != null ? {
        index: normalTextureIndex,
        scale: normalTextureScale,
        extensions: __spreadValues2({}, textureTransformExt)
      } : void 0;
      const emissiveFactor = ((_q = (_p = materialProperties.vectorProperties) == null ? void 0 : _p["_EmissionColor"]) != null ? _q : [0, 0, 0, 1]).map(
        gammaEOTF
      );
      const emissiveTextureIndex = (_r = materialProperties.textureProperties) == null ? void 0 : _r["_EmissionMap"];
      const emissiveTexture = emissiveTextureIndex != null ? {
        index: emissiveTextureIndex,
        extensions: __spreadValues2({}, textureTransformExt)
      } : void 0;
      const shadeColorFactor = ((_t = (_s = materialProperties.vectorProperties) == null ? void 0 : _s["_ShadeColor"]) != null ? _t : [0.97, 0.81, 0.86, 1]).map(
        gammaEOTF
      );
      const shadeMultiplyTextureIndex = (_u = materialProperties.textureProperties) == null ? void 0 : _u["_ShadeTexture"];
      const shadeMultiplyTexture = shadeMultiplyTextureIndex != null ? {
        index: shadeMultiplyTextureIndex,
        extensions: __spreadValues2({}, textureTransformExt)
      } : void 0;
      let shadingShiftFactor = (_w = (_v = materialProperties.floatProperties) == null ? void 0 : _v["_ShadeShift"]) != null ? _w : 0;
      let shadingToonyFactor = (_y = (_x = materialProperties.floatProperties) == null ? void 0 : _x["_ShadeToony"]) != null ? _y : 0.9;
      shadingToonyFactor = MathUtils.lerp(shadingToonyFactor, 1, 0.5 + 0.5 * shadingShiftFactor);
      shadingShiftFactor = -shadingShiftFactor - (1 - shadingToonyFactor);
      const giIntensityFactor = (_A = (_z = materialProperties.floatProperties) == null ? void 0 : _z["_IndirectLightIntensity"]) != null ? _A : 0.1;
      const giEqualizationFactor = giIntensityFactor ? 1 - giIntensityFactor : void 0;
      const matcapTextureIndex = (_B = materialProperties.textureProperties) == null ? void 0 : _B["_SphereAdd"];
      const matcapFactor = matcapTextureIndex != null ? [1, 1, 1] : void 0;
      const matcapTexture = matcapTextureIndex != null ? {
        index: matcapTextureIndex
      } : void 0;
      const rimLightingMixFactor = (_D = (_C = materialProperties.floatProperties) == null ? void 0 : _C["_RimLightingMix"]) != null ? _D : 0;
      const rimMultiplyTextureIndex = (_E = materialProperties.textureProperties) == null ? void 0 : _E["_RimTexture"];
      const rimMultiplyTexture = rimMultiplyTextureIndex != null ? {
        index: rimMultiplyTextureIndex,
        extensions: __spreadValues2({}, textureTransformExt)
      } : void 0;
      const parametricRimColorFactor = ((_G = (_F = materialProperties.vectorProperties) == null ? void 0 : _F["_RimColor"]) != null ? _G : [0, 0, 0, 1]).map(
        gammaEOTF
      );
      const parametricRimFresnelPowerFactor = (_I = (_H = materialProperties.floatProperties) == null ? void 0 : _H["_RimFresnelPower"]) != null ? _I : 1;
      const parametricRimLiftFactor = (_K = (_J = materialProperties.floatProperties) == null ? void 0 : _J["_RimLift"]) != null ? _K : 0;
      const outlineWidthMode = ["none", "worldCoordinates", "screenCoordinates"][(_M = (_L = materialProperties.floatProperties) == null ? void 0 : _L["_OutlineWidthMode"]) != null ? _M : 0];
      let outlineWidthFactor = (_O = (_N = materialProperties.floatProperties) == null ? void 0 : _N["_OutlineWidth"]) != null ? _O : 0;
      outlineWidthFactor = 0.01 * outlineWidthFactor;
      const outlineWidthMultiplyTextureIndex = (_P = materialProperties.textureProperties) == null ? void 0 : _P["_OutlineWidthTexture"];
      const outlineWidthMultiplyTexture = outlineWidthMultiplyTextureIndex != null ? {
        index: outlineWidthMultiplyTextureIndex,
        extensions: __spreadValues2({}, textureTransformExt)
      } : void 0;
      const outlineColorFactor = ((_R = (_Q = materialProperties.vectorProperties) == null ? void 0 : _Q["_OutlineColor"]) != null ? _R : [0, 0, 0]).map(
        gammaEOTF
      );
      const outlineColorMode = (_T = (_S = materialProperties.floatProperties) == null ? void 0 : _S["_OutlineColorMode"]) != null ? _T : 0;
      const outlineLightingMixFactor = outlineColorMode === 1 ? (_V = (_U = materialProperties.floatProperties) == null ? void 0 : _U["_OutlineLightingMix"]) != null ? _V : 1 : 0;
      const uvAnimationMaskTextureIndex = (_W = materialProperties.textureProperties) == null ? void 0 : _W["_UvAnimMaskTexture"];
      const uvAnimationMaskTexture = uvAnimationMaskTextureIndex != null ? {
        index: uvAnimationMaskTextureIndex,
        extensions: __spreadValues2({}, textureTransformExt)
      } : void 0;
      const uvAnimationScrollXSpeedFactor = (_Y = (_X = materialProperties.floatProperties) == null ? void 0 : _X["_UvAnimScrollX"]) != null ? _Y : 0;
      let uvAnimationScrollYSpeedFactor = (__ = (_Z = materialProperties.floatProperties) == null ? void 0 : _Z["_UvAnimScrollY"]) != null ? __ : 0;
      if (uvAnimationScrollYSpeedFactor != null) {
        uvAnimationScrollYSpeedFactor = -uvAnimationScrollYSpeedFactor;
      }
      const uvAnimationRotationSpeedFactor = (_aa = (_$ = materialProperties.floatProperties) == null ? void 0 : _$["_UvAnimRotation"]) != null ? _aa : 0;
      const mtoonExtension = {
        specVersion: "1.0",
        transparentWithZWrite,
        renderQueueOffsetNumber,
        shadeColorFactor,
        shadeMultiplyTexture,
        shadingShiftFactor,
        shadingToonyFactor,
        giEqualizationFactor,
        matcapFactor,
        matcapTexture,
        rimLightingMixFactor,
        rimMultiplyTexture,
        parametricRimColorFactor,
        parametricRimFresnelPowerFactor,
        parametricRimLiftFactor,
        outlineWidthMode,
        outlineWidthFactor,
        outlineWidthMultiplyTexture,
        outlineColorFactor,
        outlineLightingMixFactor,
        uvAnimationMaskTexture,
        uvAnimationScrollXSpeedFactor,
        uvAnimationScrollYSpeedFactor,
        uvAnimationRotationSpeedFactor
      };
      return __spreadProps(__spreadValues2({}, schemaMaterial), {
        pbrMetallicRoughness: {
          baseColorFactor,
          baseColorTexture
        },
        normalTexture,
        emissiveTexture,
        emissiveFactor,
        alphaMode,
        alphaCutoff,
        doubleSided,
        extensions: {
          // eslint-disable-next-line @typescript-eslint/naming-convention
          VRMC_materials_mtoon: mtoonExtension
        }
      });
    }
    _parseV0UnlitProperties(materialProperties, schemaMaterial) {
      var _a, _b, _c, _d, _e;
      const isTransparentZWrite = materialProperties.shader === "VRM/UnlitTransparentZWrite";
      const isTransparent = materialProperties.shader === "VRM/UnlitTransparent" || isTransparentZWrite;
      const renderQueueOffsetNumber = this._v0ParseRenderQueue(materialProperties);
      const isCutoff = materialProperties.shader === "VRM/UnlitCutout";
      const alphaMode = isTransparent ? "BLEND" : isCutoff ? "MASK" : "OPAQUE";
      const alphaCutoff = isCutoff ? (_b = (_a = materialProperties.floatProperties) == null ? void 0 : _a["_Cutoff"]) != null ? _b : 0.5 : void 0;
      const textureTransformExt = this._portTextureTransform(materialProperties);
      const baseColorFactor = ((_d = (_c = materialProperties.vectorProperties) == null ? void 0 : _c["_Color"]) != null ? _d : [1, 1, 1, 1]).map(gammaEOTF);
      const baseColorTextureIndex = (_e = materialProperties.textureProperties) == null ? void 0 : _e["_MainTex"];
      const baseColorTexture = baseColorTextureIndex != null ? {
        index: baseColorTextureIndex,
        extensions: __spreadValues2({}, textureTransformExt)
      } : void 0;
      const mtoonExtension = {
        specVersion: "1.0",
        transparentWithZWrite: isTransparentZWrite,
        renderQueueOffsetNumber,
        shadeColorFactor: baseColorFactor,
        shadeMultiplyTexture: baseColorTexture
      };
      return __spreadProps(__spreadValues2({}, schemaMaterial), {
        pbrMetallicRoughness: {
          baseColorFactor,
          baseColorTexture
        },
        alphaMode,
        alphaCutoff,
        extensions: {
          // eslint-disable-next-line @typescript-eslint/naming-convention
          VRMC_materials_mtoon: mtoonExtension
        }
      });
    }
    /**
     * Create a glTF `KHR_texture_transform` extension from v0 texture transform info.
     */
    _portTextureTransform(materialProperties) {
      var _a, _b, _c, _d, _e;
      const textureTransform = (_a = materialProperties.vectorProperties) == null ? void 0 : _a["_MainTex"];
      if (textureTransform == null) {
        return {};
      }
      const offset = [(_b = textureTransform == null ? void 0 : textureTransform[0]) != null ? _b : 0, (_c = textureTransform == null ? void 0 : textureTransform[1]) != null ? _c : 0];
      const scale = [(_d = textureTransform == null ? void 0 : textureTransform[2]) != null ? _d : 1, (_e = textureTransform == null ? void 0 : textureTransform[3]) != null ? _e : 1];
      offset[1] = 1 - scale[1] - offset[1];
      return {
        // eslint-disable-next-line @typescript-eslint/naming-convention
        KHR_texture_transform: { offset, scale }
      };
    }
    /**
     * Convert v0 render order into v1 render order.
     * This uses a map from v0 render queue to v1 compliant render queue offset which is generated in {@link _populateRenderQueueMap}.
     */
    _v0ParseRenderQueue(materialProperties) {
      var _a, _b;
      const isTransparentZWrite = materialProperties.shader === "VRM/UnlitTransparentZWrite";
      const isTransparent = ((_a = materialProperties.keywordMap) == null ? void 0 : _a["_ALPHABLEND_ON"]) != void 0 || materialProperties.shader === "VRM/UnlitTransparent" || isTransparentZWrite;
      const enabledZWrite = ((_b = materialProperties.floatProperties) == null ? void 0 : _b["_ZWrite"]) === 1 || isTransparentZWrite;
      let offset = 0;
      if (isTransparent) {
        const v0Queue = materialProperties.renderQueue;
        if (v0Queue != null) {
          if (enabledZWrite) {
            offset = this._renderQueueMapTransparentZWrite.get(v0Queue);
          } else {
            offset = this._renderQueueMapTransparent.get(v0Queue);
          }
        }
      }
      return offset;
    }
    /**
     * Create a map which maps v0 render queue to v1 compliant render queue offset.
     * This lists up all render queues the model use and creates a map to new render queue offsets in the same order.
     */
    _populateRenderQueueMap(materialPropertiesList) {
      const renderQueuesTransparent = /* @__PURE__ */ new Set();
      const renderQueuesTransparentZWrite = /* @__PURE__ */ new Set();
      materialPropertiesList.forEach((materialProperties) => {
        var _a, _b;
        const isTransparentZWrite = materialProperties.shader === "VRM/UnlitTransparentZWrite";
        const isTransparent = ((_a = materialProperties.keywordMap) == null ? void 0 : _a["_ALPHABLEND_ON"]) != void 0 || materialProperties.shader === "VRM/UnlitTransparent" || isTransparentZWrite;
        const enabledZWrite = ((_b = materialProperties.floatProperties) == null ? void 0 : _b["_ZWrite"]) === 1 || isTransparentZWrite;
        if (isTransparent) {
          const v0Queue = materialProperties.renderQueue;
          if (v0Queue != null) {
            if (enabledZWrite) {
              renderQueuesTransparentZWrite.add(v0Queue);
            } else {
              renderQueuesTransparent.add(v0Queue);
            }
          }
        }
      });
      if (renderQueuesTransparent.size > 10) {
        console.warn(
          `VRMMaterialsV0CompatPlugin: This VRM uses ${renderQueuesTransparent.size} render queues for Transparent materials while VRM 1.0 only supports up to 10 render queues. The model might not be rendered correctly.`
        );
      }
      if (renderQueuesTransparentZWrite.size > 10) {
        console.warn(
          `VRMMaterialsV0CompatPlugin: This VRM uses ${renderQueuesTransparentZWrite.size} render queues for TransparentZWrite materials while VRM 1.0 only supports up to 10 render queues. The model might not be rendered correctly.`
        );
      }
      Array.from(renderQueuesTransparent).sort().forEach((queue, i) => {
        const newQueueOffset = Math.min(Math.max(i - renderQueuesTransparent.size + 1, -9), 0);
        this._renderQueueMapTransparent.set(queue, newQueueOffset);
      });
      Array.from(renderQueuesTransparentZWrite).sort().forEach((queue, i) => {
        const newQueueOffset = Math.min(Math.max(i, 0), 9);
        this._renderQueueMapTransparentZWrite.set(queue, newQueueOffset);
      });
    }
  };
  var __async6 = (__this, __arguments, generator) => {
    return new Promise((resolve, reject) => {
      var fulfilled = (value) => {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      };
      var rejected = (value) => {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      };
      var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
      step((generator = generator.apply(__this, __arguments)).next());
    });
  };
  var _v3A6 = new Vector3();
  var VRMNodeConstraintHelper = class extends Group {
    constructor(constraint) {
      super();
      this._attrPosition = new BufferAttribute(new Float32Array([0, 0, 0, 0, 0, 0]), 3);
      this._attrPosition.setUsage(DynamicDrawUsage);
      const geometry = new BufferGeometry();
      geometry.setAttribute("position", this._attrPosition);
      const material = new LineBasicMaterial({
        color: 16711935,
        depthTest: false,
        depthWrite: false
      });
      this._line = new Line(geometry, material);
      this.add(this._line);
      this.constraint = constraint;
    }
    updateMatrixWorld(force) {
      _v3A6.setFromMatrixPosition(this.constraint.destination.matrixWorld);
      this._attrPosition.setXYZ(0, _v3A6.x, _v3A6.y, _v3A6.z);
      if (this.constraint.source) {
        _v3A6.setFromMatrixPosition(this.constraint.source.matrixWorld);
      }
      this._attrPosition.setXYZ(1, _v3A6.x, _v3A6.y, _v3A6.z);
      this._attrPosition.needsUpdate = true;
      super.updateMatrixWorld(force);
    }
  };
  function decomposePosition(matrix, target) {
    return target.set(matrix.elements[12], matrix.elements[13], matrix.elements[14]);
  }
  var _v3A22 = new Vector3();
  var _v3B4 = new Vector3();
  function decomposeRotation(matrix, target) {
    matrix.decompose(_v3A22, target, _v3B4);
    return target;
  }
  function quatInvertCompat2(target) {
    if (target.invert) {
      target.invert();
    } else {
      target.inverse();
    }
    return target;
  }
  var VRMNodeConstraint = class {
    /**
     * @param destination The destination object
     * @param source The source object
     */
    constructor(destination, source) {
      this.destination = destination;
      this.source = source;
      this.weight = 1;
    }
  };
  var _v3A32 = new Vector3();
  var _v3B22 = new Vector3();
  var _v3C2 = new Vector3();
  var _quatA7 = new Quaternion();
  var _quatB4 = new Quaternion();
  var _quatC2 = new Quaternion();
  var VRMAimConstraint = class extends VRMNodeConstraint {
    /**
     * The aim axis of the constraint.
     */
    get aimAxis() {
      return this._aimAxis;
    }
    /**
     * The aim axis of the constraint.
     */
    set aimAxis(aimAxis) {
      this._aimAxis = aimAxis;
      this._v3AimAxis.set(
        aimAxis === "PositiveX" ? 1 : aimAxis === "NegativeX" ? -1 : 0,
        aimAxis === "PositiveY" ? 1 : aimAxis === "NegativeY" ? -1 : 0,
        aimAxis === "PositiveZ" ? 1 : aimAxis === "NegativeZ" ? -1 : 0
      );
    }
    get dependencies() {
      const set = /* @__PURE__ */ new Set([this.source]);
      if (this.destination.parent) {
        set.add(this.destination.parent);
      }
      return set;
    }
    constructor(destination, source) {
      super(destination, source);
      this._aimAxis = "PositiveX";
      this._v3AimAxis = new Vector3(1, 0, 0);
      this._dstRestQuat = new Quaternion();
    }
    setInitState() {
      this._dstRestQuat.copy(this.destination.quaternion);
    }
    update() {
      this.destination.updateWorldMatrix(true, false);
      this.source.updateWorldMatrix(true, false);
      const dstParentWorldQuat = _quatA7.identity();
      const invDstParentWorldQuat = _quatB4.identity();
      if (this.destination.parent) {
        decomposeRotation(this.destination.parent.matrixWorld, dstParentWorldQuat);
        quatInvertCompat2(invDstParentWorldQuat.copy(dstParentWorldQuat));
      }
      const a0 = _v3A32.copy(this._v3AimAxis).applyQuaternion(this._dstRestQuat).applyQuaternion(dstParentWorldQuat);
      const a1 = decomposePosition(this.source.matrixWorld, _v3B22).sub(decomposePosition(this.destination.matrixWorld, _v3C2)).normalize();
      const targetQuat = _quatC2.setFromUnitVectors(a0, a1).premultiply(invDstParentWorldQuat).multiply(dstParentWorldQuat).multiply(this._dstRestQuat);
      this.destination.quaternion.copy(this._dstRestQuat).slerp(targetQuat, this.weight);
    }
  };
  function traverseAncestorsFromRoot(object, callback) {
    const ancestors = [object];
    let head = object.parent;
    while (head !== null) {
      ancestors.unshift(head);
      head = head.parent;
    }
    ancestors.forEach((ancestor) => {
      callback(ancestor);
    });
  }
  var VRMNodeConstraintManager = class {
    constructor() {
      this._constraints = /* @__PURE__ */ new Set();
      this._objectConstraintsMap = /* @__PURE__ */ new Map();
    }
    get constraints() {
      return this._constraints;
    }
    addConstraint(constraint) {
      this._constraints.add(constraint);
      let objectSet = this._objectConstraintsMap.get(constraint.destination);
      if (objectSet == null) {
        objectSet = /* @__PURE__ */ new Set();
        this._objectConstraintsMap.set(constraint.destination, objectSet);
      }
      objectSet.add(constraint);
    }
    deleteConstraint(constraint) {
      this._constraints.delete(constraint);
      const objectSet = this._objectConstraintsMap.get(constraint.destination);
      objectSet.delete(constraint);
    }
    setInitState() {
      const constraintsTried = /* @__PURE__ */ new Set();
      const constraintsDone = /* @__PURE__ */ new Set();
      for (const constraint of this._constraints) {
        this._processConstraint(constraint, constraintsTried, constraintsDone, (constraint2) => constraint2.setInitState());
      }
    }
    update() {
      const constraintsTried = /* @__PURE__ */ new Set();
      const constraintsDone = /* @__PURE__ */ new Set();
      for (const constraint of this._constraints) {
        this._processConstraint(constraint, constraintsTried, constraintsDone, (constraint2) => constraint2.update());
      }
    }
    /**
     * Update a constraint.
     * If there are other constraints that are dependant, it will try to update them recursively.
     * It might throw an error if there are circular dependencies.
     *
     * Intended to be used in {@link update} and {@link _processConstraint} itself recursively.
     *
     * @param constraint A constraint you want to update
     * @param constraintsTried Set of constraints that are already tried to be updated
     * @param constraintsDone Set of constraints that are already up to date
     */
    _processConstraint(constraint, constraintsTried, constraintsDone, callback) {
      if (constraintsDone.has(constraint)) {
        return;
      }
      if (constraintsTried.has(constraint)) {
        throw new Error("VRMNodeConstraintManager: Circular dependency detected while updating constraints");
      }
      constraintsTried.add(constraint);
      const depObjects = constraint.dependencies;
      for (const depObject of depObjects) {
        traverseAncestorsFromRoot(depObject, (depObjectAncestor) => {
          const objectSet = this._objectConstraintsMap.get(depObjectAncestor);
          if (objectSet) {
            for (const depConstraint of objectSet) {
              this._processConstraint(depConstraint, constraintsTried, constraintsDone, callback);
            }
          }
        });
      }
      callback(constraint);
      constraintsDone.add(constraint);
    }
  };
  var _quatA22 = new Quaternion();
  var _quatB22 = new Quaternion();
  var VRMRotationConstraint = class extends VRMNodeConstraint {
    get dependencies() {
      return /* @__PURE__ */ new Set([this.source]);
    }
    constructor(destination, source) {
      super(destination, source);
      this._dstRestQuat = new Quaternion();
      this._invSrcRestQuat = new Quaternion();
    }
    setInitState() {
      this._dstRestQuat.copy(this.destination.quaternion);
      quatInvertCompat2(this._invSrcRestQuat.copy(this.source.quaternion));
    }
    update() {
      const srcDeltaQuat = _quatA22.copy(this._invSrcRestQuat).multiply(this.source.quaternion);
      const targetQuat = _quatB22.copy(this._dstRestQuat).multiply(srcDeltaQuat);
      this.destination.quaternion.copy(this._dstRestQuat).slerp(targetQuat, this.weight);
    }
  };
  var _v3A42 = new Vector3();
  var _quatA32 = new Quaternion();
  var _quatB32 = new Quaternion();
  var VRMRollConstraint = class extends VRMNodeConstraint {
    /**
     * The roll axis of the constraint.
     */
    get rollAxis() {
      return this._rollAxis;
    }
    /**
     * The roll axis of the constraint.
     */
    set rollAxis(rollAxis) {
      this._rollAxis = rollAxis;
      this._v3RollAxis.set(rollAxis === "X" ? 1 : 0, rollAxis === "Y" ? 1 : 0, rollAxis === "Z" ? 1 : 0);
    }
    get dependencies() {
      return /* @__PURE__ */ new Set([this.source]);
    }
    constructor(destination, source) {
      super(destination, source);
      this._rollAxis = "X";
      this._v3RollAxis = new Vector3(1, 0, 0);
      this._dstRestQuat = new Quaternion();
      this._invDstRestQuat = new Quaternion();
      this._invSrcRestQuatMulDstRestQuat = new Quaternion();
    }
    setInitState() {
      this._dstRestQuat.copy(this.destination.quaternion);
      quatInvertCompat2(this._invDstRestQuat.copy(this._dstRestQuat));
      quatInvertCompat2(this._invSrcRestQuatMulDstRestQuat.copy(this.source.quaternion)).multiply(this._dstRestQuat);
    }
    update() {
      const quatDelta = _quatA32.copy(this._invDstRestQuat).multiply(this.source.quaternion).multiply(this._invSrcRestQuatMulDstRestQuat);
      const n1 = _v3A42.copy(this._v3RollAxis).applyQuaternion(quatDelta);
      const quatFromTo = _quatB32.setFromUnitVectors(n1, this._v3RollAxis);
      const targetQuat = quatFromTo.premultiply(this._dstRestQuat).multiply(quatDelta);
      this.destination.quaternion.copy(this._dstRestQuat).slerp(targetQuat, this.weight);
    }
  };
  var POSSIBLE_SPEC_VERSIONS7 = /* @__PURE__ */ new Set(["1.0", "1.0-beta"]);
  var _VRMNodeConstraintLoaderPlugin = class _VRMNodeConstraintLoaderPlugin2 {
    get name() {
      return _VRMNodeConstraintLoaderPlugin2.EXTENSION_NAME;
    }
    constructor(parser, options) {
      this.parser = parser;
      this.helperRoot = options == null ? void 0 : options.helperRoot;
    }
    afterRoot(gltf) {
      return __async6(this, null, function* () {
        gltf.userData.vrmNodeConstraintManager = yield this._import(gltf);
      });
    }
    /**
     * Import constraints from a GLTF and returns a {@link VRMNodeConstraintManager}.
     * It might return `null` instead when it does not need to be created or something go wrong.
     *
     * @param gltf A parsed result of GLTF taken from GLTFLoader
     */
    _import(gltf) {
      return __async6(this, null, function* () {
        var _a;
        const json = this.parser.json;
        const isConstraintsUsed = ((_a = json.extensionsUsed) == null ? void 0 : _a.indexOf(_VRMNodeConstraintLoaderPlugin2.EXTENSION_NAME)) !== -1;
        if (!isConstraintsUsed) {
          return null;
        }
        const manager = new VRMNodeConstraintManager();
        const threeNodes = yield this.parser.getDependencies("node");
        threeNodes.forEach((node, nodeIndex) => {
          var _a2;
          const schemaNode = json.nodes[nodeIndex];
          const extension = (_a2 = schemaNode == null ? void 0 : schemaNode.extensions) == null ? void 0 : _a2[_VRMNodeConstraintLoaderPlugin2.EXTENSION_NAME];
          if (extension == null) {
            return;
          }
          const specVersion = extension.specVersion;
          if (!POSSIBLE_SPEC_VERSIONS7.has(specVersion)) {
            console.warn(
              `VRMNodeConstraintLoaderPlugin: Unknown ${_VRMNodeConstraintLoaderPlugin2.EXTENSION_NAME} specVersion "${specVersion}"`
            );
            return;
          }
          const constraintDef = extension.constraint;
          if (constraintDef.roll != null) {
            const constraint = this._importRollConstraint(node, threeNodes, constraintDef.roll);
            manager.addConstraint(constraint);
          } else if (constraintDef.aim != null) {
            const constraint = this._importAimConstraint(node, threeNodes, constraintDef.aim);
            manager.addConstraint(constraint);
          } else if (constraintDef.rotation != null) {
            const constraint = this._importRotationConstraint(node, threeNodes, constraintDef.rotation);
            manager.addConstraint(constraint);
          }
        });
        gltf.scene.updateMatrixWorld();
        manager.setInitState();
        return manager;
      });
    }
    _importRollConstraint(destination, nodes, rollConstraintDef) {
      const { source: sourceIndex, rollAxis, weight } = rollConstraintDef;
      const source = nodes[sourceIndex];
      const constraint = new VRMRollConstraint(destination, source);
      if (rollAxis != null) {
        constraint.rollAxis = rollAxis;
      }
      if (weight != null) {
        constraint.weight = weight;
      }
      if (this.helperRoot) {
        const helper = new VRMNodeConstraintHelper(constraint);
        this.helperRoot.add(helper);
      }
      return constraint;
    }
    _importAimConstraint(destination, nodes, aimConstraintDef) {
      const { source: sourceIndex, aimAxis, weight } = aimConstraintDef;
      const source = nodes[sourceIndex];
      const constraint = new VRMAimConstraint(destination, source);
      if (aimAxis != null) {
        constraint.aimAxis = aimAxis;
      }
      if (weight != null) {
        constraint.weight = weight;
      }
      if (this.helperRoot) {
        const helper = new VRMNodeConstraintHelper(constraint);
        this.helperRoot.add(helper);
      }
      return constraint;
    }
    _importRotationConstraint(destination, nodes, rotationConstraintDef) {
      const { source: sourceIndex, weight } = rotationConstraintDef;
      const source = nodes[sourceIndex];
      const constraint = new VRMRotationConstraint(destination, source);
      if (weight != null) {
        constraint.weight = weight;
      }
      if (this.helperRoot) {
        const helper = new VRMNodeConstraintHelper(constraint);
        this.helperRoot.add(helper);
      }
      return constraint;
    }
  };
  _VRMNodeConstraintLoaderPlugin.EXTENSION_NAME = "VRMC_node_constraint";
  var VRMNodeConstraintLoaderPlugin = _VRMNodeConstraintLoaderPlugin;
  var __async7 = (__this, __arguments, generator) => {
    return new Promise((resolve, reject) => {
      var fulfilled = (value) => {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      };
      var rejected = (value) => {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      };
      var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
      step((generator = generator.apply(__this, __arguments)).next());
    });
  };
  var VRMSpringBoneColliderShape = class {
  };
  var _v3A7 = new Vector3();
  var _v3B5 = new Vector3();
  var VRMSpringBoneColliderShapeCapsule = class extends VRMSpringBoneColliderShape {
    get type() {
      return "capsule";
    }
    constructor(params) {
      var _a, _b, _c, _d;
      super();
      this.offset = (_a = params == null ? void 0 : params.offset) != null ? _a : new Vector3(0, 0, 0);
      this.tail = (_b = params == null ? void 0 : params.tail) != null ? _b : new Vector3(0, 0, 0);
      this.radius = (_c = params == null ? void 0 : params.radius) != null ? _c : 0;
      this.inside = (_d = params == null ? void 0 : params.inside) != null ? _d : false;
    }
    calculateCollision(colliderMatrix, objectPosition, objectRadius, target) {
      _v3A7.copy(this.offset).applyMatrix4(colliderMatrix);
      _v3B5.copy(this.tail).applyMatrix4(colliderMatrix);
      _v3B5.sub(_v3A7);
      const lengthSqCapsule = _v3B5.lengthSq();
      target.copy(objectPosition).sub(_v3A7);
      const dot = _v3B5.dot(target);
      if (dot <= 0) ; else if (lengthSqCapsule <= dot) {
        target.sub(_v3B5);
      } else {
        _v3B5.multiplyScalar(dot / lengthSqCapsule);
        target.sub(_v3B5);
      }
      const distance = this.inside ? this.radius - objectRadius - target.length() : target.length() - objectRadius - this.radius;
      target.normalize();
      if (this.inside) {
        target.negate();
      }
      return distance;
    }
  };
  var _v3A23 = new Vector3();
  var _mat3A = new Matrix3();
  var VRMSpringBoneColliderShapePlane = class extends VRMSpringBoneColliderShape {
    get type() {
      return "plane";
    }
    constructor(params) {
      var _a, _b;
      super();
      this.offset = (_a = params == null ? void 0 : params.offset) != null ? _a : new Vector3(0, 0, 0);
      this.normal = (_b = params == null ? void 0 : params.normal) != null ? _b : new Vector3(0, 0, 1);
    }
    calculateCollision(colliderMatrix, objectPosition, objectRadius, target) {
      target.copy(this.offset).applyMatrix4(colliderMatrix);
      target.negate().add(objectPosition);
      _mat3A.getNormalMatrix(colliderMatrix);
      _v3A23.copy(this.normal).applyNormalMatrix(_mat3A).normalize();
      const distance = target.dot(_v3A23) - objectRadius;
      target.copy(_v3A23);
      return distance;
    }
  };
  var VRMSpringBoneColliderShapeSphere = class extends VRMSpringBoneColliderShape {
    get type() {
      return "sphere";
    }
    constructor(params) {
      var _a, _b, _c;
      super();
      this.offset = (_a = params == null ? void 0 : params.offset) != null ? _a : new Vector3(0, 0, 0);
      this.radius = (_b = params == null ? void 0 : params.radius) != null ? _b : 0;
      this.inside = (_c = params == null ? void 0 : params.inside) != null ? _c : false;
    }
    calculateCollision(colliderMatrix, objectPosition, objectRadius, target) {
      target.copy(this.offset).applyMatrix4(colliderMatrix);
      target.negate().add(objectPosition);
      const distance = this.inside ? this.radius - objectRadius - target.length() : target.length() - objectRadius - this.radius;
      target.normalize();
      if (this.inside) {
        target.negate();
      }
      return distance;
    }
  };
  var _v3A33 = new Vector3();
  var ColliderShapeCapsuleBufferGeometry = class extends BufferGeometry {
    constructor(shape) {
      super();
      this.worldScale = 1;
      this._currentRadius = 0;
      this._currentOffset = new Vector3();
      this._currentTail = new Vector3();
      this._shape = shape;
      this._attrPos = new BufferAttribute(new Float32Array(396), 3);
      this.setAttribute("position", this._attrPos);
      this._attrIndex = new BufferAttribute(new Uint16Array(264), 1);
      this.setIndex(this._attrIndex);
      this._buildIndex();
      this.update();
    }
    update() {
      let shouldUpdateGeometry = false;
      const radius = this._shape.radius / this.worldScale;
      if (this._currentRadius !== radius) {
        this._currentRadius = radius;
        shouldUpdateGeometry = true;
      }
      if (!this._currentOffset.equals(this._shape.offset)) {
        this._currentOffset.copy(this._shape.offset);
        shouldUpdateGeometry = true;
      }
      const tail = _v3A33.copy(this._shape.tail).divideScalar(this.worldScale);
      if (this._currentTail.distanceToSquared(tail) > 1e-10) {
        this._currentTail.copy(tail);
        shouldUpdateGeometry = true;
      }
      if (shouldUpdateGeometry) {
        this._buildPosition();
      }
    }
    _buildPosition() {
      _v3A33.copy(this._currentTail).sub(this._currentOffset);
      const l = _v3A33.length() / this._currentRadius;
      for (let i = 0; i <= 16; i++) {
        const t = i / 16 * Math.PI;
        this._attrPos.setXYZ(i, -Math.sin(t), -Math.cos(t), 0);
        this._attrPos.setXYZ(17 + i, l + Math.sin(t), Math.cos(t), 0);
        this._attrPos.setXYZ(34 + i, -Math.sin(t), 0, -Math.cos(t));
        this._attrPos.setXYZ(51 + i, l + Math.sin(t), 0, Math.cos(t));
      }
      for (let i = 0; i < 32; i++) {
        const t = i / 16 * Math.PI;
        this._attrPos.setXYZ(68 + i, 0, Math.sin(t), Math.cos(t));
        this._attrPos.setXYZ(100 + i, l, Math.sin(t), Math.cos(t));
      }
      const theta = Math.atan2(_v3A33.y, Math.sqrt(_v3A33.x * _v3A33.x + _v3A33.z * _v3A33.z));
      const phi = -Math.atan2(_v3A33.z, _v3A33.x);
      this.rotateZ(theta);
      this.rotateY(phi);
      this.scale(this._currentRadius, this._currentRadius, this._currentRadius);
      this.translate(this._currentOffset.x, this._currentOffset.y, this._currentOffset.z);
      this._attrPos.needsUpdate = true;
    }
    _buildIndex() {
      for (let i = 0; i < 34; i++) {
        const i1 = (i + 1) % 34;
        this._attrIndex.setXY(i * 2, i, i1);
        this._attrIndex.setXY(68 + i * 2, 34 + i, 34 + i1);
      }
      for (let i = 0; i < 32; i++) {
        const i1 = (i + 1) % 32;
        this._attrIndex.setXY(136 + i * 2, 68 + i, 68 + i1);
        this._attrIndex.setXY(200 + i * 2, 100 + i, 100 + i1);
      }
      this._attrIndex.needsUpdate = true;
    }
  };
  var ColliderShapePlaneBufferGeometry = class extends BufferGeometry {
    constructor(shape) {
      super();
      this.worldScale = 1;
      this._currentOffset = new Vector3();
      this._currentNormal = new Vector3();
      this._shape = shape;
      this._attrPos = new BufferAttribute(new Float32Array(6 * 3), 3);
      this.setAttribute("position", this._attrPos);
      this._attrIndex = new BufferAttribute(new Uint16Array(10), 1);
      this.setIndex(this._attrIndex);
      this._buildIndex();
      this.update();
    }
    update() {
      let shouldUpdateGeometry = false;
      if (!this._currentOffset.equals(this._shape.offset)) {
        this._currentOffset.copy(this._shape.offset);
        shouldUpdateGeometry = true;
      }
      if (!this._currentNormal.equals(this._shape.normal)) {
        this._currentNormal.copy(this._shape.normal);
        shouldUpdateGeometry = true;
      }
      if (shouldUpdateGeometry) {
        this._buildPosition();
      }
    }
    _buildPosition() {
      this._attrPos.setXYZ(0, -0.5, -0.5, 0);
      this._attrPos.setXYZ(1, 0.5, -0.5, 0);
      this._attrPos.setXYZ(2, 0.5, 0.5, 0);
      this._attrPos.setXYZ(3, -0.5, 0.5, 0);
      this._attrPos.setXYZ(4, 0, 0, 0);
      this._attrPos.setXYZ(5, 0, 0, 0.25);
      this.translate(this._currentOffset.x, this._currentOffset.y, this._currentOffset.z);
      this.lookAt(this._currentNormal);
      this._attrPos.needsUpdate = true;
    }
    _buildIndex() {
      this._attrIndex.setXY(0, 0, 1);
      this._attrIndex.setXY(2, 1, 2);
      this._attrIndex.setXY(4, 2, 3);
      this._attrIndex.setXY(6, 3, 0);
      this._attrIndex.setXY(8, 4, 5);
      this._attrIndex.needsUpdate = true;
    }
  };
  var ColliderShapeSphereBufferGeometry = class extends BufferGeometry {
    constructor(shape) {
      super();
      this.worldScale = 1;
      this._currentRadius = 0;
      this._currentOffset = new Vector3();
      this._shape = shape;
      this._attrPos = new BufferAttribute(new Float32Array(32 * 3 * 3), 3);
      this.setAttribute("position", this._attrPos);
      this._attrIndex = new BufferAttribute(new Uint16Array(64 * 3), 1);
      this.setIndex(this._attrIndex);
      this._buildIndex();
      this.update();
    }
    update() {
      let shouldUpdateGeometry = false;
      const radius = this._shape.radius / this.worldScale;
      if (this._currentRadius !== radius) {
        this._currentRadius = radius;
        shouldUpdateGeometry = true;
      }
      if (!this._currentOffset.equals(this._shape.offset)) {
        this._currentOffset.copy(this._shape.offset);
        shouldUpdateGeometry = true;
      }
      if (shouldUpdateGeometry) {
        this._buildPosition();
      }
    }
    _buildPosition() {
      for (let i = 0; i < 32; i++) {
        const t = i / 16 * Math.PI;
        this._attrPos.setXYZ(i, Math.cos(t), Math.sin(t), 0);
        this._attrPos.setXYZ(32 + i, 0, Math.cos(t), Math.sin(t));
        this._attrPos.setXYZ(64 + i, Math.sin(t), 0, Math.cos(t));
      }
      this.scale(this._currentRadius, this._currentRadius, this._currentRadius);
      this.translate(this._currentOffset.x, this._currentOffset.y, this._currentOffset.z);
      this._attrPos.needsUpdate = true;
    }
    _buildIndex() {
      for (let i = 0; i < 32; i++) {
        const i1 = (i + 1) % 32;
        this._attrIndex.setXY(i * 2, i, i1);
        this._attrIndex.setXY(64 + i * 2, 32 + i, 32 + i1);
        this._attrIndex.setXY(128 + i * 2, 64 + i, 64 + i1);
      }
      this._attrIndex.needsUpdate = true;
    }
  };
  var _v3A43 = new Vector3();
  var VRMSpringBoneColliderHelper = class extends Group {
    constructor(collider) {
      super();
      this.matrixAutoUpdate = false;
      this.collider = collider;
      if (this.collider.shape instanceof VRMSpringBoneColliderShapeSphere) {
        this._geometry = new ColliderShapeSphereBufferGeometry(this.collider.shape);
      } else if (this.collider.shape instanceof VRMSpringBoneColliderShapeCapsule) {
        this._geometry = new ColliderShapeCapsuleBufferGeometry(this.collider.shape);
      } else if (this.collider.shape instanceof VRMSpringBoneColliderShapePlane) {
        this._geometry = new ColliderShapePlaneBufferGeometry(this.collider.shape);
      } else {
        throw new Error("VRMSpringBoneColliderHelper: Unknown collider shape type detected");
      }
      const material = new LineBasicMaterial({
        color: 16711935,
        depthTest: false,
        depthWrite: false
      });
      this._line = new LineSegments(this._geometry, material);
      this.add(this._line);
    }
    dispose() {
      this._geometry.dispose();
    }
    updateMatrixWorld(force) {
      this.collider.updateWorldMatrix(true, false);
      this.matrix.copy(this.collider.matrixWorld);
      const matrixWorldElements = this.matrix.elements;
      this._geometry.worldScale = _v3A43.set(matrixWorldElements[0], matrixWorldElements[1], matrixWorldElements[2]).length();
      this._geometry.update();
      super.updateMatrixWorld(force);
    }
  };
  var SpringBoneBufferGeometry = class extends BufferGeometry {
    constructor(springBone) {
      super();
      this.worldScale = 1;
      this._currentRadius = 0;
      this._currentTail = new Vector3();
      this._springBone = springBone;
      this._attrPos = new BufferAttribute(new Float32Array(294), 3);
      this.setAttribute("position", this._attrPos);
      this._attrIndex = new BufferAttribute(new Uint16Array(194), 1);
      this.setIndex(this._attrIndex);
      this._buildIndex();
      this.update();
    }
    update() {
      let shouldUpdateGeometry = false;
      const radius = this._springBone.settings.hitRadius / this.worldScale;
      if (this._currentRadius !== radius) {
        this._currentRadius = radius;
        shouldUpdateGeometry = true;
      }
      if (!this._currentTail.equals(this._springBone.initialLocalChildPosition)) {
        this._currentTail.copy(this._springBone.initialLocalChildPosition);
        shouldUpdateGeometry = true;
      }
      if (shouldUpdateGeometry) {
        this._buildPosition();
      }
    }
    _buildPosition() {
      for (let i = 0; i < 32; i++) {
        const t = i / 16 * Math.PI;
        this._attrPos.setXYZ(i, Math.cos(t), Math.sin(t), 0);
        this._attrPos.setXYZ(32 + i, 0, Math.cos(t), Math.sin(t));
        this._attrPos.setXYZ(64 + i, Math.sin(t), 0, Math.cos(t));
      }
      this.scale(this._currentRadius, this._currentRadius, this._currentRadius);
      this.translate(this._currentTail.x, this._currentTail.y, this._currentTail.z);
      this._attrPos.setXYZ(96, 0, 0, 0);
      this._attrPos.setXYZ(97, this._currentTail.x, this._currentTail.y, this._currentTail.z);
      this._attrPos.needsUpdate = true;
    }
    _buildIndex() {
      for (let i = 0; i < 32; i++) {
        const i1 = (i + 1) % 32;
        this._attrIndex.setXY(i * 2, i, i1);
        this._attrIndex.setXY(64 + i * 2, 32 + i, 32 + i1);
        this._attrIndex.setXY(128 + i * 2, 64 + i, 64 + i1);
      }
      this._attrIndex.setXY(192, 96, 97);
      this._attrIndex.needsUpdate = true;
    }
  };
  var _v3A52 = new Vector3();
  var VRMSpringBoneJointHelper = class extends Group {
    constructor(springBone) {
      super();
      this.matrixAutoUpdate = false;
      this.springBone = springBone;
      this._geometry = new SpringBoneBufferGeometry(this.springBone);
      const material = new LineBasicMaterial({
        color: 16776960,
        depthTest: false,
        depthWrite: false
      });
      this._line = new LineSegments(this._geometry, material);
      this.add(this._line);
    }
    dispose() {
      this._geometry.dispose();
    }
    updateMatrixWorld(force) {
      this.springBone.bone.updateWorldMatrix(true, false);
      this.matrix.copy(this.springBone.bone.matrixWorld);
      const matrixWorldElements = this.matrix.elements;
      this._geometry.worldScale = _v3A52.set(matrixWorldElements[0], matrixWorldElements[1], matrixWorldElements[2]).length();
      this._geometry.update();
      super.updateMatrixWorld(force);
    }
  };
  var VRMSpringBoneCollider = class extends Object3D {
    constructor(shape) {
      super();
      this.shape = shape;
    }
  };
  var _matA = new Matrix4();
  function mat4InvertCompat(target) {
    if (target.invert) {
      target.invert();
    } else {
      target.getInverse(_matA.copy(target));
    }
    return target;
  }
  var Matrix4InverseCache = class {
    constructor(matrix) {
      this._inverseCache = new Matrix4();
      this._shouldUpdateInverse = true;
      this.matrix = matrix;
      const handler = {
        set: (obj, prop, newVal) => {
          this._shouldUpdateInverse = true;
          obj[prop] = newVal;
          return true;
        }
      };
      this._originalElements = matrix.elements;
      matrix.elements = new Proxy(matrix.elements, handler);
    }
    /**
     * Inverse of given matrix.
     * Note that it will return its internal private instance.
     * Make sure copying this before mutate this.
     */
    get inverse() {
      if (this._shouldUpdateInverse) {
        mat4InvertCompat(this._inverseCache.copy(this.matrix));
        this._shouldUpdateInverse = false;
      }
      return this._inverseCache;
    }
    revert() {
      this.matrix.elements = this._originalElements;
    }
  };
  var IDENTITY_MATRIX4 = new Matrix4();
  var _v3A62 = new Vector3();
  var _v3B23 = new Vector3();
  var _v3C3 = new Vector3();
  var _worldSpacePosition = new Vector3();
  var _centerSpacePosition = new Vector3();
  var _nextTail = new Vector3();
  var _quatA8 = new Quaternion();
  var _matA2 = new Matrix4();
  var _matB = new Matrix4();
  var VRMSpringBoneJoint = class {
    /**
     * Create a new VRMSpringBone.
     *
     * @param bone An Object3D that will be attached to this bone
     * @param child An Object3D that will be used as a tail of this spring bone. It can be null when the spring bone is imported from VRM 0.0
     * @param settings Several parameters related to behavior of the spring bone
     * @param colliderGroups Collider groups that will be collided with this spring bone
     */
    constructor(bone, child, settings = {}, colliderGroups = []) {
      this._currentTail = new Vector3();
      this._prevTail = new Vector3();
      this._boneAxis = new Vector3();
      this._worldSpaceBoneLength = 0;
      this._center = null;
      this._initialLocalMatrix = new Matrix4();
      this._initialLocalRotation = new Quaternion();
      this._initialLocalChildPosition = new Vector3();
      var _a, _b, _c, _d, _e, _f;
      this.bone = bone;
      this.bone.matrixAutoUpdate = false;
      this.child = child;
      this.settings = {
        hitRadius: (_a = settings.hitRadius) != null ? _a : 0,
        stiffness: (_b = settings.stiffness) != null ? _b : 1,
        gravityPower: (_c = settings.gravityPower) != null ? _c : 0,
        gravityDir: (_e = (_d = settings.gravityDir) == null ? void 0 : _d.clone()) != null ? _e : new Vector3(0, -1, 0),
        dragForce: (_f = settings.dragForce) != null ? _f : 0.4
      };
      this.colliderGroups = colliderGroups;
    }
    get center() {
      return this._center;
    }
    set center(center) {
      var _a;
      if ((_a = this._center) == null ? void 0 : _a.userData.inverseCacheProxy) {
        this._center.userData.inverseCacheProxy.revert();
        delete this._center.userData.inverseCacheProxy;
      }
      this._center = center;
      if (this._center) {
        if (!this._center.userData.inverseCacheProxy) {
          this._center.userData.inverseCacheProxy = new Matrix4InverseCache(this._center.matrixWorld);
        }
      }
    }
    get initialLocalChildPosition() {
      return this._initialLocalChildPosition;
    }
    /**
     * Returns the world matrix of its parent object.
     * Note that it returns a reference to the matrix. Don't mutate this directly!
     */
    get _parentMatrixWorld() {
      return this.bone.parent ? this.bone.parent.matrixWorld : IDENTITY_MATRIX4;
    }
    /**
     * Set the initial state of this spring bone.
     * You might want to call {@link VRMSpringBoneManager.setInitState} instead.
     */
    setInitState() {
      this._initialLocalMatrix.copy(this.bone.matrix);
      this._initialLocalRotation.copy(this.bone.quaternion);
      if (this.child) {
        this._initialLocalChildPosition.copy(this.child.position);
      } else {
        this._initialLocalChildPosition.copy(this.bone.position).normalize().multiplyScalar(0.07);
      }
      const matrixWorldToCenter = this._getMatrixWorldToCenter(_matA2);
      this.bone.localToWorld(this._currentTail.copy(this._initialLocalChildPosition)).applyMatrix4(matrixWorldToCenter);
      this._prevTail.copy(this._currentTail);
      this._boneAxis.copy(this._initialLocalChildPosition).normalize();
    }
    /**
     * Reset the state of this bone.
     * You might want to call [[VRMSpringBoneManager.reset]] instead.
     */
    reset() {
      this.bone.quaternion.copy(this._initialLocalRotation);
      this.bone.updateMatrix();
      this.bone.matrixWorld.multiplyMatrices(this._parentMatrixWorld, this.bone.matrix);
      const matrixWorldToCenter = this._getMatrixWorldToCenter(_matA2);
      this.bone.localToWorld(this._currentTail.copy(this._initialLocalChildPosition)).applyMatrix4(matrixWorldToCenter);
      this._prevTail.copy(this._currentTail);
    }
    /**
     * Update the state of this bone.
     * You might want to call [[VRMSpringBoneManager.update]] instead.
     *
     * @param delta deltaTime
     */
    update(delta) {
      if (delta <= 0) return;
      this._calcWorldSpaceBoneLength();
      _worldSpacePosition.setFromMatrixPosition(this.bone.matrixWorld);
      let matrixWorldToCenter = this._getMatrixWorldToCenter(_matA2);
      _centerSpacePosition.copy(_worldSpacePosition).applyMatrix4(matrixWorldToCenter);
      const quatWorldToCenter = _quatA8.setFromRotationMatrix(matrixWorldToCenter);
      const centerSpaceParentMatrix = _matB.copy(matrixWorldToCenter).multiply(this._parentMatrixWorld);
      const centerSpaceBoneAxis = _v3B23.copy(this._boneAxis).applyMatrix4(this._initialLocalMatrix).applyMatrix4(centerSpaceParentMatrix).sub(_centerSpacePosition).normalize();
      const centerSpaceGravity = _v3C3.copy(this.settings.gravityDir).applyQuaternion(quatWorldToCenter).normalize();
      const matrixCenterToWorld = this._getMatrixCenterToWorld(_matA2);
      _nextTail.copy(this._currentTail).add(
        _v3A62.copy(this._currentTail).sub(this._prevTail).multiplyScalar(1 - this.settings.dragForce)
      ).add(_v3A62.copy(centerSpaceBoneAxis).multiplyScalar(this.settings.stiffness * delta)).add(_v3A62.copy(centerSpaceGravity).multiplyScalar(this.settings.gravityPower * delta)).applyMatrix4(matrixCenterToWorld);
      _nextTail.sub(_worldSpacePosition).normalize().multiplyScalar(this._worldSpaceBoneLength).add(_worldSpacePosition);
      this._collision(_nextTail);
      matrixWorldToCenter = this._getMatrixWorldToCenter(_matA2);
      this._prevTail.copy(this._currentTail);
      this._currentTail.copy(_v3A62.copy(_nextTail).applyMatrix4(matrixWorldToCenter));
      const worldSpaceInitialMatrixInv = mat4InvertCompat(
        _matA2.copy(this._parentMatrixWorld).multiply(this._initialLocalMatrix)
      );
      const applyRotation = _quatA8.setFromUnitVectors(
        this._boneAxis,
        _v3A62.copy(_nextTail).applyMatrix4(worldSpaceInitialMatrixInv).normalize()
      );
      this.bone.quaternion.copy(this._initialLocalRotation).multiply(applyRotation);
      this.bone.updateMatrix();
      this.bone.matrixWorld.multiplyMatrices(this._parentMatrixWorld, this.bone.matrix);
    }
    /**
     * Do collision math against every colliders attached to this bone.
     *
     * @param tail The tail you want to process
     */
    _collision(tail) {
      this.colliderGroups.forEach((colliderGroup) => {
        colliderGroup.colliders.forEach((collider) => {
          const dist = collider.shape.calculateCollision(collider.matrixWorld, tail, this.settings.hitRadius, _v3A62);
          if (dist < 0) {
            tail.add(_v3A62.multiplyScalar(-dist));
            tail.sub(_worldSpacePosition).normalize().multiplyScalar(this._worldSpaceBoneLength).add(_worldSpacePosition);
          }
        });
      });
    }
    /**
     * Calculate the {@link _worldSpaceBoneLength}.
     * Intended to be used in {@link update}.
     */
    _calcWorldSpaceBoneLength() {
      _v3A62.setFromMatrixPosition(this.bone.matrixWorld);
      if (this.child) {
        _v3B23.setFromMatrixPosition(this.child.matrixWorld);
      } else {
        _v3B23.copy(this._initialLocalChildPosition);
        _v3B23.applyMatrix4(this.bone.matrixWorld);
      }
      this._worldSpaceBoneLength = _v3A62.sub(_v3B23).length();
    }
    /**
     * Create a matrix that converts center space into world space.
     * @param target Target matrix
     */
    _getMatrixCenterToWorld(target) {
      if (this._center) {
        target.copy(this._center.matrixWorld);
      } else {
        target.identity();
      }
      return target;
    }
    /**
     * Create a matrix that converts world space into center space.
     * @param target Target matrix
     */
    _getMatrixWorldToCenter(target) {
      if (this._center) {
        target.copy(this._center.userData.inverseCacheProxy.inverse);
      } else {
        target.identity();
      }
      return target;
    }
  };
  function traverseAncestorsFromRoot2(object, callback) {
    const ancestors = [];
    let head = object;
    while (head !== null) {
      ancestors.unshift(head);
      head = head.parent;
    }
    ancestors.forEach((ancestor) => {
      callback(ancestor);
    });
  }
  function traverseChildrenUntilConditionMet(object, callback) {
    object.children.forEach((child) => {
      const result = callback(child);
      if (!result) {
        traverseChildrenUntilConditionMet(child, callback);
      }
    });
  }
  var VRMSpringBoneManager = class {
    constructor() {
      this._joints = /* @__PURE__ */ new Set();
      this._hasWarnedCircularDependency = false;
      this._objectSpringBonesMap = /* @__PURE__ */ new Map();
    }
    get joints() {
      return this._joints;
    }
    /**
     * @deprecated Use {@link joints} instead.
     */
    get springBones() {
      console.warn("VRMSpringBoneManager: springBones is deprecated. use joints instead.");
      return this._joints;
    }
    get colliderGroups() {
      const set = /* @__PURE__ */ new Set();
      this._joints.forEach((springBone) => {
        springBone.colliderGroups.forEach((colliderGroup) => {
          set.add(colliderGroup);
        });
      });
      return Array.from(set);
    }
    get colliders() {
      const set = /* @__PURE__ */ new Set();
      this.colliderGroups.forEach((colliderGroup) => {
        colliderGroup.colliders.forEach((collider) => {
          set.add(collider);
        });
      });
      return Array.from(set);
    }
    addJoint(joint) {
      this._joints.add(joint);
      let objectSet = this._objectSpringBonesMap.get(joint.bone);
      if (objectSet == null) {
        objectSet = /* @__PURE__ */ new Set();
        this._objectSpringBonesMap.set(joint.bone, objectSet);
      }
      objectSet.add(joint);
    }
    /**
     * @deprecated Use {@link addJoint} instead.
     */
    addSpringBone(joint) {
      console.warn("VRMSpringBoneManager: addSpringBone() is deprecated. use addJoint() instead.");
      this.addJoint(joint);
    }
    deleteJoint(joint) {
      this._joints.delete(joint);
      const objectSet = this._objectSpringBonesMap.get(joint.bone);
      objectSet.delete(joint);
    }
    /**
     * @deprecated Use {@link deleteJoint} instead.
     */
    deleteSpringBone(joint) {
      console.warn("VRMSpringBoneManager: deleteSpringBone() is deprecated. use deleteJoint() instead.");
      this.deleteJoint(joint);
    }
    setInitState() {
      const springBonesTried = /* @__PURE__ */ new Set();
      const springBonesDone = /* @__PURE__ */ new Set();
      const objectUpdated = /* @__PURE__ */ new Set();
      for (const springBone of this._joints) {
        this._processSpringBone(
          springBone,
          springBonesTried,
          springBonesDone,
          objectUpdated,
          (springBone2) => springBone2.setInitState()
        );
      }
    }
    reset() {
      const springBonesTried = /* @__PURE__ */ new Set();
      const springBonesDone = /* @__PURE__ */ new Set();
      const objectUpdated = /* @__PURE__ */ new Set();
      for (const springBone of this._joints) {
        this._processSpringBone(
          springBone,
          springBonesTried,
          springBonesDone,
          objectUpdated,
          (springBone2) => springBone2.reset()
        );
      }
    }
    update(delta) {
      const springBonesTried = /* @__PURE__ */ new Set();
      const springBonesDone = /* @__PURE__ */ new Set();
      const objectUpdated = /* @__PURE__ */ new Set();
      for (const springBone of this._joints) {
        this._processSpringBone(
          springBone,
          springBonesTried,
          springBonesDone,
          objectUpdated,
          (springBone2) => springBone2.update(delta)
        );
        traverseChildrenUntilConditionMet(springBone.bone, (object) => {
          var _a, _b;
          if (((_b = (_a = this._objectSpringBonesMap.get(object)) == null ? void 0 : _a.size) != null ? _b : 0) > 0) {
            return true;
          }
          object.updateWorldMatrix(false, false);
          return false;
        });
      }
    }
    /**
     * Update a spring bone.
     * If there are other spring bone that are dependant, it will try to update them recursively.
     * It updates matrixWorld of all ancestors and myself.
     * It might log an warning message if there are any circular dependencies.
     *
     * Intended to be used in {@link update} and {@link _processSpringBone} itself recursively.
     *
     * @param springBone A springBone you want to update
     * @param springBonesTried Set of springBones that are already tried to be updated
     * @param springBonesDone Set of springBones that are already up to date
     * @param objectUpdated Set of object3D whose matrixWorld is updated
     */
    _processSpringBone(springBone, springBonesTried, springBonesDone, objectUpdated, callback) {
      if (springBonesDone.has(springBone)) {
        return;
      }
      if (springBonesTried.has(springBone)) {
        if (!this._hasWarnedCircularDependency) {
          console.warn("VRMSpringBoneManager: Circular dependency detected while updating springbones");
          this._hasWarnedCircularDependency = true;
        }
        return;
      }
      springBonesTried.add(springBone);
      const depObjects = this._getDependencies(springBone);
      for (const depObject of depObjects) {
        traverseAncestorsFromRoot2(depObject, (depObjectAncestor) => {
          const objectSet = this._objectSpringBonesMap.get(depObjectAncestor);
          if (objectSet) {
            for (const depSpringBone of objectSet) {
              this._processSpringBone(depSpringBone, springBonesTried, springBonesDone, objectUpdated, callback);
            }
          } else if (!objectUpdated.has(depObjectAncestor)) {
            depObjectAncestor.updateWorldMatrix(false, false);
            objectUpdated.add(depObjectAncestor);
          }
        });
      }
      springBone.bone.updateMatrix();
      springBone.bone.updateWorldMatrix(false, false);
      callback(springBone);
      objectUpdated.add(springBone.bone);
      springBonesDone.add(springBone);
    }
    /**
     * Return a set of objects that are dependant of given spring bone.
     * @param springBone A spring bone
     * @return A set of objects that are dependant of given spring bone
     */
    _getDependencies(springBone) {
      const set = /* @__PURE__ */ new Set();
      const parent = springBone.bone.parent;
      if (parent) {
        set.add(parent);
      }
      springBone.colliderGroups.forEach((colliderGroup) => {
        colliderGroup.colliders.forEach((collider) => {
          set.add(collider);
        });
      });
      return set;
    }
  };
  var EXTENSION_NAME_EXTENDED_COLLIDER = "VRMC_springBone_extended_collider";
  var POSSIBLE_SPEC_VERSIONS8 = /* @__PURE__ */ new Set(["1.0", "1.0-beta"]);
  var POSSIBLE_SPEC_VERSIONS_EXTENDED_COLLIDERS = /* @__PURE__ */ new Set(["1.0"]);
  var _VRMSpringBoneLoaderPlugin = class _VRMSpringBoneLoaderPlugin2 {
    get name() {
      return _VRMSpringBoneLoaderPlugin2.EXTENSION_NAME;
    }
    constructor(parser, options) {
      var _a;
      this.parser = parser;
      this.jointHelperRoot = options == null ? void 0 : options.jointHelperRoot;
      this.colliderHelperRoot = options == null ? void 0 : options.colliderHelperRoot;
      this.useExtendedColliders = (_a = options == null ? void 0 : options.useExtendedColliders) != null ? _a : true;
    }
    afterRoot(gltf) {
      return __async7(this, null, function* () {
        gltf.userData.vrmSpringBoneManager = yield this._import(gltf);
      });
    }
    /**
     * Import spring bones from a GLTF and return a {@link VRMSpringBoneManager}.
     * It might return `null` instead when it does not need to be created or something go wrong.
     *
     * @param gltf A parsed result of GLTF taken from GLTFLoader
     */
    _import(gltf) {
      return __async7(this, null, function* () {
        const v1Result = yield this._v1Import(gltf);
        if (v1Result != null) {
          return v1Result;
        }
        const v0Result = yield this._v0Import(gltf);
        if (v0Result != null) {
          return v0Result;
        }
        return null;
      });
    }
    _v1Import(gltf) {
      return __async7(this, null, function* () {
        var _a, _b, _c, _d, _e;
        const json = gltf.parser.json;
        const isSpringBoneUsed = ((_a = json.extensionsUsed) == null ? void 0 : _a.indexOf(_VRMSpringBoneLoaderPlugin2.EXTENSION_NAME)) !== -1;
        if (!isSpringBoneUsed) {
          return null;
        }
        const manager = new VRMSpringBoneManager();
        const threeNodes = yield gltf.parser.getDependencies("node");
        const extension = (_b = json.extensions) == null ? void 0 : _b[_VRMSpringBoneLoaderPlugin2.EXTENSION_NAME];
        if (!extension) {
          return null;
        }
        const specVersion = extension.specVersion;
        if (!POSSIBLE_SPEC_VERSIONS8.has(specVersion)) {
          console.warn(
            `VRMSpringBoneLoaderPlugin: Unknown ${_VRMSpringBoneLoaderPlugin2.EXTENSION_NAME} specVersion "${specVersion}"`
          );
          return null;
        }
        const colliders = (_c = extension.colliders) == null ? void 0 : _c.map((schemaCollider, iCollider) => {
          var _a2, _b2, _c2, _d2, _e2, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o;
          const node = threeNodes[schemaCollider.node];
          const schemaShape = schemaCollider.shape;
          const schemaExCollider = (_a2 = schemaCollider.extensions) == null ? void 0 : _a2[EXTENSION_NAME_EXTENDED_COLLIDER];
          if (this.useExtendedColliders && schemaExCollider != null) {
            const specVersionExCollider = schemaExCollider.specVersion;
            if (!POSSIBLE_SPEC_VERSIONS_EXTENDED_COLLIDERS.has(specVersionExCollider)) {
              console.warn(
                `VRMSpringBoneLoaderPlugin: Unknown ${EXTENSION_NAME_EXTENDED_COLLIDER} specVersion "${specVersionExCollider}". Fallbacking to the ${_VRMSpringBoneLoaderPlugin2.EXTENSION_NAME} definition`
              );
            } else {
              const schemaExShape = schemaExCollider.shape;
              if (schemaExShape.sphere) {
                return this._importSphereCollider(node, {
                  offset: new Vector3().fromArray((_b2 = schemaExShape.sphere.offset) != null ? _b2 : [0, 0, 0]),
                  radius: (_c2 = schemaExShape.sphere.radius) != null ? _c2 : 0,
                  inside: (_d2 = schemaExShape.sphere.inside) != null ? _d2 : false
                });
              } else if (schemaExShape.capsule) {
                return this._importCapsuleCollider(node, {
                  offset: new Vector3().fromArray((_e2 = schemaExShape.capsule.offset) != null ? _e2 : [0, 0, 0]),
                  radius: (_f = schemaExShape.capsule.radius) != null ? _f : 0,
                  tail: new Vector3().fromArray((_g = schemaExShape.capsule.tail) != null ? _g : [0, 0, 0]),
                  inside: (_h = schemaExShape.capsule.inside) != null ? _h : false
                });
              } else if (schemaExShape.plane) {
                return this._importPlaneCollider(node, {
                  offset: new Vector3().fromArray((_i = schemaExShape.plane.offset) != null ? _i : [0, 0, 0]),
                  normal: new Vector3().fromArray((_j = schemaExShape.plane.normal) != null ? _j : [0, 0, 1])
                });
              }
            }
          }
          if (schemaShape.sphere) {
            return this._importSphereCollider(node, {
              offset: new Vector3().fromArray((_k = schemaShape.sphere.offset) != null ? _k : [0, 0, 0]),
              radius: (_l = schemaShape.sphere.radius) != null ? _l : 0,
              inside: false
            });
          } else if (schemaShape.capsule) {
            return this._importCapsuleCollider(node, {
              offset: new Vector3().fromArray((_m = schemaShape.capsule.offset) != null ? _m : [0, 0, 0]),
              radius: (_n = schemaShape.capsule.radius) != null ? _n : 0,
              tail: new Vector3().fromArray((_o = schemaShape.capsule.tail) != null ? _o : [0, 0, 0]),
              inside: false
            });
          }
          throw new Error(`VRMSpringBoneLoaderPlugin: The collider #${iCollider} has no valid shape`);
        });
        const colliderGroups = (_d = extension.colliderGroups) == null ? void 0 : _d.map(
          (schemaColliderGroup, iColliderGroup) => {
            var _a2;
            const cols = ((_a2 = schemaColliderGroup.colliders) != null ? _a2 : []).map((iCollider) => {
              const col = colliders == null ? void 0 : colliders[iCollider];
              if (col == null) {
                throw new Error(
                  `VRMSpringBoneLoaderPlugin: The colliderGroup #${iColliderGroup} attempted to use a collider #${iCollider} but not found`
                );
              }
              return col;
            });
            return {
              colliders: cols,
              name: schemaColliderGroup.name
            };
          }
        );
        (_e = extension.springs) == null ? void 0 : _e.forEach((schemaSpring, iSpring) => {
          var _a2;
          const schemaJoints = schemaSpring.joints;
          const colliderGroupsForSpring = (_a2 = schemaSpring.colliderGroups) == null ? void 0 : _a2.map((iColliderGroup) => {
            const group = colliderGroups == null ? void 0 : colliderGroups[iColliderGroup];
            if (group == null) {
              throw new Error(
                `VRMSpringBoneLoaderPlugin: The spring #${iSpring} attempted to use a colliderGroup ${iColliderGroup} but not found`
              );
            }
            return group;
          });
          const center = schemaSpring.center != null ? threeNodes[schemaSpring.center] : void 0;
          let prevSchemaJoint;
          schemaJoints.forEach((schemaJoint) => {
            if (prevSchemaJoint) {
              const nodeIndex = prevSchemaJoint.node;
              const node = threeNodes[nodeIndex];
              const childIndex = schemaJoint.node;
              const child = threeNodes[childIndex];
              const setting = {
                hitRadius: prevSchemaJoint.hitRadius,
                dragForce: prevSchemaJoint.dragForce,
                gravityPower: prevSchemaJoint.gravityPower,
                stiffness: prevSchemaJoint.stiffness,
                gravityDir: prevSchemaJoint.gravityDir != null ? new Vector3().fromArray(prevSchemaJoint.gravityDir) : void 0
              };
              const joint = this._importJoint(node, child, setting, colliderGroupsForSpring);
              if (center) {
                joint.center = center;
              }
              manager.addJoint(joint);
            }
            prevSchemaJoint = schemaJoint;
          });
        });
        manager.setInitState();
        return manager;
      });
    }
    _v0Import(gltf) {
      return __async7(this, null, function* () {
        var _a, _b, _c;
        const json = gltf.parser.json;
        const isVRMUsed = ((_a = json.extensionsUsed) == null ? void 0 : _a.indexOf("VRM")) !== -1;
        if (!isVRMUsed) {
          return null;
        }
        const extension = (_b = json.extensions) == null ? void 0 : _b["VRM"];
        const schemaSecondaryAnimation = extension == null ? void 0 : extension.secondaryAnimation;
        if (!schemaSecondaryAnimation) {
          return null;
        }
        const schemaBoneGroups = schemaSecondaryAnimation == null ? void 0 : schemaSecondaryAnimation.boneGroups;
        if (!schemaBoneGroups) {
          return null;
        }
        const manager = new VRMSpringBoneManager();
        const threeNodes = yield gltf.parser.getDependencies("node");
        const colliderGroups = (_c = schemaSecondaryAnimation.colliderGroups) == null ? void 0 : _c.map(
          (schemaColliderGroup) => {
            var _a2;
            const node = threeNodes[schemaColliderGroup.node];
            const colliders = ((_a2 = schemaColliderGroup.colliders) != null ? _a2 : []).map((schemaCollider, iCollider) => {
              var _a3, _b2, _c2;
              const offset = new Vector3(0, 0, 0);
              if (schemaCollider.offset) {
                offset.set(
                  (_a3 = schemaCollider.offset.x) != null ? _a3 : 0,
                  (_b2 = schemaCollider.offset.y) != null ? _b2 : 0,
                  schemaCollider.offset.z ? -schemaCollider.offset.z : 0
                  // z is opposite in VRM0.0
                );
              }
              return this._importSphereCollider(node, {
                offset,
                radius: (_c2 = schemaCollider.radius) != null ? _c2 : 0,
                inside: false
              });
            });
            return { colliders };
          }
        );
        schemaBoneGroups == null ? void 0 : schemaBoneGroups.forEach((schemaBoneGroup, iBoneGroup) => {
          const rootIndices = schemaBoneGroup.bones;
          if (!rootIndices) {
            return;
          }
          rootIndices.forEach((rootIndex) => {
            var _a2, _b2, _c2, _d;
            const root = threeNodes[rootIndex];
            const gravityDir = new Vector3();
            if (schemaBoneGroup.gravityDir) {
              gravityDir.set(
                (_a2 = schemaBoneGroup.gravityDir.x) != null ? _a2 : 0,
                (_b2 = schemaBoneGroup.gravityDir.y) != null ? _b2 : 0,
                (_c2 = schemaBoneGroup.gravityDir.z) != null ? _c2 : 0
              );
            } else {
              gravityDir.set(0, -1, 0);
            }
            const center = schemaBoneGroup.center != null ? threeNodes[schemaBoneGroup.center] : void 0;
            const setting = {
              hitRadius: schemaBoneGroup.hitRadius,
              dragForce: schemaBoneGroup.dragForce,
              gravityPower: schemaBoneGroup.gravityPower,
              stiffness: schemaBoneGroup.stiffiness,
              gravityDir
            };
            const colliderGroupsForSpring = (_d = schemaBoneGroup.colliderGroups) == null ? void 0 : _d.map((iColliderGroup) => {
              const group = colliderGroups == null ? void 0 : colliderGroups[iColliderGroup];
              if (group == null) {
                throw new Error(
                  `VRMSpringBoneLoaderPlugin: The spring #${iBoneGroup} attempted to use a colliderGroup ${iColliderGroup} but not found`
                );
              }
              return group;
            });
            root.traverse((node) => {
              var _a3;
              const child = (_a3 = node.children[0]) != null ? _a3 : null;
              const joint = this._importJoint(node, child, setting, colliderGroupsForSpring);
              if (center) {
                joint.center = center;
              }
              manager.addJoint(joint);
            });
          });
        });
        gltf.scene.updateMatrixWorld();
        manager.setInitState();
        return manager;
      });
    }
    _importJoint(node, child, setting, colliderGroupsForSpring) {
      const springBone = new VRMSpringBoneJoint(node, child, setting, colliderGroupsForSpring);
      if (this.jointHelperRoot) {
        const helper = new VRMSpringBoneJointHelper(springBone);
        this.jointHelperRoot.add(helper);
        helper.renderOrder = this.jointHelperRoot.renderOrder;
      }
      return springBone;
    }
    _importSphereCollider(destination, params) {
      const shape = new VRMSpringBoneColliderShapeSphere(params);
      const collider = new VRMSpringBoneCollider(shape);
      destination.add(collider);
      if (this.colliderHelperRoot) {
        const helper = new VRMSpringBoneColliderHelper(collider);
        this.colliderHelperRoot.add(helper);
        helper.renderOrder = this.colliderHelperRoot.renderOrder;
      }
      return collider;
    }
    _importCapsuleCollider(destination, params) {
      const shape = new VRMSpringBoneColliderShapeCapsule(params);
      const collider = new VRMSpringBoneCollider(shape);
      destination.add(collider);
      if (this.colliderHelperRoot) {
        const helper = new VRMSpringBoneColliderHelper(collider);
        this.colliderHelperRoot.add(helper);
        helper.renderOrder = this.colliderHelperRoot.renderOrder;
      }
      return collider;
    }
    _importPlaneCollider(destination, params) {
      const shape = new VRMSpringBoneColliderShapePlane(params);
      const collider = new VRMSpringBoneCollider(shape);
      destination.add(collider);
      if (this.colliderHelperRoot) {
        const helper = new VRMSpringBoneColliderHelper(collider);
        this.colliderHelperRoot.add(helper);
        helper.renderOrder = this.colliderHelperRoot.renderOrder;
      }
      return collider;
    }
  };
  _VRMSpringBoneLoaderPlugin.EXTENSION_NAME = "VRMC_springBone";
  var VRMSpringBoneLoaderPlugin = _VRMSpringBoneLoaderPlugin;

  // src/VRMLoaderPlugin.ts
  var VRMLoaderPlugin = class {
    get name() {
      return "VRMLoaderPlugin";
    }
    constructor(parser, options) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
      this.parser = parser;
      const helperRoot = options == null ? void 0 : options.helperRoot;
      const autoUpdateHumanBones = options == null ? void 0 : options.autoUpdateHumanBones;
      this.expressionPlugin = (_a = options == null ? void 0 : options.expressionPlugin) != null ? _a : new VRMExpressionLoaderPlugin(parser);
      this.firstPersonPlugin = (_b = options == null ? void 0 : options.firstPersonPlugin) != null ? _b : new VRMFirstPersonLoaderPlugin(parser);
      this.humanoidPlugin = (_c = options == null ? void 0 : options.humanoidPlugin) != null ? _c : new VRMHumanoidLoaderPlugin(parser, {
        helperRoot,
        autoUpdateHumanBones
      });
      this.lookAtPlugin = (_d = options == null ? void 0 : options.lookAtPlugin) != null ? _d : new VRMLookAtLoaderPlugin(parser, { helperRoot });
      this.metaPlugin = (_e = options == null ? void 0 : options.metaPlugin) != null ? _e : new VRMMetaLoaderPlugin(parser);
      this.mtoonMaterialPlugin = (_f = options == null ? void 0 : options.mtoonMaterialPlugin) != null ? _f : new MToonMaterialLoaderPlugin(parser);
      this.materialsHDREmissiveMultiplierPlugin = (_g = options == null ? void 0 : options.materialsHDREmissiveMultiplierPlugin) != null ? _g : new VRMMaterialsHDREmissiveMultiplierLoaderPlugin(parser);
      this.materialsV0CompatPlugin = (_h = options == null ? void 0 : options.materialsV0CompatPlugin) != null ? _h : new VRMMaterialsV0CompatPlugin(parser);
      this.springBonePlugin = (_i = options == null ? void 0 : options.springBonePlugin) != null ? _i : new VRMSpringBoneLoaderPlugin(parser, {
        colliderHelperRoot: helperRoot,
        jointHelperRoot: helperRoot
      });
      this.nodeConstraintPlugin = (_j = options == null ? void 0 : options.nodeConstraintPlugin) != null ? _j : new VRMNodeConstraintLoaderPlugin(parser, { helperRoot });
    }
    beforeRoot() {
      return __async(this, null, function* () {
        yield this.materialsV0CompatPlugin.beforeRoot();
        yield this.mtoonMaterialPlugin.beforeRoot();
      });
    }
    loadMesh(meshIndex) {
      return __async(this, null, function* () {
        return yield this.mtoonMaterialPlugin.loadMesh(meshIndex);
      });
    }
    getMaterialType(materialIndex) {
      const mtoonType = this.mtoonMaterialPlugin.getMaterialType(materialIndex);
      if (mtoonType != null) {
        return mtoonType;
      }
      return null;
    }
    extendMaterialParams(materialIndex, materialParams) {
      return __async(this, null, function* () {
        yield this.materialsHDREmissiveMultiplierPlugin.extendMaterialParams(materialIndex, materialParams);
        yield this.mtoonMaterialPlugin.extendMaterialParams(materialIndex, materialParams);
      });
    }
    afterRoot(gltf) {
      return __async(this, null, function* () {
        yield this.metaPlugin.afterRoot(gltf);
        yield this.humanoidPlugin.afterRoot(gltf);
        yield this.expressionPlugin.afterRoot(gltf);
        yield this.lookAtPlugin.afterRoot(gltf);
        yield this.firstPersonPlugin.afterRoot(gltf);
        yield this.springBonePlugin.afterRoot(gltf);
        yield this.nodeConstraintPlugin.afterRoot(gltf);
        yield this.mtoonMaterialPlugin.afterRoot(gltf);
        const meta = gltf.userData.vrmMeta;
        const humanoid = gltf.userData.vrmHumanoid;
        if (meta && humanoid) {
          const vrm = new VRM({
            scene: gltf.scene,
            expressionManager: gltf.userData.vrmExpressionManager,
            firstPerson: gltf.userData.vrmFirstPerson,
            humanoid,
            lookAt: gltf.userData.vrmLookAt,
            meta,
            materials: gltf.userData.vrmMToonMaterials,
            springBoneManager: gltf.userData.vrmSpringBoneManager,
            nodeConstraintManager: gltf.userData.vrmNodeConstraintManager
          });
          gltf.userData.vrm = vrm;
        }
      });
    }
  };
  /*!
   * @pixiv/three-vrm-core v3.1.1
   * The implementation of core features of VRM, for @pixiv/three-vrm
   *
   * Copyright (c) 2019-2024 pixiv Inc.
   * @pixiv/three-vrm-core is distributed under MIT License
   * https://github.com/pixiv/three-vrm/blob/release/LICENSE
   */
  /*!
   * @pixiv/three-vrm-materials-mtoon v3.1.1
   * MToon (toon material) module for @pixiv/three-vrm
   *
   * Copyright (c) 2019-2024 pixiv Inc.
   * @pixiv/three-vrm-materials-mtoon is distributed under MIT License
   * https://github.com/pixiv/three-vrm/blob/release/LICENSE
   */
  /*!
   * @pixiv/three-vrm-materials-hdr-emissive-multiplier v3.1.1
   * Support VRMC_hdr_emissiveMultiplier for @pixiv/three-vrm
   *
   * Copyright (c) 2019-2024 pixiv Inc.
   * @pixiv/three-vrm-materials-hdr-emissive-multiplier is distributed under MIT License
   * https://github.com/pixiv/three-vrm/blob/release/LICENSE
   */
  /*!
   * @pixiv/three-vrm-materials-v0compat v3.1.1
   * VRM0.0 materials compatibility layer plugin for @pixiv/three-vrm
   *
   * Copyright (c) 2019-2024 pixiv Inc.
   * @pixiv/three-vrm-materials-v0compat is distributed under MIT License
   * https://github.com/pixiv/three-vrm/blob/release/LICENSE
   */
  /*!
   * @pixiv/three-vrm-node-constraint v3.1.1
   * Node constraint module for @pixiv/three-vrm
   *
   * Copyright (c) 2019-2024 pixiv Inc.
   * @pixiv/three-vrm-node-constraint is distributed under MIT License
   * https://github.com/pixiv/three-vrm/blob/release/LICENSE
   */
  /*!
   * @pixiv/three-vrm-springbone v3.1.1
   * Spring bone module for @pixiv/three-vrm
   *
   * Copyright (c) 2019-2024 pixiv Inc.
   * @pixiv/three-vrm-springbone is distributed under MIT License
   * https://github.com/pixiv/three-vrm/blob/release/LICENSE
   */

  // Define the loadVrm function
  function loadVrm(vrmUrl, buffer) {
    return new Promise(/*#__PURE__*/function () {
      var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(resolve, reject) {
        var loader, gltf, vrm;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              loader = new GLTFLoader(); // Register the VRMLoaderPlugin with the GLTFLoader
              loader.register(function (parser) {
                return new VRMLoaderPlugin(parser);
              });
              _context.next = 4;
              return loader.parseAsync(buffer, vrmUrl)["catch"](function (error) {
                reject(new Error("Failed to parse VRM model."));
                return error;
              });
            case 4:
              gltf = _context.sent;
              if (gltf) {
                _context.next = 7;
                break;
              }
              return _context.abrupt("return");
            case 7:
              // Once loaded, retrieve the VRM model from gltf.userData
              vrm = gltf.userData.vrm;
              if (vrm) {
                resolve(vrm);
              } else {
                reject(new Error("Failed to load VRM model."));
              }
            case 9:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));
      return function (_x, _x2) {
        return _ref.apply(this, arguments);
      };
    }());
  }

  function workerVrma2motion(_x, _x2, _x3, _x4) {
    return _workerVrma2motion.apply(this, arguments);
  }
  function _workerVrma2motion() {
    _workerVrma2motion = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(filePath, uid, arrayBuffer, vrm) {
      var converter, motion;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            converter = new VRMAConverter(vrm);
            _context2.next = 3;
            return converter.vrma2motion(uid, generateProgressCallback(uid), arrayBuffer);
          case 3:
            motion = _context2.sent;
            return _context2.abrupt("return", motion);
          case 5:
          case "end":
            return _context2.stop();
        }
      }, _callee2);
    }));
    return _workerVrma2motion.apply(this, arguments);
  }
  function workerFbx2motion(_x5, _x6, _x7, _x8) {
    return _workerFbx2motion.apply(this, arguments);
  }
  function _workerFbx2motion() {
    _workerFbx2motion = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(filePath, uid, arrayBuffer, vrm) {
      var converter, motion;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            converter = new FBXConverter(vrm);
            _context3.next = 3;
            return converter.fbx2motion(uid, generateProgressCallback(uid), arrayBuffer);
          case 3:
            motion = _context3.sent;
            return _context3.abrupt("return", motion);
          case 5:
          case "end":
            return _context3.stop();
        }
      }, _callee3);
    }));
    return _workerFbx2motion.apply(this, arguments);
  }
  function workerBvh2vrmaBlob(_x9, _x10, _x11, _x12) {
    return _workerBvh2vrmaBlob.apply(this, arguments);
  }
  function _workerBvh2vrmaBlob() {
    _workerBvh2vrmaBlob = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4(filePath, uid, arrayBuffer, vrm) {
      var converter, motion;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            converter = new BVHConverter(vrm);
            _context4.next = 3;
            return converter.bvh2motion(uid, generateProgressCallback(uid), arrayBuffer);
          case 3:
            motion = _context4.sent;
            return _context4.abrupt("return", motion);
          case 5:
          case "end":
            return _context4.stop();
        }
      }, _callee4);
    }));
    return _workerBvh2vrmaBlob.apply(this, arguments);
  }
  function generateProgressCallback(uid) {
    return function (name, progress) {
      return postMessage({
        uid: uid,
        response: {
          kind: "progress",
          data: {
            name: name,
            progress: progress
          }
        }
      });
    };
  }
  var functionMap = {
    CWvrma2motion: workerVrma2motion,
    CWfbx2motion: workerFbx2motion,
    CWbvh2motion: workerBvh2vrmaBlob
  };
  // add event listener
  self.addEventListener("message", /*#__PURE__*/function () {
    var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(e) {
      var data, vrm, func, result;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            data = e.data; // const vrmBlob = new Blob([data.vrmArrayBuffer]);
            // const vrmArrayBufferBlobUrl = URL.createObjectURL(vrmBlob);
            _context.next = 3;
            return loadVrm("vrmArrayBufferBlobUrl", data.vrmArrayBuffer);
          case 3:
            vrm = _context.sent;
            func = functionMap[data.func];
            if (!func) {
              _context.next = 10;
              break;
            }
            _context.next = 8;
            return func(data.filePath, data.uid, data.arrayBuffer, vrm);
          case 8:
            result = _context.sent;
            postMessage({
              uid: data.uid,
              filePath: data.filePath,
              response: {
                kind: "output",
                data: {
                  clip: AnimationClip.toJSON(result.clip)
                }
              }
            });
          case 10:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return function (_x13) {
      return _ref.apply(this, arguments);
    };
  }());

})();
//# sourceMappingURL=motion-expression-worker.bundle.js.map
